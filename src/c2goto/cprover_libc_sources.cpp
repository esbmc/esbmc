
#include <boost/filesystem.hpp>
#include <boost/filesystem/operations.hpp>
#include <c2goto/cprover_library.h>
#include <fstream>
#include <util/language.h>
#include <util/filesystem.h>

extern "C"
{
#include <libc.h>
#include <libm.h>
#include <headers/libc_hdr.h>
#undef ESBMC_FLAIL
}

/* This class represents the extracted internal libc. It uses the headers
 * generated by the build system to dump the bundled libc/libm files in a
 * temporary directory. The headers contain invocations of the form
 * ESBMC_FLAIL(body, size, name) for each bundled file,
 * see scripts/flail.py --macro. */
static class
{
  file_operations::tmp_path base;
  std::string libc, libm, headers;

  const std::string &base_path()
  {
    if (base.path() == "")
      base = file_operations::create_tmp_dir();
    return base.path();
  }

  template <typename F>
  void foreach_libc_libm_(F &&f [[maybe_unused]])
  {
#define ESBMC_FLAIL(body, size, ...) f(body, size, libc + "/" #__VA_ARGS__);
#include <libc.h>
#undef ESBMC_FLAIL

#define ESBMC_FLAIL(body, size, ...) f(body, size, libm + "/" #__VA_ARGS__);
#include <libm.h>
#undef ESBMC_FLAIL
  }

public:
  const std::string &header_dir()
  {
    if (headers == "")
    {
      using namespace boost::filesystem;
      headers = base_path() + "/headers";
      create_directory(headers);
      create_directory(headers + "/__esbmc");
      create_directory(headers + "/bits");
      create_directory(headers + "/sys");
      create_directory(headers + "/sys/_types");
      create_directory(headers + "/sys/_pthread");
      create_directory(headers + "/ubuntu20.04");
      create_directory(headers + "/ubuntu20.04/kernel_5.15.0-76");
      create_directory(headers + "/ubuntu20.04/kernel_5.15.0-76/include");
      create_directory(headers + "/ubuntu20.04/kernel_5.15.0-76/include/linux");
      create_directory(headers + "/ubuntu20.04/kernel_5.15.0-76/include/asm");
#define ESBMC_FLAIL(body, size, ...)                                           \
  std::ofstream(headers + "/" #__VA_ARGS__).write(body, size);
#include <headers/libc_hdr.h>
#undef ESBMC_FLAIL
    }
    return headers;
  }

  template <typename F>
  void foreach_libc_libm(F &&f)
  {
    if (libc == "")
    {
      using namespace boost::filesystem;
      libc = base_path() + "/library";
      libm = libc + "/libm";
      create_directory(libc);
      create_directory(libm);
      foreach_libc_libm_([&f](const char *body, size_t size, std::string path) {
        std::ofstream(path).write(body, size);
        f(path);
      });
    }
    else
      foreach_libc_libm_(
        [&f](const char *, size_t, std::string path) { f(path); });
  }
} internal_libc;

const std::string *internal_libc_header_dir()
{
  return config.ansi_c.lib == configt::ansi_ct::libt::LIB_NONE
           ? nullptr
           : &internal_libc.header_dir();
}

/* copy of clang_c_convertert::get_filename_from_path(); TODO: unify */
static std::string get_filename_from_path(std::string path)
{
  if (path.find_last_of('/') != std::string::npos)
    return path.substr(path.find_last_of('/') + 1);

  return path;
}

void add_bundled_library_sources(contextt &context, const languaget &c_language)
{
  /* First extract headers (if not already done) */
  if (internal_libc_header_dir())
  {
    bool skip_fenv = false;
#ifdef ESBMC_CHERI_CLANG_MORELLO
    /* Morello is hard-float, which has an incompatible <fenv.h> */
    skip_fenv = config.ansi_c.cheri != configt::ansi_ct::CHERI_OFF;
#endif

    /* Next, extract (if not already done) and process every libc/libm file. */
    internal_libc.foreach_libc_libm([&](const std::string &path) {
      if (skip_fenv && get_filename_from_path(path) == "fenv.c")
        return;
      languaget *l = c_language.new_language();
      log_status("file {}: Parsing", path);
      if (l->parse(path) || l->typecheck(context))
      {
        log_error("error processing internal libc source {}", path);
        abort();
      }
      delete l;
    });
  }
}
