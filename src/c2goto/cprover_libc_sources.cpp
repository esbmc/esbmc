
#include <boost/filesystem.hpp>
#include <c2goto/cprover_library.h>
#include <fstream>
#include <util/language.h>

extern "C"
{
#include <libc.h>
#include <libm.h>
#include <headers/libc_hdr.h>
#undef ESBMC_FLAIL
}

/* This class represents the extracted internal libc. It uses the headers
 * generated by the build system to dump the bundled libc/libm files in a
 * temporary directory. The headers contain invocations of the form
 * ESBMC_FLAIL(body, size, name) for each bundled file,
 * see scripts/flail.py --macro. */
static class
{
  file_operations::tmp_path base;
  std::string libc, libm, headers;

  const std::string &base_path()
  {
    if(base.path() == "")
      base = file_operations::create_tmp_dir();
    return base.path();
  }

  template <typename F>
  void foreach_libc_libm_(F &&f [[gnu::unused]])
  {
#define ESBMC_FLAIL(body, size, ...) f(body, size, libc + "/" #__VA_ARGS__);
#include <libc.h>
#undef ESBMC_FLAIL

#define ESBMC_FLAIL(body, size, ...) f(body, size, libm + "/" #__VA_ARGS__);
#include <libm.h>
#undef ESBMC_FLAIL
  }

public:
  const std::string &header_dir()
  {
    if(headers == "")
    {
      using namespace boost::filesystem;
      headers = base_path() + "/headers";
      create_directory(headers);
      create_directory(headers + "/bits");
      create_directory(headers + "/sys");
      create_directory(headers + "/sys/_types");
      create_directory(headers + "/sys/_pthread");
#define ESBMC_FLAIL(body, size, ...)                                           \
  std::ofstream(headers + "/" #__VA_ARGS__).write(body, size);
#include <headers/libc_hdr.h>
#undef ESBMC_FLAIL
    }
    return headers;
  }

  template <typename F>
  void foreach_libc_libm(F &&f)
  {
    if(libc == "")
    {
      using namespace boost::filesystem;
      libc = base_path() + "/library";
      libm = libc + "/libm";
      create_directory(libc);
      create_directory(libm);
      foreach_libc_libm_([&f](const char *body, size_t size, std::string path) {
        std::ofstream(path).write(body, size);
        f(path);
      });
    }
    else
      foreach_libc_libm_(
        [&f](const char *, size_t, std::string path) { f(path); });
  }
} internal_libc;

const std::string *internal_libc_header_dir()
{
  return config.ansi_c.lib == configt::ansi_ct::libt::LIB_NONE
           ? nullptr
           : &internal_libc.header_dir();
}

void add_bundled_library_sources(
  contextt &context,
  const messaget &message_handler,
  const languaget &c_language)
{
  /* First extract headers (if not already done) */
  if(internal_libc_header_dir())
    /* Next, extract (if not already done) and process every libc/libm file. */
    internal_libc.foreach_libc_libm([&](const std::string &path) {
      languaget *l = c_language.new_language(message_handler);
      message_handler.status("file " + path + ": Parsing");
      if(
        l->parse(path, message_handler) ||
        l->typecheck(context, path, message_handler))
      {
        message_handler.error("error processing internal libc source " + path);
        abort();
      }
      delete l;
    });
}
