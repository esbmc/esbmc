/*******************************************************************\

Module:

Author: Daniel Kroening, kroening@kroening.com

\*******************************************************************/

#include <ac_config.h>
#include <boost/filesystem.hpp>
#include <c2goto/cprover_library.h>
#include <cstdlib>
#include <fstream>
#include <goto-programs/read_goto_binary.h>
#include <util/c_link.h>
#include <util/config.h>
#include <util/language.h>

extern "C"
{
  extern const uint8_t clib32_buf[];
  extern const uint8_t clib64_buf[];
  extern const unsigned int clib32_buf_size;
  extern const unsigned int clib64_buf_size;

  extern const uint8_t clib32_fp_buf[];
  extern const uint8_t clib64_fp_buf[];
  extern const unsigned int clib32_fp_buf_size;
  extern const unsigned int clib64_fp_buf_size;

#include <libc.h>
#include <libm.h>
#include <headers/libc_hdr.h>
#undef ESBMC_FLAIL
}

namespace
{
/* [floatbv ? 1 : 0][wordsz == 64 ? 1 : 0] */
static const struct buffer
{
  const uint8_t *start;
  size_t size;
} clibs[2][2] = {
#ifdef ESBMC_BUNDLE_LIBC
  {
    {&clib32_buf[0], clib32_buf_size},
    {&clib64_buf[0], clib64_buf_size},
  },
  {
    {&clib32_fp_buf[0], clib32_fp_buf_size},
    {&clib64_fp_buf[0], clib64_fp_buf_size},
  },
#endif
};
} // namespace

static void generate_symbol_deps(
  irep_idt name,
  irept irep,
  std::multimap<irep_idt, irep_idt> &deps)
{
  std::pair<irep_idt, irep_idt> type;

  if(irep.id() == "symbol")
  {
    type = std::pair<irep_idt, irep_idt>(name, irep.identifier());
    deps.insert(type);
    return;
  }

  forall_irep(irep_it, irep.get_sub())
  {
    if(irep_it->id() == "symbol")
    {
      type = std::pair<irep_idt, irep_idt>(name, irep_it->identifier());
      deps.insert(type);
      generate_symbol_deps(name, *irep_it, deps);
    }
    else if(irep_it->id() == "argument")
    {
      type = std::pair<irep_idt, irep_idt>(name, irep_it->cmt_identifier());
      deps.insert(type);
    }
    else
    {
      generate_symbol_deps(name, *irep_it, deps);
    }
  }

  forall_named_irep(irep_it, irep.get_named_sub())
  {
    if(irep_it->second.id() == "symbol")
    {
      type = std::pair<irep_idt, irep_idt>(name, irep_it->second.identifier());
      deps.insert(type);
    }
    else if(irep_it->second.id() == "argument")
    {
      type =
        std::pair<irep_idt, irep_idt>(name, irep_it->second.cmt_identifier());
      deps.insert(type);
    }
    else
    {
      generate_symbol_deps(name, irep_it->second, deps);
    }
  }
}

static void ingest_symbol(
  irep_idt name,
  std::multimap<irep_idt, irep_idt> &deps,
  std::list<irep_idt> &to_include)
{
  std::pair<
    std::multimap<irep_idt, irep_idt>::const_iterator,
    std::multimap<irep_idt, irep_idt>::const_iterator>
    range;
  std::multimap<irep_idt, irep_idt>::const_iterator it;

  range = deps.equal_range(name);
  if(range.first == range.second)
    return;

  for(it = range.first; it != range.second; it++)
    to_include.push_back(it->second);

  deps.erase(name);
}

/* This class represents the extracted internal libc. It uses the headers
 * generated by the build system to dump the bundled libc/libm files in a
 * temporary directory. The headers contain invocations of the form
 * ESBMC_FLAIL(body, size, name) for each bundled file,
 * see scripts/flail.py --macro. */
static class
{
  file_operations::tmp_path base;
  std::string libc, libm, headers;

  const std::string &base_path()
  {
    if(base.path() == "")
      base = file_operations::create_tmp_dir();
    return base.path();
  }

  template <typename F>
  void foreach_libc_libm_(F &&f)
  {
#define ESBMC_FLAIL(body, size, ...) f(body, size, libc + "/" #__VA_ARGS__);
#include <libc.h>
#undef ESBMC_FLAIL

#define ESBMC_FLAIL(body, size, ...) f(body, size, libm + "/" #__VA_ARGS__);
#include <libm.h>
#undef ESBMC_FLAIL
  }

public:
  const std::string &header_dir()
  {
    if(headers == "")
    {
      using namespace boost::filesystem;
      headers = base_path() + "/headers";
      create_directory(headers);
#define ESBMC_FLAIL(body, size, ...)                                           \
  std::ofstream(headers + "/" #__VA_ARGS__).write(body, size);
#include <headers/libc_hdr.h>
#undef ESBMC_FLAIL
    }
    return headers;
  }

  template <typename F>
  void foreach_libc_libm(F &&f)
  {
    if(libc == "")
    {
      using namespace boost::filesystem;
      libc = base_path() + "/library";
      libm = libc + "/libm";
      create_directory(libc);
      create_directory(libm);
      foreach_libc_libm_([&f](const char *body, size_t size, std::string path) {
        std::ofstream(path).write(body, size);
        f(path);
      });
    }
    else
      foreach_libc_libm_(
        [&f](const char *, size_t, std::string path) { f(path); });
  }
} internal_libc;

const std::string *internal_libc_header_dir()
{
  return config.ansi_c.lib == configt::ansi_ct::libt::LIB_NONE
           ? nullptr
           : &internal_libc.header_dir();
}

/* Adds the internal libc to `context` by parsing and linking all C sources.
 *
 * Note that parsing the entire ESBMC standard library is a slow process.
 */
static void add_bundled_library_sources(
  contextt &context,
  const messaget &message_handler,
  const languaget &c_language)
{
  /* First extract headers (if not already done) */
  if(internal_libc_header_dir())
    /* Next, extract (if not already done) and process every libc/libm file. */
    internal_libc.foreach_libc_libm([&](const std::string &path) {
      languaget *l = c_language.new_language(message_handler);
      message_handler.status("file " + path + ": Parsing");
      if(
        l->parse(path, message_handler) ||
        l->typecheck(context, path, message_handler))
      {
        message_handler.error("error processing internal libc source " + path);
        abort();
      }
      delete l;
    });
}

void add_cprover_library(
  contextt &context,
  const messaget &message_handler,
  const languaget *c_language)
{
  if(config.ansi_c.lib == configt::ansi_ct::libt::LIB_NONE)
    return;

  contextt new_ctx(message_handler), store_ctx(message_handler);
  goto_functionst goto_functions;
  std::multimap<irep_idt, irep_idt> symbol_deps;
  std::list<irep_idt> to_include;
  const buffer *clib;

  switch(config.ansi_c.word_size)
  {
  case 16:
    message_handler.warning(
      "Warning: this version of ESBMC does not have a C library "
      "for 16 bit machines");
    return;
  case 32:
  case 64:
    break;
  default:
    message_handler.error(
      fmt::format("No C library for bitwidth {}", config.ansi_c.word_size));
    abort();
  }

  clib =
    &clibs[!config.ansi_c.use_fixed_for_float][config.ansi_c.word_size == 64];

  if(clib->size == 0)
  {
    if(c_language)
      return add_bundled_library_sources(context, message_handler, *c_language);
    message_handler.error("error: Zero-lengthed internal C library");
    abort();
  }

  if(read_goto_binary_array(
       clib->start, clib->size, new_ctx, goto_functions, message_handler))
    abort();

  new_ctx.foreach_operand([&symbol_deps](const symbolt &s) {
    generate_symbol_deps(s.id, s.value, symbol_deps);
    generate_symbol_deps(s.id, s.type, symbol_deps);
  });

  // Add two hacks; we might use either pthread_mutex_lock or the checked
  // variant; so if one version is used, pull in the other too.
  std::pair<irep_idt, irep_idt> lockcheck(
    dstring("pthread_mutex_lock"), dstring("pthread_mutex_lock_check"));
  symbol_deps.insert(lockcheck);

  std::pair<irep_idt, irep_idt> condcheck(
    dstring("pthread_cond_wait"), dstring("pthread_cond_wait_check"));
  symbol_deps.insert(condcheck);

  std::pair<irep_idt, irep_idt> joincheck(
    dstring("pthread_join"), dstring("pthread_join_noswitch"));
  symbol_deps.insert(joincheck);

  /* The code just pulled into store_ctx might use other symbols in the C
   * library. So, repeatedly search for new C library symbols that we use but
   * haven't pulled in, then pull them in. We finish when we've made a pass
   * that adds no new symbols. */

  new_ctx.foreach_operand(
    [&context, &store_ctx, &symbol_deps, &to_include](const symbolt &s) {
      const symbolt *symbol = context.find_symbol(s.id);
      if(symbol != nullptr && symbol->value.is_nil())
      {
        store_ctx.add(s);
        ingest_symbol(s.id, symbol_deps, to_include);
      }
    });

  for(std::list<irep_idt>::const_iterator nameit = to_include.begin();
      nameit != to_include.end();
      nameit++)
  {
    symbolt *s = new_ctx.find_symbol(*nameit);
    if(s != nullptr)
    {
      store_ctx.add(*s);
      ingest_symbol(*nameit, symbol_deps, to_include);
    }
  }

  if(c_link(context, store_ctx, message_handler, "<built-in-library>"))
  {
    // Merging failed
    message_handler.error("Failed to merge C library");
    abort();
  }
}
