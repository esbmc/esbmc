/*******************************************************************
 Module:

 Author: Felipe Rodrigues

 Date: January 2013

 \*******************************************************************/

#ifndef __STL_MAP
#define __STL_MAP

#include "utility"
#include "vector"
#include "functional"

#define MAP_SIZE 15

namespace std {

#if 0
template<class T>
class node {
public:
	T data;
	node* prev;
	node* next;
	node(T t, node* p, node* n) :
	data(t), prev(p), next(n) {
	}
};

template<class T>
class list_esbmc {
public:

	typedef bool (pred_double)(double, double);
	typedef bool (pred)(const int &);

	node<T>* head;
	node<T>* tail;
	int _size;

	explicit list_esbmc() :
	head(NULL), tail(NULL), _size(0) {
	}

	explicit list_esbmc(int n, const T& value = T()) {
		int i;
		this->_size = 0;
		for (i = 0; i < n; i++)
		this->push_back(value);
	}

	explicit list_esbmc(T* t1, T* t2) {

		this->_size = 0;
		for (; t1 != t2; t1++)
		this->push_back(*t1);
	}

	list_esbmc(const list_esbmc<T>& x) {
		this->head = x.head;
		this->tail = x.tail;
		this->_size = x._size;
	}

	~list_esbmc() {
		while (head) {
			node<T>* temp(head);
			head = head->next;
			delete temp;
		}
	}

	bool empty() const {
		if (this->_size == 0)
		return true;
		return false;
	}

	void push_back(const T& x) {
		if (this->empty()) {
			this->tail = new node<T>(x, NULL, NULL);
			this->head = this->tail;
		} else {
			this->tail->next = new node<T>(x, this->tail, NULL);
			this->tail = this->tail->next;
			if (this->_size == 1)
			this->head->next == this->tail;
		}
		this->_size++;
	}

	void push_front(const T& x) {
		if (this->empty()) {
			this->head = new node<T>(x, NULL, NULL);
			this->tail = this->head;
		} else {
			this->head->prev = new node<T>(x, NULL, this->head);
			this->head = this->head->prev;
			if (this->_size == 1)
			this->tail->prev == this->head;
		}
		this->_size++;
	}

	void pop_front() {
		if (this->_size == 1) {
			this->head = this->tail = NULL;
		} else {
			this->head->data = this->head->next->data;
			this->head->prev = NULL;
			this->head->next = this->head->next->next;
		}
		this->_size--;
	}
	void pop_back () {
		if (this->_size == 1) {
			this->head = this->tail = NULL;
		} else {
			this->tail->data = this->tail->prev->data;
			this->tail->prev = this->tail->prev->prev;
			this->tail->next = NULL;
		}
		this->_size--;
	}

};

namespace std {

	template<class Key, class T, class Compare = less<Key> >
	class map {

	public:

		typedef Key key_type;
		typedef T mapped_type;
		typedef pair<const Key, T> value_type;
		typedef Compare key_compare;
		typedef unsigned int size_type;

		class value_compare
		{
			friend class map;
		protected:
			Compare comp;
			value_compare (Compare c) : comp(c) {}
		public:
			typedef bool result_type;
			typedef value_type first_argument_type;
			typedef value_type second_argument_type;
			bool operator() (const value_type& x, const value_type& y) const
			{
				return comp(x.first, y.first);
			}
		};

		list_esbmc<value_type>* map_list;
		size_type _size;

		typedef bool (func)(Key, Key);

		class iterator {
		public:

			iterator(const iterator& x);
			iterator();
			iterator& operator=(const iterator& x);

			value_type * operator ->();

			value_type & operator *();

			iterator& operator ++();
			iterator operator ++(int);

			iterator& operator --();
			iterator operator --(int);

			//bool operator == (const iterator& it) const;
			bool operator !=(const iterator& it) const;
		};

		class const_iterator {/*
		 public:
		 const_iterator(const const_iterator&);
		 const_iterator();
		 const_iterator& operator=(const const_iterator&);

		 //const value_type * operator -> ();

		 //const value_type & operator * ();

		 const_iterator& operator ++ ();
		 const_iterator operator ++ (int);

		 const_iterator& operator -- ();
		 const_iterator operator -- (int);

		 bool operator == ( const const_iterator&)const;
		 bool operator != ( const const_iterator&)const;
		 */
		};

		class reverse_iterator {
		public:
			//reverse_iterator(reverse_iterator);
			reverse_iterator();
			//explicit reverse_iterator(iterator);

			//iterator base() const; // explicit

			//reverse_iterator& operator=(const reverse_iterator&);

			value_type * operator ->();

			value_type & operator *();

			reverse_iterator& operator ++();
			reverse_iterator operator ++(int);

			//reverse_iterator& operator -- ();
			//reverse_iterator operator -- (int);

			//bool operator == ( const reverse_iterator&)const;
			bool operator !=(const reverse_iterator&) const;
		};

		class const_reverse_iterator {
			/*public:
			 const_reverse_iterator(const_reverse_iterator);
			 const_reverse_iterator();
			 explicit const_reverse_iterator(const_iterator);

			 const_iterator base() const; // explicit

			 const_reverse_iterator& operator=(const const_reverse_iterator);

			 //const value_type * operator -> ();

			 //const value_type & operator * ();

			 const_reverse_iterator& operator ++ ();
			 const_reverse_iterator operator++ (int);

			 const_reverse_iterator& operator -- ();
			 const_reverse_iterator operator -- (int);

			 bool operator == ( const const_reverse_iterator&)const;
			 bool operator != ( const const_reverse_iterator&)const;
			 */};

		map() {
			map_list = new list_esbmc<value_type>();
			this->_size = 0;
		}

		map(iterator first, iterator last);

		map(func* x);

		map(map& x) {
			this->map_list = x.map_list;
			this->_size = x._size;
		}

		mapped_type& operator[](const Key& x) {
			value_type par(x, T());
			node<value_type>* tmp = this->map_list->head;

			if (this->_size == 0) {
				this->map_list->push_back(par);
				this->_size++;
				return this->map_list->head->data.second;
			} else {
				while (tmp != NULL) {
					if (!(par.first < tmp->data.first)) {
						if (tmp->data.first < par.first) {
							if (tmp->prev == NULL) {
								this->map_list->push_front(par);
								return this->map_list->head->data.second;
							} else {
								node<value_type>* new_node = new node<value_type>(
										par, tmp->prev, tmp);
								tmp->prev->next = new_node;
								tmp->prev = new_node;
								return tmp->prev->data.second;
							}
						}
						return tmp->data.second;
					}
					tmp = tmp->next;
				}
				if (tmp == NULL) {
					this->map_list->push_back(par);
					return this->map_list->tail->data.second;
				}
			}
		}

		// iterators:
		iterator begin();
		const_iterator begin() const;
		iterator end();
		const_iterator end() const;
		reverse_iterator rbegin();
		const_reverse_iterator rbegin() const;
		reverse_iterator rend();
		const_reverse_iterator rend() const;

		size_type count(const key_type& x) const;
		void erase(iterator position);
		void erase(iterator first, iterator last);

		mapped_type& at(const Key& x) {
			value_type par(x, mapped_type());
			node<value_type>* tmp = this->map_list->head;

			if (this->_size == 0) {
				this->map_list->push_back(par);
				this->_size++;
				return this->map_list->head->data.second;
			} else {
				while (tmp != NULL) {
					if (!(par.first < tmp->data.first)) {
						if (tmp->data.first < par.first) {
							if (tmp->prev == NULL) {
								this->map_list->push_front(par);
								this->_size++;
								return this->map_list->head->data.second;
							} else {
								node<value_type>* new_node = new node<value_type>(
										par, tmp->prev, tmp);
								tmp->prev->next = new_node;
								tmp->prev = new_node;
								this->_size++;
								return tmp->prev->data.second;
							}
						}
						return tmp->data.second;
					}
					tmp = tmp->next;
				}
				if (tmp == NULL) {
					this->map_list->push_back(par);
					this->_size++;
					return this->map_list->tail->data.second;
				}
			}
		}

		bool empty() const {
			if(this->_size == 0)
			return true;
			return false;
		}

		size_type size() const {
			return this->_size;
		}

		size_type max_size() const {
			return nondet_int();
		}

		map& operator= (const map& x) {
			this->map_list = x.map_list;
			this->_size = x._size;
			return *this;
		}

		void clear() {
			this->map_list->~list_esbmc();
			this->_size = 0;
		}

		~map() {
			this->map_list->~list_esbmc();
			this->_size = 0;
		}

		void swap (map& x) {
			node<value_type>* tmpHead = this->map_list->head;
			node<value_type>* tmpTail = this->map_list->tail;
			size_type tmpSize = this->_size;
			this->map_list->head = x.map_list->head;
			this->map_list->tail = x.map_list->tail;
			this->_size = x._size;
			x.map_list->head = tmpHead;
			x.map_list->tail = tmpTail;
			x._size = tmpSize;
		}

		void insert (const value_type& val) {
			this->at(val.first) = val.second;
		}

		size_type erase (const key_type& k) {
			value_type par(k, mapped_type());
			node<value_type>* tmp = this->map_list->head;

			if (this->_size == 0) {
				return this->_size;
			} else {
				while (tmp != NULL) {
					if (!(par.first < tmp->data.first)) {
						if (tmp->data.first < par.first) {
							if (tmp->prev == NULL) {
								return this->_size;
							} else {
								return this->_size;
							}
						}
						if(tmp->prev != NULL)
						tmp->prev->next = tmp->next;
						if(tmp->next != NULL)
						tmp->next->prev = tmp->prev;
						return this->_size--;
					}
					tmp = tmp->next;
				}
				return this->_size;
			}
		}

		key_compare key_comp() const {
			return key_compare();
		}

		value_compare value_comp() const; //{
		//return value_compare(Compare());
		//}
#if 0
		// modifiers:
		pair<iterator,bool> insert ( const value_type& x );
		iterator insert ( iterator position, const value_type& x );
		void insert ( map<Key,T>::iterator first, map<Key,T>::iterator last );
		//pair<iterator, bool> insert(const value_type& x);
		//pair<iterator, bool> insert(const std::pair<Key,T>& x);
		//map<Key,T>::iterator insert(map<Key,T>::iterator position, const value_type& x);
		void insert( map<Key,T>::iterator position, std::pair<Key,T>& x);

		//void swap(map<Key,T,Compare>);

		// map operations:
		iterator find(const key_type& x);
		const_iterator find(const key_type& x) const;
		iterator lower_bound(const key_type& x);
		//const_iterator lower_bound(const key_type& x) const;
		iterator upper_bound(const key_type& x);
		//const_iterator upper_bound(const key_type& x) const;
		pair<iterator,iterator> equal_range(const key_type& x);
		pair<const_iterator,const_iterator> equal_range(const key_type& x) const;
		key_compare key_comp ( ) const;

		void swap(map<Key,T>& x);

		// comparators:

		bool operator == (const map<Key,T,Compare>&) const;
		bool operator != (const map<Key,T,Compare>&) const;
		bool operator >= (const map<Key,T,Compare>&) const;
		bool operator <= (const map<Key,T,Compare>&) const;

#endif
	};
#endif

template<class Key, class T, class Compare = less<Key> >
class map {

public:

	typedef Key key_type;
	typedef T mapped_type;
	typedef pair<Key, T> value_type;
	typedef Compare key_compare;
	typedef unsigned int size_type;

	key_type _key[MAP_SIZE];
	mapped_type _value[MAP_SIZE];
	int _size;

	typedef bool (func)(Key, Key);

	class value_compare {
	public:
		Compare comp;
		value_compare(Compare c) :
				comp(c) {
		}
		typedef bool result_type;
		typedef value_type first_argument_type;
		typedef value_type second_argument_type;
		bool operator()(value_type& x, value_type& y) const {
			return comp(x.first, y.first);
		}
	};

	class iterator {
	public:

		key_type* it_key;
		mapped_type* it_value;
		value_type it_pair;
		int it_pos;

		iterator(const iterator& x) {
			this->it_key = x.it_key;
			this->it_pos = x.it_pos;
			this->it_value = x.it_value;
			this->it_pair = x.it_pair;
		}
		iterator() {
			this->it_pos = -1;
		}
		iterator& operator=(const iterator& x) {
			this->it_key = x.it_key;
			this->it_pos = x.it_pos;
			this->it_value = x.it_value;
			this->it_pair = x.it_pair;
			return *this;
		}

		value_type * operator ->() {
			return &(this->it_pair);
		}

		value_type & operator *() {
			return this->it_pair;
		}

		iterator& operator ++() {
			this->it_pos++;
			this->it_pair.first = this->it_key[this->it_pos];
			this->it_pair.second = this->it_value[this->it_pos];
			return *this;
		}
		iterator operator ++(int) {
			this->it_pos++;
			this->it_pair.first = this->it_key[this->it_pos];
			this->it_pair.second = this->it_value[this->it_pos];
			return *this;
		}

		iterator& operator --() {
			this->it_pos--;
			this->it_pair.first = this->it_key[this->it_pos];
			this->it_pair.second = this->it_value[this->it_pos];
			return *this;
		}
		iterator operator --(int) {
			this->it_pos--;
			this->it_pair.first = this->it_key[this->it_pos];
			this->it_pair.second = this->it_value[this->it_pos];
			return *this;
		}

		bool operator ==(const iterator& it) const {
			if (this->it_pos == it.it_pos)
				return true;
			if ((this->it_pair.first == it.it_pair.first)
					&& (this->it_pair.second == it.it_pair.second))
				return true;
			return false;
		}
		bool operator !=(const iterator& it) const {
			if (this->it_pos != it.it_pos)
				return true;
			if ((this->it_pair.first != it.it_pair.first)
					&& (this->it_pair.second != it.it_pair.second))
				return true;
			return false;
		}
	};

	typedef iterator const_iterator;

	class reverse_iterator {
	public:

		key_type* it_key;
		mapped_type* it_value;
		value_type it_pair;
		int it_pos;
		int* it_size;

		reverse_iterator(const reverse_iterator& x) {
			this->it_key = x.it_key;
			this->it_pos = x.it_pos;
			this->it_value = x.it_value;
			this->it_pair = x.it_pair;
			this->it_size = x.it_size;
		}
		reverse_iterator() {
			this->it_pos = -1;
		}
		reverse_iterator& operator=(const reverse_iterator& x) {
			this->it_key = x.it_key;
			this->it_pos = x.it_pos;
			this->it_value = x.it_value;
			this->it_pair = x.it_pair;
			this->it_size = x.it_size;
			return *this;
		}

		value_type * operator ->() {
			return &(this->it_pair);
		}

		value_type & operator *() {
			return this->it_pair;
		}

		reverse_iterator& operator ++() {
			if (this->it_pos == 0) {
				this->it_pos--;
				this->it_pair.first = Key();
				this->it_pair.second = T();
				return *this;
			}
			if (this->it_pos == -1) {
				this->it_pos = *(this->it_size) - 1;
			} else {
				this->it_pos--;
			}
			this->it_pair.first = this->it_key[this->it_pos];
			this->it_pair.second = this->it_value[this->it_pos];
			return *this;
		}
		reverse_iterator operator ++(int) {
			if (this->it_pos == 0) {
				this->it_pos--;
				this->it_pair.first = Key();
				this->it_pair.second = T();
				return *this;
			}
			if (this->it_pos == -1) {
				this->it_pos = *(this->it_size) - 1;
			} else {
				this->it_pos--;
			}
			this->it_pair.first = this->it_key[this->it_pos];
			this->it_pair.second = this->it_value[this->it_pos];
			return *this;
		}

		reverse_iterator& operator --() {
			if (this->it_pos == this->it_size) {
				this->it_pos = 0;
			} else {
				this->it_pos++;
			}
			this->it_pair.first = this->it_key[this->it_pos];
			this->it_pair.second = this->it_value[this->it_pos];
			return *this;
		}
		reverse_iterator operator --(int) {
			if (this->it_pos == this->it_size) {
				this->it_pos = 0;
			} else {
				this->it_pos++;
			}
			this->it_pair.first = this->it_key[this->it_pos];
			this->it_pair.second = this->it_value[this->it_pos];
			return *this;
		}

		bool operator ==(const reverse_iterator& it) const {
			if (this->it_pos == it.it_pos)
				return true;
			if ((this->it_pair.first == it.it_pair.first)
					&& (this->it_pair.second == it.it_pair.second))
				return true;
			return false;
		}
		bool operator !=(const reverse_iterator& it) const {
			if (this->it_pos != it.it_pos)
				return true;
			if ((this->it_pair.first != it.it_pair.first)
					&& (this->it_pair.second != it.it_pair.second))
				return true;
			return false;
		}
	};

	//class const_reverse_iterator {};

	map() {
		this->_size = 0;
	}

	map(iterator first, iterator last) {
		int j = 0;
		this->_size = 0;
		int limit = last.it_pos - first.it_pos;
		for (int i = first.it_pos; i != limit; i++, j++) {
			this->_key[j] = first.it_key[i];
			this->_value[j] = first.it_value[i];
			this->_size++;
		}
	}

	map(func* x) {
		this->_size = 0;
	}

	map(map& x) {
		this->_size = x._size;
		size_type s = x._size;
		for (int i = 0; i < s; i++) {
			this->_key[i] = x._key[i];
			this->_value[i] = x._value[i];
		}
	}

	T& operator[](const Key& x) {
		unsigned int s = this->_size;
		if (this->_size == 0) {
			this->_key[0] = x;
			this->_size++;
			//this->_value[0] = T();
			this->_value[0] = T();
			this->_key[this->_size + 1] = Key();
			return this->_value[0];
		} else {
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == x) {
					return this->_value[i];
				}
				//if(x < this->_key[i]){
				if (key_compare()((Key&) x, this->_key[i])) {
					int j;
					Key y = x;
					Key t;
					T u, v;

					for (j = i; j < s; j++) {
						t = this->_key[j];
						this->_key[j] = y;
						y = t;
						u = this->_value[j];
						this->_value[j] = v;
						v = u;
					}
					this->_key[j] = y;
					this->_value[j] = u;

					this->_size++;
					//this->_value[i] = T();
					this->_value[i] = T();
					this->_key[this->_size + 1] = Key();
					return this->_value[i];
				}
			}
			this->_size++;
			this->_key[s] = x;
			//this->_value[s] = T();
			this->_value[s] = T();
			this->_key[this->_size + 1] = Key();
			return this->_value[s];
		}
	}

	// iterators:
	iterator begin() {
		iterator it;
		it.it_key = this->_key;
		it.it_value = this->_value;
		it.it_pos = 0;
		it.it_pair.first = this->_key[0];
		it.it_pair.second = this->_value[0];
		return it;
	}
	//const_iterator begin() const;
	iterator end() {
		iterator it;
		it.it_key = this->_key;
		it.it_value = this->_value;
		it.it_pos = this->_size;
		it.it_pair.first = this->_key[it.it_pos];
		it.it_pair.second = this->_value[it.it_pos];
		return it;
	}
	//const_iterator end() const;
	reverse_iterator rbegin() {
		reverse_iterator it;
		it.it_key = this->_key;
		it.it_value = this->_value;
		it.it_size = &(this->_size);
		it.it_pos = this->_size - 1;
		it.it_pair.first = this->_key[it.it_pos];
		it.it_pair.second = this->_value[it.it_pos];
		return it;
	}
	//const_reverse_iterator rbegin() const;
	reverse_iterator rend() {
		reverse_iterator it;
		it.it_key = this->_key;
		it.it_value = this->_value;
		it.it_size = &(this->_size);
		it.it_pos = -1;
		it.it_pair.first = Key();
		it.it_pair.second = T();
		return it;
	}
	//const_reverse_iterator rend() const;

	mapped_type& at(const Key& x) {
		unsigned int s = this->_size;
		if (this->_size == 0) {
			this->_key[0] = x;
			this->_size++;
			//this->_value[0] = T();
			this->_value[0] = T();
			this->_key[this->_size + 1] = Key();
			return this->_value[0];
		} else {
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == x) {
					return this->_value[i];
				}
				//if(x < this->_key[i]){
				if (key_compare()((Key &) x, this->_key[i])) {
					int j;
					Key y = x;
					Key t;
					T u, v;

					for (j = i; j < s; j++) {
						t = this->_key[j];
						this->_key[j] = y;
						y = t;
						u = this->_value[j];
						this->_value[j] = v;
						v = u;
					}
					this->_key[j] = y;
					this->_value[j] = u;

					this->_size++;
					//this->_value[i] = T();
					this->_value[i] = T();
					this->_key[this->_size + 1] = Key();
					return this->_value[i];
				}
			}
			this->_size++;
			this->_key[s] = x;
			//this->_value[s] = T();
			this->_value[s] = T();
			this->_key[this->_size + 1] = Key();
			return this->_value[s];
		}
	}

	bool empty() const {
		if (this->_size == 0)
			return true;
		return false;
	}

	size_type size() const {
		return this->_size;
	}

	size_type max_size() const {
		return size_type();
	}

	map& operator=(const map& x) {
		this->clear();
		this->_size = x._size;
		for (int i = 0; i < x._size; i++) {
			this->_key[i] = x._key[i];
			this->_value[i] = x._value[i];
		}
		return *this;
	}

	void clear() {
		this->_size = 0;
		for (int i = 0; i < this->_size; i++) {
			this->_key[i] = Key();
			this->_value[i] = T();
		}
	}

	~map() {
		this->clear();
	}

	void swap(map& x) {
		map tmp;
		tmp = *this;
		*this = x;
		x = tmp;
	}

	pair<iterator, bool> insert(value_type& val) {
		unsigned int s = this->_size;
		pair<iterator, bool> _pair;
		if (this->_size == 0) {
			this->_key[0] = val.first;
			this->_size++;
			//this->_value[0] = T();
			this->_value[0] = val.second;
			_pair.first = this->begin();
			_pair.second = true;
			return _pair;
		} else {
			iterator it = this->begin();
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == val.first) {
					_pair.first = it;
					_pair.second = false;
					return _pair;
				}
				//if(x < this->_key[i]){
				if (key_compare()(val.first, this->_key[i])) {
					int j;
					Key y = val.first;
					Key t;
					T u, v;

					for (j = i; j < s; j++) {
						t = this->_key[j];
						this->_key[j] = y;
						y = t;
						u = this->_value[j];
						this->_value[j] = v;
						v = u;
					}
					this->_key[j] = y;
					this->_value[j] = u;

					this->_size++;
					//this->_value[i] = T();
					this->_value[i] = val.second;
					_pair.first = it;
					_pair.second = true;
					return _pair;
				}
				it++;
			}
			this->_size++;
			this->_key[s] = val.first;
			//this->_value[s] = T();
			this->_value[s] = val.second;
			_pair.first = this->end();
			_pair.second = true;
			return _pair;
		}
	}

	iterator insert(iterator position, const value_type& val) {
		key_type x = val.first;
		unsigned int s = this->_size;
		if (this->_size == 0) {
			this->_key[0] = x;
			this->_size++;
			//this->_value[0] = T();
			this->_value[0] = val.second;
			return this->begin();
		} else {
			iterator it = this->begin();
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == x) {
					return it;
				}
				//if(x < this->_key[i]){
				if (key_compare()(x, this->_key[i])) {
					int j;
					Key y = x;
					Key t;
					T u, v;

					for (j = i; j < s; j++) {
						t = this->_key[j];
						this->_key[j] = y;
						y = t;
						u = this->_value[j];
						this->_value[j] = v;
						v = u;
					}
					this->_key[j] = y;
					this->_value[j] = u;

					this->_size++;
					//this->_value[i] = T();
					this->_value[i] = val.second;
					return it;
				}
				it++;
			}
			this->_size++;
			this->_key[s] = x;
			//this->_value[s] = T();
			this->_value[s] = val.second;
			return this->end();
		}
	}

	void insert(iterator first, iterator last) {
		for (iterator it = first; it.it_pos != last.it_pos; it++) {
			this->at(it.it_key[it.it_pos]) = it.it_value[it.it_pos];
		}
	}

	size_type erase(const key_type& k) {
		if (this->_size != 0) {
			unsigned int s = this->_size;
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == k) {
					this->_size--;
					int j;
					for (j = i; j < s; j++) {
						this->_key[j] = this->_key[j + 1];
						this->_value[j] = this->_value[j + 1];
					}
					this->_key[j - 1] = Key();
					this->_value[j - 1] = T();
					return this->_size;
				}
			}
		}
		return this->_size;
	}

	void erase(iterator position) {
		if (this->_size != 0) {
			unsigned int s = this->_size;
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == position.it_key[position.it_pos]) {
					this->_size--;
					int j;
					for (j = i; j < s; j++) {
						this->_key[j] = this->_key[j + 1];
						this->_value[j] = this->_value[j + 1];
					}
					this->_key[j - 1] = Key();
					this->_value[j - 1] = T();
					return;
				}
			}
		}
	}

	void erase(iterator first, iterator last) {
		if (this->_size != 0) {
			unsigned int s = this->_size;
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == first.it_key[first.it_pos]) {
					this->_size = this->_size - (last.it_pos - first.it_pos);
					int j;
					for (j = i; j < s; j++) {
						this->_key[j] = this->_key[j + last.it_pos];
						this->_value[j] = this->_value[j + last.it_pos];
					}
					this->_key[j - 1] = Key();
					this->_value[j - 1] = T();
					return;
				}
			}
		}
	}

	size_type count(key_type& x) {
		if (this->_size != 0) {
			int s = this->_size;
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == x) {
					return 1;
				}
			}
		}
		return 0;
	}

	iterator find(const key_type& x) {
		unsigned int s = this->_size;
		iterator it = this->begin();
		if (this->_size == 0) {
			return it;
		} else {
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == x) {
					return it;
				}
				//if(x < this->_key[i]){
				if (key_compare()((Key &) x, this->_key[i])) {
					int j;
					Key y = x;
					Key t;
					T u, v;

					for (j = i; j < s; j++) {
						t = this->_key[j];
						this->_key[j] = y;
						y = t;
						u = this->_value[j];
						this->_value[j] = v;
						v = u;
					}
					this->_key[j] = y;
					this->_value[j] = u;

					this->_size++;
					//this->_value[i] = T();
					this->_value[i] = T();
					return it;
				}
				it++;
			}
			this->_size++;
			this->_key[s] = x;
			//this->_value[s] = T();
			this->_value[s] = T();
			return this->end();
		}
	}

	key_compare key_comp() const {
		return key_compare();
	}

	value_compare value_comp() const {
		return value_compare(Compare());
	}

	iterator lower_bound(const key_type& x) {
		unsigned int s = this->_size;
		if (this->_size == 0) {
			return this->end();
		} else {
			iterator it = this->begin();
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == x) {
					return it;
				}
				//if(x < this->_key[i]){
				if (key_compare()((Key&) x, this->_key[i])) {
					return this->end();
				}
				it++;
			}
			return this->end();
		}
	}

	iterator upper_bound(const key_type& x) {
		unsigned int s = this->_size;
		if (this->_size == 0) {
			return this->end();
		} else {
			iterator it = this->begin();
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == x) {
					it++;
					return it;
				}
				//if(x < this->_key[i]){
				if (key_compare()((Key&) x, this->_key[i])) {
					return this->end();
				}
				it++;
			}
			return this->end();
		}
	}

	pair<iterator, iterator> equal_range(const key_type& k) {
		unsigned int s = this->_size;
		pair<iterator, iterator> _pair;
		_pair.second = this->upper_bound(k);
		if (this->_size == 0) {
			_pair.first = this->upper_bound(k);
			return _pair;
		} else {
			iterator it = this->begin();
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == k) {
					_pair.first = it;
					return _pair;
				}
				//if(x < this->_key[i]){
				if (key_compare()((Key&) k, this->_key[i])) {
					_pair.first = this->upper_bound(k);
					return _pair;
				}
				it++;
			}
			_pair.first = this->upper_bound(k);
			return _pair;
		}
	}

#if 0
	// modifiers:
	pair<iterator,bool> insert ( const value_type& x );
	iterator insert ( iterator position, const value_type& x );
	void insert ( map<Key,T>::iterator first, map<Key,T>::iterator last );
	//pair<iterator, bool> insert(const value_type& x);
	//pair<iterator, bool> insert(const std::pair<Key,T>& x);
	//map<Key,T>::iterator insert(map<Key,T>::iterator position, const value_type& x);
	void insert( map<Key,T>::iterator position, std::pair<Key,T>& x);

	// map operations:
	iterator find(const key_type& x);
	const_iterator find(const key_type& x) const;
	iterator lower_bound(const key_type& x);
	//const_iterator lower_bound(const key_type& x) const;
	iterator upper_bound(const key_type& x);
	//const_iterator upper_bound(const key_type& x) const;
	pair<iterator,iterator> equal_range(const key_type& x);
	pair<const_iterator,const_iterator> equal_range(const key_type& x) const;

	// comparators:

	bool operator == (const map<Key,T,Compare>&) const;
	bool operator != (const map<Key,T,Compare>&) const;
	bool operator >= (const map<Key,T,Compare>&) const;
	bool operator <= (const map<Key,T,Compare>&) const;

#endif
};

template<class Key, class T, class Compare>
void swap(map<Key, T, Compare>&, vector<Key, T, Compare>&);

template<class Key, class T, class Compare = less<Key> >
class multimap {
public:
	typedef Key key_type;
	typedef T mapped_type;
	typedef pair<Key, T> value_type;
	typedef Compare key_compare;
	typedef int size_type;

	key_type _key[MAP_SIZE];
	mapped_type _value[MAP_SIZE];
	int _size;

	typedef bool (func)(Key, Key);

	class value_compare
	{
	public:
	  Compare comp;
	  value_compare (Compare c) : comp(c) {}  // constructed with multimap's comparison object
	  typedef bool result_type;
	  typedef value_type first_argument_type;
	  typedef value_type second_argument_type;
	  bool operator() ( value_type& x, value_type& y) const
	  {
	    return comp(x.first, y.first);
	  }
	};

	class iterator {
	public:

		key_type* it_key;
		mapped_type* it_value;
		value_type it_pair;
		int it_pos;

		iterator(const iterator& x) {
			this->it_key = x.it_key;
			this->it_pos = x.it_pos;
			this->it_value = x.it_value;
			this->it_pair = x.it_pair;
		}
		iterator() {
			this->it_pos = -1;
		}
		iterator& operator=(const iterator& x) {
			this->it_key = x.it_key;
			this->it_pos = x.it_pos;
			this->it_value = x.it_value;
			this->it_pair = x.it_pair;
			return *this;
		}

		value_type * operator ->() {
			return &(this->it_pair);
		}

		value_type & operator *() {
			return this->it_pair;
		}

		iterator& operator ++() {
			this->it_pos++;
			this->it_pair.first = this->it_key[this->it_pos];
			this->it_pair.second = this->it_value[this->it_pos];
			return *this;
		}
		iterator operator ++(int) {
			this->it_pos++;
			this->it_pair.first = this->it_key[this->it_pos];
			this->it_pair.second = this->it_value[this->it_pos];
			return *this;
		}

		iterator& operator --() {
			this->it_pos--;
			this->it_pair.first = this->it_key[this->it_pos];
			this->it_pair.second = this->it_value[this->it_pos];
			return *this;
		}
		iterator operator --(int) {
			this->it_pos--;
			this->it_pair.first = this->it_key[this->it_pos];
			this->it_pair.second = this->it_value[this->it_pos];
			return *this;
		}

		bool operator ==(const iterator& it) const {
			if (this->it_pos == it.it_pos)
				return true;
			if ((this->it_pair.first == it.it_pair.first)
					&& (this->it_pair.second == it.it_pair.second))
				return true;
			return false;
		}
		bool operator !=(const iterator& it) const {
			if (this->it_pos != it.it_pos)
				return true;
			if ((this->it_pair.first != it.it_pair.first)
					&& (this->it_pair.second != it.it_pair.second))
				return true;
			return false;
		}
	};

	typedef iterator const_iterator;

	class reverse_iterator {
	public:

		key_type* it_key;
		mapped_type* it_value;
		value_type it_pair;
		int it_pos;
		int* it_size;

		reverse_iterator(const reverse_iterator& x) {
			this->it_key = x.it_key;
			this->it_pos = x.it_pos;
			this->it_value = x.it_value;
			this->it_pair = x.it_pair;
			this->it_size = x.it_size;
		}
		reverse_iterator() {
			this->it_pos = -1;
		}
		reverse_iterator& operator=(const reverse_iterator& x) {
			this->it_key = x.it_key;
			this->it_pos = x.it_pos;
			this->it_value = x.it_value;
			this->it_pair = x.it_pair;
			this->it_size = x.it_size;
			return *this;
		}

		value_type * operator ->() {
			return &(this->it_pair);
		}

		value_type & operator *() {
			return this->it_pair;
		}

		reverse_iterator& operator ++() {
			if (this->it_pos == 0) {
				this->it_pos--;
				this->it_pair.first = Key();
				this->it_pair.second = T();
				return *this;
			}
			if (this->it_pos == -1) {
				this->it_pos = *(this->it_size) - 1;
			} else {
				this->it_pos--;
			}
			this->it_pair.first = this->it_key[this->it_pos];
			this->it_pair.second = this->it_value[this->it_pos];
			return *this;
		}
		reverse_iterator operator ++(int) {
			if (this->it_pos == 0) {
				this->it_pos--;
				this->it_pair.first = Key();
				this->it_pair.second = T();
				return *this;
			}
			if (this->it_pos == -1) {
				this->it_pos = *(this->it_size) - 1;
			} else {
				this->it_pos--;
			}
			this->it_pair.first = this->it_key[this->it_pos];
			this->it_pair.second = this->it_value[this->it_pos];
			return *this;
		}

		reverse_iterator& operator --() {
			if (this->it_pos == this->it_size) {
				this->it_pos = 0;
			} else {
				this->it_pos++;
			}
			this->it_pair.first = this->it_key[this->it_pos];
			this->it_pair.second = this->it_value[this->it_pos];
			return *this;
		}
		reverse_iterator operator --(int) {
			if (this->it_pos == this->it_size) {
				this->it_pos = 0;
			} else {
				this->it_pos++;
			}
			this->it_pair.first = this->it_key[this->it_pos];
			this->it_pair.second = this->it_value[this->it_pos];
			return *this;
		}

		bool operator ==(const reverse_iterator& it) const {
			if (this->it_pos == it.it_pos)
				return true;
			if ((this->it_pair.first == it.it_pair.first)
					&& (this->it_pair.second == it.it_pair.second))
				return true;
			return false;
		}
		bool operator !=(const reverse_iterator& it) const {
			if (this->it_pos != it.it_pos)
				return true;
			if ((this->it_pair.first != it.it_pair.first)
					&& (this->it_pair.second != it.it_pair.second))
				return true;
			return false;
		}
	};

	explicit multimap(const key_compare& comp = key_compare()){
		this->_size = 0;
	}

	template<class InputIterator>
	multimap(InputIterator first, InputIterator last, const key_compare& comp =
			key_compare()) {
		int j = 0;
		this->_size = 0;
		int limit = last.it_pos - first.it_pos;
		for (int i = first.it_pos; i != limit; i++, j++) {
			this->_key[j] = first.it_key[i];
			this->_value[j] = first.it_value[i];
			this->_size++;
		}
	}

	multimap(const multimap& x) {
		this->clear();
		this->_size = x._size;
		for (int i = 0; i < x._size; i++) {
			this->_key[i] = x._key[i];
			this->_value[i] = x._value[i];
		}
	}

	~multimap(){
		this->clear();
	}

	multimap& operator= (const multimap& x) {
		this->clear();
		this->_size = x._size;
		for (int i = 0; i < x._size; i++) {
			this->_key[i] = x._key[i];
			this->_value[i] = x._value[i];
		}
		return *this;
	}

	iterator insert(const value_type& val) {
		key_type x = val.first;
		size_type s = this->_size;
		if (this->_size == 0) {
			this->_key[0] = x;
			this->_size++;
			this->_value[0] = val.second;
			return this->begin();
		} else {
			iterator it = this->begin();
			for (int i = 0; i < s; i++) {
				if (key_compare()(x, this->_key[i])) {
					int j;
					Key y = x;
					Key t;
					T u, v;

					for (j = i; j < s; j++) {
						t = this->_key[j];
						this->_key[j] = y;
						y = t;
						u = this->_value[j];
						this->_value[j] = v;
						v = u;
					}
					this->_key[j] = y;
					this->_value[j] = u;

					this->_size++;
					this->_value[i] = val.second;
					it.it_pos = i;
					it.it_pair.first = this->_key[i];
					it.it_pair.second = this->_value[i];
					return it;
				}
				it++;
			}
			this->_size++;
			this->_key[s] = x;
			this->_value[s] = val.second;
			return this->end();
		}
	}

	const iterator insert(iterator position, const value_type& val) {
		key_type x = val.first;
		size_type s = this->_size;
		if (this->_size == 0) {
			this->_key[0] = x;
			this->_size++;
			this->_value[0] = val.second;
			return this->begin();
		} else {
			iterator it = this->begin();
			for (int i = 0; i < s; i++) {
				if (key_compare()(x, this->_key[i])) {
					int j;
					Key y = x;
					Key t;
					T u, v;

					for (j = i; j < s; j++) {
						t = this->_key[j];
						this->_key[j] = y;
						y = t;
						u = this->_value[j];
						this->_value[j] = v;
						v = u;
					}
					this->_key[j] = y;
					this->_value[j] = u;

					this->_size++;
					this->_value[i] = val.second;
					return it;
				}
				it++;
			}
			this->_size++;
			this->_key[s] = x;
			this->_value[s] = val.second;
			return this->end();
		}
	}

	void insert(iterator first, iterator last) {
		value_type val;
		for (iterator it = first; it.it_pos != last.it_pos; it++) {
			val.first = it.it_key[it.it_pos];
			val.second = it.it_value[it.it_pos];
			this->insert(val);
		}
	}

	bool empty() const{
		if (this->_size == 0)
			return true;
		return false;
	}
	size_type size(){
		return this->_size;
	}
	size_type max_size() const{
		return size_type();
	}

	void clear() {
		this->_size = 0;
		for (int i = 0; i < this->_size; i++) {
			this->_key[i] = Key();
			this->_value[i] = T();
		}
	}
	// iterators:
	iterator begin() {
		iterator it;
		it.it_key = this->_key;
		it.it_value = this->_value;
		it.it_pos = 0;
		it.it_pair.first = this->_key[0];
		it.it_pair.second = this->_value[0];
		return it;
	}
	iterator end() {
		iterator it;
		it.it_key = this->_key;
		it.it_value = this->_value;
		it.it_pos = this->_size;
		it.it_pair.first = this->_key[it.it_pos];
		it.it_pair.second = this->_value[it.it_pos];
		return it;
	}

	reverse_iterator rbegin() {
		reverse_iterator it;
		it.it_key = this->_key;
		it.it_value = this->_value;
		it.it_size = &(this->_size);
		it.it_pos = this->_size - 1;
		it.it_pair.first = this->_key[it.it_pos];
		it.it_pair.second = this->_value[it.it_pos];
		return it;
	}
	reverse_iterator rend() {
		reverse_iterator it;
		it.it_key = this->_key;
		it.it_value = this->_value;
		it.it_size = &(this->_size);
		it.it_pos = -1;
		it.it_pair.first = Key();
		it.it_pair.second = T();
		return it;
	}

    iterator find (const key_type& x) {
		size_type s = this->_size;
		iterator it = this->begin();
		if (this->_size == 0) {
			return it;
		} else {
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == x) {
					return it;
				}
				if (key_compare()((Key &) x, this->_key[i])) {
					int j;
					Key y = x;
					Key t;
					T u, v;

					for (j = i; j < s; j++) {
						t = this->_key[j];
						this->_key[j] = y;
						y = t;
						u = this->_value[j];
						this->_value[j] = v;
						v = u;
					}
					this->_key[j] = y;
					this->_value[j] = u;

					this->_size++;
					this->_value[i] = T();
					return it;
				}
				it++;
			}
			this->_size++;
			this->_key[s] = x;
			this->_value[s] = T();
			return this->end();
		}
	}

	void swap(multimap& x) {
		multimap tmp;
		tmp = *this;
		*this = x;
		x = tmp;
	}
    void erase (iterator position) {
		if (this->_size != 0) {
			unsigned int s = this->_size;
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == position.it_key[position.it_pos]) {
					this->_size--;
					int j;
					for (j = i; j < s; j++) {
						this->_key[j] = this->_key[j + 1];
						this->_value[j] = this->_value[j + 1];
					}
					this->_key[j - 1] = Key();
					this->_value[j - 1] = T();
					return;
				}
			}
		}
	}

    size_type erase (const key_type& k) {
		if (this->_size != 0) {
			unsigned int s = this->_size;
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == k) {
					this->_size--;
					int j;
					for (j = i; j < s; j++) {
						this->_key[j] = this->_key[j + 1];
						this->_value[j] = this->_value[j + 1];
					}
					this->_key[j - 1] = Key();
					this->_value[j - 1] = T();
					return this->_size;
				}
			}
		}
		return this->_size;
	}

    void erase (iterator first, iterator last) {
		if (this->_size != 0) {
			unsigned int s = this->_size;
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == first.it_key[first.it_pos]) {
					this->_size = this->_size - (last.it_pos - first.it_pos);
					int j;
					for (j = i; j < s; j++) {
						this->_key[j] = this->_key[j + last.it_pos];
						this->_value[j] = this->_value[j + last.it_pos];
					}
					this->_key[j - 1] = Key();
					this->_value[j - 1] = T();
					return;
				}
			}
		}
	}

	key_compare key_comp() const {
		return key_compare();
	}

	value_compare value_comp() const {
		return value_compare(Compare());
	}

	iterator upper_bound (const key_type& x) {
		unsigned int s = this->_size;
		if (this->_size == 0) {
			return this->end();
		} else {
			iterator it = this->begin();
			for (int i = 0; i < s; i++) {
				if ( (this->_key[i] == x) && (this->_key[i+1] != x)) {
					it++;
					return it;
				}
				if (key_compare()((Key&) x, this->_key[i])) {
					return this->end();
				}
				it++;
			}
			return this->end();
		}
	}

    iterator lower_bound (const key_type& x) {
		unsigned int s = this->_size;
		if (this->_size == 0) {
			return this->end();
		} else {
			iterator it = this->begin();
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == x) {
					return it;
				}
				if (key_compare()((Key&) x, this->_key[i])) {
					return this->end();
				}
				it++;
			}
			return this->end();
		}
	}

    pair<iterator,iterator> equal_range (const key_type& k) {
		unsigned int s = this->_size;
		pair<iterator, iterator> _pair;
		_pair.second = this->upper_bound(k);
		if (this->_size == 0) {
			_pair.first = this->upper_bound(k);
			return _pair;
		} else {
			iterator it = this->begin();
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == k) {
					_pair.first = it;
					return _pair;
				}
				if (key_compare()((Key&) k, this->_key[i])) {
					_pair.first = this->upper_bound(k);
					return _pair;
				}
				it++;
			}
			_pair.first = this->upper_bound(k);
			return _pair;
		}
	}

    size_type count (const key_type& x) const {
		if (this->_size != 0) {
			int s = this->_size;
			size_type c = 0;
			for (int i = 0; i < s; i++) {
				if (this->_key[i] == x) {
					c++;
				}
			}
			return c;
		}
		return 0;
	}

    bool operator==( multimap& y ){
    	if(this->_size != y._size)
    		return false;
    	for(int i = 0; i < this->_size; i++){
    		if((this->_key[i] != y._key[i]) || (this->_value[i] != y._value[i]))
    			return false;
    	}
    	return true;
    }

    bool operator!=( multimap& y ){
    	if(this->_size != y._size)
    		return true;
    	for(int i = 0; i < this->_size; i++){
    		if((this->_key[i] != y._key[i]) || (this->_value[i] != y._value[i]))
    			return true;
    	}
    	return false;
    }

};
#if 0
template< class Key, class T >
bool operator==( multimap<Key,T>& x, multimap<Key,T>& y){
	if(x._size != y._size)
		return false;
	for(int i = 0; i < x._size; i++){
		if((x._key[i] != y._key[i]) || (x._value[i] != y._value[i]))
			return false;
	}
	return true;
}

template< class Key, class T >
bool operator!=( multimap<Key,T>& x, multimap<Key,T>& y){
	if(x._size != y._size)
		return true;
	for(int i = 0; i < x._size; i++){
		if((x._key[i] != y._key[i]) || (x._value[i] != y._value[i]))
			return true;
	}
	return false;
}
#endif
}

#endif
