#ifndef STL_FUNCTIONAL
#define STL_FUNCTIONAL

#include <cassert>
#include <utility>  // std::forward

namespace std {

// Base class for callable objects
class callable_base {
public:
    virtual ~callable_base() = default;
    virtual int invoke(int, int) const = 0;
};

// Wrapper for callable types (function pointers, lambdas, functors)
template <typename Callable>
class callable_wrapper : public callable_base {
private:
    Callable func;
public:
    explicit callable_wrapper(Callable&& f) : func(forward<Callable>(f)) {}

    int invoke(int a, int b) const override {
        return func(forward<int>(a), forward<int>(b));
    }
};

// Standard-like std::function model
template <typename Signature>
class function;

// Specialization for function types
template <typename Ret, typename... Args>
class function<Ret(Args...)> {
private:
    callable_base* func = nullptr;

public:
    function() = default;

    // Function pointer constructor
    function(Ret (*f)(Args...)) {
        if (f) {
            func = new callable_wrapper<Ret (*)(Args...)>(move(f));
        }
    }

    // General callable constructor (lambdas, functors)
    template <typename Callable>
    function(Callable f) {
        func = new callable_wrapper<Callable>(move(f));
    }

    function(const function& other) = delete; // Disable copy for simplicity
    function& operator=(const function& other) = delete;

    function(function&& other) noexcept {
        func = other.func;
        other.func = nullptr;
    }

    function& operator=(function&& other) noexcept {
        if (this != &other) {
            delete func;
            func = other.func;
            other.func = nullptr;
        }
        return *this;
    }

    ~function() {
        delete func;
    }

    Ret operator()(Args... args) const {
        assert(func != nullptr);  // Ensure function is valid before calling
        return func->invoke(forward<Args>(args)...);
    }

    explicit operator bool() const noexcept {
        return func != nullptr;
    }
};

// Simplified std::invoke model
template <typename Func, typename... Args>
decltype(auto) invoke(Func&& f, Args&&... args) {
    return forward<Func>(f)(forward<Args>(args)...);
}

} // namespace std

#endif // STL_FUNCTIONAL

