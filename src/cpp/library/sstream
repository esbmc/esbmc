#ifndef STL_SSTREAM
#define STL_SSTREAM

#include "streambuf"
#include "definitions.h"
#include "ostream"
#include "ios"
#include "string"
#include "cstdio"
#include "cstdlib"
#include "cstring"

#ifdef _WIN64
#  define NUM_SIZE 32
#else
#  define NUM_SIZE 32
#endif
#define DEC 10

/* TODO: this is not part of <sstream> */
extern "C" void itoa(int value, char *str, int base);

namespace std
{
class stringbuf : public streambuf
{
public:
  explicit stringbuf(ios_base::openmode which = ios_base::in | ios_base::out);
  explicit stringbuf(
    const string &str,
    ios_base::openmode which = ios_base::in | ios_base::out);
  void str(const string &s);
  string str() const;
};

class istringstream : public istream
{
public:
  explicit istringstream(openmode which = ios_base::in)
  {
    istream();
  }
  explicit istringstream(const string &str, openmode which = ios_base::in)
  {
    istream();
  }
  stringbuf *rdbuf() const;
  string str() const;
  void str(const string &s);
};

class stringstream : public istream, public ostream
{
public:
  string _string;
  explicit stringstream(openmode which = ios_base::out | ios_base::in)
    : istream(), ostream(), _string("")
  {
  }

  explicit stringstream(
    const string &str,
    openmode which = ios_base::out | ios_base::in)
    : istream(), ostream(), _string("")
  {
  }

  stringbuf *rdbuf() const;

  string str() const
  {
    return _string;
  }

  ostream &operator<<(const string &val)
  {
    _string.append(val.c_str());
    return *this;
  }

  ostream &operator<<(bool val)
  {
    if (val)
      _string.append("1");
    else
      _string.append("0");
    return *this;
  }

  ostream &operator<<(void *val)
  {
    char *temp = new char[NUM_SIZE];
    // Convert pointer to string representation (hexadecimal)
    // For simplicity, just convert the pointer value to decimal
    itoa((long)val, temp, DEC);
    _string.append(temp);
    return *this;
  }

  ostream &operator<<(short val)
  {
    char *temp = new char[NUM_SIZE];
    itoa(val, temp, DEC);
    _string.append(temp);
    return *this;
  }

  ostream &operator<<(int val)
  {
    char *temp = new char[NUM_SIZE];
    itoa(val, temp, DEC);
    _string.append(temp);
    return *this;
  }

  ostream &operator<<(long val)
  {
    char *temp = new char[NUM_SIZE];
    itoa(val, temp, DEC);
    _string.append(temp);
    return *this;
  }

  ostream &operator<<(unsigned short val)
  {
    char *temp = new char[NUM_SIZE];
    itoa(val, temp, DEC);
    _string.append(temp);
    return *this;
  }

  ostream &operator<<(unsigned int val)
  {
    char *temp = new char[NUM_SIZE];
    itoa(val, temp, DEC);
    _string.append(temp);
    return *this;
  }

  ostream &operator<<(unsigned long val)
  {
    char *temp = new char[NUM_SIZE];
    itoa(val, temp, DEC);
    _string.append(temp);
    return *this;
  }

  ostream &operator<<(float val)
  {
    // Handle special cases
    if (val != val)
    { // NaN check
      _string.append("nan");
      return *this;
    }

    char *temp = new char[NUM_SIZE];
    temp[0] = '\0'; // Initialize as empty string

    // Handle negative values
    bool negative = false;
    if (val < 0)
    {
      negative = true;
      val = -val;
    }

    // Convert integer part
    int n = (int)val;
    char *int_part = new char[NUM_SIZE / 2];
    itoa(n, int_part, DEC);

    if (negative)
    {
      strcat(temp, "-");
    }
    strcat(temp, int_part);
    strcat(temp, ".");

    // Multiply by 10000 and use integer arithmetic
    // This avoids accumulating floating-point errors
    val = val - (float)n; // Get fractional part
    long scaled =
      (long)((val * 10000.0f) + 0.5f); // Scale to 4 decimal places and round

    // Extract each decimal digit
    int d1 = (scaled / 1000) % 10;
    int d2 = (scaled / 100) % 10;
    int d3 = (scaled / 10) % 10;
    int d4 = scaled % 10;

    // Append digits, removing trailing zeros
    size_t len = strlen(temp);
    if (d1 != 0 || d2 != 0 || d3 != 0 || d4 != 0)
    {
      temp[len++] = '0' + d1;
      temp[len] = '\0';

      if (d2 != 0 || d3 != 0 || d4 != 0)
      {
        temp[len++] = '0' + d2;
        temp[len] = '\0';
      }

      if (d3 != 0 || d4 != 0)
      {
        temp[len++] = '0' + d3;
        temp[len] = '\0';
      }

      if (d4 != 0)
      {
        temp[len++] = '0' + d4;
        temp[len] = '\0';
      }
    }
    else
    {
      // No fractional part, add a single zero
      temp[len++] = '0';
      temp[len] = '\0';
    }

    _string.append(temp);
    delete[] temp;
    delete[] int_part;
    return *this;
  }

  ostream &operator<<(double val)
  {
    // Handle special cases
    if (val != val)
    { // NaN check
      _string.append("nan");
      return *this;
    }

    char *temp = new char[NUM_SIZE];
    temp[0] = '\0'; // Initialize as empty string

    // Handle negative values
    bool negative = false;
    if (val < 0)
    {
      negative = true;
      val = -val;
    }

    // Convert integer part
    int n = (int)val;
    char *int_part = new char[NUM_SIZE / 2];
    itoa(n, int_part, DEC);

    if (negative)
    {
      strcat(temp, "-");
    }
    strcat(temp, int_part);
    strcat(temp, ".");

    // Convert fractional part with bounds checking
    val = val - (double)n;
    int decimal_places = 0;
    const int max_decimal_places = 6; // Limit precision to avoid overflow

    while (val > 0.0001 && decimal_places < max_decimal_places &&
           strlen(temp) < NUM_SIZE - 2)
    {
      val = val * 10.0;
      n = (int)val;
      if (n >= 0 && n <= 9)
      { // Safety check
        char digit = '0' + n;
        size_t len = strlen(temp);
        if (len < NUM_SIZE - 1)
        {
          temp[len] = digit;
          temp[len + 1] = '\0';
        }
      }
      val = val - (double)n;
      decimal_places++;
    }

    _string.append(temp);
    delete[] temp;
    delete[] int_part;
    return *this;
  }

  ostream &operator<<(char val)
  {
    _string.append(&val, 1);
    return *this;
  }

  ostream &operator<<(unsigned char val)
  {
    _string.append(reinterpret_cast<const char *>(&val), 1);
    return *this;
  }

  ostream &operator<<(const char *val)
  {
    _string.append(val);
    return *this;
  }
};

class ostringstream : public ostream
{
public:
  explicit ostringstream(openmode which = out)
  {
    ostream();
  }
  explicit ostringstream(const string &str, openmode which = out)
  {
    ostream();
  }
  stringbuf *rdbuf() const;
  string str() const;
  void str(const string &s);
};

} // namespace std

#endif