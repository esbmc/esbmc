// This file is computer-generated by onnx2c 
// (TODO: add creating command line here)
// (TODO: print creation date here )

// ONNX model:
// produced by pytorch, version 1.11.0
// ONNX IR version: 9
// Model documentation: 
/*

*/

#include <float.h>
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#define MAX(X,Y) ( X > Y ? X : Y)
#define MIN(X,Y) ( X < Y ? X : Y)
#define CLIP(X,L) ( MAX(MIN(X,L), -L) )

static const float tensor_quantized_Gemm_0_weight[10][4] = 
{
  {0.60839658975601196289f, 1.2167931795120239258f, -1.2167931795120239258f, -1.2167931795120239258f},
  {0.60839658975601196289f, 0.60839658975601196289f, -0.60839658975601196289f, -1.8251898288726806641f},
  {0.60839658975601196289f, 0.60839658975601196289f, -1.2167931795120239258f, -1.2167931795120239258f},
  {0.0000000000000000000f, 0.0000000000000000000f, 0.0000000000000000000f, -0.60839658975601196289f},
  {0.0000000000000000000f, -0.60839658975601196289f, 1.2167931795120239258f, 1.8251898288726806641f},
  {0.0000000000000000000f, -0.60839658975601196289f, 0.60839658975601196289f, 1.8251898288726806641f},
  {0.0000000000000000000f, 0.0000000000000000000f, -0.60839658975601196289f, 0.0000000000000000000f},
  {0.0000000000000000000f, 1.2167931795120239258f, -0.60839658975601196289f, -1.2167931795120239258f},
  {-0.60839658975601196289f, -0.60839658975601196289f, 0.0000000000000000000f, 0.0000000000000000000f},
  {0.0000000000000000000f, 0.0000000000000000000f, 1.2167931795120239258f, 1.2167931795120239258f}
};
static const float tensor_quantized_Gemm_0_bias[10] = 
{0.60839658975601196289f, 1.2167931795120239258f, 1.2167931795120239258f, 0.60839658975601196289f, 0.0000000000000000000f, 0.0000000000000000000f, 0.0000000000000000000f, 1.2167931795120239258f, 0.0000000000000000000f, -0.60839658975601196289f};
static const float tensor_quantized_Gemm_1_weight[3][10] = 
{
  {1.8196383714675903320f, 0.0000000000000000000f, 1.8196383714675903320f, 0.0000000000000000000f, -3.6392767429351806641f, -1.8196383714675903320f, 0.0000000000000000000f, 1.8196383714675903320f, 0.0000000000000000000f, -1.8196383714675903320f},
  {0.0000000000000000000f, 0.0000000000000000000f, 0.0000000000000000000f, 0.0000000000000000000f, 0.0000000000000000000f, 0.0000000000000000000f, 0.0000000000000000000f, 0.0000000000000000000f, 0.0000000000000000000f, 0.0000000000000000000f},
  {0.0000000000000000000f, -1.8196383714675903320f, -1.8196383714675903320f, 0.0000000000000000000f, 1.8196383714675903320f, 0.0000000000000000000f, 0.0000000000000000000f, -1.8196383714675903320f, 0.0000000000000000000f, 0.0000000000000000000f}
};
static const float tensor_quantized_Gemm_1_bias[3] = 
{0.0000000000000000000f, 0.0000000000000000000f, 0.0000000000000000000f};
union tensor_quantized_union_0 {
float tensor_quantized_onnx__Gemm_5[1][4];
float tensor_quantized_onnx__Gemm_7[1][10];
};
static union tensor_quantized_union_0 tu_quantized0;

union tensor_quantized_union_1 {
float tensor_quantized_input[1][10];
};
static union tensor_quantized_union_1 tu_quantized1;


static inline void node_quantized_Flatten_0( const float tensor_quantized_onnx__Flatten_0[1][4], float tensor_quantized_onnx__Gemm_5[1][4] )
{
	/* Flatten*/
	float *input = (float*)tensor_quantized_onnx__Flatten_0;
	float *output = (float*)tensor_quantized_onnx__Gemm_5;
	for( uint32_t i=0; i<4; i++ )
		output[i] = input[i];

}

static inline void node_quantized_Gemm_1( const float tensor_quantized_onnx__Gemm_5[1][4], const float tensor_quantized_Gemm_0_weight[10][4], const float tensor_quantized_Gemm_0_bias[10], float tensor_quantized_input[1][10] )
{
	/* Gemm */
	/* alpha   = 1.0000000000000000000
	   beta    = 1.0000000000000000000
	   transA  = 0
	   transB  = 1
	 */
	const int M = 1;
	const int K = 4;
	const int N = 10;
	float (*A)[4]  = (float(*)[4])tensor_quantized_onnx__Gemm_5;
	float (*Y)[10]  = (float(*)[10])tensor_quantized_input;
	float alpha = 1.0000000000000000000;
	float beta = 1.0000000000000000000;
	float (*C)[10]  = (float(*)[10])tensor_quantized_Gemm_0_bias;
	for( uint32_t r=0; r<M; r++ )
		for( uint32_t c=0; c<N; c++ ) {
			float ABrc = 0;
			for( uint32_t i=0; i<K; i++ ) {
				float B = tensor_quantized_Gemm_0_weight[c][i];
				ABrc += A[r][i] * B;
			}
			float tmp = ABrc * alpha;
			tmp += C[0][c] * beta;
			Y[r][c] = tmp;
	}
}

static inline void node_quantized_Relu_2( const float tensor_quantized_input[1][10], float tensor_quantized_onnx__Gemm_7[1][10] )
{
	/*Relu*/
	float *X = (float*)tensor_quantized_input;
	float *Y = (float*)tensor_quantized_onnx__Gemm_7;
	for( uint32_t i=0; i<10; i++ )
		Y[i] = X[i] > 0 ? X[i] : 0;

}

static inline void node_quantized_Gemm_3( const float tensor_quantized_onnx__Gemm_7[1][10], const float tensor_quantized_Gemm_1_weight[3][10], const float tensor_quantized_Gemm_1_bias[3], float tensor_quantized_8[1][3] )
{
	/* Gemm */
	/* alpha   = 1.0000000000000000000
	   beta    = 1.0000000000000000000
	   transA  = 0
	   transB  = 1
	 */
	const int M = 1;
	const int K = 10;
	const int N = 3;
	float (*A)[10]  = (float(*)[10])tensor_quantized_onnx__Gemm_7;
	float (*Y)[3]  = (float(*)[3])tensor_quantized_8;
	float alpha = 1.0000000000000000000;
	float beta = 1.0000000000000000000;
	float (*C)[3]  = (float(*)[3])tensor_quantized_Gemm_1_bias;
	for( uint32_t r=0; r<M; r++ )
		for( uint32_t c=0; c<N; c++ ) {
			float ABrc = 0;
			for( uint32_t i=0; i<K; i++ ) {
				float B = tensor_quantized_Gemm_1_weight[c][i];
				ABrc += A[r][i] * B;
			}
			float tmp = ABrc * alpha;
			tmp += C[0][c] * beta;
			Y[r][c] = tmp;
	}
}


void entry_quantized(const float tensor_quantized_onnx__Flatten_0[1][4], float tensor_quantized_8[1][3]) {
	node_quantized_Flatten_0( tensor_quantized_onnx__Flatten_0, tu_quantized0.tensor_quantized_onnx__Gemm_5);
	node_quantized_Gemm_1( tu_quantized0.tensor_quantized_onnx__Gemm_5, tensor_quantized_Gemm_0_weight, tensor_quantized_Gemm_0_bias, tu_quantized1.tensor_quantized_input);
	node_quantized_Relu_2( tu_quantized1.tensor_quantized_input, tu_quantized0.tensor_quantized_onnx__Gemm_7);
	node_quantized_Gemm_3( tu_quantized0.tensor_quantized_onnx__Gemm_7, tensor_quantized_Gemm_1_weight, tensor_quantized_Gemm_1_bias, tensor_quantized_8);
}
