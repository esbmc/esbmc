// This file is part of the SV-Benchmarks collection of verification tasks:
// https://gitlab.com/sosy-lab/benchmarking/sv-benchmarks
// SPDX-FileCopyrightText: 1985-2011 Free Software Foundation, Inc.
// SPDX-FileCopyrightText: 2011-2022 University of Tartu & Technische Universität München
//
// SPDX-License-Identifier: GPL-3.0-or-later

#include <time.h>

extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));
extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));
extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));
extern unsigned int __VERIFIER_nondet_uint();
extern void abort(void);
void reach_error() { ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail ("0", "instrumented_nohup_comb.c", 9, __extension__ __PRETTY_FUNCTION__); })); }
typedef unsigned long size_t;
typedef unsigned char __u_char;
typedef unsigned short __u_short;
typedef unsigned int __u_int;
typedef unsigned long __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long __int64_t;
typedef unsigned long __uint64_t;
typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;
typedef long __quad_t;
typedef unsigned long __u_quad_t;
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
struct __anonstruct___fsid_t_109580352 {
   int __val[2] ;
};
typedef struct __anonstruct___fsid_t_109580352 __fsid_t;
typedef unsigned long __rlim_t;
typedef unsigned long __rlim64_t;
typedef unsigned int __id_t;
typedef unsigned int __useconds_t;
typedef long __suseconds_t;
typedef long __suseconds64_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __blkcnt64_t;
typedef unsigned long __fsblkcnt_t;
typedef unsigned long __fsblkcnt64_t;
typedef unsigned long __fsfilcnt_t;
typedef unsigned long __fsfilcnt64_t;
typedef long __fsword_t;
typedef long __ssize_t;
typedef unsigned long __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef char *__caddr_t;
typedef long __intptr_t;
typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
typedef __pid_t pid_t;
struct sched_param {
   int sched_priority ;
};
typedef unsigned long __cpu_mask;
struct __anonstruct_cpu_set_t_826868708 {
   __cpu_mask __bits[1024UL / (8UL * sizeof(__cpu_mask ))] ;
};
typedef struct __anonstruct_cpu_set_t_826868708 cpu_set_t;
typedef __clockid_t clockid_t;
typedef __timer_t timer_t;
struct sigevent ;
struct __locale_data ;
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const *__ctype_b ;
   int const *__ctype_tolower ;
   int const *__ctype_toupper ;
   char const *__names[13] ;
};
typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
struct __anonstruct___value32_817613185 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion___atomic_wide_counter_825226138 {
   unsigned long long __value64 ;
   struct __anonstruct___value32_817613185 __value32 ;
};
typedef union __anonunion___atomic_wide_counter_825226138 __atomic_wide_counter;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
typedef struct __pthread_internal_slist __pthread_slist_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
struct __pthread_cond_s {
   __atomic_wide_counter __wseq ;
   __atomic_wide_counter __g1_start ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
typedef unsigned int __tss_t;
typedef unsigned long __thrd_t;
struct __anonstruct___once_flag_826868709 {
   int __data ;
};
typedef struct __anonstruct___once_flag_826868709 __once_flag;
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
union __anonunion_pthread_rwlock_t_656928968 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
typedef union __anonunion_pthread_rwlock_t_656928968 pthread_rwlock_t;
union __anonunion_pthread_rwlockattr_t_145707745 {
   char __size[8] ;
   long __align ;
};
typedef union __anonunion_pthread_rwlockattr_t_145707745 pthread_rwlockattr_t;
typedef int volatile pthread_spinlock_t;
union __anonunion_pthread_barrier_t_145707746 {
   char __size[32] ;
   long __align ;
};
typedef union __anonunion_pthread_barrier_t_145707746 pthread_barrier_t;
union __anonunion_pthread_barrierattr_t_951761806 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_barrierattr_t_951761806 pthread_barrierattr_t;
typedef long __jmp_buf[8];
struct __anonstruct___sigset_t_764561023 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_764561023 __sigset_t;
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
enum __anonenum_34415463 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1
} ;
enum __anonenum_508643754 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
    PTHREAD_MUTEX_NORMAL = 0,
    PTHREAD_MUTEX_RECURSIVE = 1,
    PTHREAD_MUTEX_ERRORCHECK = 2,
    PTHREAD_MUTEX_DEFAULT = 0
} ;
enum __anonenum_931900394 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_STALLED_NP = 0,
    PTHREAD_MUTEX_ROBUST = 1,
    PTHREAD_MUTEX_ROBUST_NP = 1
} ;
enum __anonenum_205214487 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2
} ;
enum __anonenum_25043950 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
    PTHREAD_RWLOCK_DEFAULT_NP = 0
} ;
enum __anonenum_436439511 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1
} ;
enum __anonenum_998661166 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1
} ;
enum __anonenum_146137331 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1
} ;
struct _pthread_cleanup_buffer {
   void (*__routine)(void * ) ;
   void *__arg ;
   int __canceltype ;
   struct _pthread_cleanup_buffer *__prev ;
};
enum __anonenum_53396917 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1
} ;
enum __anonenum_904563783 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1
} ;
struct __cancel_jmp_buf_tag {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
struct __anonstruct___pthread_unwind_buf_t_530692248 {
   struct __cancel_jmp_buf_tag __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
typedef struct __anonstruct___pthread_unwind_buf_t_530692248 __attribute__((__aligned__)) __pthread_unwind_buf_t;
struct __pthread_cleanup_frame {
   void (*__cancel_routine)(void * ) ;
   void *__cancel_arg ;
   int __do_it ;
   int __cancel_type ;
};
typedef __mode_t mode_t;
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
struct allocator {
   void *(*allocate)(size_t ) ;
   void *(*reallocate)(void * , size_t ) ;
   void (*free)(void * ) ;
   void (*die)(size_t ) ;
};
typedef __ssize_t ssize_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
typedef __builtin_va_list __gnuc_va_list;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef struct _IO_FILE _IO_FILE;
struct obstack ;
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7,
    custom_quoting_style = 8
} ;
struct argv_iterator ;
enum argv_iter_err {
    AI_ERR_OK = 1,
    AI_ERR_EOF = 2,
    AI_ERR_MEM = 3,
    AI_ERR_READ = 4
} ;
struct argv_iterator {
   FILE *fp ;
   size_t item_idx ;
   char *tok ;
   size_t buf_len ;
   char **arg_list ;
   char **p ;
};
enum backup_type {
    no_backups = 0,
    simple_backups = 1,
    numbered_existing_backups = 2,
    numbered_backups = 3
} ;
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream ;
typedef struct __dirstream DIR;
enum numbered_backup_result {
    BACKUP_IS_SAME_LENGTH = 0,
    BACKUP_IS_LONGER = 1,
    BACKUP_IS_NEW = 2
} ;
struct base64_decode_context {
   unsigned int i ;
   char buf[4] ;
};
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
struct sockaddr_at ;
struct sockaddr_ax25 ;
struct sockaddr_dl ;
struct sockaddr_eon ;
struct sockaddr_in ;
struct sockaddr_in6 ;
struct sockaddr_inarp ;
struct sockaddr_ipx ;
struct sockaddr_iso ;
struct sockaddr_ns ;
struct sockaddr_un ;
struct sockaddr_x25 ;
union __anonunion___SOCKADDR_ARG_18 {
   struct sockaddr * __restrict __sockaddr__ ;
   struct sockaddr_at * __restrict __sockaddr_at__ ;
   struct sockaddr_ax25 * __restrict __sockaddr_ax25__ ;
   struct sockaddr_dl * __restrict __sockaddr_dl__ ;
   struct sockaddr_eon * __restrict __sockaddr_eon__ ;
   struct sockaddr_in * __restrict __sockaddr_in__ ;
   struct sockaddr_in6 * __restrict __sockaddr_in6__ ;
   struct sockaddr_inarp * __restrict __sockaddr_inarp__ ;
   struct sockaddr_ipx * __restrict __sockaddr_ipx__ ;
   struct sockaddr_iso * __restrict __sockaddr_iso__ ;
   struct sockaddr_ns * __restrict __sockaddr_ns__ ;
   struct sockaddr_un * __restrict __sockaddr_un__ ;
   struct sockaddr_x25 * __restrict __sockaddr_x25__ ;
};
typedef union __anonunion___SOCKADDR_ARG_18 __attribute__((__transparent_union__)) __SOCKADDR_ARG;
typedef uint16_t in_port_t;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
union __anonunion___in6_u_22 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
struct in6_addr {
   union __anonunion___in6_u_22 __in6_u ;
};
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
enum canonicalize_mode_t {
    CAN_EXISTING = 0,
    CAN_ALL_BUT_LAST = 1,
    CAN_MISSING = 2
} ;
typedef enum canonicalize_mode_t canonicalize_mode_t;
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
typedef struct hash_tuning Hash_tuning;
struct hash_table ;
typedef struct hash_table Hash_table;
typedef __off_t off_t;
struct md5_ctx {
   uint32_t A ;
   uint32_t B ;
   uint32_t C ;
   uint32_t D ;
   uint32_t total[2] ;
   uint32_t buflen ;
   uint32_t buffer[32] ;
};
struct sha1_ctx {
   uint32_t A ;
   uint32_t B ;
   uint32_t C ;
   uint32_t D ;
   uint32_t E ;
   uint32_t total[2] ;
   uint32_t buflen ;
   uint32_t buffer[32] ;
};
struct sha256_ctx {
   uint32_t state[8] ;
   uint32_t total[2] ;
   size_t buflen ;
   uint32_t buffer[32] ;
};
typedef unsigned long uint64_t;
typedef uint64_t u64;
struct sha512_ctx {
   u64 state[8] ;
   u64 total[2] ;
   size_t buflen ;
   u64 buffer[32] ;
};
typedef __ino_t ino_t;
typedef __dev_t dev_t;
typedef unsigned long uintmax_t;
struct dev_ino {
   ino_t st_ino ;
   dev_t st_dev ;
};
struct cycle_check_state {
   struct dev_ino dev_ino ;
   uintmax_t chdir_counter ;
   int magic ;
};
struct di_set ;
struct ino_map ;
typedef size_t hashint;
struct di_ent {
   dev_t dev ;
   struct hash_table *ino_set ;
};
struct di_set {
   struct hash_table *dev_map ;
   struct ino_map *ino_map ;
   struct di_ent *probe ;
};
typedef struct _IO_FILE __FILE;
union __anonunion___value_4 {
   unsigned int __wch ;
   char __wchb[4] ;
};
struct __anonstruct___mbstate_t_3 {
   int __count ;
   union __anonunion___value_4 __value ;
};
typedef struct __anonstruct___mbstate_t_3 __mbstate_t;
typedef unsigned int wint_t;
typedef __mbstate_t mbstate_t;
struct exclude ;
struct mbchar {
   char const *ptr ;
   size_t bytes ;
   _Bool wc_valid ;
   wchar_t wc ;
   char buf[24] ;
};
typedef struct mbchar mbchar_t;
struct mbuiter_multi {
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
typedef struct mbuiter_multi mbui_iterator_t;
struct patopts {
   char const *pattern ;
   int options ;
};
struct exclude_pattern {
   struct patopts *exclude ;
   size_t exclude_alloc ;
   size_t exclude_count ;
};
enum exclude_type {
    exclude_hash = 0,
    exclude_pattern = 1
} ;
union __anonunion_v_31 {
   Hash_table *table ;
   struct exclude_pattern pat ;
};
struct exclude_segment {
   struct exclude_segment *next ;
   enum exclude_type type ;
   int options ;
   union __anonunion_v_31 v ;
};
struct exclude {
   struct exclude_segment *head ;
   struct exclude_segment *tail ;
};
enum __anonenum_fadvice_t_20 {
    FADVISE_NORMAL = 0,
    FADVISE_SEQUENTIAL = 2,
    FADVISE_NOREUSE = 5,
    FADVISE_DONTNEED = 4,
    FADVISE_WILLNEED = 3,
    FADVISE_RANDOM = 1
} ;
typedef enum __anonenum_fadvice_t_20 fadvice_t;
typedef __gnuc_va_list va_list;
struct F_triple {
   char *name ;
   ino_t st_ino ;
   dev_t st_dev ;
};
struct timeval {
   time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
typedef struct timezone * __restrict __timezone_ptr_t;
typedef __gid_t gid_t;
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry const *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const *tuning ;
   size_t (*hasher)(void const * , size_t ) ;
   _Bool (*comparator)(void const * , void const * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
struct heap ;
struct heap {
   void **array ;
   size_t capacity ;
   size_t count ;
   int (*compare)(void const * , void const * ) ;
};
typedef long intmax_t;
typedef int __gwchar_t;
enum strtol_error {
    LONGINT_OK = 0,
    LONGINT_OVERFLOW = 1,
    LONGINT_INVALID_SUFFIX_CHAR = 2,
    LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
    LONGINT_INVALID = 4
} ;
typedef enum strtol_error strtol_error;
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
struct I_ring {
   int ir_data[4] ;
   int ir_default_val ;
   unsigned int ir_front ;
   unsigned int ir_back ;
   _Bool ir_empty ;
};
typedef struct I_ring I_ring;
typedef __uid_t uid_t;
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
union __anonunion_id_24 {
   uid_t u ;
   gid_t g ;
};
struct userid {
   union __anonunion_id_24 id ;
   struct userid *next ;
   char name[] ;
};
struct ino_map_ent {
   ino_t ino ;
   size_t mapped_ino ;
};
struct ino_map {
   struct hash_table *map ;
   size_t next_mapped_ino ;
   struct ino_map_ent *probe ;
};
struct linebuffer {
   size_t size ;
   size_t length ;
   char *buffer ;
};
typedef int nl_item;
struct __pthread_mutex_s___0 {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   int __spins ;
   __pthread_list_t __list ;
};
union __anonunion_pthread_mutex_t_11 {
   struct __pthread_mutex_s___0 __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_11 pthread_mutex_t___0;
typedef pthread_mutex_t gl_recursive_lock_t;
struct rpl_option {
   char const *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
struct preliminary_header {
   void *next ;
   char room[sizeof(int )] ;
};
struct header {
   void *next ;
   char room[((((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL - sizeof(struct preliminary_header )) + sizeof(int )] ;
};
enum __anonenum_mbs_align_t_1 {
    MBS_ALIGN_LEFT = 0,
    MBS_ALIGN_RIGHT = 1,
    MBS_ALIGN_CENTER = 2
} ;
typedef enum __anonenum_mbs_align_t_1 mbs_align_t;
typedef unsigned long longword;
struct savewd ;
enum __anonenum_state_18 {
    INITIAL_STATE = 0,
    FD_STATE = 1,
    FD_POST_CHDIR_STATE = 2,
    FORKING_STATE = 3,
    ERROR_STATE = 4,
    FINAL_STATE = 5
} ;
union __anonunion_val_19 {
   int fd ;
   int errnum ;
   pid_t child ;
};
struct savewd {
   enum __anonenum_state_18 state ;
   union __anonunion_val_19 val ;
};
struct mode_change ;
struct mode_change {
   char op ;
   char flag ;
   mode_t affected ;
   mode_t value ;
   mode_t mentioned ;
};
enum nproc_query {
    NPROC_ALL = 0,
    NPROC_CURRENT = 1,
    NPROC_CURRENT_OVERRIDABLE = 2
} ;
typedef long long_time_t;
struct __anonstruct_textint_29 {
   _Bool negative ;
   long value ;
   size_t digits ;
};
typedef struct __anonstruct_textint_29 textint;
struct __anonstruct_table_30 {
   char const *name ;
   int type ;
   int value ;
};
typedef struct __anonstruct_table_30 table;
struct __anonstruct_relative_time_33 {
   long year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   long_time_t seconds ;
   long ns ;
};
typedef struct __anonstruct_relative_time_33 relative_time;
struct __anonstruct_parser_control_34 {
   char const *input ;
   long day_ordinal ;
   int day_number ;
   int local_isdst ;
   long time_zone ;
   int meridian ;
   textint year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   struct timespec seconds ;
   relative_time rel ;
   _Bool timespec_seen ;
   _Bool rels_seen ;
   size_t dates_seen ;
   size_t days_seen ;
   size_t local_zones_seen ;
   size_t dsts_seen ;
   size_t times_seen ;
   size_t zones_seen ;
   table local_time_zone_table[3] ;
};
typedef struct __anonstruct_parser_control_34 parser_control;
union YYSTYPE ;
union YYSTYPE {
   long intval ;
   textint textintval ;
   struct timespec timespec ;
   relative_time rel ;
};
typedef union YYSTYPE YYSTYPE;
typedef unsigned char yytype_uint8;
typedef signed char yytype_int8;
typedef short yytype_int16;
union yyalloc {
   yytype_int16 yyss_alloc ;
   YYSTYPE yyvs_alloc ;
};
typedef unsigned short fpucw_t;
struct quoting_options ;
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const *left_quote ;
   char const *right_quote ;
};
struct slotvec {
   size_t size ;
   char *val ;
};
struct randread_source ;
typedef uintmax_t randint;
struct randint_source ;
struct randint_source {
   struct randread_source *source ;
   randint randnum ;
   randint randmax ;
};
struct sparse_ent_ {
   size_t index ;
   size_t val ;
};
typedef Hash_table sparse_map;
typedef unsigned long uint_least64_t;
typedef uint_least64_t isaac_word;
struct isaac_state {
   isaac_word m[1 << 8] ;
   isaac_word a ;
   isaac_word b ;
   isaac_word c ;
};
union __anonunion_data_32 {
   isaac_word w[1 << 8] ;
   unsigned char b[(unsigned long )(1 << 8) * sizeof(isaac_word )] ;
};
struct isaac {
   size_t buffered ;
   struct isaac_state state ;
   union __anonunion_data_32 data ;
};
union __anonunion_buf_31 {
   char c[2UL * ((unsigned long )(1 << 8) * sizeof(isaac_word ))] ;
   struct isaac isaac ;
};
struct randread_source {
   FILE *source ;
   void (*handler)(void const * ) ;
   void const *handler_arg ;
   union __anonunion_buf_31 buf ;
};
struct tokenbuffer {
   size_t size ;
   char *buffer ;
};
typedef struct tokenbuffer token_buffer;
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
union __anonunion_temp_26 {
   long tempint ;
   void *tempptr ;
};
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_26 temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
struct Tokens {
   size_t n_tok ;
   char **tok ;
   size_t *tok_len ;
   struct obstack o_data ;
   struct obstack o_tok ;
   struct obstack o_tok_len ;
};
struct saved_cwd {
   int desc ;
   char *name ;
};
union __anonunion_50 {
   int __in ;
   int __i ;
};
union __anonunion_51 {
   int __in ;
   int __i ;
};
union __anonunion_52 {
   int __in ;
   int __i ;
};
typedef void *iconv_t;
union __anonunion_tmp_21 {
   unsigned int align ;
   char buf[4096] ;
};
struct mbiter_multi {
   char const *limit ;
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
typedef struct mbiter_multi mbi_iterator_t;
typedef uint32_t ucs4_t;
struct fs_res {
   dev_t dev ;
   int resolution ;
   _Bool exact ;
};
struct cd_buf {
   int fd ;
};
struct fs_usage {
   uintmax_t fsu_blocksize ;
   uintmax_t fsu_blocks ;
   uintmax_t fsu_bfree ;
   uintmax_t fsu_bavail ;
   _Bool fsu_bavail_top_bit_set ;
   uintmax_t fsu_files ;
   uintmax_t fsu_ffree ;
};
struct statfs {
   long f_type ;
   long f_bsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsid_t f_fsid ;
   long f_namelen ;
   long f_frsize ;
   long f_flags ;
   long f_spare[4] ;
};
typedef __nlink_t nlink_t;
struct _ftsent ;
union __anonunion_fts_cycle_20 {
   struct hash_table *ht ;
   struct cycle_check_state *state ;
};
struct __anonstruct_FTS_19 {
   struct _ftsent *fts_cur ;
   struct _ftsent *fts_child ;
   struct _ftsent **fts_array ;
   dev_t fts_dev ;
   char *fts_path ;
   int fts_rfd ;
   int fts_cwd_fd ;
   size_t fts_pathlen ;
   size_t fts_nitems ;
   int (*fts_compar)(struct _ftsent const ** , struct _ftsent const ** ) ;
   int fts_options ;
   struct hash_table *fts_leaf_optimization_works_ht ;
   union __anonunion_fts_cycle_20 fts_cycle ;
   I_ring fts_fd_ring ;
};
typedef struct __anonstruct_FTS_19 FTS;
struct _ftsent {
   struct _ftsent *fts_cycle ;
   struct _ftsent *fts_parent ;
   struct _ftsent *fts_link ;
   DIR *fts_dirp ;
   long fts_number ;
   void *fts_pointer ;
   char *fts_accpath ;
   char *fts_path ;
   int fts_errno ;
   int fts_symfd ;
   size_t fts_pathlen ;
   FTS *fts_fts ;
   ptrdiff_t fts_level ;
   size_t fts_namelen ;
   nlink_t fts_n_dirs_remaining ;
   unsigned short fts_info ;
   unsigned short fts_flags ;
   unsigned short fts_instr ;
   struct stat fts_statp[1] ;
   char fts_name[1] ;
};
typedef struct _ftsent FTSENT;
struct Active_dir {
   dev_t dev ;
   ino_t ino ;
   FTSENT *fts_ent ;
};
struct LCO_ent {
   dev_t st_dev ;
   _Bool opt_ok ;
};
typedef long long xtime_t;
enum __ord {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
struct _getopt_data {
   int rpl_optind ;
   int rpl_opterr ;
   int rpl_optopt ;
   char *rpl_optarg ;
   int __initialized ;
   char *__nextchar ;
   enum __ord __ordering ;
   int __posixly_correct ;
   int __first_nonopt ;
   int __last_nonopt ;
};
struct option_list {
   struct rpl_option const *p ;
   struct option_list *next ;
};
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
union __anonunion_memory_double_2 {
   long double value ;
   unsigned int word[((sizeof(long double ) + sizeof(unsigned int )) - 1UL) / sizeof(unsigned int )] ;
};
typedef union __anonunion_memory_double_2 memory_double;
struct mount_entry {
   char *me_devname ;
   char *me_mountdir ;
   char *me_type ;
   dev_t me_dev ;
   unsigned int me_dummy : 1 ;
   unsigned int me_remote : 1 ;
   unsigned int me_type_malloced : 1 ;
   struct mount_entry *me_next ;
};
struct mntent {
   char *mnt_fsname ;
   char *mnt_dir ;
   char *mnt_type ;
   char *mnt_opts ;
   int mnt_freq ;
   int mnt_passno ;
};
enum __anonenum_arg_type_3 {
    TYPE_NONE = 0,
    TYPE_SCHAR = 1,
    TYPE_UCHAR = 2,
    TYPE_SHORT = 3,
    TYPE_USHORT = 4,
    TYPE_INT = 5,
    TYPE_UINT = 6,
    TYPE_LONGINT = 7,
    TYPE_ULONGINT = 8,
    TYPE_LONGLONGINT = 9,
    TYPE_ULONGLONGINT = 10,
    TYPE_DOUBLE = 11,
    TYPE_LONGDOUBLE = 12,
    TYPE_CHAR = 13,
    TYPE_WIDE_CHAR = 14,
    TYPE_STRING = 15,
    TYPE_WIDE_STRING = 16,
    TYPE_POINTER = 17,
    TYPE_COUNT_SCHAR_POINTER = 18,
    TYPE_COUNT_SHORT_POINTER = 19,
    TYPE_COUNT_INT_POINTER = 20,
    TYPE_COUNT_LONGINT_POINTER = 21,
    TYPE_COUNT_LONGLONGINT_POINTER = 22
} ;
typedef enum __anonenum_arg_type_3 arg_type;
union __anonunion_a_5 {
   signed char a_schar ;
   unsigned char a_uchar ;
   short a_short ;
   unsigned short a_ushort ;
   int a_int ;
   unsigned int a_uint ;
   long a_longint ;
   unsigned long a_ulongint ;
   long long a_longlongint ;
   unsigned long long a_ulonglongint ;
   float a_float ;
   double a_double ;
   long double a_longdouble ;
   int a_char ;
   wint_t a_wide_char ;
   char const *a_string ;
   wchar_t const *a_wide_string ;
   void *a_pointer ;
   signed char *a_count_schar_pointer ;
   short *a_count_short_pointer ;
   int *a_count_int_pointer ;
   long *a_count_longint_pointer ;
   long long *a_count_longlongint_pointer ;
};
struct __anonstruct_argument_4 {
   arg_type type ;
   union __anonunion_a_5 a ;
};
typedef struct __anonstruct_argument_4 argument;
struct __anonstruct_arguments_6 {
   size_t count ;
   argument *arg ;
   argument direct_alloc_arg[7] ;
};
typedef struct __anonstruct_arguments_6 arguments;
struct __anonstruct_char_directive_7 {
   char const *dir_start ;
   char const *dir_end ;
   int flags ;
   char const *width_start ;
   char const *width_end ;
   size_t width_arg_index ;
   char const *precision_start ;
   char const *precision_end ;
   size_t precision_arg_index ;
   char conversion ;
   size_t arg_index ;
};
typedef struct __anonstruct_char_directive_7 char_directive;
struct __anonstruct_char_directives_8 {
   size_t count ;
   char_directive *dir ;
   size_t max_width_length ;
   size_t max_precision_length ;
   char_directive direct_alloc_dir[7] ;
};
typedef struct __anonstruct_char_directives_8 char_directives;
struct __exit_status {
   short e_termination ;
   short e_exit ;
};
struct __anonstruct_ut_tv_16 {
   __int32_t tv_sec ;
   __int32_t tv_usec ;
};
struct utmpx {
   short ut_type ;
   __pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct __exit_status ut_exit ;
   __int32_t ut_session ;
   struct __anonstruct_ut_tv_16 ut_tv ;
   __int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
typedef struct utmpx STRUCT_UTMP;
struct numname {
   int num ;
   char const name[8] ;
};
union __anonunion___u_36 {
   long double __l ;
   int __i[3] ;
};
typedef void (*__sighandler_t)(int );
void ( __attribute__((__nonnull__(1,4))) qsort)(void *ptr , size_t count , size_t size ,
                                                int (*comp)(void const * , void const * ) );
void *bsearch(void const *key , void const *ptr , size_t count , size_t size ,
              int (*comp)(void const * , void const * ) );
int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *once_control ,
                                                      void (*init_routine)(void) );
__inline extern unsigned int gnu_dev_major(unsigned long long __dev ) __attribute__((__nothrow__)) ;
__inline extern unsigned int gnu_dev_minor(unsigned long long __dev ) __attribute__((__nothrow__)) ;
__inline extern unsigned long long gnu_dev_makedev(unsigned int __major , unsigned int __minor ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1,2))) stat)(char const *__path ,
                                                              struct stat *__statbuf ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1,2))) lstat)(char const *__path ,
                                                               struct stat *__statbuf ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2))) fstat)(int __fd , struct stat *__statbuf ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2,3))) fstatat)(int __fd , char const *__filename ,
                                                                 struct stat *__statbuf ,
                                                                 int __flag ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1))) mknod)(char const *__path ,
                                                             __mode_t __mode , __dev_t __dev ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2))) mknodat)(int __fd , char const *__path ,
                                                               __mode_t __mode , __dev_t __dev ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1,2))) stat64)(char const *__path ,
                                                                struct stat64 *__statbuf ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1,2))) lstat64)(char const *__path ,
                                                                 struct stat64 *__statbuf ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2))) fstat64)(int __fd , struct stat64 *__statbuf ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2,3))) fstatat64)(int __fd , char const *__filename ,
                                                                   struct stat64 *__statbuf ,
                                                                   int __flag ) __attribute__((__nothrow__)) ;
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1))) atof)(char const *__nptr ) __attribute__((__pure__,
__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) atoi)(char const *__nptr ) __attribute__((__pure__,
__nothrow__)) ;
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1))) atol)(char const *__nptr ) __attribute__((__pure__,
__nothrow__)) ;
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1))) atoll)(char const *__nptr ) __attribute__((__pure__,
__nothrow__)) ;
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) realpath)(char const *__name ,
                                                                                                             char *__resolved ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2), __artificial__, __always_inline__)) ptsname_r)(int __fd ,
                                                                                                    char *__buf ,
                                                                                                    size_t __buflen ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) wctomb)(char *__s ,
                                                                                                         wchar_t __wchar ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                                      char const *__src ,
                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) wcstombs)(char *__dst ,
                                                                                      wchar_t const *__src ,
                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
__inline extern size_t __strcspn_c1(char const *__s , int __reject ) ;
__inline extern size_t __strcspn_c2(char const *__s , int __reject1 , int __reject2 ) ;
__inline extern size_t __strcspn_c3(char const *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) ;
__inline extern size_t __strspn_c1(char const *__s , int __accept ) ;
__inline extern size_t __strspn_c2(char const *__s , int __accept1 , int __accept2 ) ;
__inline extern size_t __strspn_c3(char const *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
__inline extern char *__strpbrk_c2(char const *__s , int __accept1 , int __accept2 ) ;
__inline extern char *__strpbrk_c3(char const *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) ;
__inline extern char *__strsep_1c(char **__s , char __reject ) ;
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) ;
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) memcpy)(void *__dest ,
                                                                                                     void const *__src ,
                                                                                                     size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) memmove)(void *__dest ,
                                                                                                      void const *__src ,
                                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) mempcpy)(void *__dest ,
                                                                                                      void const *__src ,
                                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void *( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) memset)(void *__dest ,
                                                                                                   int __ch ,
                                                                                                   size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void ( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) bcopy)(void const *__src ,
                                                                                                   void *__dest ,
                                                                                                   size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) bzero)(void *__dest ,
                                                                                                 size_t __len ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) strcpy)(char *__dest ,
                                                                                                     char const *__src ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) stpcpy)(char *__dest ,
                                                                                                     char const *__src ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) strncpy)(char *__dest ,
                                                                                                      char const *__src ,
                                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) stpncpy)(char *__dest ,
                                                                                                      char const *__src ,
                                                                                                      size_t __n ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) strcat)(char *__dest ,
                                                                                                     char const *__src ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) strncat)(char *__dest ,
                                                                                                      char const *__src ,
                                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
int chmod_or_fchmod(char const *name , int desc , mode_t mode ) ;
int qset_acl(char const *name , int desc , mode_t mode ) ;
int set_acl(char const *name , int desc , mode_t mode ) ;
static int qcopy_acl(char const *src_name , int source_desc , char const *dst_name ,
                     int dest_desc , mode_t mode ) ;
int copy_acl(char const *src_name , int source_desc , char const *dst_name , int dest_desc ,
             mode_t mode ) ;
int file_has_acl(char const *name , struct stat const *sb ) ;
extern int open(char const *__path , int __oflag, ...) ;
extern int open64(char const *__path ,int __oflag, ...) ;
extern int openat(int __fd ,char const *__path ,int __oflag, ...) ;
extern int openat64(int __fd ,char const *__path ,int __oflag, ...) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) read)(int __fd ,
                                                                                                           void *__buf ,
                                                                                                           size_t __nbytes ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) pread)(int __fd ,
                                                                                                            void *__buf ,
                                                                                                            size_t __nbytes ,
                                                                                                            __off_t __offset ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) pread64)(int __fd ,
                                                                                                              void *__buf ,
                                                                                                              size_t __nbytes ,
                                                                                                              __off64_t __offset ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__artificial__, __always_inline__)) readlink)(char const *__path , char *__buf ,
                                              size_t __len ) __attribute__((__nothrow__)) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__artificial__, __always_inline__)) readlinkat)(int __fd , char const *__path ,
                                                char *__buf , size_t __len ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) getcwd)(char *__buf ,
                                                                                                           size_t __size ) __attribute__((__nothrow__)) ;
__inline extern char __attribute__((__deprecated__)) *( __attribute__((__warn_unused_result__,
__nonnull__(1), __artificial__, __always_inline__)) getwd)(char *__buf ) __attribute__((__nothrow__,
__deprecated__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) confstr)(int __name ,
                                                                                     char *__buf ,
                                                                                     size_t __len ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) getgroups)(int __size ,
                                                                                                            __gid_t *__list ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __artificial__,
__always_inline__)) ttyname_r)(int __fd , char *__buf , size_t __buflen ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) getlogin_r)(char *__buf ,
                                                                                                     size_t __buflen ) ;
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) gethostname)(char *__buf ,
                                                                                                      size_t __buflen ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __artificial__,
__always_inline__)) getdomainname)(char *__buf , size_t __buflen ) __attribute__((__nothrow__)) ;
char *areadlink(char const *filename ) ;
char *areadlink_with_size(char const *file , size_t size ) ;
char *areadlinkat(int fd , char const *filename ) ;
__inline extern int getchar(void) ;
__inline extern int fgetc_unlocked(FILE *__fp ) ;
__inline extern int getchar_unlocked(void) ;
__inline extern int putchar(int __c ) ;
__inline extern int fputc_unlocked(int __c , FILE *__stream ) ;
__inline extern int putchar_unlocked(int __c ) ;
__inline extern __ssize_t ( __attribute__((__warn_unused_result__)) getline)(char **__lineptr ,
                                                                             size_t *__n ,
                                                                             FILE *__stream ) ;
__inline extern int ( __attribute__((__warn_unused_result__)) feof_unlocked)(FILE *__stream ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__)) ferror_unlocked)(FILE *__stream ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                   char const *__fmt ,
                                                                                   __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
extern int snprintf(char *str, size_t size, const char *format, ...);
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vsnprintf)(char *__s ,
                                                                                    size_t __n ,
                                                                                    char const *__fmt ,
                                                                                    __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
extern int fprintf(FILE *stream,
                   const char *format, ...);


__inline extern int ( __attribute__((__artificial__, __always_inline__)) vprintf)(char const *__fmt ,
                                                                                  __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                   char const *__fmt ,
                                                                                   __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) asprintf)(char **__ptr ,
                                                                                                           char const *__fmt
                                                                                                           , ...) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) dprintf)(int __fd ,
                                                                                  char const *__fmt
                                                                                  , ...) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) obstack_printf)(struct obstack *__obstack ,
                                                                                         char const *__fmt
                                                                                         , ...) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) vasprintf)(char **__ptr ,
                                                                                                            char const *__fmt ,
                                                                                                            __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vdprintf)(int __fd ,
                                                                                   char const *__fmt ,
                                                                                   __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) obstack_vprintf)(struct obstack *__obstack ,
                                                                                          char const *__fmt ,
                                                                                          __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets)(char *__s ,
                                                                                                          int __n ,
                                                                                                          FILE *__stream ) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread)(void *__ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE *__stream ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets_unlocked)(char *__s ,
                                                                                                                   int __n ,
                                                                                                                   FILE *__stream ) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread_unlocked)(void *__ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE *__stream ) ;
static void __argmatch_die(void) ;
ptrdiff_t argmatch(char const *arg , char const **arglist , char const *vallist ,
                   size_t valsize ) ;
void argmatch_invalid(char const *context , char const *value , ptrdiff_t problem ) ;
void argmatch_valid(char const **arglist , char const *vallist , size_t valsize ) ;
ptrdiff_t __xargmatch_internal(char const *context , char const *arg , char const **arglist ,
                               char const *vallist , size_t valsize , void (*exit_fn)(void) ) ;
char const *argmatch_to_argument(char const *value , char const **arglist ,
                                   char const *vallist , size_t valsize ) ;
struct argv_iterator *( __attribute__((__nonnull__(1))) argv_iter_init_argv)(char **argv ) ;
struct argv_iterator *( __attribute__((__nonnull__(1))) argv_iter_init_stream)(FILE *fp ) ;
char *( __attribute__((__nonnull__(1,2))) argv_iter)(struct argv_iterator *ai , enum argv_iter_err *err ) ;
size_t ( __attribute__((__nonnull__(1))) argv_iter_n_args)(struct argv_iterator const *ai ) ;
void ( __attribute__((__nonnull__(1))) argv_iter_free)(struct argv_iterator *ai ) ;
__inline static void *xnrealloc(void *p , size_t n , size_t s ) __attribute__((__alloc_size__(2,3))) ;
static void check_extension(char *file , size_t filelen , char e ) ;
static enum numbered_backup_result numbered_backup(char **buffer , size_t buffer_size ,
                                                   size_t filelen ) ;
char *find_backup_file_name(char const *file , enum backup_type backup_type ) ;
enum backup_type get_version(char const *context , char const *version ) ;
enum backup_type xget_version(char const *context , char const *version ) ;
__inline static unsigned char to_uchar(char ch ) ;
void base64_encode(char const *in , size_t inlen , char *out , size_t outlen ) ;
size_t base64_encode_alloc(char const *in , size_t inlen , char **out ) ;
_Bool isbase64(char ch ) ;
void base64_decode_ctx_init(struct base64_decode_context *ctx ) ;
__inline static char *get_4(struct base64_decode_context *ctx , char const * __restrict *in ,
                            char const * __restrict in_end , size_t *n_non_newline ) ;
__inline static _Bool decode_4(char const * __restrict in , size_t inlen , char * __restrict *outp ,
                               size_t *outleft ) ;
_Bool base64_decode_ctx(struct base64_decode_context *ctx , char const *in , size_t inlen ,
                        char *out , size_t *outlen ) ;
_Bool base64_decode_alloc_ctx(struct base64_decode_context *ctx , char const *in ,
                              size_t inlen , char **out , size_t *outlen ) ;
_Bool c_isascii(int c ) ;
_Bool c_isalnum(int c ) ;
_Bool c_isalpha(int c ) ;
_Bool c_isblank(int c ) ;
_Bool c_iscntrl(int c ) ;
_Bool c_isdigit(int c ) ;
_Bool c_islower(int c ) ;
_Bool c_isgraph(int c ) ;
_Bool c_isprint(int c ) ;
_Bool c_ispunct(int c ) ;
_Bool c_isspace(int c ) ;
_Bool c_isupper(int c ) ;
_Bool c_isxdigit(int c ) ;
int c_tolower(int c ) ;
int c_toupper(int c ) ;
int c_strcasecmp(char const *s1 , char const *s2 ) ;
int c_strncasecmp(char const *s1 , char const *s2 , size_t n ) ;
__inline static locale_t c_locale(void) ;
double c_strtod(char const *nptr , char **endptr ) ;
__inline static locale_t c_locale___0(void) ;
long double c_strtold(char const *nptr , char **endptr ) ;
__inline extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr , struct cmsghdr *__cmsg ) __attribute__((__nothrow__)) ;
__inline extern ssize_t ( __attribute__((__artificial__, __always_inline__)) recv)(int __fd ,
                                                                                   void *__buf ,
                                                                                   size_t __n ,
                                                                                   int __flags ) ;
__inline extern ssize_t ( __attribute__((__artificial__, __always_inline__)) recvfrom)(int __fd ,
                                                                                       void *__buf ,
                                                                                       size_t __n ,
                                                                                       int __flags ,
                                                                                       struct sockaddr *__cil_tmp14 ,
                                                                                       socklen_t *__addr_len ) ;
char *canon_host(char const *host ) ;
char *canon_host_r(char const *host , int *cherror ) ;
char const *ch_strerror(void) ;
static _Bool seen_triple(Hash_table **ht___0 , char const *filename , struct stat const *st ) ;
char *canonicalize_filename_mode(char const *name , canonicalize_mode_t can_mode ) ;
ssize_t careadlinkatcwd(int fd , char const *filename , char *buffer , size_t buffer_size ) ;
char *careadlinkat(int fd , char const *filename , char *buffer , size_t buffer_size ,
                   struct allocator const *alloc , ssize_t (*preadlinkat)(int ,
                                                                            char const * ,
                                                                            char * ,
                                                                            size_t ) ) ;
int set_cloexec_flag(int desc , _Bool value ) ;
int dup_cloexec(int fd ) ;
int close_stream(FILE *stream ) ;
void close_stdin_set_file_name(char const *file ) ;
void close_stdin(void) ;
void close_stdout_set_file_name(char const *file ) ;
void close_stdout_set_ignore_EPIPE(_Bool ignore ) ;
void close_stdout(void) ;
void md5_init_ctx(struct md5_ctx *ctx ) __attribute__((__nothrow__)) ;
__inline static void set_uint32(char *cp , uint32_t v ) ;
void *md5_read_ctx(struct md5_ctx const *ctx , void *resbuf ) __attribute__((__nothrow__)) ;
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) __attribute__((__nothrow__)) ;
int md5_stream(FILE *stream , void *resblock ) __attribute__((__nothrow__)) ;
void *md5_buffer(char const *buffer , size_t len , void *resblock ) __attribute__((__nothrow__)) ;
void md5_process_bytes(void const *buffer , size_t len , struct md5_ctx *ctx ) __attribute__((__nothrow__)) ;
void md5_process_block(void const *buffer , size_t len , struct md5_ctx *ctx ) __attribute__((__nothrow__)) ;
void sha1_init_ctx(struct sha1_ctx *ctx ) ;
void *sha1_read_ctx(struct sha1_ctx const *ctx , void *resbuf ) ;
void *sha1_finish_ctx(struct sha1_ctx *ctx , void *resbuf ) ;
int sha1_stream(FILE *stream , void *resblock ) ;
void *sha1_buffer(char const *buffer , size_t len , void *resblock ) ;
void sha1_process_bytes(void const *buffer , size_t len , struct sha1_ctx *ctx ) ;
void sha1_process_block(void const *buffer , size_t len , struct sha1_ctx *ctx ) ;
void sha256_init_ctx(struct sha256_ctx *ctx ) ;
void sha224_init_ctx(struct sha256_ctx *ctx ) ;
void *sha256_read_ctx(struct sha256_ctx const *ctx , void *resbuf ) ;
void *sha224_read_ctx(struct sha256_ctx const *ctx , void *resbuf ) ;
static void sha256_conclude_ctx(struct sha256_ctx *ctx ) ;
void *sha256_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) ;
void *sha224_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) ;
int sha256_stream(FILE *stream , void *resblock ) ;
int sha224_stream(FILE *stream , void *resblock ) ;
void *sha256_buffer(char const *buffer , size_t len , void *resblock ) ;
void *sha224_buffer(char const *buffer , size_t len , void *resblock ) ;
void sha256_process_bytes(void const *buffer , size_t len , struct sha256_ctx *ctx ) ;
void sha256_process_block(void const *buffer , size_t len , struct sha256_ctx *ctx ) ;
void sha512_init_ctx(struct sha512_ctx *ctx ) ;
void sha384_init_ctx(struct sha512_ctx *ctx ) ;
__inline static void set_uint64(char *cp , u64 v ) ;
void *sha512_read_ctx(struct sha512_ctx const *ctx , void *resbuf ) ;
void *sha384_read_ctx(struct sha512_ctx const *ctx , void *resbuf ) ;
static void sha512_conclude_ctx(struct sha512_ctx *ctx ) ;
void *sha512_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) ;
void *sha384_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) ;
int sha512_stream(FILE *stream , void *resblock ) ;
int sha384_stream(FILE *stream , void *resblock ) ;
void *sha512_buffer(char const *buffer , size_t len , void *resblock ) ;
void *sha384_buffer(char const *buffer , size_t len , void *resblock ) ;
void sha512_process_bytes(void const *buffer , size_t len , struct sha512_ctx *ctx ) ;
void sha512_process_block(void const *buffer , size_t len , struct sha512_ctx *ctx ) ;
__inline static _Bool is_zero_or_power_of_two(uintmax_t i ) ;
void cycle_check_init(struct cycle_check_state *state ) ;
_Bool cycle_check(struct cycle_check_state *state , struct stat const *sb ) ;
static size_t di_ent_hash(void const *x , size_t table_size ) ;
static _Bool di_ent_compare(void const *x , void const *y ) ;
static void di_ent_free(void *v ) ;
struct di_set *di_set_alloc(void) ;
void ( __attribute__((__nonnull__(1))) di_set_free)(struct di_set *dis ) ;
static size_t di_ino_hash(void const *i , size_t table_size ) ;
static struct hash_table *map_device(struct di_set *dis , dev_t dev ) ;
static hashint map_inode_number(struct di_set *dis , ino_t ino ) ;
int ( __attribute__((__nonnull__(1))) di_set_insert)(struct di_set *dis , dev_t dev ,
                                                     ino_t ino ) ;
int ( __attribute__((__nonnull__(1))) di_set_lookup)(struct di_set *dis , dev_t dev ,
                                                     ino_t ino ) ;
DIR *opendir_safer(char const *name ) ;
char *dir_name(char const *file ) ;
char *base_name(char const *name ) ;
size_t dir_len(char const *file ) ;
char *mdir_name(char const *file ) ;
char *last_component(char const *name ) ;
size_t base_len(char const *name ) ;
_Bool strip_trailing_slashes(char *file ) ;
int dtoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , double x ) ;
struct timespec dtotimespec(double sec ) ;
__inline extern int tolower(int __c ) __attribute__((__nothrow__)) ;
__inline extern int toupper(int __c ) __attribute__((__nothrow__)) ;
__inline extern wint_t btowc(int __c ) __attribute__((__nothrow__)) ;
__inline extern int wctob(wint_t __wc ) __attribute__((__nothrow__)) ;
__inline extern size_t mbrlen(char const *__s , size_t __n , mbstate_t *__ps ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wmemcpy)(wchar_t *__s1 ,
                                                                                       wchar_t const *__s2 ,
                                                                                       size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wmemmove)(wchar_t *__s1 ,
                                                                                        wchar_t const *__s2 ,
                                                                                        size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wmempcpy)(wchar_t *__s1 ,
                                                                                        wchar_t const *__s2 ,
                                                                                        size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wmemset)(wchar_t *__s ,
                                                                                       wchar_t __c ,
                                                                                       size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcscpy)(wchar_t *__dest ,
                                                                                      wchar_t const *__src ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcpcpy)(wchar_t *__dest ,
                                                                                      wchar_t const *__src ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcsncpy)(wchar_t *__dest ,
                                                                                       wchar_t const *__src ,
                                                                                       size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcpncpy)(wchar_t *__dest ,
                                                                                       wchar_t const *__src ,
                                                                                       size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcscat)(wchar_t *__dest ,
                                                                                      wchar_t const *__src ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcsncat)(wchar_t *__dest ,
                                                                                       wchar_t const *__src ,
                                                                                       size_t __n ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) swprintf)(wchar_t *__s ,
                                                                                   size_t __n ,
                                                                                   wchar_t const *__fmt
                                                                                   , ...) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vswprintf)(wchar_t *__s ,
                                                                                    size_t __n ,
                                                                                    wchar_t const *__fmt ,
                                                                                    __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) wprintf)(wchar_t const *__fmt
                                                                                  , ...) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) fwprintf)(__FILE *__stream ,
                                                                                   wchar_t const *__fmt
                                                                                   , ...) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vwprintf)(wchar_t const *__fmt ,
                                                                                   __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfwprintf)(__FILE *__stream ,
                                                                                    wchar_t const *__fmt ,
                                                                                    __gnuc_va_list __ap ) ;
__inline extern wchar_t *( __attribute__((__warn_unused_result__, __artificial__,
__always_inline__)) fgetws)(wchar_t *__s , int __n , __FILE *__stream ) ;
__inline extern wchar_t *( __attribute__((__warn_unused_result__, __artificial__,
__always_inline__)) fgetws_unlocked)(wchar_t *__s , int __n , __FILE *__stream ) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) wcrtomb)(char *__s ,
                                                                                                             wchar_t __wchar ,
                                                                                                             mbstate_t *__ps ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) mbsrtowcs)(wchar_t *__dst ,
                                                                                       char const **__src ,
                                                                                       size_t __len ,
                                                                                       mbstate_t *__ps ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) wcsrtombs)(char *__dst ,
                                                                                       wchar_t const **__src ,
                                                                                       size_t __len ,
                                                                                       mbstate_t *__ps ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) mbsnrtowcs)(wchar_t *__dst ,
                                                                                        char const **__src ,
                                                                                        size_t __nmc ,
                                                                                        size_t __len ,
                                                                                        mbstate_t *__ps ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) wcsnrtombs)(char *__dst ,
                                                                                        wchar_t const **__src ,
                                                                                        size_t __nwc ,
                                                                                        size_t __len ,
                                                                                        mbstate_t *__ps ) __attribute__((__nothrow__)) ;
__inline static _Bool is_basic(char c ) ;
__inline static void mbuiter_multi_next(struct mbuiter_multi *iter ) ;
__inline static void *x2nrealloc(void *p , size_t *pn , size_t s ) ;
_Bool fnmatch_pattern_has_wildcards(char const *str , int options ) ;
static void unescape_pattern(char *str ) ;
struct exclude *new_exclude(void) ;
static size_t string_hasher(void const *data , size_t n_buckets ) ;
static size_t string_hasher_ci(void const *data , size_t n_buckets ) ;
static _Bool string_compare(void const *data1 , void const *data2 ) ;
static _Bool string_compare_ci(void const *data1 , void const *data2 ) ;
static void string_free(void *data ) ;
static struct exclude_segment *new_exclude_segment(struct exclude *ex , enum exclude_type type ,
                                                   int options ) ;
static void free_exclude_segment(struct exclude_segment *seg ) ;
void free_exclude(struct exclude *ex ) ;
static int fnmatch_no_wildcards(char const *pattern , char const *f , int options ) ;
_Bool exclude_fnmatch(char const *pattern , char const *f , int options ) ;
static _Bool excluded_file_pattern_p(struct exclude_segment const *seg , char const *f ) ;
static _Bool excluded_file_name_p(struct exclude_segment const *seg , char const *f ,
                                  char *buffer ) ;
_Bool excluded_file_name(struct exclude const *ex , char const *f ) ;
void add_exclude(struct exclude *ex , char const *pattern , int options ) ;
int add_exclude_file(void (*add_func)(struct exclude * , char const * , int ) ,
                     struct exclude *ex , char const *file_name___1 , int options ,
                     char line_end ) ;
void fdadvise(int fd , off_t offset , off_t len , fadvice_t advice ) ;
void fadvise(FILE *fp , fadvice_t advice ) ;
int creat_safer(char const *file , mode_t mode ) ;
int open_safer(char const *file , int flags , ...) ;
int fd_safer_flag(int fd , int flag ) ;
int dup_safer_flag(int fd , int flag ) ;
int fdutimensat(int fd , int dir , char const *file , struct timespec const *ts ,
                int atflag ) ;
void ( __attribute__((__nonnull__(2,3))) record_file)(Hash_table *ht___0 , char const *file ,
                                                      struct stat const *stats ) ;
_Bool seen_file(Hash_table const *ht___0 , char const *file , struct stat const *stats ) ;
char const *file_type(struct stat const *st ) ;
static char ftypelet(mode_t bits ) ;
void strmode(mode_t mode , char *str ) ;
void filemodestring(struct stat const *statp , char *str ) ;
char *file_name_concat(char const *dir , char const *abase , char **base_in_result ) ;
static char const *longest_relative_suffix(char const *f ) ;
char *mfile_name_concat(char const *dir , char const *abase , char **base_in_result ) ;
static char const *match_suffix(char const **str ) ;
__inline static int order(unsigned char c ) ;
static int verrevcmp(char const *s1 , size_t s1_len , char const *s2 , size_t s2_len ) ;
int filevercmp(char const *s1 , char const *s2 ) ;
FILE *fopen_safer(char const *file , char const *mode ) ;
__inline static size_t ( __attribute__((__nonnull__(1,4))) rpl_fwrite)(void const *ptr ,
                                                                       size_t s ,
                                                                       size_t n ,
                                                                       FILE *stream ) ;
static void fwrite_lowcase(FILE *fp , char const *src , size_t len ) ;
static void fwrite_uppcase(FILE *fp , char const *src , size_t len ) ;
__inline static int iso_week_days(int yday , int wday ) ;
static size_t strftime_case_(_Bool upcase , FILE *s , char const *format , struct tm const *tp ,
                             int ut , int ns ) ;
size_t fprintftime(FILE *s , char const *format , struct tm const *tp , int ut ,
                   int ns ) ;
size_t freadahead(FILE *fp ) ;
char const *freadptr(FILE *fp , size_t *sizep ) ;
__inline static void freadptrinc(FILE *fp , size_t increment ) ;
int freadseek(FILE *fp , size_t offset ) ;
static _Bool protect_fd(int fd ) ;
FILE *freopen_safer(char const *name , char const *mode , FILE *f ) ;
void fseterr(FILE *fp ) ;
int ftoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , float x ) ;
size_t full_read(int fd , void *buf___1 , size_t count ) ;
size_t full_write(int fd , void const *buf___1 , size_t count ) ;
ssize_t getndelim2(char **lineptr , size_t *linesize , size_t offset , size_t nmax ,
                   int delim1 , int delim2 , FILE *stream ) ;
void gettime(struct timespec *ts ) ;
int getugroups(int maxcount , gid_t *grouplist , char const *username , gid_t gid ) ;
_Bool hard_locale(int category ) ;
__inline static size_t rotr_sz(size_t x , int n ) ;
size_t hash_get_n_buckets(Hash_table const *table___0 ) ;
size_t hash_get_n_buckets_used(Hash_table const *table___0 ) ;
size_t hash_get_n_entries(Hash_table const *table___0 ) ;
size_t hash_get_max_bucket_length(Hash_table const *table___0 ) ;
_Bool hash_table_ok(Hash_table const *table___0 ) ;
void hash_print_statistics(Hash_table const *table___0 , FILE *stream ) ;
static struct hash_entry *safe_hasher(Hash_table const *table___0 , void const *key ) ;
void *hash_lookup(Hash_table const *table___0 , void const *entry ) ;
void *hash_get_first(Hash_table const *table___0 ) ;
void *hash_get_next(Hash_table const *table___0 , void const *entry ) ;
size_t hash_get_entries(Hash_table const *table___0 , void **buffer , size_t buffer_size ) ;
size_t hash_do_for_each(Hash_table const *table___0 , _Bool (*processor)(void * ,
                                                                           void * ) ,
                        void *processor_data ) ;
size_t hash_string(char const *string , size_t n_buckets ) ;
static _Bool is_prime(size_t candidate ) ;
static size_t next_prime(size_t candidate ) ;
void hash_reset_tuning(Hash_tuning *tuning ) ;
static size_t raw_hasher(void const *data , size_t n ) ;
static _Bool raw_comparator(void const *a , void const *b ) ;
static _Bool check_tuning(Hash_table *table___0 ) ;
static size_t compute_bucket_size(size_t candidate , Hash_tuning const *tuning ) ;
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const *tuning ,
                                                                       size_t (*hasher)(void const * ,
                                                                                        size_t ) ,
                                                                       _Bool (*comparator)(void const * ,
                                                                                           void const * ) ,
                                                                       void (*data_freer)(void * ) ) ;
void hash_clear(Hash_table *table___0 ) ;
void hash_free(Hash_table *table___0 ) ;
static struct hash_entry *allocate_entry(Hash_table *table___0 ) ;
static void free_entry(Hash_table *table___0 , struct hash_entry *entry ) ;
static void *hash_find_entry(Hash_table *table___0 , void const *entry , struct hash_entry **bucket_head ,
                             _Bool delete ) ;
static _Bool transfer_entries(Hash_table *dst , Hash_table *src , _Bool safe ) ;
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table___0 ,
                                                             size_t candidate ) ;
int hash_insert0(Hash_table *table___0 , void const *entry , void const **matched_ent ) ;
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table___0 ,
                                                             void const *entry ) ;
void *hash_delete(Hash_table *table___0 , void const *entry ) ;
size_t hash_pjw(void const *x , size_t tablesize ) ;
size_t triple_hash(void const *x , size_t table_size ) ;
size_t triple_hash_no_name(void const *x , size_t table_size ) ;
_Bool triple_compare(void const *x , void const *y ) ;
_Bool triple_compare_ino_str(void const *x , void const *y ) ;
void triple_free(void *x ) ;
__inline static void *xnmalloc(size_t n , size_t s ) __attribute__((__malloc__, __alloc_size__(1,2))) ;
struct heap *heap_alloc(int (*compare)(void const * , void const * ) , size_t n_reserve ) ;
static int heap_default_compare(void const *a , void const *b ) ;
void heap_free(struct heap *heap ) ;
int heap_insert(struct heap *heap , void *item ) ;
void *heap_remove_top(struct heap *heap ) ;
static size_t heapify_down(void **array , size_t count , size_t initial , int (*compare)(void const * ,
                                                                                         void const * ) ) ;
static void heapify_up(void **array , size_t count , int (*compare)(void const * ,
                                                                    void const * ) ) ;
__inline extern intmax_t strtoimax(char const *nptr , char **endptr , int base ) __attribute__((__nothrow__)) ;
__inline extern uintmax_t strtoumax(char const *nptr , char **endptr , int base ) __attribute__((__nothrow__)) ;
__inline extern intmax_t wcstoimax(__gwchar_t const *nptr , __gwchar_t **endptr ,
                                   int base ) __attribute__((__nothrow__)) ;
__inline extern uintmax_t wcstoumax(__gwchar_t const *nptr , __gwchar_t **endptr ,
                                    int base ) __attribute__((__nothrow__)) ;
static long double adjust_value(int inexact_style , long double value ) ;
static char *group_number(char *number , size_t numberlen , char const *grouping ,
                          char const *thousands_sep ) ;
char *human_readable(uintmax_t n , char *buf___1 , int opts , uintmax_t from_block_size ,
                     uintmax_t to_block_size ) ;
static uintmax_t default_block_size(void) ;
static strtol_error humblock(char const *spec , uintmax_t *block_size , int *options ) ;
enum strtol_error human_options(char const *spec , int *opts , uintmax_t *block_size ) ;
void i_ring_init(I_ring *ir , int default_val ) ;
_Bool i_ring_empty(I_ring const *ir ) ;
int i_ring_push(I_ring *ir , int val ) ;
int i_ring_pop(I_ring *ir ) ;
char *getuser(uid_t uid ) ;
uid_t *getuidbyname(char const *user ) ;
char *getgroup(gid_t gid ) ;
gid_t *getgidbyname(char const *group ) ;
static size_t ino_hash(void const *x , size_t table_size ) ;
static _Bool ino_compare(void const *x , void const *y ) ;
struct ino_map *ino_map_alloc(size_t next_mapped_ino ) ;
void ( __attribute__((__nonnull__(1))) ino_map_free)(struct ino_map *map ) ;
size_t ( __attribute__((__nonnull__(1))) ino_map_insert)(struct ino_map *im , ino_t ino ) ;
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i , char *buf___1 ) ;
char *( __attribute__((__warn_unused_result__)) inttostr)(int i , char *buf___1 ) ;
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i , char *buf___1 ) ;
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i , char *buf___1 ) ;
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i , char *buf___1 ) ;
int ldtoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , long double x ) ;
void initbuffer(struct linebuffer *linebuffer ) ;
struct linebuffer *readlinebuffer(struct linebuffer *linebuffer , FILE *stream ) ;
struct linebuffer *readlinebuffer_delim(struct linebuffer *linebuffer , FILE *stream ,
                                        char delimiter ) ;
void freebuffer(struct linebuffer *linebuffer ) ;
static char const *get_charset_aliases(void) ;
char const *locale_charset(void) ;
extern int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 , pthread_t __thread2 ) __attribute__((__nothrow__,
__const__)) ;
int glthread_recursive_lock_init_multithreaded(gl_recursive_lock_t *lock ) ;
int glthread_once_singlethreaded(pthread_once_t *once_control ) ;
void parse_long_options(int argc , char **argv , char const *command_name , char const *package ,
                        char const *version , void (*usage_func)(int ) , ...) ;
void *mmalloca(size_t n ) ;
void freea(void *p ) ;
static _Bool wc_ensure_printable(wchar_t *wchars ) ;
static size_t wc_truncate(wchar_t *wc , size_t width ) ;
static char *mbs_align_pad(char *dest , char const *dest_end , size_t n_spaces ) ;
size_t mbsalign(char const *src , char *dest , size_t dest_size , size_t *width ,
                mbs_align_t align , int flags ) ;
char *ambsalign(char const *src , size_t *width , mbs_align_t align , int flags ) ;
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const *s1 , char const *s2 ) ;
size_t ( __attribute__((__nonnull__(1))) mbslen)(char const *string ) ;
__inline static void mb_copy(mbchar_t *new_mbc , mbchar_t const *old_mbc ) ;
static _Bool knuth_morris_pratt(unsigned char const *haystack , unsigned char const *needle ,
                                size_t needle_len , unsigned char const **resultp ) ;
static _Bool knuth_morris_pratt_multibyte(char const *haystack , char const *needle ,
                                          char const **resultp ) ;
char *( __attribute__((__nonnull__(1,2))) mbsstr)(char const *haystack , char const *needle ) ;
int gnu_mbswidth(char const *string , int flags ) ;
int mbsnwidth(char const *string , size_t nbytes , int flags ) ;
int memcasecmp(void const *vs1 , void const *vs2 , size_t n ) ;
void *memchr2(void const *s , int c1_in , int c2_in , size_t n ) ;
int memcmp2(char const *s1 , size_t n1 , char const *s2 , size_t n2 ) ;
__inline static int strcoll_loop(char const *s1 , size_t s1size , char const *s2 ,
                                 size_t s2size ) ;
int memcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) ;
int memcoll0(char const *s1 , size_t s1size , char const *s2 , size_t s2size ) ;
static gid_t *realloc_groupbuf(gid_t *g , size_t num ) ;
int mgetgroups(char const *username , gid_t gid , gid_t **groups ) ;
ptrdiff_t mkancesdirs(char *file , struct savewd *wd , int (*make_dir)(char const * ,
                                                                       char const * ,
                                                                       void * ) ,
                      void *make_dir_arg ) ;
int dirchownmod(int fd , char const *dir , mode_t mkdir_mode , uid_t owner , gid_t group ,
                mode_t mode , mode_t mode_bits ) ;
__inline static int savewd_errno(struct savewd const *wd ) ;
_Bool make_dir_parents(char *dir , struct savewd *wd , int (*make_ancestor)(char const * ,
                                                                            char const * ,
                                                                            void * ) ,
                       void *options , mode_t mode , void (*announce)(char const * ,
                                                                      void * ) , mode_t mode_bits ,
                       uid_t owner , gid_t group , _Bool preserve_existing ) ;
static mode_t octal_to_mode(unsigned int octal ) ;
static struct mode_change *make_node_op_equals(mode_t new_mode , mode_t mentioned ) ;
struct mode_change *mode_compile(char const *mode_string ) ;
struct mode_change *mode_create_from_ref(char const *ref_file ) ;
mode_t mode_adjust(mode_t oldmode , _Bool dir , mode_t umask_value , struct mode_change const *changes ,
                   mode_t *pmode_bits ) ;
static void mpsort_into_tmp(void const ** __restrict base , size_t n , void const ** __restrict tmp ,
                            int (*cmp)(void const * , void const * ) ) ;
static void mpsort_with_tmp(void const **base , size_t n , void const **tmp ,
                            int (*cmp)(void const * , void const * ) ) ;
void mpsort(void const **base , size_t n , int (*cmp)(void const * , void const * ) ) ;
static unsigned long num_processors_via_affinity_mask(void) ;
unsigned long num_processors(enum nproc_query query ) ;
void openat_save_fail(int errnum ) __attribute__((__noreturn__)) ;
void openat_restore_fail(int errnum ) __attribute__((__noreturn__)) ;
int openat_safer(int fd , char const *file , int flags , ...) ;
static void digits_to_date_time(parser_control *pc , textint text_int ) ;
static void apply_relative_time(parser_control *pc , relative_time rel , int factor ) ;
static void set_hhmmss(parser_control *pc , long hour , long minutes , time_t sec ,
                       long nsec ) ;
static void yydestruct(char const *yymsg , int yytype , YYSTYPE *yyvaluep , parser_control *pc ) ;
int yyparse(parser_control *pc ) ;
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) ;
static int to_hour(long hours , int meridian ) ;
static long to_year(textint textyear ) ;
static table const *lookup_zone(parser_control const *pc , char const *name ) ;
static table const *lookup_word(parser_control const *pc , char *word ) ;
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) ;
static int yyerror(parser_control const *pc __attribute__((__unused__)) , char const *s __attribute__((__unused__)) ) ;
static _Bool mktime_ok(struct tm const *tm0 , struct tm const *tm1 , time_t t ) ;
static char *get_tz(char *tzbuf ) ;
_Bool parse_datetime(struct timespec *result , char const *p , struct timespec const *now ) ;
double physmem_total(void) ;
double physmem_available(void) ;
static int year(struct tm *tm , int const *digit_pair , size_t n , unsigned int syntax_bits ) ;
static int posix_time_parse(struct tm *tm , char const *s , unsigned int syntax_bits ) ;
_Bool posixtime(time_t *p , char const *s , unsigned int syntax_bits ) ;
int posix2_version(void) ;
__inline extern int __signbitf(float __x ) __attribute__((__nothrow__, __const__)) ;
__inline extern int __signbit(double __x ) __attribute__((__nothrow__, __const__)) ;
double printf_frexp(double x , int *expptr ) ;
long double printf_frexpl(long double x , int *expptr ) ;
void set_program_name(char const *argv0 ) ;
static _Bool mbsstr_trimmed_wordbounded(char const *string , char const *sub ) ;
char const *proper_name(char const *name ) ;
char const *proper_name_utf8(char const *name_ascii , char const *name_utf8 ) ;
char const *quote_n(int n , char const *name ) ;
char const *quote(char const *name ) ;
__inline static char *xcharalloc(size_t n ) __attribute__((__malloc__, __alloc_size__(1))) ;
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
int set_quoting_flags(struct quoting_options *o , int i ) ;
void set_custom_quoting(struct quoting_options *o , char const *left_quote , char const *right_quote ) ;
static struct quoting_options quoting_options_from_style(enum quoting_style style ) ;
static char const *gettext_quote(char const *msgid , enum quoting_style s ) ;
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const *quote_these_too ,
                                       char const *left_quote , char const *right_quote ) ;
size_t quotearg_buffer(char *buffer , size_t buffersize , char const *arg , size_t argsize ,
                       struct quoting_options const *o ) ;
char *quotearg_alloc(char const *arg , size_t argsize , struct quoting_options const *o ) ;
char *quotearg_alloc_mem(char const *arg , size_t argsize , size_t *size , struct quoting_options const *o ) ;
void quotearg_free(void) ;
static char *quotearg_n_options(int n , char const *arg , size_t argsize , struct quoting_options const *options ) ;
char *quotearg_n(int n , char const *arg ) ;
char *quotearg_n_mem(int n , char const *arg , size_t argsize ) ;
char *quotearg(char const *arg ) ;
char *quotearg_mem(char const *arg , size_t argsize ) ;
char *quotearg_n_style(int n , enum quoting_style s , char const *arg ) ;
char *quotearg_n_style_mem(int n , enum quoting_style s , char const *arg , size_t argsize ) ;
char *quotearg_style(enum quoting_style s , char const *arg ) ;
char *quotearg_style_mem(enum quoting_style s , char const *arg , size_t argsize ) ;
char *quotearg_char_mem(char const *arg , size_t argsize , char ch ) ;
char *quotearg_char(char const *arg , char ch ) ;
char *quotearg_colon(char const *arg ) ;
char *quotearg_colon_mem(char const *arg , size_t argsize ) ;
char *quotearg_n_custom(int n , char const *left_quote , char const *right_quote ,
                        char const *arg ) ;
char *quotearg_n_custom_mem(int n , char const *left_quote , char const *right_quote ,
                            char const *arg , size_t argsize ) ;
char *quotearg_custom(char const *left_quote , char const *right_quote , char const *arg ) ;
char *quotearg_custom_mem(char const *left_quote , char const *right_quote , char const *arg ,
                          size_t argsize ) ;
struct randint_source *randint_new(struct randread_source *source ) ;
struct randint_source *randint_all_new(char const *name , size_t bytes_bound ) ;
struct randread_source *randint_get_source(struct randint_source const *s ) __attribute__((__pure__)) ;
__inline static randint shift_left(randint x ) ;
randint randint_genmax(struct randint_source *s , randint genmax ) ;
void randint_free(struct randint_source *s ) ;
int randint_all_free(struct randint_source *s ) ;
__inline static randint randint_choose(struct randint_source *s , randint choices ) ;
static size_t ceil_lg(size_t n ) __attribute__((__const__)) ;
size_t randperm_bound(size_t h , size_t n ) __attribute__((__const__)) ;
static void swap(size_t *v , size_t i , size_t j ) ;
static size_t sparse_hash_(void const *x , size_t table_size ) ;
static _Bool sparse_cmp_(void const *x , void const *y ) ;
static sparse_map *sparse_new(size_t size_hint ) ;
static void sparse_swap(sparse_map *sv , size_t *v , size_t i , size_t j ) ;
static void sparse_free(sparse_map *sv ) ;
size_t *randperm_new(struct randint_source *r , size_t h , size_t n ) ;
static void randread_error(void const *file_name___1 ) __attribute__((__noreturn__)) ;
static struct randread_source *simple_new(FILE *source , void const *handler_arg ) ;
static void get_nonce(void *buffer , size_t bufsize___0 , size_t bytes_bound ) ;
struct randread_source *randread_new(char const *name , size_t bytes_bound ) ;
void randread_set_handler(struct randread_source *s , void (*handler)(void const * ) ) ;
void randread_set_handler_arg(struct randread_source *s , void const *handler_arg ) ;
static void readsource(struct randread_source *s , unsigned char *p , size_t size ) ;
static void readisaac(struct isaac *isaac , unsigned char *p , size_t size ) ;
void randread(struct randread_source *s , void *buf___1 , size_t size ) ;
int randread_free(struct randread_source *s ) ;
__inline static isaac_word just(isaac_word a ) ;
__inline static isaac_word ind(isaac_word const *m , isaac_word x ) ;
void isaac_refill(struct isaac_state *s , isaac_word *result ) ;
void isaac_seed(struct isaac_state *s ) ;
char *fread_file(FILE *stream , size_t *length ) ;
static char *internal_read_file(char const *filename , size_t *length , char const *mode ) ;
char *read_file(char const *filename , size_t *length ) ;
char *read_binary_file(char const *filename , size_t *length ) ;
void init_tokenbuffer(token_buffer *tokenbuffer ) ;
size_t readtoken(FILE *stream , char const *delim , size_t n_delim , token_buffer *tokenbuffer ) ;
size_t readtokens(FILE *stream , size_t projected_n_tokens , char const *delim ,
                  size_t n_delim , char ***tokens_out , size_t **token_lengths ) ;
void readtokens0_init(struct Tokens *t ) ;
void readtokens0_free(struct Tokens *t ) ;
static void save_token(struct Tokens *t ) ;
_Bool readtokens0(FILE *in , struct Tokens *t ) ;
size_t safe_read(int fd , void *buf___1 , size_t count ) ;
size_t safe_write(int fd , void const *buf___1 , size_t count ) ;
_Bool same_name(char const *source , char const *dest ) ;
int save_cwd(struct saved_cwd *cwd ) ;
int restore_cwd(struct saved_cwd const *cwd ) ;
void free_cwd(struct saved_cwd *cwd ) ;
char *streamsavedir(DIR *dirp ) ;
static char *savedirstream(DIR *dirp ) ;
char *savedir(char const *dir ) ;
char *fdsavedir(int fd ) ;
__inline static void savewd_init(struct savewd *wd ) ;
__inline extern int __sigismember(__sigset_t const *__set , int __sig ) ;
__inline extern int __sigaddset(__sigset_t *__set , int __sig ) ;
__inline extern int __sigdelset(__sigset_t *__set , int __sig ) ;
static _Bool savewd_save(struct savewd *wd ) ;
int savewd_chdir(struct savewd *wd , char const *dir , int options , int *open_result ) ;
int savewd_restore(struct savewd *wd , int status ) ;
void savewd_finish(struct savewd *wd ) ;
__inline static _Bool savewd_delegating(struct savewd const *wd ) ;
int savewd_process_files(int n_files , char **file , int (*act)(char * , struct savewd * ,
                                                                void * ) , void *options ) ;
int settime(struct timespec const *ts ) ;
int gl_sockets_startup(int version __attribute__((__unused__)) ) ;
int gl_sockets_cleanup(void) ;
int mkstemp_safer(char *templ ) ;
static char *memcpy_lowcase(char *dest , char const *src , size_t len ) ;
static char *memcpy_uppcase(char *dest , char const *src , size_t len ) ;
static size_t strftime_case____0(_Bool upcase , char *s , size_t maxsize , char const *format ,
                                 struct tm const *tp , int ut , int ns ) ;
size_t nstrftime(char *s , size_t maxsize , char const *format , struct tm const *tp ,
                 int ut , int ns ) ;
int mem_cd_iconv(char const *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) ;
char *str_cd_iconv(char const *src , iconv_t cd ) ;
char *str_iconv(char const *src , char const *from_codeset , char const *to_codeset ) ;
size_t strnlen1(char const *string , size_t maxlen ) ;
__inline static _Bool __attribute__((__pure__)) check_x_suffix(char const *s ,
                                                                size_t len ) ;
int gen_tempname_len(char *tmpl , int suffixlen , int flags , int kind , size_t x_suffix_len ) ;
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) ;
__inline static void mbiter_multi_next(struct mbiter_multi *iter ) ;
char *trim2(char const *s , int how ) ;
__inline static int u8_uctomb(uint8_t *s , ucs4_t uc , int n ) ;
long unicode_to_mb(unsigned int code , long (*success)(char const *buf , size_t buflen ,
                                                       void *callback_arg ) , long (*failure)(unsigned int code ,
                                                                                              char const *msg ,
                                                                                              void *callback_arg ) ,
                   void *callback_arg ) ;
long fwrite_success_callback(char const *buf___1 , size_t buflen , void *callback_arg ) ;
static long exit_failure_callback(unsigned int code , char const *msg , void *callback_arg __attribute__((__unused__)) ) ;
static long fallback_failure_callback(unsigned int code , char const *msg __attribute__((__unused__)) ,
                                      void *callback_arg ) ;
void print_unicode_char(FILE *stream , unsigned int code , int exit_on_error ) ;
int dup_safer(int fd ) ;
int fd_safer(int fd ) ;
int pipe_safer(int *fd ) ;
int u8_mbtoucr(ucs4_t *puc , uint8_t const *s , size_t n ) ;
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) ;
__inline static int streq9(char const *s1 , char const *s2 ) ;
__inline static int streq8(char const *s1 , char const *s2 , char s28 ) ;
__inline static int streq7(char const *s1 , char const *s2 , char s27 , char s28 ) ;
__inline static int streq6(char const *s1 , char const *s2 , char s26 , char s27 ,
                           char s28 ) ;
__inline static int streq5(char const *s1 , char const *s2 , char s25 , char s26 ,
                           char s27 , char s28 ) ;
__inline static int streq4(char const *s1 , char const *s2 , char s24 , char s25 ,
                           char s26 , char s27 , char s28 ) ;
__inline static int streq3(char const *s1 , char const *s2 , char s23 , char s24 ,
                           char s25 , char s26 , char s27 , char s28 ) ;
__inline static int streq2(char const *s1 , char const *s2 , char s22 , char s23 ,
                           char s24 , char s25 , char s26 , char s27 , char s28 ) ;
__inline static int streq1(char const *s1 , char const *s2 , char s21 , char s22 ,
                           char s23 , char s24 , char s25 , char s26 , char s27 ,
                           char s28 ) ;
__inline static int streq0(char const *s1 , char const *s2 , char s20 , char s21 ,
                           char s22 , char s23 , char s24 , char s25 , char s26 ,
                           char s27 , char s28 ) ;
static int is_cjk_encoding(char const *encoding ) ;
int uc_width(ucs4_t uc , char const *encoding ) ;
static char const *parse_with_separator(char const *spec , char const *separator ,
                                          uid_t *uid , gid_t *gid , char **username ,
                                          char **groupname ) ;
char const *parse_user_spec(char const *spec , uid_t *uid , gid_t *gid , char **username ,
                              char **groupname ) ;
__inline static long get_stat_atime_ns(struct stat const *st ) ;
__inline static long get_stat_ctime_ns(struct stat const *st ) ;
__inline static long get_stat_mtime_ns(struct stat const *st ) ;
static size_t dev_info_hash(void const *x , size_t table_size ) ;
static _Bool dev_info_compare(void const *x , void const *y ) ;
int utimecmp(char const *dst_name , struct stat const *dst_stat , struct stat const *src_stat ,
             int options ) ;
__inline static struct timespec get_stat_atime(struct stat const *st ) ;
__inline static struct timespec get_stat_mtime(struct stat const *st ) ;
static int validate_timespec(struct timespec *timespec ) ;
static _Bool update_timespec(struct stat const *statbuf , struct timespec **ts ) ;
int fdutimens(int fd , char const *file , struct timespec const *timespec ) ;
int utimens(char const *file , struct timespec const *timespec ) ;
int lutimens(char const *file , struct timespec const *timespec ) ;
void verror(int status , int errnum , char const *format , va_list args ) ;
void verror_at_line(int status , int errnum , char const *file , unsigned int line_number ,
                    char const *format , va_list args ) ;
void version_etc_arn(FILE *stream , char const *command_name , char const *package ,
                     char const *version , char const **authors , size_t n_authors ) ;
void version_etc_ar(FILE *stream , char const *command_name , char const *package ,
                    char const *version , char const **authors ) ;
void version_etc_va(FILE *stream , char const *command_name , char const *package ,
                    char const *version , va_list authors ) ;
void version_etc(FILE *stream , char const *command_name , char const *package ,
                 char const *version , ...) __attribute__((__sentinel__)) ;
void emit_bug_reporting_address(void) ;
_Bool can_write_any_file(void) ;
void *xmalloc(size_t n ) __attribute__((__malloc__, __alloc_size__(1))) ;
void *xrealloc(void *p , size_t n ) __attribute__((__alloc_size__(2))) ;
void *x2realloc(void *p , size_t *pn ) ;
void *xzalloc(size_t s ) __attribute__((__malloc__, __alloc_size__(1))) ;
void *xcalloc(size_t n , size_t s ) __attribute__((__malloc__, __alloc_size__(1,2))) ;
void *xmemdup(void const *p , size_t s ) __attribute__((__malloc__, __alloc_size__(2))) ;
char *xstrdup(char const *string ) __attribute__((__malloc__)) ;
void xalloc_die(void) __attribute__((__noreturn__)) ;
void xfreopen(char const *filename , char const *mode , FILE *fp ) ;
char *xgetcwd(void) ;
int xgetgroups(char const *username , gid_t gid , gid_t **groups ) ;
char *xgethostname(void) ;
static void collate_error(int collation_errno , char const *s1 , size_t s1len ,
                          char const *s2 , size_t s2len ) ;
int xmemcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) ;
int xmemcoll0(char const *s1 , size_t s1size , char const *s2 , size_t s2size ) ;
int xnanosleep(double seconds ) ;
int xprintf(char const *format , ...) ;
int xvprintf(char const *format , va_list args ) ;
int xfprintf(FILE *stream , char const *format , ...) ;
int xvfprintf(FILE *stream , char const *format , va_list args ) ;
char *xreadlink(char const *filename ) ;
int xmem_cd_iconv(char const *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) ;
char *xstr_cd_iconv(char const *src , iconv_t cd ) ;
char *xstr_iconv(char const *src , char const *from_codeset , char const *to_codeset ) ;
char *xstrndup(char const *string , size_t n ) ;
_Bool xstrtod(char const *str , char const **ptr , double *result , double (*convert)(char const * ,
                                                                                          char ** ) ) ;
static strtol_error bkm_scale(intmax_t *x , int scale_factor ) ;
static strtol_error bkm_scale_by_power(intmax_t *x , int base , int power ) ;
strtol_error xstrtoimax(char const *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const *valid_suffixes ) ;
static strtol_error bkm_scale___0(long *x , int scale_factor ) ;
static strtol_error bkm_scale_by_power___0(long *x , int base , int power ) ;
strtol_error xstrtol(char const *s , char **ptr , int strtol_base , long *val ,
                     char const *valid_suffixes ) ;
static strtol_error bkm_scale___1(unsigned long *x , int scale_factor ) ;
static strtol_error bkm_scale_by_power___1(unsigned long *x , int base , int power ) ;
strtol_error xstrtoul(char const *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const *valid_suffixes ) ;
static void xstrtol_error(enum strtol_error err , int opt_idx , char c , struct rpl_option const *long_options___0 ,
                          char const *arg , int exit_status ) ;
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct rpl_option const *long_options___0 ,
                   char const *arg ) __attribute__((__noreturn__)) ;
_Bool xstrtold(char const *str , char const **ptr , long double *result , long double (*convert)(char const * ,
                                                                                                     char ** ) ) ;
static strtol_error bkm_scale___2(uintmax_t *x , int scale_factor ) ;
static strtol_error bkm_scale_by_power___2(uintmax_t *x , int base , int power ) ;
strtol_error xstrtoumax(char const *s , char **ptr , int strtol_base , uintmax_t *val ,
                        char const *valid_suffixes ) ;
__inline static size_t __attribute__((__pure__)) xsum(size_t size1 , size_t size2 ) ;
__inline static char *xstrcat(size_t argcount , va_list args ) ;
char *xvasprintf(char const *format , va_list args ) ;
char *xasprintf(char const *format , ...) ;
_Bool yesno(void) ;
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max ) __attribute__((__const__)) ;
char *asnprintf(char *resultbuf , size_t *lengthp , char const *format , ...) ;
int ( __attribute__((__nonnull__(1,2))) rpl_asprintf)(char **resultp , char const *format
                                                      , ...) ;
__inline static void cdb_init(struct cd_buf *cdb ) ;
__inline static int cdb_fchdir(struct cd_buf const *cdb ) ;
__inline static void cdb_free(struct cd_buf const *cdb ) ;
static int cdb_advance_fd(struct cd_buf *cdb , char const *dir ) ;
__inline static char *find_non_slash(char const *s ) ;
int chdir_long(char *dir ) ;
int ( __attribute__((__nonnull__(1))) rpl_fclose)(FILE *fp ) ;
int rpl_fcntl(int fd , int action , ...) ;
__inline static void clear_ungetc_buffer_preserving_position(FILE *fp ) ;
int rpl_fflush(FILE *stream ) ;
int ( __attribute__((__nonnull__(1))) fpurge)(FILE *fp ) ;
int ( __attribute__((__nonnull__(1))) rpl_fseek)(FILE *fp , long offset , int whence ) ;
int ( __attribute__((__nonnull__(1))) rpl_fseeko)(FILE *fp , off_t offset , int whence ) ;
int get_fs_usage(char const *file , char const *disk , struct fs_usage *fsp ) ;
static _Bool AD_compare(void const *x , void const *y ) ;
static size_t AD_hash(void const *x , size_t table_size ) ;
static _Bool setup_dir(FTS *fts ) ;
static _Bool enter_dir(FTS *fts , FTSENT *ent ) ;
static void leave_dir(FTS *fts , FTSENT *ent ) ;
static void free_dir(FTS *sp ) ;
static void fd_ring_clear(I_ring *fd_ring ) ;
static void fts_set_stat_required(FTSENT *p , _Bool required ) ;
__inline static DIR *opendirat(int fd , char const *dir , int extra_flags , int *pdir_fd ) ;
static void cwd_advance_fd(FTS *sp , int fd , _Bool chdir_down_one ) ;
__inline static int diropen(FTS const *sp , char const *dir ) ;
FTS *( __attribute__((__warn_unused_result__)) fts_open)(char **argv , int options ,
                                                         int (*compar)(FTSENT const ** ,
                                                                       FTSENT const ** ) ) __attribute__((__nothrow__)) ;
static void fts_load(FTS *sp , FTSENT *p ) ;
int ( __attribute__((__warn_unused_result__)) fts_close)(FTS *sp ) __attribute__((__nothrow__)) ;
static _Bool dirent_inode_sort_may_be_useful(int dir_fd ) ;
static _Bool leaf_optimization_applies(int dir_fd ) ;
static size_t LCO_hash(void const *x , size_t table_size ) ;
static _Bool LCO_compare(void const *x , void const *y ) ;
static _Bool link_count_optimize_ok(FTSENT const *p ) ;
FTSENT *( __attribute__((__warn_unused_result__)) fts_read)(FTS *sp ) __attribute__((__nothrow__)) ;
int fts_set(FTS *sp __attribute__((__unused__)) , FTSENT *p , int instr ) __attribute__((__nothrow__)) ;
FTSENT *( __attribute__((__warn_unused_result__)) fts_children)(FTS *sp , int instr ) __attribute__((__nothrow__)) ;
static int fts_compare_ino(struct _ftsent const **a , struct _ftsent const **b ) ;
static void set_stat_type(struct stat *st , unsigned int dtype ) ;
static FTSENT *fts_build(FTS *sp , int type ) ;
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) ;
static int fts_compar(void const *a , void const *b ) ;
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) ;
static FTSENT *fts_alloc(FTS *sp , char const *name , size_t namelen ) ;
static void fts_lfree(FTSENT *head ) ;
static _Bool fts_palloc(FTS *sp , size_t more ) ;
static void fts_padjust(FTS *sp , FTSENT *head ) ;
static size_t fts_maxarglen(char **argv ) ;
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const *dir ) ;
int rpl_futimens(int fd , struct timespec const *times ) ;
char *rpl_getcwd(char *buf___1 , size_t size ) ;
__inline static xtime_t xtime_make(xtime_t s , long ns ) ;
xtime_t gethrxtime(void) ;
static void exchange(char **argv , struct _getopt_data *d ) ;
static char const *_getopt_initialize(int argc __attribute__((__unused__)) , char **argv __attribute__((__unused__)) ,
                                        char const *optstring , struct _getopt_data *d ,
                                        int posixly_correct ) ;
int _getopt_internal_r(int argc , char **argv , char const *optstring , struct rpl_option const *longopts ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct ) ;
int rpl_getopt_internal(int argc , char **argv , char const *optstring , struct rpl_option const *longopts ,
                        int *longind , int long_only , int posixly_correct ) ;
int ( __attribute__((__nonnull__(2,3))) rpl_getopt)(int argc , char **argv , char const *optstring ) __attribute__((__nothrow__)) ;
int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long)(int argc , char **argv ,
                                                         char const *options , struct rpl_option const *long_options___0 ,
                                                         int *opt_index ) __attribute__((__nothrow__)) ;
int _getopt_long_r(int argc , char **argv , char const *options , struct rpl_option const *long_options___0 ,
                   int *opt_index , struct _getopt_data *d ) ;
int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long_only)(int argc , char **argv ,
                                                              char const *options ,
                                                              struct rpl_option const *long_options___0 ,
                                                              int *opt_index ) __attribute__((__nothrow__)) ;
int _getopt_long_only_r(int argc , char **argv , char const *options , struct rpl_option const *long_options___0 ,
                        int *opt_index , struct _getopt_data *d ) ;
static void call_fclose(void *arg ) ;
char *( __attribute__((__nonnull__(1))) gnu_getpass)(char const *prompt ) ;
int isapipe(int fd ) ;
int rpl_isnanl(long double x ) ;
static int linkat_follow(int fd1 , char const *file1 , int fd2 , char const *file2 ) ;
int ( __attribute__((__nonnull__(2,4))) rpl_linkat)(int fd1 , char const *file1 ,
                                                    int fd2 , char const *file2 ,
                                                    int flag ) ;
static dev_t dev_from_mount_options(char const *mount_options ) ;
struct mount_entry *read_file_system_list(_Bool need_fs_type ) ;
int ( __attribute__((__nonnull__(1))) rpl_nanosleep)(struct timespec const *requested_delay ,
                                                     struct timespec *remaining_delay ) ;
char *openat_proc_name(char *buf___1 , int fd , char const *file ) ;
int printf_fetchargs(va_list args , arguments *a ) ;
int printf_parse(char const *format , char_directives *d , arguments *a ) ;
char *extract_trimmed_name(STRUCT_UTMP const *ut ) ;
__inline static _Bool desirable_utmp_entry(STRUCT_UTMP const *u , int options ) ;
int read_utmp(char const *file , size_t *n_entries , STRUCT_UTMP **utmp_buf , int options ) ;
int ( __attribute__((__nonnull__(1))) rpl_remove)(char const *name ) ;
struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i ) ;
__inline static int getfilecon(char const *file __attribute__((__unused__)) , char **con __attribute__((__unused__)) ) ;
__inline static int setfilecon(char const *file __attribute__((__unused__)) , char *con __attribute__((__unused__)) ) ;
int getfileconat(int fd , char const *file , char **con ) ;
int lgetfileconat(int fd , char const *file , char **con ) ;
int setfileconat(int fd , char const *file , char *con ) ;
int lsetfileconat(int fd , char const *file , char *con ) ;
static int str2signum(char const *signame ) ;
int str2sig(char const *signame , int *signum ) ;
int sig2str(int signum , char *signame ) ;
char *rpl_strerror(int n ) ;
int ( __attribute__((__nonnull__(2))) rpl_utimensat)(int fd , char const *file ,
                                                     struct timespec const *times ,
                                                     int flag ) ;
static int local_utimensat(int fd , char const *file , struct timespec const *ts ,
                           int flag ) ;
__inline static size_t __attribute__((__pure__)) xsum4(size_t size1 , size_t size2 ,
                                                        size_t size3 , size_t size4 ) ;
__inline static size_t __attribute__((__pure__)) xmax(size_t size1 , size_t size2 ) ;
__inline extern int __signbitl(long double __x ) __attribute__((__nothrow__, __const__)) ;
static char decimal_point_char(void) ;
static int is_infinite_or_zerol(long double x ) ;
char *vasnprintf(char *resultbuf , size_t *lengthp , char const *format , va_list args ) ;
int ( __attribute__((__nonnull__(1,2))) rpl_vasprintf)(char **resultp , char const *format ,
                                                       va_list args ) ;
int ( __attribute__((__nonnull__(1,2))) rpl_vfprintf)(FILE *fp , char const *format ,
                                                      va_list args ) ;
int ( __attribute__((__nonnull__(1))) rpl_vprintf)(char const *format , va_list args ) ;
_Bool euidaccess_stat(struct stat const *st , int mode ) ;
int fd_reopen(int desired_fd , char const *file , int flags , mode_t mode ) ;
FTS *xfts_open(char **argv , int options , int (*compar)(FTSENT const ** , FTSENT const ** ) ) ;
_Bool cycle_warning_required(FTS const *fts , FTSENT const *ent ) __attribute__((__pure__)) ;
__inline static int __attribute__((__pure__)) fraccompare(char const *a , char const *b ,
                                                           char decimal_point ) ;
__inline static int __attribute__((__pure__)) numcompare(char const *a , char const *b ,
                                                          int decimal_point , int thousands_sep ) ;
int strintcmp(char const *a , char const *b ) __attribute__((__pure__)) ;
int __attribute__((__pure__)) strnumcmp(char const *a , char const *b , int decimal_point ,
                                         int thousands_sep ) ;
__inline static void initialize_exit_failure(int status ) ;
__inline static void emit_ancillary_info(void) ;
void usage(int status ) __attribute__((__noreturn__)) ;
int main(int argc , char **argv ) ;
void ( __attribute__((__nonnull__(1,4))) qsort)(void *ptr , size_t count , size_t size ,
                                                int (*comp)(void const * , void const * ) );
void *bsearch(void const *key , void const *ptr , size_t count , size_t size ,
              int (*comp)(void const * , void const * ) );
extern int ( __attribute__((__leaf__)) __sched_cpucount)(size_t __setsize , cpu_set_t const *__setp ) __attribute__((__nothrow__)) ;
extern cpu_set_t *( __attribute__((__leaf__)) __sched_cpualloc)(size_t __count ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) __sched_cpufree)(cpu_set_t *__set ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_setparam)(__pid_t __pid , struct sched_param const *__param ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_getparam)(__pid_t __pid , struct sched_param *__param ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_setscheduler)(__pid_t __pid , int __policy ,
                                                           struct sched_param const *__param ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_getscheduler)(__pid_t __pid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_yield)(void) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_get_priority_max)(int __algorithm ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_get_priority_min)(int __algorithm ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_rr_get_interval)(__pid_t __pid , struct timespec *__t ) __attribute__((__nothrow__)) ;
extern char *__tzname[2] ;
extern int __daylight ;
extern long __timezone ;
extern char *tzname[2] ;
extern void ( __attribute__((__leaf__)) tzset)(void) __attribute__((__nothrow__)) ;
extern int daylight ;
extern long timezone ;
extern time_t ( __attribute__((__leaf__)) timegm)(struct tm *__tp ) __attribute__((__nothrow__)) ;
extern time_t ( __attribute__((__leaf__)) timelocal)(struct tm *__tp ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) dysize)(int __year ) __attribute__((__nothrow__,
__const__)) ;
extern int nanosleep(struct timespec const *__requested_time , struct timespec *__remaining ) ;
extern int ( __attribute__((__leaf__)) clock_getres)(clockid_t __clock_id , struct timespec *__res ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id , struct timespec *__tp ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) clock_settime)(clockid_t __clock_id , struct timespec const *__tp ) __attribute__((__nothrow__)) ;
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec const *__req ,
                           struct timespec *__rem ) ;
extern int ( __attribute__((__leaf__)) clock_getcpuclockid)(pid_t __pid , clockid_t *__clock_id ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) timer_create)(clockid_t __clock_id , struct sigevent * __restrict __evp ,
                                                     timer_t * __restrict __timerid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) timer_delete)(timer_t __timerid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) timer_settime)(timer_t __timerid , int __flags ,
                                                      struct itimerspec const * __restrict __value ,
                                                      struct itimerspec * __restrict __ovalue ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) timer_gettime)(timer_t __timerid , struct itimerspec *__value ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) timer_getoverrun)(timer_t __timerid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict __newthread ,
                                                               pthread_attr_t const * __restrict __attr ,
                                                               void *(*__start_routine)(void * ) ,
                                                               void * __restrict __arg ) __attribute__((__nothrow__)) ;
extern void pthread_exit(void *__retval ) __attribute__((__noreturn__)) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern int ( __attribute__((__leaf__)) pthread_detach)(pthread_t __th ) __attribute__((__nothrow__)) ;
extern pthread_t ( __attribute__((__leaf__)) pthread_self)(void) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 , pthread_t __thread2 ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_init)(pthread_attr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_destroy)(pthread_attr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getdetachstate)(pthread_attr_t const *__attr ,
                                                                                      int *__detachstate ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setdetachstate)(pthread_attr_t *__attr ,
                                                                                    int __detachstate ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getguardsize)(pthread_attr_t const *__attr ,
                                                                                    size_t *__guardsize ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setguardsize)(pthread_attr_t *__attr ,
                                                                                  size_t __guardsize ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getschedparam)(pthread_attr_t const * __restrict __attr ,
                                                                                     struct sched_param * __restrict __param ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_setschedparam)(pthread_attr_t * __restrict __attr ,
                                                                                     struct sched_param const * __restrict __param ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getschedpolicy)(pthread_attr_t const * __restrict __attr ,
                                                                                      int * __restrict __policy ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setschedpolicy)(pthread_attr_t *__attr ,
                                                                                    int __policy ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getinheritsched)(pthread_attr_t const * __restrict __attr ,
                                                                                       int * __restrict __inherit ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setinheritsched)(pthread_attr_t *__attr ,
                                                                                     int __inherit ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getscope)(pthread_attr_t const * __restrict __attr ,
                                                                                int * __restrict __scope ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setscope)(pthread_attr_t *__attr ,
                                                                              int __scope ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getstackaddr)(pthread_attr_t const * __restrict __attr ,
                                                                                    void ** __restrict __stackaddr ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstackaddr)(pthread_attr_t *__attr ,
                                                                                  void *__stackaddr ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getstacksize)(pthread_attr_t const * __restrict __attr ,
                                                                                    size_t * __restrict __stacksize ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstacksize)(pthread_attr_t *__attr ,
                                                                                  size_t __stacksize ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) pthread_attr_getstack)(pthread_attr_t const * __restrict __attr ,
                                                                                  void ** __restrict __stackaddr ,
                                                                                  size_t * __restrict __stacksize ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstack)(pthread_attr_t *__attr ,
                                                                              void *__stackaddr ,
                                                                              size_t __stacksize ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3), __leaf__)) pthread_setschedparam)(pthread_t __target_thread ,
                                                                              int __policy ,
                                                                              struct sched_param const *__param ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) pthread_getschedparam)(pthread_t __target_thread ,
                                                                                int * __restrict __policy ,
                                                                                struct sched_param * __restrict __param ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pthread_setschedprio)(pthread_t __target_thread ,
                                                             int __prio ) __attribute__((__nothrow__)) ;
int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *once_control ,
                                                      void (*init_routine)(void) );
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
extern int pthread_cancel(pthread_t __th ) ;
extern void pthread_testcancel(void) ;
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf ) __attribute__((__weak__,
__noreturn__)) ;
extern int __sigsetjmp_cancel(struct __cancel_jmp_buf_tag *__env , int __savemask ) __asm__("__sigsetjmp") __attribute__((__returns_twice__,
__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                           pthread_mutexattr_t const *__mutexattr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_trylock)(pthread_mutex_t *__mutex ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_mutex_timedlock)(pthread_mutex_t * __restrict __mutex ,
                                                                        struct timespec const * __restrict __abstime ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutex_getprioceiling)(pthread_mutex_t const * __restrict __mutex ,
                                                                                       int * __restrict __prioceiling ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,3), __leaf__)) pthread_mutex_setprioceiling)(pthread_mutex_t * __restrict __mutex ,
                                                                                       int __prioceiling ,
                                                                                       int * __restrict __old_ceiling ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_consistent)(pthread_mutex_t *__mutex ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_init)(pthread_mutexattr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_destroy)(pthread_mutexattr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getpshared)(pthread_mutexattr_t const * __restrict __attr ,
                                                                                       int * __restrict __pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setpshared)(pthread_mutexattr_t *__attr ,
                                                                                     int __pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_gettype)(pthread_mutexattr_t const * __restrict __attr ,
                                                                                    int * __restrict __kind ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_settype)(pthread_mutexattr_t *__attr ,
                                                                                  int __kind ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getprotocol)(pthread_mutexattr_t const * __restrict __attr ,
                                                                                        int * __restrict __protocol ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setprotocol)(pthread_mutexattr_t *__attr ,
                                                                                      int __protocol ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getprioceiling)(pthread_mutexattr_t const * __restrict __attr ,
                                                                                           int * __restrict __prioceiling ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setprioceiling)(pthread_mutexattr_t *__attr ,
                                                                                         int __prioceiling ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getrobust)(pthread_mutexattr_t const *__attr ,
                                                                                      int *__robustness ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setrobust)(pthread_mutexattr_t *__attr ,
                                                                                    int __robustness ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlock_init)(pthread_rwlock_t * __restrict __rwlock ,
                                                                            pthread_rwlockattr_t const * __restrict __attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlock_destroy)(pthread_rwlock_t *__rwlock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_rdlock)(pthread_rwlock_t *__rwlock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_tryrdlock)(pthread_rwlock_t *__rwlock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_rwlock_timedrdlock)(pthread_rwlock_t * __restrict __rwlock ,
                                                                           struct timespec const * __restrict __abstime ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_wrlock)(pthread_rwlock_t *__rwlock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_trywrlock)(pthread_rwlock_t *__rwlock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_rwlock_timedwrlock)(pthread_rwlock_t * __restrict __rwlock ,
                                                                           struct timespec const * __restrict __abstime ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_unlock)(pthread_rwlock_t *__rwlock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_init)(pthread_rwlockattr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_destroy)(pthread_rwlockattr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_rwlockattr_getpshared)(pthread_rwlockattr_t const * __restrict __attr ,
                                                                                        int * __restrict __pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_setpshared)(pthread_rwlockattr_t *__attr ,
                                                                                      int __pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_rwlockattr_getkind_np)(pthread_rwlockattr_t const * __restrict __attr ,
                                                                                        int * __restrict __pref ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_setkind_np)(pthread_rwlockattr_t *__attr ,
                                                                                      int __pref ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t * __restrict __cond ,
                                                                          pthread_condattr_t const * __restrict __cond_attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_destroy)(pthread_cond_t *__cond ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict __cond ,
                                                                  pthread_mutex_t * __restrict __mutex ) ;
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t * __restrict __cond ,
                                                                         pthread_mutex_t * __restrict __mutex ,
                                                                         struct timespec const * __restrict __abstime ) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_init)(pthread_condattr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_destroy)(pthread_condattr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_condattr_getpshared)(pthread_condattr_t const * __restrict __attr ,
                                                                                      int * __restrict __pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_setpshared)(pthread_condattr_t *__attr ,
                                                                                    int __pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_condattr_getclock)(pthread_condattr_t const * __restrict __attr ,
                                                                                    __clockid_t * __restrict __clock_id ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_setclock)(pthread_condattr_t *__attr ,
                                                                                  __clockid_t __clock_id ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_spin_init)(pthread_spinlock_t *__lock ,
                                                                          int __pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_spin_destroy)(pthread_spinlock_t *__lock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_spin_lock)(pthread_spinlock_t *__lock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_spin_trylock)(pthread_spinlock_t *__lock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_spin_unlock)(pthread_spinlock_t *__lock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrier_init)(pthread_barrier_t * __restrict __barrier ,
                                                                             pthread_barrierattr_t const * __restrict __attr ,
                                                                             unsigned int __count ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrier_destroy)(pthread_barrier_t *__barrier ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_barrier_wait)(pthread_barrier_t *__barrier ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrierattr_init)(pthread_barrierattr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrierattr_destroy)(pthread_barrierattr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_barrierattr_getpshared)(pthread_barrierattr_t const * __restrict __attr ,
                                                                                         int * __restrict __pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrierattr_setpshared)(pthread_barrierattr_t *__attr ,
                                                                                       int __pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_key_create)(pthread_key_t *__key ,
                                                                           void (*__destr_function)(void * ) ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pthread_key_delete)(pthread_key_t __key ) __attribute__((__nothrow__)) ;
extern void *( __attribute__((__leaf__)) pthread_getspecific)(pthread_key_t __key ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pthread_setspecific)(pthread_key_t __key ,
                                                            void const *__pointer ) __attribute__((__nothrow__,
__access__(__none__,2))) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) pthread_getcpuclockid)(pthread_t __thread_id ,
                                                                              __clockid_t *__clock_id ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pthread_atfork)(void (*__prepare)(void) , void (*__parent)(void) ,
                                                       void (*__child)(void) ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-8ULYWCPx.i","")
#pragma merger(0,"/tmp/cil-cjMIscCZ.i","-g,-O2")
__inline extern unsigned int gnu_dev_major(unsigned long long __dev ) __attribute__((__nothrow__)) ;
__inline extern unsigned int gnu_dev_minor(unsigned long long __dev ) __attribute__((__nothrow__)) ;
__inline extern unsigned long long gnu_dev_makedev(unsigned int __major , unsigned int __minor ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1,2))) stat)(char const *__path ,
                                                              struct stat *__statbuf ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2))) fstat)(int __fd , struct stat *__statbuf ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1,2))) stat64)(char const *__path ,
                                                                struct stat64 *__statbuf ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2))) fstat64)(int __fd , struct stat64 *__statbuf ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2,3))) fstatat)(int __fd , char const *__filename ,
                                                                 struct stat *__statbuf ,
                                                                 int __flag ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2,3))) fstatat64)(int __fd , char const *__filename ,
                                                                   struct stat64 *__statbuf ,
                                                                   int __flag ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1,2))) lstat)(char const *__path ,
                                                               struct stat *__statbuf ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1,2))) lstat64)(char const *__path ,
                                                                 struct stat64 *__statbuf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) chmod)(char const *__file , __mode_t __mode ) __attribute__((__nothrow__)) ;
extern int fchmod(int __fd , __mode_t __mode ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1))) mknod)(char const *__path ,
                                                             __mode_t __mode , __dev_t __dev ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2))) mknodat)(int __fd , char const *__path ,
                                                               __mode_t __mode , __dev_t __dev ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver , int __fildes ,
                                                       struct stat *__stat_buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver , char const *__filename ,
                                                        struct stat *__stat_buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver , char const *__filename ,
                                                         struct stat *__stat_buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver , int __fildes ,
                                                           char const *__filename ,
                                                           struct stat *__stat_buf ,
                                                           int __flag ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3))) __fxstat64)(int __ver , int __fildes ,
                                                         struct stat64 *__stat_buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2,3))) __xstat64)(int __ver , char const *__filename ,
                                                          struct stat64 *__stat_buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2,3))) __lxstat64)(int __ver , char const *__filename ,
                                                           struct stat64 *__stat_buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3,4))) __fxstatat64)(int __ver , int __fildes ,
                                                             char const *__filename ,
                                                             struct stat64 *__stat_buf ,
                                                             int __flag ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver , char const *__path ,
                                                         __mode_t __mode , __dev_t *__dev ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver , int __fd ,
                                                           char const *__path ,
                                                           __mode_t __mode , __dev_t *__dev ) __attribute__((__nothrow__)) ;
int set_acl(char const *name , int desc , mode_t mode ) ;
int qset_acl(char const *name , int desc , mode_t mode ) ;
int chmod_or_fchmod(char const *name , int desc , mode_t mode ) ;
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1))) atof)(char const *__nptr ) __attribute__((__pure__,
__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) atoi)(char const *__nptr ) __attribute__((__pure__,
__nothrow__)) ;
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1))) atol)(char const *__nptr ) __attribute__((__pure__,
__nothrow__)) ;
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1))) atoll)(char const *__nptr ) __attribute__((__pure__,
__nothrow__)) ;
extern double ( __attribute__((__warn_unused_result__, __nonnull__(1))) strtod)(char const * __restrict __nptr ,
                                                                                char ** __restrict __endptr ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__warn_unused_result__, __nonnull__(1))) strtol)(char const * __restrict __nptr ,
                                                                              char ** __restrict __endptr ,
                                                                              int __base ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1))) strtoll)(char const * __restrict __nptr ,
                                                                                    char ** __restrict __endptr ,
                                                                                    int __base ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) wctomb)(char *__s ,
                                                                                                         wchar_t __wchar ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                                      char const *__src ,
                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) wcstombs)(char *__dst ,
                                                                                      wchar_t const *__src ,
                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2), __artificial__, __always_inline__)) ptsname_r)(int __fd ,
                                                                                                    char *__buf ,
                                                                                                    size_t __buflen ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__)) __realpath_chk)(char const * __restrict __name ,
                                                                       char * __restrict __resolved ,
                                                                       size_t __resolvedlen ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__)) __realpath_alias)(char const * __restrict __name ,
                                                                         char * __restrict __resolved ) __asm__("realpath") __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) realpath)(char const *__name ,
                                                                                                             char *__resolved ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2))) __ptsname_r_chk)(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2))) __ptsname_r_alias)(int __fd , char *__buf ,
                                                                size_t __buflen ) __asm__("ptsname_r") __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2))) __ptsname_r_chk_warn)(int __fd , char *__buf ,
                                                                   size_t __buflen ,
                                                                   size_t __nreal ) __asm__("__ptsname_r_chk") __attribute__((__warning__("ptsname_r called with buflen bigger than size of buf"),
__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__)) __wctomb_chk)(char *__s , wchar_t __wchar ,
                                                                   size_t __buflen ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__)) __wctomb_alias)(char *__s , wchar_t __wchar ) __asm__("wctomb") __attribute__((__nothrow__)) ;
extern size_t __mbstowcs_chk(wchar_t * __restrict __dst , char const * __restrict __src ,
                             size_t __len , size_t __dstlen ) __attribute__((__nothrow__)) ;
extern size_t __mbstowcs_alias(wchar_t * __restrict __dst , char const * __restrict __src ,
                               size_t __len ) __asm__("mbstowcs") __attribute__((__nothrow__)) ;
extern size_t __mbstowcs_chk_warn(wchar_t * __restrict __dst , char const * __restrict __src ,
                                  size_t __len , size_t __dstlen ) __asm__("__mbstowcs_chk") __attribute__((__warning__("mbstowcs called with dst buffer smaller than len * sizeof (wchar_t)"),
__nothrow__)) ;
extern size_t __wcstombs_chk(char * __restrict __dst , wchar_t const * __restrict __src ,
                             size_t __len , size_t __dstlen ) __attribute__((__nothrow__)) ;
extern size_t __wcstombs_alias(char * __restrict __dst , wchar_t const * __restrict __src ,
                               size_t __len ) __asm__("wcstombs") __attribute__((__nothrow__)) ;
extern size_t __wcstombs_chk_warn(char * __restrict __dst , wchar_t const * __restrict __src ,
                                  size_t __len , size_t __dstlen ) __asm__("__wcstombs_chk") __attribute__((__warning__("wcstombs called with dst buffer smaller than len"),
__nothrow__)) ;
extern void error(int __status , int __errnum , char const *__format , ...) ;
char const *quote(char const *name ) ;
extern int *__errno_location(void) __attribute__((__nothrow__, __const__)) ;
extern char *dcgettext(char const *__domainname , char const *__msgid , int __category ) __attribute__((__nothrow__,
__format_arg__(2))) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) memcpy)(void *__dest ,
                                                                                                     void const *__src ,
                                                                                                     size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) memmove)(void *__dest ,
                                                                                                      void const *__src ,
                                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void *( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) memset)(void *__dest ,
                                                                                                   int __ch ,
                                                                                                   size_t __len ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) strcpy)(char *__dest ,
                                                                                                     char const *__src ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) strncpy)(char *__dest ,
                                                                                                      char const *__src ,
                                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) strcat)(char *__dest ,
                                                                                                     char const *__src ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) strncat)(char *__dest ,
                                                                                                      char const *__src ,
                                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) mempcpy)(void *__dest ,
                                                                                                      void const *__src ,
                                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void ( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) bcopy)(void const *__src ,
                                                                                                   void *__dest ,
                                                                                                   size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) bzero)(void *__dest ,
                                                                                                 size_t __len ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) stpcpy)(char *__dest ,
                                                                                                     char const *__src ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) stpncpy)(char *__dest ,
                                                                                                      char const *__src ,
                                                                                                      size_t __n ) __attribute__((__nothrow__)) ;
__inline extern size_t __strcspn_c1(char const *__s , int __reject ) ;
__inline extern size_t __strcspn_c2(char const *__s , int __reject1 , int __reject2 ) ;
__inline extern size_t __strcspn_c3(char const *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) ;
__inline extern size_t __strspn_c1(char const *__s , int __accept ) ;
__inline extern size_t __strspn_c2(char const *__s , int __accept1 , int __accept2 ) ;
__inline extern size_t __strspn_c3(char const *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
__inline extern char *__strpbrk_c2(char const *__s , int __accept1 , int __accept2 ) ;
__inline extern char *__strpbrk_c3(char const *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) ;
__inline extern char *__strsep_1c(char **__s , char __reject ) ;
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) ;
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) ;
extern char *__stpncpy_chk(char *__dest , char const *__src , size_t __n , size_t __destlen ) __attribute__((__nothrow__)) ;
extern char *__stpncpy_alias(char *__dest , char const *__src , size_t __n ) __asm__("stpncpy") __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-4zEP0CVl.i","-g,-O2")
int copy_acl(char const *src_name , int source_desc , char const *dst_name , int dest_desc ,
             mode_t mode ) ;
#pragma merger(0,"/tmp/cil-otGs9Vbe.i","-g,-O2")
int file_has_acl(char const *name , struct stat const *sb ) ;
#pragma merger(0,"/tmp/cil-tq52fNIy.i","-g,-O2")
struct allocator const stdlib_allocator ;
extern void *( __attribute__((__warn_unused_result__)) malloc)(size_t __size ) __attribute__((__nothrow__,
__malloc__)) ;
extern void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr , size_t __size ) __attribute__((__nothrow__)) ;
extern void free(void *__ptr ) __attribute__((__nothrow__)) ;
struct allocator const stdlib_allocator = {(void *(*)(size_t ))(& malloc), (void *(*)(void * , size_t ))(& realloc), & free,
    (void (*)(size_t ))((void *)0)};
#pragma merger(0,"/tmp/cil-SWXekWD4.i","-g,-O2")
char *areadlink(char const *filename ) ;
extern int open(char const *__path , int __oflag, ...) ;
extern int open64(char const *__path ,int __oflag, ...) ;
extern int openat(int __fd ,char const *__path ,int __oflag, ...) ;
extern int openat64(int __fd ,char const *__path ,int __oflag, ...) ;
extern int ( __attribute__((__nonnull__(1))) __open_2)(char const *__path , int __oflag ) ;
extern int ( __attribute__((__nonnull__(1))) __open_alias)(char const *__path ,
                                                           int __oflag , ...) __asm__("open") ;
extern int ( __attribute__((__nonnull__(1))) __open64_2)(char const *__path , int __oflag ) ;
extern int ( __attribute__((__nonnull__(1))) __open64_alias)(char const *__path ,
                                                             int __oflag , ...) __asm__("open64") ;
extern void __open64_too_many_args(void) __attribute__((__error__("open64 can be called either with 2 or 3 arguments, not more"))) ;
extern int ( __attribute__((__nonnull__(2))) __openat_2)(int __fd , char const *__path ,
                                                         int __oflag ) ;
extern int ( __attribute__((__nonnull__(2))) __openat_alias)(int __fd , char const *__path ,
                                                             int __oflag , ...) __asm__("openat") ;
extern int ( __attribute__((__nonnull__(2))) __openat64_2)(int __fd , char const *__path ,
                                                           int __oflag ) ;
extern int ( __attribute__((__nonnull__(2))) __openat64_alias)(int __fd , char const *__path ,
                                                               int __oflag , ...) __asm__("openat64") ;
extern void __openat64_too_many_args(void) __attribute__((__error__("openat64 can be called either with 3 or 4 arguments, not more"))) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) read)(int __fd ,
                                                                                                           void *__buf ,
                                                                                                           size_t __nbytes ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) pread)(int __fd ,
                                                                                                            void *__buf ,
                                                                                                            size_t __nbytes ,
                                                                                                            __off_t __offset ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) pread64)(int __fd ,
                                                                                                              void *__buf ,
                                                                                                              size_t __nbytes ,
                                                                                                              __off64_t __offset ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) getcwd)(char *__buf ,
                                                                                                           size_t __size ) __attribute__((__nothrow__)) ;
__inline extern char __attribute__((__deprecated__)) *( __attribute__((__warn_unused_result__,
__nonnull__(1), __artificial__, __always_inline__)) getwd)(char *__buf ) __attribute__((__nothrow__,
__deprecated__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) confstr)(int __name ,
                                                                                     char *__buf ,
                                                                                     size_t __len ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) getgroups)(int __size ,
                                                                                                            __gid_t *__list ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __artificial__,
__always_inline__)) ttyname_r)(int __fd , char *__buf , size_t __buflen ) __attribute__((__nothrow__)) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__artificial__, __always_inline__)) readlink)(char const *__path , char *__buf ,
                                              size_t __len ) __attribute__((__nothrow__)) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__artificial__, __always_inline__)) readlinkat)(int __fd , char const *__path ,
                                                char *__buf , size_t __len ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) getlogin_r)(char *__buf ,
                                                                                                     size_t __buflen ) ;
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) gethostname)(char *__buf ,
                                                                                                      size_t __buflen ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __artificial__,
__always_inline__)) getdomainname)(char *__buf , size_t __buflen ) __attribute__((__nothrow__)) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk)(int __fd , void *__buf ,
                                                                     size_t __nbytes ,
                                                                     size_t __buflen ) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_alias)(int __fd ,
                                                                       void *__buf ,
                                                                       size_t __nbytes ) __asm__("read") ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk_warn)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          size_t __buflen ) __asm__("__read_chk") __attribute__((__warning__("read called with bigger length than size of the destination buffer"))) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_chk)(int __fd , void *__buf ,
                                                                      size_t __nbytes ,
                                                                      __off_t __offset ,
                                                                      size_t __bufsize ) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_chk)(int __fd ,
                                                                        void *__buf ,
                                                                        size_t __nbytes ,
                                                                        __off64_t __offset ,
                                                                        size_t __bufsize ) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_alias)(int __fd ,
                                                                        void *__buf ,
                                                                        size_t __nbytes ,
                                                                        __off_t __offset ) __asm__("pread") ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_alias)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          __off64_t __offset ) __asm__("pread64") ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_chk_warn)(int __fd ,
                                                                           void *__buf ,
                                                                           size_t __nbytes ,
                                                                           __off_t __offset ,
                                                                           size_t __bufsize ) __asm__("__pread_chk") __attribute__((__warning__("pread called with bigger length than size of the destination buffer"))) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_chk_warn)(int __fd ,
                                                                             void *__buf ,
                                                                             size_t __nbytes ,
                                                                             __off64_t __offset ,
                                                                             size_t __bufsize ) __asm__("__pread64_chk") __attribute__((__warning__("pread64 called with bigger length than size of the destination buffer"))) ;
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2))) __readlink_chk)(char const * __restrict __path ,
                                                                                           char * __restrict __buf ,
                                                                                           size_t __len ,
                                                                                           size_t __buflen ) __attribute__((__nothrow__)) ;
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2))) __readlink_alias)(char const * __restrict __path ,
                                                                                             char * __restrict __buf ,
                                                                                             size_t __len ) __asm__("readlink") __attribute__((__nothrow__)) ;
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2))) __readlink_chk_warn)(char const * __restrict __path ,
                                                                                                char * __restrict __buf ,
                                                                                                size_t __len ,
                                                                                                size_t __buflen ) __asm__("__readlink_chk") __attribute__((__warning__("readlink called with bigger length than size of destination buffer"),
__nothrow__)) ;
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3))) __readlinkat_chk)(int __fd ,
                                                                                             char const * __restrict __path ,
                                                                                             char * __restrict __buf ,
                                                                                             size_t __len ,
                                                                                             size_t __buflen ) __attribute__((__nothrow__)) ;
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3))) __readlinkat_alias)(int __fd ,
                                                                                               char const * __restrict __path ,
                                                                                               char * __restrict __buf ,
                                                                                               size_t __len ) __asm__("readlinkat") __attribute__((__nothrow__)) ;
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3))) __readlinkat_chk_warn)(int __fd ,
                                                                                                  char const * __restrict __path ,
                                                                                                  char * __restrict __buf ,
                                                                                                  size_t __len ,
                                                                                                  size_t __buflen ) __asm__("__readlinkat_chk") __attribute__((__warning__("readlinkat called with bigger length than size of destination buffer"),
__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__)) __getcwd_chk)(char *__buf ,
                                                                     size_t __size ,
                                                                     size_t __buflen ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__)) __getcwd_alias)(char *__buf ,
                                                                       size_t __size ) __asm__("getcwd") __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__)) __getcwd_chk_warn)(char *__buf ,
                                                                          size_t __size ,
                                                                          size_t __buflen ) __asm__("__getcwd_chk") __attribute__((__warning__("getcwd caller with bigger length than size of destination buffer"),
__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1))) __getwd_chk)(char *__buf ,
                                                                                    size_t buflen ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1))) __getwd_warn)(char *__buf ) __asm__("getwd") __attribute__((__warning__("please use getcwd instead, as getwd doesn\'t specify buffer size"),
__nothrow__)) ;
extern size_t __confstr_chk(int __name , char *__buf , size_t __len , size_t __buflen ) __attribute__((__nothrow__)) ;
extern size_t __confstr_alias(int __name , char *__buf , size_t __len ) __asm__("confstr") __attribute__((__nothrow__)) ;
extern size_t __confstr_chk_warn(int __name , char *__buf , size_t __len , size_t __buflen ) __asm__("__confstr_chk") __attribute__((__warning__("confstr called with bigger length than size of destination buffer"),
__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__)) __getgroups_chk)(int __size ,
                                                                      __gid_t *__list ,
                                                                      size_t __listlen ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__)) __getgroups_alias)(int __size ,
                                                                        __gid_t *__list ) __asm__("getgroups") __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__)) __getgroups_chk_warn)(int __size ,
                                                                           __gid_t *__list ,
                                                                           size_t __listlen ) __asm__("__getgroups_chk") __attribute__((__warning__("getgroups called with bigger group count than what can fit into destination buffer"),
__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2))) __ttyname_r_chk)(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2))) __ttyname_r_alias)(int __fd , char *__buf ,
                                                                size_t __buflen ) __asm__("ttyname_r") __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2))) __ttyname_r_chk_warn)(int __fd , char *__buf ,
                                                                   size_t __buflen ,
                                                                   size_t __nreal ) __asm__("__ttyname_r_chk") __attribute__((__warning__("ttyname_r called with bigger buflen than size of destination buffer"),
__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk)(char *__buf , size_t __buflen ,
                                                               size_t __nreal ) ;
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_alias)(char *__buf , size_t __buflen ) __asm__("getlogin_r") ;
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk_warn)(char *__buf ,
                                                                    size_t __buflen ,
                                                                    size_t __nreal ) __asm__("__getlogin_r_chk") __attribute__((__warning__("getlogin_r called with bigger buflen than size of destination buffer"))) ;
extern int ( __attribute__((__nonnull__(1))) __gethostname_chk)(char *__buf , size_t __buflen ,
                                                                size_t __nreal ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) __gethostname_alias)(char *__buf , size_t __buflen ) __asm__("gethostname") __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) __gethostname_chk_warn)(char *__buf ,
                                                                     size_t __buflen ,
                                                                     size_t __nreal ) __asm__("__gethostname_chk") __attribute__((__warning__("gethostname called with bigger buflen than size of destination buffer"),
__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) __getdomainname_chk)(char *__buf ,
                                                                                          size_t __buflen ,
                                                                                          size_t __nreal ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) __getdomainname_alias)(char *__buf ,
                                                                                            size_t __buflen ) __asm__("getdomainname") __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) __getdomainname_chk_warn)(char *__buf ,
                                                                                               size_t __buflen ,
                                                                                               size_t __nreal ) __asm__("__getdomainname_chk") __attribute__((__warning__("getdomainname called with bigger buflen than size of destination buffer"),
__nothrow__)) ;
char *careadlinkat(int fd , char const *filename , char *buffer , size_t buffer_size ,
                   struct allocator const *alloc , ssize_t (*preadlinkat)(int ,
                                                                            char const * ,
                                                                            char * ,
                                                                            size_t ) ) ;
ssize_t careadlinkatcwd(int fd , char const *filename , char *buffer , size_t buffer_size ) ;
#pragma merger(0,"/tmp/cil-kDu7uLPM.i","-g,-O2")
char *areadlink_with_size(char const *file , size_t size ) ;
#pragma merger(0,"/tmp/cil-oseHcCTq.i","-g,-O2")
char *areadlinkat(int fd , char const *filename ) ;
#pragma merger(0,"/tmp/cil-AKmgpeKh.i","-g,-O2")
ptrdiff_t argmatch(char const *arg , char const **arglist , char const *vallist ,
                   size_t valsize ) ;
void (*argmatch_die)(void) ;
void argmatch_invalid(char const *context , char const *value , ptrdiff_t problem ) ;
void argmatch_valid(char const **arglist , char const *vallist , size_t valsize ) ;
ptrdiff_t __xargmatch_internal(char const *context , char const *arg , char const **arglist ,
                               char const *vallist , size_t valsize , void (*exit_fn)(void) ) ;
char const *argmatch_to_argument(char const *value , char const **arglist ,
                                   char const *vallist , size_t valsize ) ;
extern int __uflow(_IO_FILE * ) ;
extern int __overflow(_IO_FILE * , int ) ;
extern int _IO_getc(_IO_FILE *__fp ) ;
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
extern struct _IO_FILE *stdin ;
extern struct _IO_FILE *stdout ;
extern struct _IO_FILE *stderr ;
extern int fprintf(FILE *stream,
                   const char *format, ...);

extern int printf(const char *format, ...);
extern int sprintf(char *str, char const *format, ...);
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                   char const *__fmt ,
                                                                                   __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vprintf)(char const *__fmt ,
                                                                                  __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                   char const *__fmt ,
                                                                                   __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
extern int snprintf(char *str, size_t size, const char *format, ...);
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vsnprintf)(char *__s ,
                                                                                    size_t __n ,
                                                                                    char const *__fmt ,
                                                                                    __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) vasprintf)(char **__ptr ,
                                                                                                            char const *__fmt ,
                                                                                                            __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) asprintf)(char **__ptr ,
                                                                                                           char const *__fmt
                                                                                                           , ...) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vdprintf)(int __fd ,
                                                                                   char const *__fmt ,
                                                                                   __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) dprintf)(int __fd ,
                                                                                  char const *__fmt
                                                                                  , ...) ;
__inline extern int getchar(void) ;
extern int getc_unlocked(FILE *__fp ) ;
__inline extern int getchar_unlocked(void) ;
__inline extern int fgetc_unlocked(FILE *__fp ) ;
__inline extern int putchar(int __c ) ;
__inline extern int fputc_unlocked(int __c , FILE *__stream ) ;
__inline extern int putchar_unlocked(int __c ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets)(char *__s ,
                                                                                                          int __n ,
                                                                                                          FILE *__stream ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets_unlocked)(char *__s ,
                                                                                                                   int __n ,
                                                                                                                   FILE *__stream ) ;
extern __ssize_t ( __attribute__((__warn_unused_result__)) __getdelim)(char ** __restrict __lineptr ,
                                                                       size_t * __restrict __n ,
                                                                       int __delimiter ,
                                                                       FILE * __restrict __stream ) ;
__inline extern __ssize_t ( __attribute__((__warn_unused_result__)) getline)(char **__lineptr ,
                                                                             size_t *__n ,
                                                                             FILE *__stream ) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread)(void *__ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE *__stream ) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread_unlocked)(void *__ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE *__stream ) ;
__inline extern int ( __attribute__((__warn_unused_result__)) feof_unlocked)(FILE *__stream ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__)) ferror_unlocked)(FILE *__stream ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) obstack_printf)(struct obstack *__obstack ,
                                                                                         char const *__fmt
                                                                                         , ...) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) obstack_vprintf)(struct obstack *__obstack ,
                                                                                          char const *__fmt ,
                                                                                          __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
extern int __fprintf_chk(FILE * __restrict __stream , int __flag , char const * __restrict __format
                         , ...) ;
extern int __printf_chk(int __flag , char const * __restrict __format , ...) ;
extern int __vfprintf_chk(FILE * __restrict __stream , int __flag , char const * __restrict __format ,
                          __gnuc_va_list __ap ) ;
extern int ( __attribute__((__warn_unused_result__)) __asprintf_chk)(char ** __restrict __ptr ,
                                                                     int __flag ,
                                                                     char const * __restrict __fmt
                                                                     , ...) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__)) __vasprintf_chk)(char ** __restrict __ptr ,
                                                                      int __flag ,
                                                                      char const * __restrict __fmt ,
                                                                      __gnuc_va_list __arg ) __attribute__((__nothrow__)) ;
extern int __dprintf_chk(int __fd , int __flag , char const * __restrict __fmt
                         , ...) ;
extern int __vdprintf_chk(int __fd , int __flag , char const * __restrict __fmt ,
                          __gnuc_va_list __arg ) ;
extern int __obstack_printf_chk(struct obstack * __restrict __obstack , int __flag ,
                                char const * __restrict __format , ...) __attribute__((__nothrow__)) ;
extern int __obstack_vprintf_chk(struct obstack * __restrict __obstack , int __flag ,
                                 char const * __restrict __format , __gnuc_va_list __args ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk)(char * __restrict __s ,
                                                                    size_t __size ,
                                                                    int __n , FILE * __restrict __stream ) ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_alias)(char * __restrict __s ,
                                                                      int __n , FILE * __restrict __stream ) __asm__("fgets") ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk_warn)(char * __restrict __s ,
                                                                         size_t __size ,
                                                                         int __n ,
                                                                         FILE * __restrict __stream ) __asm__("__fgets_chk") __attribute__((__warning__("fgets called with bigger size than length of destination buffer"))) ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk)(void * __restrict __ptr ,
                                                                     size_t __ptrlen ,
                                                                     size_t __size ,
                                                                     size_t __n ,
                                                                     FILE * __restrict __stream ) ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_alias)(void * __restrict __ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE * __restrict __stream ) __asm__("fread") ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk_warn)(void * __restrict __ptr ,
                                                                          size_t __ptrlen ,
                                                                          size_t __size ,
                                                                          size_t __n ,
                                                                          FILE * __restrict __stream ) __asm__("__fread_chk") __attribute__((__warning__("fread called with bigger size * nmemb than length of destination buffer"))) ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_chk)(char * __restrict __s ,
                                                                             size_t __size ,
                                                                             int __n ,
                                                                             FILE * __restrict __stream ) ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_alias)(char * __restrict __s ,
                                                                               int __n ,
                                                                               FILE * __restrict __stream ) __asm__("fgets_unlocked") ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_chk_warn)(char * __restrict __s ,
                                                                                  size_t __size ,
                                                                                  int __n ,
                                                                                  FILE * __restrict __stream ) __asm__("__fgets_unlocked_chk") __attribute__((__warning__("fgets_unlocked called with bigger size than length of destination buffer"))) ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk)(void * __restrict __ptr ,
                                                                              size_t __ptrlen ,
                                                                              size_t __size ,
                                                                              size_t __n ,
                                                                              FILE * __restrict __stream ) ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_alias)(void * __restrict __ptr ,
                                                                                size_t __size ,
                                                                                size_t __n ,
                                                                                FILE * __restrict __stream ) __asm__("fread_unlocked") ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk_warn)(void * __restrict __ptr ,
                                                                                   size_t __ptrlen ,
                                                                                   size_t __size ,
                                                                                   size_t __n ,
                                                                                   FILE * __restrict __stream ) __asm__("__fread_unlocked_chk") __attribute__((__warning__("fread_unlocked called with bigger size * nmemb than length of destination buffer"))) ;
extern int ( __attribute__((__nonnull__(1,2))) memcmp)(void const *__s1 , void const *__s2 ,
                                                       size_t __n ) __attribute__((__pure__,
__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2))) strncmp)(char const *__s1 , char const *__s2 ,
                                                        size_t __n ) __attribute__((__pure__,
__nothrow__)) ;
extern size_t ( __attribute__((__nonnull__(1))) strlen)(char const *__s ) __attribute__((__pure__,
__nothrow__)) ;
char *quotearg_n_style(int n , enum quoting_style s , char const *arg ) ;
char const *quote_n(int n , char const *name ) ;
void usage(int status ) __attribute__((__noreturn__)) ;
void (*argmatch_die)(void) = & __argmatch_die;
#pragma merger(0,"/tmp/cil-cjsl91iM.i","-g,-O2")
extern __ssize_t ( __attribute__((__warn_unused_result__)) getdelim)(char ** __restrict __lineptr ,
                                                                     size_t * __restrict __n ,
                                                                     int __delimiter ,
                                                                     FILE * __restrict __stream ) ;
extern int ( __attribute__((__warn_unused_result__)) feof)(FILE *__stream ) __attribute__((__nothrow__)) ;
struct argv_iterator *( __attribute__((__nonnull__(1))) argv_iter_init_argv)(char **argv ) ;
struct argv_iterator *( __attribute__((__nonnull__(1))) argv_iter_init_stream)(FILE *fp ) ;
char *( __attribute__((__nonnull__(1,2))) argv_iter)(struct argv_iterator *ai , enum argv_iter_err *err ) ;
size_t ( __attribute__((__nonnull__(1))) argv_iter_n_args)(struct argv_iterator const *ai ) ;
void ( __attribute__((__nonnull__(1))) argv_iter_free)(struct argv_iterator *ai ) ;
#pragma merger(0,"/tmp/cil-RXNDjJn4.i","-g,-O2")
char const *simple_backup_suffix ;
char *find_backup_file_name(char const *file , enum backup_type backup_type ) ;
enum backup_type get_version(char const *context , char const *version ) ;
enum backup_type xget_version(char const *context , char const *version ) ;
size_t base_len(char const *name ) ;
char *last_component(char const *name ) ;
void xalloc_die(void) __attribute__((__noreturn__)) ;
void *xmalloc(size_t n ) __attribute__((__malloc__, __alloc_size__(1))) ;
void *xrealloc(void *p , size_t n ) __attribute__((__alloc_size__(2))) ;
__inline static void *xnrealloc(void *p , size_t n , size_t s ) __attribute__((__alloc_size__(2,3))) ;
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1))) getenv)(char const *__name ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__nonnull__(1))) pathconf)(char const *__path , int __name ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
DIR *opendir_safer(char const *name ) ;
char const *simple_backup_suffix = (char const *)"~";
static char const *backup_args[9] =
  { (char const *)"none", (char const *)"off", (char const *)"simple", (char const *)"never",
        (char const *)"existing", (char const *)"nil", (char const *)"numbered", (char const *)"t",
        (char const *)((void *)0)};
static enum backup_type const backup_types[8] =
  { (enum backup_type const )0, (enum backup_type const )0, (enum backup_type const )1, (enum backup_type const )1,
        (enum backup_type const )2, (enum backup_type const )2, (enum backup_type const )3, (enum backup_type const )3};
#pragma merger(0,"/tmp/cil-cX6h4v4p.i","-g,-O2")
_Bool isbase64(char ch ) ;
void base64_encode(char const *in , size_t inlen , char *out , size_t outlen ) ;
size_t base64_encode_alloc(char const *in , size_t inlen , char **out ) ;
void base64_decode_ctx_init(struct base64_decode_context *ctx ) ;
_Bool base64_decode_ctx(struct base64_decode_context *ctx , char const *in , size_t inlen ,
                        char *out , size_t *outlen ) ;
_Bool base64_decode_alloc_ctx(struct base64_decode_context *ctx , char const *in ,
                              size_t inlen , char **out , size_t *outlen ) ;
extern void *( __attribute__((__nonnull__(1))) memchr)(void const *__s , int __c ,
                                                       size_t __n ) __attribute__((__pure__,
__nothrow__)) ;
static char const b64str[64] =
  { (char const )'A', (char const )'B', (char const )'C', (char const )'D',
        (char const )'E', (char const )'F', (char const )'G', (char const )'H',
        (char const )'I', (char const )'J', (char const )'K', (char const )'L',
        (char const )'M', (char const )'N', (char const )'O', (char const )'P',
        (char const )'Q', (char const )'R', (char const )'S', (char const )'T',
        (char const )'U', (char const )'V', (char const )'W', (char const )'X',
        (char const )'Y', (char const )'Z', (char const )'a', (char const )'b',
        (char const )'c', (char const )'d', (char const )'e', (char const )'f',
        (char const )'g', (char const )'h', (char const )'i', (char const )'j',
        (char const )'k', (char const )'l', (char const )'m', (char const )'n',
        (char const )'o', (char const )'p', (char const )'q', (char const )'r',
        (char const )'s', (char const )'t', (char const )'u', (char const )'v',
        (char const )'w', (char const )'x', (char const )'y', (char const )'z',
        (char const )'0', (char const )'1', (char const )'2', (char const )'3',
        (char const )'4', (char const )'5', (char const )'6', (char const )'7',
        (char const )'8', (char const )'9', (char const )'+', (char const )'/'};
static signed char const b64[256] =
  { (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )62,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )63,
        (signed char const )52, (signed char const )53, (signed char const )54, (signed char const )55,
        (signed char const )56, (signed char const )57, (signed char const )58, (signed char const )59,
        (signed char const )60, (signed char const )61, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )0, (signed char const )1, (signed char const )2,
        (signed char const )3, (signed char const )4, (signed char const )5, (signed char const )6,
        (signed char const )7, (signed char const )8, (signed char const )9, (signed char const )10,
        (signed char const )11, (signed char const )12, (signed char const )13, (signed char const )14,
        (signed char const )15, (signed char const )16, (signed char const )17, (signed char const )18,
        (signed char const )19, (signed char const )20, (signed char const )21, (signed char const )22,
        (signed char const )23, (signed char const )24, (signed char const )25, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )26, (signed char const )27, (signed char const )28,
        (signed char const )29, (signed char const )30, (signed char const )31, (signed char const )32,
        (signed char const )33, (signed char const )34, (signed char const )35, (signed char const )36,
        (signed char const )37, (signed char const )38, (signed char const )39, (signed char const )40,
        (signed char const )41, (signed char const )42, (signed char const )43, (signed char const )44,
        (signed char const )45, (signed char const )46, (signed char const )47, (signed char const )48,
        (signed char const )49, (signed char const )50, (signed char const )51, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1};
#pragma merger(0,"/tmp/cil-YBceyscx.i","-g,-O2")
_Bool c_isascii(int c ) ;
_Bool c_isalnum(int c ) ;
_Bool c_isalpha(int c ) ;
_Bool c_isblank(int c ) ;
_Bool c_iscntrl(int c ) ;
_Bool c_isdigit(int c ) ;
_Bool c_islower(int c ) ;
_Bool c_isgraph(int c ) ;
_Bool c_isprint(int c ) ;
_Bool c_ispunct(int c ) ;
_Bool c_isspace(int c ) ;
_Bool c_isupper(int c ) ;
_Bool c_isxdigit(int c ) ;
int c_tolower(int c ) ;
int c_toupper(int c ) ;
#pragma merger(0,"/tmp/cil-4RmVUeLS.i","-g,-O2")
int c_strcasecmp(char const *s1 , char const *s2 ) ;
#pragma merger(0,"/tmp/cil-4osLdqOA.i","-g,-O2")
int c_strncasecmp(char const *s1 , char const *s2 , size_t n ) ;
#pragma merger(0,"/tmp/cil-BW_QBIa7.i","-g,-O2")
double c_strtod(char const *nptr , char **endptr ) ;
extern __locale_t newlocale(int __category_mask , char const *__locale , __locale_t __base ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__warn_unused_result__, __nonnull__(1,3))) strtod_l)(char const * __restrict __nptr ,
                                                                                    char ** __restrict __endptr ,
                                                                                    __locale_t __loc ) __attribute__((__nothrow__)) ;
static locale_t volatile c_locale_cache ;
#pragma merger(0,"/tmp/cil-2g0yZ0wy.i","-g,-O2")
long double c_strtold(char const *nptr , char **endptr ) ;
extern long double ( __attribute__((__warn_unused_result__, __nonnull__(1,3))) strtold_l)(char const * __restrict __nptr ,
                                                                                          char ** __restrict __endptr ,
                                                                                          __locale_t __loc ) __attribute__((__nothrow__)) ;
static locale_t volatile c_locale_cache___0 ;
#pragma merger(0,"/tmp/cil-du72BYyE.i","-g,-O2")
char *canon_host(char const *host ) ;
char *canon_host_r(char const *host , int *cherror ) ;
char const *ch_strerror(void) ;
extern char *__strdup(char const *__string ) __attribute__((__nothrow__, __malloc__)) ;
__inline extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr , struct cmsghdr *__cmsg ) __attribute__((__nothrow__)) ;
__inline extern ssize_t ( __attribute__((__artificial__, __always_inline__)) recv)(int __fd ,
                                                                                   void *__buf ,
                                                                                   size_t __n ,
                                                                                   int __flags ) ;
__inline extern ssize_t ( __attribute__((__artificial__, __always_inline__)) recvfrom)(int __fd ,
                                                                                       void *__buf ,
                                                                                       size_t __n ,
                                                                                       int __flags ,
                                                                                       struct sockaddr *__cil_tmp14 ,
                                                                                       socklen_t *__addr_len ) ;
extern ssize_t __recv_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                          int __flags ) ;
extern ssize_t __recv_alias(int __fd , void *__buf , size_t __n , int __flags ) __asm__("recv") ;
extern ssize_t __recv_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                               int __flags ) __asm__("__recv_chk") __attribute__((__warning__("recv called with bigger length than size of destination buffer"))) ;
extern ssize_t __recvfrom_chk(int __fd , void * __restrict __buf , size_t __n , size_t __buflen ,
                              int __flags , struct sockaddr * __restrict __addr ,
                              socklen_t * __restrict __addr_len ) ;
extern ssize_t __recvfrom_alias(int __fd , void * __restrict __buf , size_t __n ,
                                int __flags , struct sockaddr * __restrict __addr ,
                                socklen_t * __restrict __addr_len ) __asm__("recvfrom") ;
extern ssize_t __recvfrom_chk_warn(int __fd , void * __restrict __buf , size_t __n ,
                                   size_t __buflen , int __flags , struct sockaddr * __restrict __addr ,
                                   socklen_t * __restrict __addr_len ) __asm__("__recvfrom_chk") __attribute__((__warning__("recvfrom called with bigger length than size of destination buffer"))) ;
extern int getaddrinfo(char const * __restrict __name , char const * __restrict __service ,
                       struct addrinfo const * __restrict __req , struct addrinfo ** __restrict __pai ) ;
extern void freeaddrinfo(struct addrinfo *__ai ) __attribute__((__nothrow__)) ;
extern char const *gai_strerror(int __ecode ) __attribute__((__nothrow__)) ;
static int last_cherror ;
static struct addrinfo hints ;
#pragma merger(0,"/tmp/cil-CM8cDkCw.i","-g,-O2")
char *canonicalize_filename_mode(char const *name , canonicalize_mode_t can_mode ) ;
extern void *__rawmemchr(void const *__s , int __c ) ;
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const *tuning ,
                                                                       size_t (*hasher)(void const * ,
                                                                                        size_t ) ,
                                                                       _Bool (*comparator)(void const * ,
                                                                                           void const * ) ,
                                                                       void (*data_freer)(void * ) ) ;
void hash_free(Hash_table *table___0 ) ;
void ( __attribute__((__nonnull__(2,3))) record_file)(Hash_table *ht___0 , char const *file ,
                                                      struct stat const *stats ) ;
_Bool seen_file(Hash_table const *ht___0 , char const *file , struct stat const *stats ) ;
size_t triple_hash(void const *x , size_t table_size ) ;
_Bool triple_compare_ino_str(void const *x , void const *y ) ;
void triple_free(void *x ) ;
char *xgetcwd(void) ;
#pragma merger(0,"/tmp/cil-2LOrzFgC.i","-g,-O2")
extern void abort(void) __attribute__((__nothrow__, __noreturn__)) ;
#pragma merger(0,"/tmp/cil-GIolek74.i","-g,-O2")
int set_cloexec_flag(int desc , _Bool value ) ;
int dup_cloexec(int fd ) ;
int rpl_fcntl(int fd , int action , ...) ;
#pragma merger(0,"/tmp/cil-LMWJr_aV.i","-g,-O2")
int ( __attribute__((__nonnull__(1))) rpl_fclose)(FILE *fp ) ;
int close_stream(FILE *stream ) ;
extern size_t __fpending(FILE *__fp ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-xGB33bni.i","-g,-O2")
void close_stdin_set_file_name(char const *file ) ;
void close_stdin(void) ;
int rpl_fflush(FILE *stream ) ;
int ( __attribute__((__nonnull__(1))) rpl_fseeko)(FILE *fp , off_t offset , int whence ) ;
extern void _exit(int __status ) __attribute__((__noreturn__)) ;
void close_stdout(void) ;
int volatile exit_failure ;
size_t freadahead(FILE *fp ) ;
char *quotearg_colon(char const *arg ) ;
static char const *file_name ;
#pragma merger(0,"/tmp/cil-7wdVAxsF.i","-g,-O2")
void close_stdout_set_file_name(char const *file ) ;
void close_stdout_set_ignore_EPIPE(_Bool ignore ) ;
static char const *file_name___0 ;
static _Bool ignore_EPIPE ;
#pragma merger(0,"/tmp/cil-F8TMknQP.i","-g,-O2")
void md5_init_ctx(struct md5_ctx *ctx ) __attribute__((__nothrow__)) ;
void md5_process_block(void const *buffer , size_t len , struct md5_ctx *ctx ) __attribute__((__nothrow__)) ;
void md5_process_bytes(void const *buffer , size_t len , struct md5_ctx *ctx ) __attribute__((__nothrow__)) ;
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) __attribute__((__nothrow__)) ;
void *md5_read_ctx(struct md5_ctx const *ctx , void *resbuf ) __attribute__((__nothrow__)) ;
int md5_stream(FILE *stream , void *resblock ) __attribute__((__nothrow__)) ;
void *md5_buffer(char const *buffer , size_t len , void *resblock ) __attribute__((__nothrow__)) ;
static unsigned char const fillbuf[64] = { (unsigned char const )128, (unsigned char const )0};
#pragma merger(0,"/tmp/cil-V2GVRCyz.i","-g,-O2")
void sha1_init_ctx(struct sha1_ctx *ctx ) ;
void sha1_process_block(void const *buffer , size_t len , struct sha1_ctx *ctx ) ;
void sha1_process_bytes(void const *buffer , size_t len , struct sha1_ctx *ctx ) ;
void *sha1_finish_ctx(struct sha1_ctx *ctx , void *resbuf ) ;
void *sha1_read_ctx(struct sha1_ctx const *ctx , void *resbuf ) ;
int sha1_stream(FILE *stream , void *resblock ) ;
void *sha1_buffer(char const *buffer , size_t len , void *resblock ) ;
static unsigned char const fillbuf___0[64] = { (unsigned char const )128, (unsigned char const )0};
#pragma merger(0,"/tmp/cil-N0C5u41g.i","-g,-O2")
void sha256_init_ctx(struct sha256_ctx *ctx ) ;
void sha224_init_ctx(struct sha256_ctx *ctx ) ;
void sha256_process_block(void const *buffer , size_t len , struct sha256_ctx *ctx ) ;
void sha256_process_bytes(void const *buffer , size_t len , struct sha256_ctx *ctx ) ;
void *sha256_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) ;
void *sha224_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) ;
void *sha256_read_ctx(struct sha256_ctx const *ctx , void *resbuf ) ;
void *sha224_read_ctx(struct sha256_ctx const *ctx , void *resbuf ) ;
int sha256_stream(FILE *stream , void *resblock ) ;
int sha224_stream(FILE *stream , void *resblock ) ;
void *sha256_buffer(char const *buffer , size_t len , void *resblock ) ;
void *sha224_buffer(char const *buffer , size_t len , void *resblock ) ;
static unsigned char const fillbuf___1[64] = { (unsigned char const )128, (unsigned char const )0};
static uint32_t const sha256_round_constants[64] =
  { (uint32_t const )1116352408UL, (uint32_t const )1899447441UL, (uint32_t const )3049323471UL, (uint32_t const )3921009573UL,
        (uint32_t const )961987163UL, (uint32_t const )1508970993UL, (uint32_t const )2453635748UL, (uint32_t const )2870763221UL,
        (uint32_t const )3624381080UL, (uint32_t const )310598401UL, (uint32_t const )607225278UL, (uint32_t const )1426881987UL,
        (uint32_t const )1925078388UL, (uint32_t const )2162078206UL, (uint32_t const )2614888103UL, (uint32_t const )3248222580UL,
        (uint32_t const )3835390401UL, (uint32_t const )4022224774UL, (uint32_t const )264347078UL, (uint32_t const )604807628UL,
        (uint32_t const )770255983UL, (uint32_t const )1249150122UL, (uint32_t const )1555081692UL, (uint32_t const )1996064986UL,
        (uint32_t const )2554220882UL, (uint32_t const )2821834349UL, (uint32_t const )2952996808UL, (uint32_t const )3210313671UL,
        (uint32_t const )3336571891UL, (uint32_t const )3584528711UL, (uint32_t const )113926993UL, (uint32_t const )338241895UL,
        (uint32_t const )666307205UL, (uint32_t const )773529912UL, (uint32_t const )1294757372UL, (uint32_t const )1396182291UL,
        (uint32_t const )1695183700UL, (uint32_t const )1986661051UL, (uint32_t const )2177026350UL, (uint32_t const )2456956037UL,
        (uint32_t const )2730485921UL, (uint32_t const )2820302411UL, (uint32_t const )3259730800UL, (uint32_t const )3345764771UL,
        (uint32_t const )3516065817UL, (uint32_t const )3600352804UL, (uint32_t const )4094571909UL, (uint32_t const )275423344UL,
        (uint32_t const )430227734UL, (uint32_t const )506948616UL, (uint32_t const )659060556UL, (uint32_t const )883997877UL,
        (uint32_t const )958139571UL, (uint32_t const )1322822218UL, (uint32_t const )1537002063UL, (uint32_t const )1747873779UL,
        (uint32_t const )1955562222UL, (uint32_t const )2024104815UL, (uint32_t const )2227730452UL, (uint32_t const )2361852424UL,
        (uint32_t const )2428436474UL, (uint32_t const )2756734187UL, (uint32_t const )3204031479UL, (uint32_t const )3329325298UL};
#pragma merger(0,"/tmp/cil-MC9W5KA8.i","-g,-O2")
void sha512_init_ctx(struct sha512_ctx *ctx ) ;
void sha384_init_ctx(struct sha512_ctx *ctx ) ;
void sha512_process_block(void const *buffer , size_t len , struct sha512_ctx *ctx ) ;
void sha512_process_bytes(void const *buffer , size_t len , struct sha512_ctx *ctx ) ;
void *sha512_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) ;
void *sha384_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) ;
void *sha512_read_ctx(struct sha512_ctx const *ctx , void *resbuf ) ;
void *sha384_read_ctx(struct sha512_ctx const *ctx , void *resbuf ) ;
int sha512_stream(FILE *stream , void *resblock ) ;
int sha384_stream(FILE *stream , void *resblock ) ;
void *sha512_buffer(char const *buffer , size_t len , void *resblock ) ;
void *sha384_buffer(char const *buffer , size_t len , void *resblock ) ;
static unsigned char const fillbuf___2[128] = { (unsigned char const )128, (unsigned char const )0};
static u64 const sha512_round_constants[80] =
  { (u64 const )((1116352408UL << 32) + 3609767458UL), (u64 const )((1899447441UL << 32) + 602891725UL), (u64 const )((3049323471UL << 32) + 3964484399UL), (u64 const )((3921009573UL << 32) + 2173295548UL),
        (u64 const )((961987163UL << 32) + 4081628472UL), (u64 const )((1508970993UL << 32) + 3053834265UL), (u64 const )((2453635748UL << 32) + 2937671579UL), (u64 const )((2870763221UL << 32) + 3664609560UL),
        (u64 const )((3624381080UL << 32) + 2734883394UL), (u64 const )((310598401UL << 32) + 1164996542UL), (u64 const )((607225278UL << 32) + 1323610764UL), (u64 const )((1426881987UL << 32) + 3590304994UL),
        (u64 const )((1925078388UL << 32) + 4068182383UL), (u64 const )((2162078206UL << 32) + 991336113UL), (u64 const )((2614888103UL << 32) + 633803317UL), (u64 const )((3248222580UL << 32) + 3479774868UL),
        (u64 const )((3835390401UL << 32) + 2666613458UL), (u64 const )((4022224774UL << 32) + 944711139UL), (u64 const )((264347078UL << 32) + 2341262773UL), (u64 const )((604807628UL << 32) + 2007800933UL),
        (u64 const )((770255983UL << 32) + 1495990901UL), (u64 const )((1249150122UL << 32) + 1856431235UL), (u64 const )((1555081692UL << 32) + 3175218132UL), (u64 const )((1996064986UL << 32) + 2198950837UL),
        (u64 const )((2554220882UL << 32) + 3999719339UL), (u64 const )((2821834349UL << 32) + 766784016UL), (u64 const )((2952996808UL << 32) + 2566594879UL), (u64 const )((3210313671UL << 32) + 3203337956UL),
        (u64 const )((3336571891UL << 32) + 1034457026UL), (u64 const )((3584528711UL << 32) + 2466948901UL), (u64 const )((113926993UL << 32) + 3758326383UL), (u64 const )((338241895UL << 32) + 168717936UL),
        (u64 const )((666307205UL << 32) + 1188179964UL), (u64 const )((773529912UL << 32) + 1546045734UL), (u64 const )((1294757372UL << 32) + 1522805485UL), (u64 const )((1396182291UL << 32) + 2643833823UL),
        (u64 const )((1695183700UL << 32) + 2343527390UL), (u64 const )((1986661051UL << 32) + 1014477480UL), (u64 const )((2177026350UL << 32) + 1206759142UL), (u64 const )((2456956037UL << 32) + 344077627UL),
        (u64 const )((2730485921UL << 32) + 1290863460UL), (u64 const )((2820302411UL << 32) + 3158454273UL), (u64 const )((3259730800UL << 32) + 3505952657UL), (u64 const )((3345764771UL << 32) + 106217008UL),
        (u64 const )((3516065817UL << 32) + 3606008344UL), (u64 const )((3600352804UL << 32) + 1432725776UL), (u64 const )((4094571909UL << 32) + 1467031594UL), (u64 const )((275423344UL << 32) + 851169720UL),
        (u64 const )((430227734UL << 32) + 3100823752UL), (u64 const )((506948616UL << 32) + 1363258195UL), (u64 const )((659060556UL << 32) + 3750685593UL), (u64 const )((883997877UL << 32) + 3785050280UL),
        (u64 const )((958139571UL << 32) + 3318307427UL), (u64 const )((1322822218UL << 32) + 3812723403UL), (u64 const )((1537002063UL << 32) + 2003034995UL), (u64 const )((1747873779UL << 32) + 3602036899UL),
        (u64 const )((1955562222UL << 32) + 1575990012UL), (u64 const )((2024104815UL << 32) + 1125592928UL), (u64 const )((2227730452UL << 32) + 2716904306UL), (u64 const )((2361852424UL << 32) + 442776044UL),
        (u64 const )((2428436474UL << 32) + 593698344UL), (u64 const )((2756734187UL << 32) + 3733110249UL), (u64 const )((3204031479UL << 32) + 2999351573UL), (u64 const )((3329325298UL << 32) + 3815920427UL),
        (u64 const )((3391569614UL << 32) + 3928383900UL), (u64 const )((3515267271UL << 32) + 566280711UL), (u64 const )((3940187606UL << 32) + 3454069534UL), (u64 const )((4118630271UL << 32) + 4000239992UL),
        (u64 const )((116418474UL << 32) + 1914138554UL), (u64 const )((174292421UL << 32) + 2731055270UL), (u64 const )((289380356UL << 32) + 3203993006UL), (u64 const )((460393269UL << 32) + 320620315UL),
        (u64 const )((685471733UL << 32) + 587496836UL), (u64 const )((852142971UL << 32) + 1086792851UL), (u64 const )((1017036298UL << 32) + 365543100UL), (u64 const )((1126000580UL << 32) + 2618297676UL),
        (u64 const )((1288033470UL << 32) + 3409855158UL), (u64 const )((1501505948UL << 32) + 4234509866UL), (u64 const )((1607167915UL << 32) + 987167468UL), (u64 const )((1816402316UL << 32) + 1246189591UL)};
#pragma merger(0,"/tmp/cil-6Ziuf9IL.i","-g,-O2")
extern void __assert_fail(char const *__assertion , char const *__file , unsigned int __line ,
                          char const *__function ) __attribute__((__nothrow__,
__noreturn__)) ;
void cycle_check_init(struct cycle_check_state *state ) ;
_Bool cycle_check(struct cycle_check_state *state , struct stat const *sb ) ;
#pragma merger(0,"/tmp/cil-lQKk38Pv.i","-g,-O2")
struct di_set *di_set_alloc(void) ;
int ( __attribute__((__nonnull__(1))) di_set_insert)(struct di_set *dis , dev_t dev ,
                                                     ino_t ino ) ;
void ( __attribute__((__nonnull__(1))) di_set_free)(struct di_set *dis ) ;
int ( __attribute__((__nonnull__(1))) di_set_lookup)(struct di_set *dis , dev_t dev ,
                                                     ino_t ino ) ;
void *hash_lookup(Hash_table const *table___0 , void const *entry ) ;
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table___0 ,
                                                             void const *entry ) ;
int hash_insert0(Hash_table *table___0 , void const *entry , void const **matched_ent ) ;
struct ino_map *ino_map_alloc(size_t next_mapped_ino ) ;
size_t ( __attribute__((__nonnull__(1))) ino_map_insert)(struct ino_map *im , ino_t ino ) ;
#pragma merger(0,"/tmp/cil-nFOZk6Rv.i","-g,-O2")
char const diacrit_base[256] ;
char const diacrit_diac[256] ;
char const diacrit_base[256] =
  { (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )'A', (char const )'B', (char const )'C',
        (char const )'D', (char const )'E', (char const )'F', (char const )'G',
        (char const )'H', (char const )'I', (char const )'J', (char const )'K',
        (char const )'L', (char const )'M', (char const )'N', (char const )'O',
        (char const )'P', (char const )'Q', (char const )'R', (char const )'S',
        (char const )'T', (char const )'U', (char const )'V', (char const )'W',
        (char const )'X', (char const )'Y', (char const )'Z', (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )'a', (char const )'b', (char const )'c',
        (char const )'d', (char const )'e', (char const )'f', (char const )'g',
        (char const )'h', (char const )'i', (char const )'j', (char const )'k',
        (char const )'l', (char const )'m', (char const )'n', (char const )'o',
        (char const )'p', (char const )'q', (char const )'r', (char const )'s',
        (char const )'t', (char const )'u', (char const )'v', (char const )'w',
        (char const )'x', (char const )'y', (char const )'z', (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )'A', (char const )'A', (char const )'A', (char const )'A',
        (char const )'A', (char const )'A', (char const )'A', (char const )'C',
        (char const )'E', (char const )'E', (char const )'E', (char const )'E',
        (char const )'I', (char const )'I', (char const )'I', (char const )'I',
        (char const )0, (char const )'N', (char const )'O', (char const )'O',
        (char const )'O', (char const )'O', (char const )'O', (char const )0,
        (char const )'O', (char const )'U', (char const )'U', (char const )'U',
        (char const )'U', (char const )'Y', (char const )0, (char const )0,
        (char const )'a', (char const )'a', (char const )'a', (char const )'a',
        (char const )'a', (char const )'a', (char const )'a', (char const )'c',
        (char const )'e', (char const )'e', (char const )'e', (char const )'e',
        (char const )'i', (char const )'i', (char const )'i', (char const )'i',
        (char const )0, (char const )'n', (char const )'o', (char const )'o',
        (char const )'o', (char const )'o', (char const )'o', (char const )0,
        (char const )'o', (char const )'u', (char const )'u', (char const )'u',
        (char const )'u', (char const )'y', (char const )0, (char const )'y'};
char const diacrit_diac[256] =
  { (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )4, (char const )0,
        (char const )3, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )6, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )0, (char const )0, (char const )0, (char const )0,
        (char const )3, (char const )2, (char const )4, (char const )6,
        (char const )5, (char const )8, (char const )1, (char const )7,
        (char const )3, (char const )2, (char const )4, (char const )5,
        (char const )3, (char const )2, (char const )4, (char const )5,
        (char const )0, (char const )6, (char const )3, (char const )2,
        (char const )4, (char const )6, (char const )5, (char const )0,
        (char const )9, (char const )3, (char const )2, (char const )4,
        (char const )5, (char const )2, (char const )0, (char const )0,
        (char const )3, (char const )2, (char const )4, (char const )6,
        (char const )5, (char const )8, (char const )1, (char const )7,
        (char const )3, (char const )2, (char const )4, (char const )5,
        (char const )3, (char const )2, (char const )4, (char const )5,
        (char const )0, (char const )6, (char const )3, (char const )2,
        (char const )4, (char const )6, (char const )5, (char const )0,
        (char const )9, (char const )3, (char const )2, (char const )4,
        (char const )5, (char const )2, (char const )0, (char const )0};
#pragma merger(0,"/tmp/cil-LNTrpPJG.i","-g,-O2")
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const *__name ) ;
extern DIR *fdopendir(int __fd ) ;
extern int ( __attribute__((__nonnull__(1))) dirfd)(DIR *__dirp ) __attribute__((__nothrow__)) ;
extern int close(int __fd ) ;
int dup_safer(int fd ) ;
#pragma merger(0,"/tmp/cil-vzNqwqIX.i","-g,-O2")
char *dir_name(char const *file ) ;
char *mdir_name(char const *file ) ;
#pragma merger(0,"/tmp/cil-T1DO3Ht_.i","-g,-O2")
char *base_name(char const *name ) ;
char *xstrndup(char const *string , size_t n ) ;
#pragma merger(0,"/tmp/cil-t9EJ0OFP.i","-g,-O2")
size_t dir_len(char const *file ) ;
#pragma merger(0,"/tmp/cil-BzAWVA58.i","-g,-O2")
#pragma merger(0,"/tmp/cil-sB6jEMZ2.i","-g,-O2")
_Bool strip_trailing_slashes(char *file ) ;
#pragma merger(0,"/tmp/cil-KIKnPJ4S.i","-g,-O2")
int dtoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , double x ) ;
#pragma merger(0,"/tmp/cil-Aur6k6LT.i","-g,-O2")
struct timespec dtotimespec(double sec ) ;
#pragma merger(0,"/tmp/cil-DrCo3LJV.i","-g,-O2")
extern unsigned short const **__ctype_b_loc(void) __attribute__((__nothrow__, __const__)) ;
extern __int32_t const **__ctype_tolower_loc(void) __attribute__((__nothrow__,
__const__)) ;
extern __int32_t const **__ctype_toupper_loc(void) __attribute__((__nothrow__,
__const__)) ;
__inline extern int tolower(int __c ) __attribute__((__nothrow__)) ;
__inline extern int toupper(int __c ) __attribute__((__nothrow__)) ;
extern FILE *( __attribute__((__warn_unused_result__)) fopen)(char const * __restrict __filename ,
                                                              char const * __restrict __modes ) ;
extern size_t ( __attribute__((__warn_unused_result__)) __ctype_get_mb_cur_max)(void) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__nonnull__(1))) strrchr)(char const *__s , int __c ) __attribute__((__pure__,
__nothrow__)) ;
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const *s1 , char const *s2 ) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcscpy)(wchar_t *__dest ,
                                                                                      wchar_t const *__src ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcsncpy)(wchar_t *__dest ,
                                                                                       wchar_t const *__src ,
                                                                                       size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcscat)(wchar_t *__dest ,
                                                                                      wchar_t const *__src ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcsncat)(wchar_t *__dest ,
                                                                                       wchar_t const *__src ,
                                                                                       size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wmemcpy)(wchar_t *__s1 ,
                                                                                       wchar_t const *__s2 ,
                                                                                       size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wmemmove)(wchar_t *__s1 ,
                                                                                        wchar_t const *__s2 ,
                                                                                        size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wmemset)(wchar_t *__s ,
                                                                                       wchar_t __c ,
                                                                                       size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wmempcpy)(wchar_t *__s1 ,
                                                                                        wchar_t const *__s2 ,
                                                                                        size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wint_t btowc(int __c ) __attribute__((__nothrow__)) ;
__inline extern int wctob(wint_t __wc ) __attribute__((__nothrow__)) ;
extern int mbsinit(mbstate_t const *__ps ) __attribute__((__pure__, __nothrow__)) ;
extern size_t mbrtowc(wchar_t * __restrict __pwc , char const * __restrict __s ,
                      size_t __n , mbstate_t *__p ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) wcrtomb)(char *__s ,
                                                                                                             wchar_t __wchar ,
                                                                                                             mbstate_t *__ps ) __attribute__((__nothrow__)) ;
extern size_t __mbrlen(char const * __restrict __s , size_t __n , mbstate_t * __restrict __ps ) __attribute__((__nothrow__)) ;
__inline extern size_t mbrlen(char const *__s , size_t __n , mbstate_t *__ps ) __attribute__((__nothrow__)) ;
extern wint_t __btowc_alias(int __c ) __asm__("btowc") ;
extern int __wctob_alias(wint_t __c ) __asm__("wctob") ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) mbsrtowcs)(wchar_t *__dst ,
                                                                                       char const **__src ,
                                                                                       size_t __len ,
                                                                                       mbstate_t *__ps ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) wcsrtombs)(char *__dst ,
                                                                                       wchar_t const **__src ,
                                                                                       size_t __len ,
                                                                                       mbstate_t *__ps ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) mbsnrtowcs)(wchar_t *__dst ,
                                                                                        char const **__src ,
                                                                                        size_t __nmc ,
                                                                                        size_t __len ,
                                                                                        mbstate_t *__ps ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) wcsnrtombs)(char *__dst ,
                                                                                        wchar_t const **__src ,
                                                                                        size_t __nwc ,
                                                                                        size_t __len ,
                                                                                        mbstate_t *__ps ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcpcpy)(wchar_t *__dest ,
                                                                                      wchar_t const *__src ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcpncpy)(wchar_t *__dest ,
                                                                                       wchar_t const *__src ,
                                                                                       size_t __n ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) fwprintf)(__FILE *__stream ,
                                                                                   wchar_t const *__fmt
                                                                                   , ...) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) wprintf)(wchar_t const *__fmt
                                                                                  , ...) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) swprintf)(wchar_t *__s ,
                                                                                   size_t __n ,
                                                                                   wchar_t const *__fmt
                                                                                   , ...) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfwprintf)(__FILE *__stream ,
                                                                                    wchar_t const *__fmt ,
                                                                                    __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vwprintf)(wchar_t const *__fmt ,
                                                                                   __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vswprintf)(wchar_t *__s ,
                                                                                    size_t __n ,
                                                                                    wchar_t const *__fmt ,
                                                                                    __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__warn_unused_result__, __artificial__,
__always_inline__)) fgetws)(wchar_t *__s , int __n , __FILE *__stream ) ;
__inline extern wchar_t *( __attribute__((__warn_unused_result__, __artificial__,
__always_inline__)) fgetws_unlocked)(wchar_t *__s , int __n , __FILE *__stream ) ;
extern wchar_t *__wmemcpy_chk(wchar_t * __restrict __s1 , wchar_t const * __restrict __s2 ,
                              size_t __n , size_t __ns1 ) __attribute__((__nothrow__)) ;
extern wchar_t *__wmemcpy_alias(wchar_t * __restrict __s1 , wchar_t const * __restrict __s2 ,
                                size_t __n ) __asm__("wmemcpy") __attribute__((__nothrow__)) ;
extern wchar_t *__wmemcpy_chk_warn(wchar_t * __restrict __s1 , wchar_t const * __restrict __s2 ,
                                   size_t __n , size_t __ns1 ) __asm__("__wmemcpy_chk") __attribute__((__warning__("wmemcpy called with length bigger than size of destination buffer"),
__nothrow__)) ;
extern wchar_t *__wmemmove_chk(wchar_t *__s1 , wchar_t const *__s2 , size_t __n ,
                               size_t __ns1 ) __attribute__((__nothrow__)) ;
extern wchar_t *__wmemmove_alias(wchar_t *__s1 , wchar_t const *__s2 , size_t __n ) __asm__("wmemmove") __attribute__((__nothrow__)) ;
extern wchar_t *__wmemmove_chk_warn(wchar_t *__s1 , wchar_t const *__s2 , size_t __n ,
                                    size_t __ns1 ) __asm__("__wmemmove_chk") __attribute__((__warning__("wmemmove called with length bigger than size of destination buffer"),
__nothrow__)) ;
extern wchar_t *__wmempcpy_chk(wchar_t * __restrict __s1 , wchar_t const * __restrict __s2 ,
                               size_t __n , size_t __ns1 ) __attribute__((__nothrow__)) ;
extern wchar_t *__wmempcpy_alias(wchar_t * __restrict __s1 , wchar_t const * __restrict __s2 ,
                                 size_t __n ) __asm__("wmempcpy") __attribute__((__nothrow__)) ;
extern wchar_t *__wmempcpy_chk_warn(wchar_t * __restrict __s1 , wchar_t const * __restrict __s2 ,
                                    size_t __n , size_t __ns1 ) __asm__("__wmempcpy_chk") __attribute__((__warning__("wmempcpy called with length bigger than size of destination buffer"),
__nothrow__)) ;
extern wchar_t *__wmemset_chk(wchar_t *__s , wchar_t __c , size_t __n , size_t __ns ) __attribute__((__nothrow__)) ;
extern wchar_t *__wmemset_alias(wchar_t *__s , wchar_t __c , size_t __n ) __asm__("wmemset") __attribute__((__nothrow__)) ;
extern wchar_t *__wmemset_chk_warn(wchar_t *__s , wchar_t __c , size_t __n , size_t __ns ) __asm__("__wmemset_chk") __attribute__((__warning__("wmemset called with length bigger than size of destination buffer"),
__nothrow__)) ;
extern wchar_t *__wcscpy_chk(wchar_t * __restrict __dest , wchar_t const * __restrict __src ,
                             size_t __n ) __attribute__((__nothrow__)) ;
extern wchar_t *__wcscpy_alias(wchar_t * __restrict __dest , wchar_t const * __restrict __src ) __asm__("wcscpy") __attribute__((__nothrow__)) ;
extern wchar_t *__wcpcpy_chk(wchar_t * __restrict __dest , wchar_t const * __restrict __src ,
                             size_t __destlen ) __attribute__((__nothrow__)) ;
extern wchar_t *__wcpcpy_alias(wchar_t * __restrict __dest , wchar_t const * __restrict __src ) __asm__("wcpcpy") __attribute__((__nothrow__)) ;
extern wchar_t *__wcsncpy_chk(wchar_t * __restrict __dest , wchar_t const * __restrict __src ,
                              size_t __n , size_t __destlen ) __attribute__((__nothrow__)) ;
extern wchar_t *__wcsncpy_alias(wchar_t * __restrict __dest , wchar_t const * __restrict __src ,
                                size_t __n ) __asm__("wcsncpy") __attribute__((__nothrow__)) ;
extern wchar_t *__wcsncpy_chk_warn(wchar_t * __restrict __dest , wchar_t const * __restrict __src ,
                                   size_t __n , size_t __destlen ) __asm__("__wcsncpy_chk") __attribute__((__warning__("wcsncpy called with length bigger than size of destination buffer"),
__nothrow__)) ;
extern wchar_t *__wcpncpy_chk(wchar_t * __restrict __dest , wchar_t const * __restrict __src ,
                              size_t __n , size_t __destlen ) __attribute__((__nothrow__)) ;
extern wchar_t *__wcpncpy_alias(wchar_t * __restrict __dest , wchar_t const * __restrict __src ,
                                size_t __n ) __asm__("wcpncpy") __attribute__((__nothrow__)) ;
extern wchar_t *__wcpncpy_chk_warn(wchar_t * __restrict __dest , wchar_t const * __restrict __src ,
                                   size_t __n , size_t __destlen ) __asm__("__wcpncpy_chk") __attribute__((__warning__("wcpncpy called with length bigger than size of destination buffer"),
__nothrow__)) ;
extern wchar_t *__wcscat_chk(wchar_t * __restrict __dest , wchar_t const * __restrict __src ,
                             size_t __destlen ) __attribute__((__nothrow__)) ;
extern wchar_t *__wcscat_alias(wchar_t * __restrict __dest , wchar_t const * __restrict __src ) __asm__("wcscat") __attribute__((__nothrow__)) ;
extern wchar_t *__wcsncat_chk(wchar_t * __restrict __dest , wchar_t const * __restrict __src ,
                              size_t __n , size_t __destlen ) __attribute__((__nothrow__)) ;
extern wchar_t *__wcsncat_alias(wchar_t * __restrict __dest , wchar_t const * __restrict __src ,
                                size_t __n ) __asm__("wcsncat") __attribute__((__nothrow__)) ;
extern int __swprintf_chk(wchar_t * __restrict __s , size_t __n , int __flag , size_t __s_len ,
                          wchar_t const * __restrict __format , ...) __attribute__((__nothrow__)) ;
extern int __swprintf_alias(wchar_t * __restrict __s , size_t __n , wchar_t const * __restrict __fmt
                            , ...) __asm__("swprintf") __attribute__((__nothrow__)) ;
extern int __vswprintf_chk(wchar_t * __restrict __s , size_t __n , int __flag , size_t __s_len ,
                           wchar_t const * __restrict __format , __gnuc_va_list __arg ) __attribute__((__nothrow__)) ;
extern int __vswprintf_alias(wchar_t * __restrict __s , size_t __n , wchar_t const * __restrict __fmt ,
                             __gnuc_va_list __ap ) __asm__("vswprintf") __attribute__((__nothrow__)) ;
extern int __fwprintf_chk(__FILE * __restrict __stream , int __flag , wchar_t const * __restrict __format
                          , ...) ;
extern int __wprintf_chk(int __flag , wchar_t const * __restrict __format , ...) ;
extern int __vfwprintf_chk(__FILE * __restrict __stream , int __flag , wchar_t const * __restrict __format ,
                           __gnuc_va_list __ap ) ;
extern int __vwprintf_chk(int __flag , wchar_t const * __restrict __format , __gnuc_va_list __ap ) ;
extern wchar_t *( __attribute__((__warn_unused_result__)) __fgetws_chk)(wchar_t * __restrict __s ,
                                                                        size_t __size ,
                                                                        int __n ,
                                                                        __FILE * __restrict __stream ) ;
extern wchar_t *( __attribute__((__warn_unused_result__)) __fgetws_alias)(wchar_t * __restrict __s ,
                                                                          int __n ,
                                                                          __FILE * __restrict __stream ) __asm__("fgetws") ;
extern wchar_t *( __attribute__((__warn_unused_result__)) __fgetws_chk_warn)(wchar_t * __restrict __s ,
                                                                             size_t __size ,
                                                                             int __n ,
                                                                             __FILE * __restrict __stream ) __asm__("__fgetws_chk") __attribute__((__warning__("fgetws called with bigger size than length of destination buffer"))) ;
extern wchar_t *( __attribute__((__warn_unused_result__)) __fgetws_unlocked_chk)(wchar_t * __restrict __s ,
                                                                                 size_t __size ,
                                                                                 int __n ,
                                                                                 __FILE * __restrict __stream ) ;
extern wchar_t *( __attribute__((__warn_unused_result__)) __fgetws_unlocked_alias)(wchar_t * __restrict __s ,
                                                                                   int __n ,
                                                                                   __FILE * __restrict __stream ) __asm__("fgetws_unlocked") ;
extern wchar_t *( __attribute__((__warn_unused_result__)) __fgetws_unlocked_chk_warn)(wchar_t * __restrict __s ,
                                                                                      size_t __size ,
                                                                                      int __n ,
                                                                                      __FILE * __restrict __stream ) __asm__("__fgetws_unlocked_chk") __attribute__((__warning__("fgetws_unlocked called with bigger size than length of destination buffer"))) ;
extern size_t ( __attribute__((__warn_unused_result__)) __wcrtomb_chk)(char * __restrict __s ,
                                                                       wchar_t __wchar ,
                                                                       mbstate_t * __restrict __p ,
                                                                       size_t __buflen ) __attribute__((__nothrow__)) ;
extern size_t ( __attribute__((__warn_unused_result__)) __wcrtomb_alias)(char * __restrict __s ,
                                                                         wchar_t __wchar ,
                                                                         mbstate_t * __restrict __ps ) __asm__("wcrtomb") __attribute__((__nothrow__)) ;
extern size_t __mbsrtowcs_chk(wchar_t * __restrict __dst , char const ** __restrict __src ,
                              size_t __len , mbstate_t * __restrict __ps , size_t __dstlen ) __attribute__((__nothrow__)) ;
extern size_t __mbsrtowcs_alias(wchar_t * __restrict __dst , char const ** __restrict __src ,
                                size_t __len , mbstate_t * __restrict __ps ) __asm__("mbsrtowcs") __attribute__((__nothrow__)) ;
extern size_t __mbsrtowcs_chk_warn(wchar_t * __restrict __dst , char const ** __restrict __src ,
                                   size_t __len , mbstate_t * __restrict __ps , size_t __dstlen ) __asm__("__mbsrtowcs_chk") __attribute__((__warning__("mbsrtowcs called with dst buffer smaller than len * sizeof (wchar_t)"),
__nothrow__)) ;
extern size_t __wcsrtombs_chk(char * __restrict __dst , wchar_t const ** __restrict __src ,
                              size_t __len , mbstate_t * __restrict __ps , size_t __dstlen ) __attribute__((__nothrow__)) ;
extern size_t __wcsrtombs_alias(char * __restrict __dst , wchar_t const ** __restrict __src ,
                                size_t __len , mbstate_t * __restrict __ps ) __asm__("wcsrtombs") __attribute__((__nothrow__)) ;
extern size_t __wcsrtombs_chk_warn(char * __restrict __dst , wchar_t const ** __restrict __src ,
                                   size_t __len , mbstate_t * __restrict __ps , size_t __dstlen ) __asm__("__wcsrtombs_chk") __attribute__((__warning__("wcsrtombs called with dst buffer smaller than len"),
__nothrow__)) ;
extern size_t __mbsnrtowcs_chk(wchar_t * __restrict __dst , char const ** __restrict __src ,
                               size_t __nmc , size_t __len , mbstate_t * __restrict __ps ,
                               size_t __dstlen ) __attribute__((__nothrow__)) ;
extern size_t __mbsnrtowcs_alias(wchar_t * __restrict __dst , char const ** __restrict __src ,
                                 size_t __nmc , size_t __len , mbstate_t * __restrict __ps ) __asm__("mbsnrtowcs") __attribute__((__nothrow__)) ;
extern size_t __mbsnrtowcs_chk_warn(wchar_t * __restrict __dst , char const ** __restrict __src ,
                                    size_t __nmc , size_t __len , mbstate_t * __restrict __ps ,
                                    size_t __dstlen ) __asm__("__mbsnrtowcs_chk") __attribute__((__warning__("mbsnrtowcs called with dst buffer smaller than len * sizeof (wchar_t)"),
__nothrow__)) ;
extern size_t __wcsnrtombs_chk(char * __restrict __dst , wchar_t const ** __restrict __src ,
                               size_t __nwc , size_t __len , mbstate_t * __restrict __ps ,
                               size_t __dstlen ) __attribute__((__nothrow__)) ;
extern size_t __wcsnrtombs_alias(char * __restrict __dst , wchar_t const ** __restrict __src ,
                                 size_t __nwc , size_t __len , mbstate_t * __restrict __ps ) __asm__("wcsnrtombs") __attribute__((__nothrow__)) ;
extern size_t __wcsnrtombs_chk_warn(char * __restrict __dst , wchar_t const ** __restrict __src ,
                                    size_t __nwc , size_t __len , mbstate_t * __restrict __ps ,
                                    size_t __dstlen ) __asm__("__wcsnrtombs_chk") __attribute__((__warning__("wcsnrtombs called with dst buffer smaller than len"),
__nothrow__)) ;
extern wint_t towlower(wint_t __wc ) __attribute__((__nothrow__)) ;
_Bool fnmatch_pattern_has_wildcards(char const *str , int options ) ;
struct exclude *new_exclude(void) ;
void free_exclude(struct exclude *ex ) ;
void add_exclude(struct exclude *ex , char const *pattern , int options ) ;
int add_exclude_file(void (*add_func)(struct exclude * , char const * , int ) ,
                     struct exclude *ex , char const *file_name___1 , int options ,
                     char line_end ) ;
_Bool excluded_file_name(struct exclude const *ex , char const *f ) ;
_Bool exclude_fnmatch(char const *pattern , char const *f , int options ) ;
size_t hash_string(char const *string , size_t n_buckets ) ;
unsigned int const is_basic_table[8] ;
size_t strnlen1(char const *string , size_t maxlen ) ;
extern int fnmatch(char const *__pattern , char const *__name , int __flags ) ;
void *xzalloc(size_t s ) __attribute__((__malloc__, __alloc_size__(1))) ;
void *x2realloc(void *p , size_t *pn ) ;
char *xstrdup(char const *string ) __attribute__((__malloc__)) ;
#pragma merger(0,"/tmp/cil-ATKXZMYu.i","-g,-O2")
int volatile exit_failure = (int volatile )1;
#pragma merger(0,"/tmp/cil-BuwfHWUM.i","-g,-O2")
extern int ( __attribute__((__warn_unused_result__)) fileno)(FILE *__stream ) __attribute__((__nothrow__)) ;
extern int posix_fadvise(int __fd , __off_t __offset , __off_t __len , int __advise ) __attribute__((__nothrow__)) ;
void fdadvise(int fd , off_t offset , off_t len , fadvice_t advice ) ;
void fadvise(FILE *fp , fadvice_t advice ) ;
#pragma merger(0,"/tmp/cil-kVI1qgVW.i","-g,-O2")
int creat_safer(char const *file , mode_t mode ) ;
extern int ( __attribute__((__nonnull__(1))) creat)(char const *__file , __mode_t __mode ) ;
int fd_safer(int fd ) ;
#pragma merger(0,"/tmp/cil-AFAt3US3.i","-g,-O2")
int open_safer(char const *file , int flags , ...) ;
#pragma merger(0,"/tmp/cil-rO9SayKB.i","-g,-O2")
#pragma merger(0,"/tmp/cil-Y0y6ZDam.i","-g,-O2")
int dup_safer_flag(int fd , int flag ) ;
int fd_safer_flag(int fd , int flag ) ;
#pragma merger(0,"/tmp/cil-2iGt_FNZ.i","-g,-O2")
#pragma merger(0,"/tmp/cil-zY7AvlEo.i","-g,-O2")
int rpl_futimens(int fd , struct timespec const *times ) ;
int ( __attribute__((__nonnull__(2))) rpl_utimensat)(int fd , char const *file ,
                                                     struct timespec const *times ,
                                                     int flag ) ;
int fdutimensat(int fd , int dir , char const *file , struct timespec const *ts ,
                int atflag ) ;
#pragma merger(0,"/tmp/cil-upAmL0LZ.i","-g,-O2")
#pragma merger(0,"/tmp/cil-zsnj7wcN.i","-g,-O2")
char const *file_type(struct stat const *st ) ;
#pragma merger(0,"/tmp/cil-YmxOGSWk.i","-g,-O2")
void strmode(mode_t mode , char *str ) ;
void filemodestring(struct stat const *statp , char *str ) ;
#pragma merger(0,"/tmp/cil-ajYKLC_9.i","-g,-O2")
char *file_name_concat(char const *dir , char const *abase , char **base_in_result ) ;
char *mfile_name_concat(char const *dir , char const *abase , char **base_in_result ) ;
#pragma merger(0,"/tmp/cil-CsxNKZLJ.i","-g,-O2")
#pragma merger(0,"/tmp/cil-LWCXPaKo.i","-g,-O2")
int filevercmp(char const *s1 , char const *s2 ) ;
#pragma merger(0,"/tmp/cil-_sI2s1x_.i","-g,-O2")
extern FILE *( __attribute__((__warn_unused_result__)) fdopen)(int __fd , char const *__modes ) __attribute__((__nothrow__)) ;
FILE *fopen_safer(char const *file , char const *mode ) ;
#pragma merger(0,"/tmp/cil-saVQXsxK.i","-g,-O2")
extern int fputc(int __c , FILE *__stream ) ;
extern size_t fwrite(void const * __restrict __ptr , size_t __size , size_t __n ,
                     FILE * __restrict __s ) ;
size_t fprintftime(FILE *s , char const *format , struct tm const *tp , int ut ,
                   int ns ) ;
#pragma merger(0,"/tmp/cil-ztRb6z_d.i","-g,-O2")
#pragma merger(0,"/tmp/cil-zP5Aoosk.i","-g,-O2")
#pragma merger(0,"/tmp/cil-vDNMEXYj.i","-g,-O2")
char const *freadptr(FILE *fp , size_t *sizep ) ;
#pragma merger(0,"/tmp/cil-B5HvgpJq.i","-g,-O2")
extern int fgetc(FILE *__stream ) ;
extern int ( __attribute__((__warn_unused_result__)) ferror)(FILE *__stream ) __attribute__((__nothrow__)) ;
int freadseek(FILE *fp , size_t offset ) ;
extern __off_t lseek(int __fd , __off_t __offset , int __whence ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-lqbX4cDW.i","-g,-O2")
extern FILE *( __attribute__((__warn_unused_result__)) freopen)(char const * __restrict __filename ,
                                                                char const * __restrict __modes ,
                                                                FILE * __restrict __stream ) ;
FILE *freopen_safer(char const *name , char const *mode , FILE *f ) ;
extern int dup2(int __fd , int __fd2 ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-JDOXkos9.i","-g,-O2")
void fseterr(FILE *fp ) ;
#pragma merger(0,"/tmp/cil-T_QGVLoq.i","-g,-O2")
int ftoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , float x ) ;
extern float ( __attribute__((__warn_unused_result__, __nonnull__(1))) strtof)(char const * __restrict __nptr ,
                                                                               char ** __restrict __endptr ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-FIppj7wc.i","-g,-O2")
size_t full_read(int fd , void *buf___1 , size_t count ) ;
size_t safe_read(int fd , void *buf___1 , size_t count ) ;
#pragma merger(0,"/tmp/cil-G9SfYcZz.i","-g,-O2")
size_t full_write(int fd , void const *buf___1 , size_t count ) ;
size_t safe_write(int fd , void const *buf___1 , size_t count ) ;
#pragma merger(0,"/tmp/cil-J1SYbdhw.i","-g,-O2")
ssize_t getndelim2(char **lineptr , size_t *linesize , size_t offset , size_t nmax ,
                   int delim1 , int delim2 , FILE *stream ) ;
void *memchr2(void const *s , int c1_in , int c2_in , size_t n ) ;
#pragma merger(0,"/tmp/cil-ZqsGmBkR.i","-g,-O2")
void gettime(struct timespec *ts ) ;
extern int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict __tv ,
                                                           __timezone_ptr_t __tz ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-WU8bhowZ.i","-g,-O2")
int getugroups(int maxcount , gid_t *grouplist , char const *username , gid_t gid ) ;
extern void setgrent(void) ;
extern void endgrent(void) ;
extern struct group *getgrent(void) ;
#pragma merger(0,"/tmp/cil-2AJ0O4fs.i","-g,-O2")
_Bool hard_locale(int category ) ;
extern char *setlocale(int __category , char const *__locale ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-0YyoiNqN.i","-g,-O2")
size_t hash_get_n_buckets(Hash_table const *table___0 ) ;
size_t hash_get_n_buckets_used(Hash_table const *table___0 ) ;
size_t hash_get_n_entries(Hash_table const *table___0 ) ;
size_t hash_get_max_bucket_length(Hash_table const *table___0 ) ;
_Bool hash_table_ok(Hash_table const *table___0 ) ;
void hash_print_statistics(Hash_table const *table___0 , FILE *stream ) ;
void *hash_get_first(Hash_table const *table___0 ) ;
void *hash_get_next(Hash_table const *table___0 , void const *entry ) ;
size_t hash_get_entries(Hash_table const *table___0 , void **buffer , size_t buffer_size ) ;
size_t hash_do_for_each(Hash_table const *table___0 , _Bool (*processor)(void * ,
                                                                           void * ) ,
                        void *processor_data ) ;
void hash_reset_tuning(Hash_tuning *tuning ) ;
void hash_clear(Hash_table *table___0 ) ;
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table___0 ,
                                                             size_t candidate ) ;
void *hash_delete(Hash_table *table___0 , void const *entry ) ;
extern void *( __attribute__((__warn_unused_result__)) calloc)(size_t __nmemb , size_t __size ) __attribute__((__nothrow__,
__malloc__)) ;
static struct hash_tuning const default_tuning = {(float )0.0, (float )1.0, (float )0.8, (float )1.414, (_Bool)0};
#pragma merger(0,"/tmp/cil-zaoCfeDr.i","-g,-O2")
size_t hash_pjw(void const *x , size_t tablesize ) ;
#pragma merger(0,"/tmp/cil-cXtd8kxk.i","-g,-O2")
size_t triple_hash_no_name(void const *x , size_t table_size ) ;
_Bool triple_compare(void const *x , void const *y ) ;
_Bool same_name(char const *source , char const *dest ) ;
#pragma merger(0,"/tmp/cil-fPrWATfZ.i","-g,-O2")
struct heap *heap_alloc(int (*compare)(void const * , void const * ) , size_t n_reserve ) ;
void heap_free(struct heap *heap ) ;
int heap_insert(struct heap *heap , void *item ) ;
void *heap_remove_top(struct heap *heap ) ;
__inline static void *xnmalloc(size_t n , size_t s ) __attribute__((__malloc__, __alloc_size__(1,2))) ;
static int heap_default_compare(void const *a , void const *b ) ;
static size_t heapify_down(void **array , size_t count , size_t initial , int (*compare)(void const * ,
                                                                                         void const * ) ) ;
static void heapify_up(void **array , size_t count , int (*compare)(void const * ,
                                                                    void const * ) ) ;
#pragma merger(0,"/tmp/cil-Ngtg3QH2.i","-g,-O2")
__inline extern intmax_t strtoimax(char const *nptr , char **endptr , int base ) __attribute__((__nothrow__)) ;
__inline extern uintmax_t strtoumax(char const *nptr , char **endptr , int base ) __attribute__((__nothrow__)) ;
__inline extern intmax_t wcstoimax(__gwchar_t const *nptr , __gwchar_t **endptr ,
                                   int base ) __attribute__((__nothrow__)) ;
__inline extern uintmax_t wcstoumax(__gwchar_t const *nptr , __gwchar_t **endptr ,
                                    int base ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__warn_unused_result__, __nonnull__(1))) __strtol_internal)(char const * __restrict __nptr ,
                                                                                         char ** __restrict __endptr ,
                                                                                         int __base ,
                                                                                         int __group ) __attribute__((__nothrow__)) ;
extern unsigned long ( __attribute__((__warn_unused_result__, __nonnull__(1))) __strtoul_internal)(char const * __restrict __nptr ,
                                                                                                   char ** __restrict __endptr ,
                                                                                                   int __base ,
                                                                                                   int __group ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__warn_unused_result__, __nonnull__(1))) __wcstol_internal)(__gwchar_t const * __restrict __nptr ,
                                                                                         __gwchar_t ** __restrict __endptr ,
                                                                                         int __base ,
                                                                                         int __group ) __attribute__((__nothrow__)) ;
extern unsigned long ( __attribute__((__warn_unused_result__, __nonnull__(1))) __wcstoul_internal)(__gwchar_t const * __restrict __nptr ,
                                                                                                   __gwchar_t ** __restrict __endptr ,
                                                                                                   int __base ,
                                                                                                   int __group ) __attribute__((__nothrow__)) ;
strtol_error xstrtoumax(char const *s , char **ptr , int strtol_base , uintmax_t *val ,
                        char const *valid_suffixes ) ;
char *human_readable(uintmax_t n , char *buf___1 , int opts , uintmax_t from_block_size ,
                     uintmax_t to_block_size ) ;
enum strtol_error human_options(char const *spec , int *opts , uintmax_t *block_size ) ;
extern struct lconv *localeconv(void) __attribute__((__nothrow__)) ;
static char const power_letter[9] =
  { (char const )0, (char const )'K', (char const )'M', (char const )'G',
        (char const )'T', (char const )'P', (char const )'E', (char const )'Z',
        (char const )'Y'};
static char const *block_size_args[3] = { (char const *)"human-readable", (char const *)"si", (char const *)0};
static int const block_size_opts[2] = { (int const )176, (int const )144};
#pragma merger(0,"/tmp/cil-7E9QST21.i","-g,-O2")
void i_ring_init(I_ring *ir , int default_val ) ;
int i_ring_push(I_ring *ir , int val ) ;
int i_ring_pop(I_ring *ir ) ;
_Bool i_ring_empty(I_ring const *ir ) ;
#pragma merger(0,"/tmp/cil-UXRXXj5q.i","-g,-O2")
char *getuser(uid_t uid ) ;
char *getgroup(gid_t gid ) ;
uid_t *getuidbyname(char const *user ) ;
gid_t *getgidbyname(char const *group ) ;
extern struct passwd *getpwuid(__uid_t __uid ) ;
extern struct passwd *getpwnam(char const *__name ) ;
extern struct group *getgrgid(__gid_t __gid ) ;
extern struct group *getgrnam(char const *__name ) ;
static struct userid *user_alist ;
static struct userid *nouser_alist ;
static struct userid *group_alist ;
static struct userid *nogroup_alist ;
#pragma merger(0,"/tmp/cil-STWqJWJl.i","-g,-O2")
void ( __attribute__((__nonnull__(1))) ino_map_free)(struct ino_map *map ) ;
#pragma merger(0,"/tmp/cil-M2o9sadc.i","-g,-O2")
#pragma GCC diagnostic ignored "-Wtype-limits"
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i , char *buf___1 ) ;
#pragma merger(0,"/tmp/cil-yJAvgcLC.i","-g,-O2")
#pragma GCC diagnostic ignored "-Wtype-limits"
char *( __attribute__((__warn_unused_result__)) inttostr)(int i , char *buf___1 ) ;
#pragma merger(0,"/tmp/cil-RowT0Odn.i","-g,-O2")
#pragma GCC diagnostic ignored "-Wtype-limits"
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i , char *buf___1 ) ;
#pragma merger(0,"/tmp/cil-mPLJU93n.i","-g,-O2")
#pragma GCC diagnostic ignored "-Wtype-limits"
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i , char *buf___1 ) ;
#pragma merger(0,"/tmp/cil-5smMv8wp.i","-g,-O2")
#pragma GCC diagnostic ignored "-Wtype-limits"
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i , char *buf___1 ) ;
#pragma merger(0,"/tmp/cil-qGn38_1r.i","-g,-O2")
int ldtoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , long double x ) ;
extern long double ( __attribute__((__warn_unused_result__, __nonnull__(1))) strtold)(char const * __restrict __nptr ,
                                                                                      char ** __restrict __endptr ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-1GvUG_eX.i","-g,-O2")
void initbuffer(struct linebuffer *linebuffer ) ;
struct linebuffer *readlinebuffer_delim(struct linebuffer *linebuffer , FILE *stream ,
                                        char delimiter ) ;
struct linebuffer *readlinebuffer(struct linebuffer *linebuffer , FILE *stream ) ;
void freebuffer(struct linebuffer *linebuffer ) ;
#pragma merger(0,"/tmp/cil-utpmCqBC.i","-g,-O2")
char const *locale_charset(void) ;
extern int ( __attribute__((__warn_unused_result__)) fscanf)(FILE * __restrict __stream ,
                                                             char const * __restrict __format
                                                             , ...) ;
extern int ungetc(int __c , FILE *__stream ) ;
extern char *nl_langinfo(nl_item __item ) __attribute__((__nothrow__)) ;
static char const * volatile charset_aliases ;
#pragma merger(0,"/tmp/cil-zFsvc8XO.i","-g,-O2")
#pragma weak pthread_mutex_init
#pragma weak pthread_mutex_lock
#pragma weak pthread_mutex_unlock
#pragma weak pthread_mutex_destroy
#pragma weak pthread_rwlock_init
#pragma weak pthread_rwlock_rdlock
#pragma weak pthread_rwlock_wrlock
#pragma weak pthread_rwlock_unlock
#pragma weak pthread_rwlock_destroy
#pragma weak pthread_once
#pragma weak pthread_cond_init
#pragma weak pthread_cond_wait
#pragma weak pthread_cond_signal
#pragma weak pthread_cond_broadcast
#pragma weak pthread_cond_destroy
#pragma weak pthread_mutexattr_init
#pragma weak pthread_mutexattr_settype
#pragma weak pthread_mutexattr_destroy
#pragma weak pthread_self
#pragma weak pthread_cancel
int glthread_recursive_lock_init_multithreaded(gl_recursive_lock_t *lock ) ;
int glthread_once_singlethreaded(pthread_once_t *once_control ) ;
static int const fresh_once = (pthread_once_t const )0;
#pragma merger(0,"/tmp/cil-5GSFnkkV.i","-g,-O2")
void parse_long_options(int argc , char **argv , char const *command_name , char const *package ,
                        char const *version , void (*usage_func)(int ) , ...) ;
extern void exit(int __status ) __attribute__((__nothrow__, __noreturn__)) ;
int rpl_optind ;
int rpl_opterr ;
int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long)(int argc , char **argv ,
                                                         char const *options , struct rpl_option const *long_options___0 ,
                                                         int *opt_index ) __attribute__((__nothrow__)) ;
void version_etc_va(FILE *stream , char const *command_name , char const *package ,
                    char const *version , va_list authors ) ;
static struct rpl_option const long_options[3] = { {(char const *)"help", 0, (int *)((void *)0), 'h'},
        {(char const *)"version", 0, (int *)((void *)0), 'v'},
        {(char const *)((void *)0), 0, (int *)((void *)0), 0}};
#pragma merger(0,"/tmp/cil-qlCqfvCJ.i","-g,-O2")
void *mmalloca(size_t n ) ;
void freea(void *p ) ;
static void *mmalloca_results[257] ;
#pragma merger(0,"/tmp/cil-Wugf18wQ.i","-g,-O2")
unsigned int const is_basic_table[8] =
  { (unsigned int const )6656, (unsigned int const )4294967279U, (unsigned int const )4294967294U, (unsigned int const )2147483646,
        (unsigned int const )0U, (unsigned int const )0U, (unsigned int const )0U, (unsigned int const )0U};
#pragma merger(0,"/tmp/cil-Eh3hNPaq.i","-g,-O2")
size_t mbsalign(char const *src , char *dest , size_t dest_size , size_t *width ,
                mbs_align_t align , int flags ) ;
char *ambsalign(char const *src , size_t *width , mbs_align_t align , int flags ) ;
extern int wcwidth(wchar_t __c ) __attribute__((__nothrow__)) ;
extern int wcswidth(wchar_t const *__s , size_t __n ) __attribute__((__nothrow__)) ;
extern int iswprint(wint_t __wc ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-In6du6JB.i","-g,-O2")
#pragma merger(0,"/tmp/cil-JgdeT8e1.i","-g,-O2")
size_t ( __attribute__((__nonnull__(1))) mbslen)(char const *string ) ;
#pragma merger(0,"/tmp/cil-1Q3l_JeC.i","-g,-O2")
extern size_t ( __attribute__((__nonnull__(1))) strnlen)(char const *__string ,
                                                         size_t __maxlen ) __attribute__((__pure__,
__nothrow__)) ;
char *( __attribute__((__nonnull__(1,2))) mbsstr)(char const *haystack , char const *needle ) ;
#pragma merger(0,"/tmp/cil-ihymVvBv.i","-g,-O2")
int gnu_mbswidth(char const *string , int flags ) ;
int mbsnwidth(char const *string , size_t nbytes , int flags ) ;
extern int iswcntrl(wint_t __wc ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-bpVVowuL.i","-g,-O2")
int memcasecmp(void const *vs1 , void const *vs2 , size_t n ) ;
#pragma merger(0,"/tmp/cil-rXaqB71M.i","-g,-O2")
#pragma merger(0,"/tmp/cil-clO2L3Yu.i","-g,-O2")
int memcmp2(char const *s1 , size_t n1 , char const *s2 , size_t n2 ) ;
#pragma merger(0,"/tmp/cil-K4HxhccU.i","-g,-O2")
int memcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) ;
int memcoll0(char const *s1 , size_t s1size , char const *s2 , size_t s2size ) ;
extern int ( __attribute__((__nonnull__(1,2))) strcoll)(char const *__s1 , char const *__s2 ) __attribute__((__pure__,
__nothrow__)) ;
#pragma merger(0,"/tmp/cil-vXmlNLFr.i","-g,-O2")
int mgetgroups(char const *username , gid_t gid , gid_t **groups ) ;
extern int getgrouplist(char const *__user , __gid_t __group , __gid_t *__groups ,
                        int *__ngroups ) ;
#pragma merger(0,"/tmp/cil-hNaCZG4w.i","-g,-O2")
ptrdiff_t mkancesdirs(char *file , struct savewd *wd , int (*make_dir)(char const * ,
                                                                       char const * ,
                                                                       void * ) ,
                      void *make_dir_arg ) ;
int savewd_chdir(struct savewd *wd , char const *dir , int options , int *open_result ) ;
#pragma merger(0,"/tmp/cil-llxXEgwu.i","-g,-O2")
int dirchownmod(int fd , char const *dir , mode_t mkdir_mode , uid_t owner , gid_t group ,
                mode_t mode , mode_t mode_bits ) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) chown)(char const *__file ,
                                                                            __uid_t __owner ,
                                                                            __gid_t __group ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__)) fchown)(int __fd , __uid_t __owner ,
                                                             __gid_t __group ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) lchown)(char const *__file ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-PhWbYBXg.i","-g,-O2")
_Bool make_dir_parents(char *dir , struct savewd *wd , int (*make_ancestor)(char const * ,
                                                                            char const * ,
                                                                            void * ) ,
                       void *options , mode_t mode , void (*announce)(char const * ,
                                                                      void * ) , mode_t mode_bits ,
                       uid_t owner , gid_t group , _Bool preserve_existing ) ;
extern int ( __attribute__((__nonnull__(1))) mkdir)(char const *__path , __mode_t __mode ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-ZBbx3fwk.i","-g,-O2")
struct mode_change *mode_compile(char const *mode_string ) ;
struct mode_change *mode_create_from_ref(char const *ref_file ) ;
mode_t mode_adjust(mode_t oldmode , _Bool dir , mode_t umask_value , struct mode_change const *changes ,
                   mode_t *pmode_bits ) ;
#pragma merger(0,"/tmp/cil-ODmzwPVm.i","-g,-O2")
void mpsort(void const **base , size_t n , int (*cmp)(void const * , void const * ) ) ;
static void mpsort_with_tmp(void const **base , size_t n , void const **tmp ,
                            int (*cmp)(void const * , void const * ) ) ;
#pragma merger(0,"/tmp/cil-SfPDResb.i","-g,-O2")
unsigned long num_processors(enum nproc_query query ) ;
extern unsigned long ( __attribute__((__warn_unused_result__, __nonnull__(1))) strtoul)(char const * __restrict __nptr ,
                                                                                        char ** __restrict __endptr ,
                                                                                        int __base ) __attribute__((__nothrow__)) ;
extern long sysconf(int __name ) __attribute__((__nothrow__)) ;
extern int sched_getaffinity(__pid_t __pid , size_t __cpusetsize , cpu_set_t *__cpuset ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-sr144Gtg.i","-g,-O2")
void openat_restore_fail(int errnum ) __attribute__((__noreturn__)) ;
void openat_save_fail(int errnum ) __attribute__((__noreturn__)) ;
#pragma merger(0,"/tmp/cil-PVqyolHj.i","-g,-O2")
int openat_safer(int fd , char const *file , int flags , ...) ;
#pragma merger(0,"/tmp/cil-AV7obLFh.i","-g,-O2")
_Bool parse_datetime(struct timespec *result , char const *p , struct timespec const *now ) ;
extern int ( __attribute__((__nonnull__(2))) setenv)(char const *__name , char const *__value ,
                                                     int __replace ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) unsetenv)(char const *__name ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__)) abs)(int __x ) __attribute__((__nothrow__,
__const__)) ;
void *xmemdup(void const *p , size_t s ) __attribute__((__malloc__, __alloc_size__(2))) ;
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) ;
static int yyerror(parser_control const *pc __attribute__((__unused__)) , char const *s __attribute__((__unused__)) ) ;
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) ;
static yytype_uint8 const yytranslate[278] =
  { (yytype_uint8 const )0, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )26, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )27,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )25, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )23, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )24, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )1, (yytype_uint8 const )2, (yytype_uint8 const )3, (yytype_uint8 const )4,
        (yytype_uint8 const )5, (yytype_uint8 const )6, (yytype_uint8 const )7, (yytype_uint8 const )8,
        (yytype_uint8 const )9, (yytype_uint8 const )10, (yytype_uint8 const )11, (yytype_uint8 const )12,
        (yytype_uint8 const )13, (yytype_uint8 const )14, (yytype_uint8 const )15, (yytype_uint8 const )16,
        (yytype_uint8 const )17, (yytype_uint8 const )18, (yytype_uint8 const )19, (yytype_uint8 const )20,
        (yytype_uint8 const )21, (yytype_uint8 const )22};
static yytype_uint8 const yyr1[92] =
  { (yytype_uint8 const )0, (yytype_uint8 const )28, (yytype_uint8 const )29, (yytype_uint8 const )29,
        (yytype_uint8 const )30, (yytype_uint8 const )31, (yytype_uint8 const )31, (yytype_uint8 const )32,
        (yytype_uint8 const )32, (yytype_uint8 const )32, (yytype_uint8 const )32, (yytype_uint8 const )32,
        (yytype_uint8 const )32, (yytype_uint8 const )32, (yytype_uint8 const )32, (yytype_uint8 const )32,
        (yytype_uint8 const )33, (yytype_uint8 const )34, (yytype_uint8 const )35, (yytype_uint8 const )35,
        (yytype_uint8 const )35, (yytype_uint8 const )35, (yytype_uint8 const )36, (yytype_uint8 const )36,
        (yytype_uint8 const )36, (yytype_uint8 const )37, (yytype_uint8 const )37, (yytype_uint8 const )38,
        (yytype_uint8 const )39, (yytype_uint8 const )39, (yytype_uint8 const )40, (yytype_uint8 const )40,
        (yytype_uint8 const )40, (yytype_uint8 const )40, (yytype_uint8 const )40, (yytype_uint8 const )40,
        (yytype_uint8 const )40, (yytype_uint8 const )41, (yytype_uint8 const )41, (yytype_uint8 const )41,
        (yytype_uint8 const )41, (yytype_uint8 const )42, (yytype_uint8 const )42, (yytype_uint8 const )42,
        (yytype_uint8 const )42, (yytype_uint8 const )42, (yytype_uint8 const )42, (yytype_uint8 const )42,
        (yytype_uint8 const )42, (yytype_uint8 const )42, (yytype_uint8 const )43, (yytype_uint8 const )44,
        (yytype_uint8 const )44, (yytype_uint8 const )44, (yytype_uint8 const )45, (yytype_uint8 const )45,
        (yytype_uint8 const )45, (yytype_uint8 const )45, (yytype_uint8 const )45, (yytype_uint8 const )45,
        (yytype_uint8 const )45, (yytype_uint8 const )45, (yytype_uint8 const )45, (yytype_uint8 const )45,
        (yytype_uint8 const )45, (yytype_uint8 const )45, (yytype_uint8 const )45, (yytype_uint8 const )45,
        (yytype_uint8 const )45, (yytype_uint8 const )45, (yytype_uint8 const )45, (yytype_uint8 const )45,
        (yytype_uint8 const )45, (yytype_uint8 const )45, (yytype_uint8 const )45, (yytype_uint8 const )46,
        (yytype_uint8 const )46, (yytype_uint8 const )46, (yytype_uint8 const )46, (yytype_uint8 const )46,
        (yytype_uint8 const )46, (yytype_uint8 const )47, (yytype_uint8 const )48, (yytype_uint8 const )48,
        (yytype_uint8 const )49, (yytype_uint8 const )49, (yytype_uint8 const )50, (yytype_uint8 const )50,
        (yytype_uint8 const )51, (yytype_uint8 const )52, (yytype_uint8 const )53, (yytype_uint8 const )53};
static yytype_uint8 const yyr2[92] =
  { (yytype_uint8 const )0, (yytype_uint8 const )2, (yytype_uint8 const )1, (yytype_uint8 const )1,
        (yytype_uint8 const )2, (yytype_uint8 const )0, (yytype_uint8 const )2, (yytype_uint8 const )1,
        (yytype_uint8 const )1, (yytype_uint8 const )1, (yytype_uint8 const )1, (yytype_uint8 const )1,
        (yytype_uint8 const )1, (yytype_uint8 const )1, (yytype_uint8 const )1, (yytype_uint8 const )1,
        (yytype_uint8 const )1, (yytype_uint8 const )3, (yytype_uint8 const )2, (yytype_uint8 const )4,
        (yytype_uint8 const )6, (yytype_uint8 const )1, (yytype_uint8 const )2, (yytype_uint8 const )4,
        (yytype_uint8 const )6, (yytype_uint8 const )0, (yytype_uint8 const )1, (yytype_uint8 const )2,
        (yytype_uint8 const )1, (yytype_uint8 const )2, (yytype_uint8 const )1, (yytype_uint8 const )1,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )3, (yytype_uint8 const )1,
        (yytype_uint8 const )2, (yytype_uint8 const )1, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )3, (yytype_uint8 const )5, (yytype_uint8 const )3,
        (yytype_uint8 const )3, (yytype_uint8 const )2, (yytype_uint8 const )4, (yytype_uint8 const )2,
        (yytype_uint8 const )3, (yytype_uint8 const )1, (yytype_uint8 const )3, (yytype_uint8 const )2,
        (yytype_uint8 const )1, (yytype_uint8 const )1, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )1, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )1,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )1, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )1, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )1, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )1, (yytype_uint8 const )1, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2, (yytype_uint8 const )2,
        (yytype_uint8 const )2, (yytype_uint8 const )1, (yytype_uint8 const )1, (yytype_uint8 const )1,
        (yytype_uint8 const )1, (yytype_uint8 const )1, (yytype_uint8 const )1, (yytype_uint8 const )1,
        (yytype_uint8 const )1, (yytype_uint8 const )2, (yytype_uint8 const )0, (yytype_uint8 const )2};
static yytype_uint8 const yydefact[114] =
  { (yytype_uint8 const )5, (yytype_uint8 const )0, (yytype_uint8 const )0, (yytype_uint8 const )2,
        (yytype_uint8 const )3, (yytype_uint8 const )85, (yytype_uint8 const )87, (yytype_uint8 const )84,
        (yytype_uint8 const )86, (yytype_uint8 const )4, (yytype_uint8 const )82, (yytype_uint8 const )83,
        (yytype_uint8 const )1, (yytype_uint8 const )56, (yytype_uint8 const )59, (yytype_uint8 const )65,
        (yytype_uint8 const )68, (yytype_uint8 const )73, (yytype_uint8 const )62, (yytype_uint8 const )81,
        (yytype_uint8 const )37, (yytype_uint8 const )35, (yytype_uint8 const )28, (yytype_uint8 const )0,
        (yytype_uint8 const )0, (yytype_uint8 const )30, (yytype_uint8 const )0, (yytype_uint8 const )88,
        (yytype_uint8 const )0, (yytype_uint8 const )0, (yytype_uint8 const )31, (yytype_uint8 const )6,
        (yytype_uint8 const )7, (yytype_uint8 const )16, (yytype_uint8 const )8, (yytype_uint8 const )21,
        (yytype_uint8 const )9, (yytype_uint8 const )10, (yytype_uint8 const )12, (yytype_uint8 const )11,
        (yytype_uint8 const )49, (yytype_uint8 const )13, (yytype_uint8 const )52, (yytype_uint8 const )74,
        (yytype_uint8 const )53, (yytype_uint8 const )14, (yytype_uint8 const )15, (yytype_uint8 const )38,
        (yytype_uint8 const )29, (yytype_uint8 const )0, (yytype_uint8 const )45, (yytype_uint8 const )54,
        (yytype_uint8 const )57, (yytype_uint8 const )63, (yytype_uint8 const )66, (yytype_uint8 const )69,
        (yytype_uint8 const )60, (yytype_uint8 const )39, (yytype_uint8 const )36, (yytype_uint8 const )90,
        (yytype_uint8 const )32, (yytype_uint8 const )75, (yytype_uint8 const )76, (yytype_uint8 const )78,
        (yytype_uint8 const )79, (yytype_uint8 const )80, (yytype_uint8 const )77, (yytype_uint8 const )55,
        (yytype_uint8 const )58, (yytype_uint8 const )64, (yytype_uint8 const )67, (yytype_uint8 const )70,
        (yytype_uint8 const )61, (yytype_uint8 const )40, (yytype_uint8 const )18, (yytype_uint8 const )47,
        (yytype_uint8 const )90, (yytype_uint8 const )0, (yytype_uint8 const )0, (yytype_uint8 const )22,
        (yytype_uint8 const )89, (yytype_uint8 const )71, (yytype_uint8 const )72, (yytype_uint8 const )33,
        (yytype_uint8 const )0, (yytype_uint8 const )51, (yytype_uint8 const )44, (yytype_uint8 const )0,
        (yytype_uint8 const )0, (yytype_uint8 const )34, (yytype_uint8 const )43, (yytype_uint8 const )48,
        (yytype_uint8 const )50, (yytype_uint8 const )27, (yytype_uint8 const )25, (yytype_uint8 const )41,
        (yytype_uint8 const )0, (yytype_uint8 const )17, (yytype_uint8 const )46, (yytype_uint8 const )91,
        (yytype_uint8 const )19, (yytype_uint8 const )90, (yytype_uint8 const )0, (yytype_uint8 const )23,
        (yytype_uint8 const )26, (yytype_uint8 const )0, (yytype_uint8 const )0, (yytype_uint8 const )25,
        (yytype_uint8 const )42, (yytype_uint8 const )25, (yytype_uint8 const )20, (yytype_uint8 const )24,
        (yytype_uint8 const )0, (yytype_uint8 const )25};
static yytype_int8 const yydefgoto[26] =
  { (yytype_int8 const )-1, (yytype_int8 const )2, (yytype_int8 const )3, (yytype_int8 const )4,
        (yytype_int8 const )31, (yytype_int8 const )32, (yytype_int8 const )33, (yytype_int8 const )34,
        (yytype_int8 const )35, (yytype_int8 const )103, (yytype_int8 const )104, (yytype_int8 const )36,
        (yytype_int8 const )37, (yytype_int8 const )38, (yytype_int8 const )39, (yytype_int8 const )40,
        (yytype_int8 const )41, (yytype_int8 const )42, (yytype_int8 const )43, (yytype_int8 const )44,
        (yytype_int8 const )9, (yytype_int8 const )10, (yytype_int8 const )11, (yytype_int8 const )45,
        (yytype_int8 const )46, (yytype_int8 const )93};
static yytype_int8 const yypact[114] =
  { (yytype_int8 const )38, (yytype_int8 const )27, (yytype_int8 const )77, (yytype_int8 const )-93,
        (yytype_int8 const )46, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )62, (yytype_int8 const )-93, (yytype_int8 const )82, (yytype_int8 const )-3,
        (yytype_int8 const )66, (yytype_int8 const )3, (yytype_int8 const )74, (yytype_int8 const )-4,
        (yytype_int8 const )83, (yytype_int8 const )84, (yytype_int8 const )75, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )71, (yytype_int8 const )-93, (yytype_int8 const )93, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )78, (yytype_int8 const )72, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )25,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )21,
        (yytype_int8 const )19, (yytype_int8 const )79, (yytype_int8 const )80, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )81, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )85,
        (yytype_int8 const )86, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-6, (yytype_int8 const )76,
        (yytype_int8 const )17, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )87, (yytype_int8 const )69, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )88, (yytype_int8 const )89, (yytype_int8 const )-1,
        (yytype_int8 const )-93, (yytype_int8 const )18, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )69, (yytype_int8 const )91};
static yytype_int8 const yypgoto[26] =
  { (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )20, (yytype_int8 const )-68, (yytype_int8 const )-27, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )60, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )-93, (yytype_int8 const )-92, (yytype_int8 const )-93,
        (yytype_int8 const )-93, (yytype_int8 const )43};
static yytype_uint8 const yytable[113] =
  { (yytype_uint8 const )79, (yytype_uint8 const )67, (yytype_uint8 const )68, (yytype_uint8 const )69,
        (yytype_uint8 const )70, (yytype_uint8 const )71, (yytype_uint8 const )72, (yytype_uint8 const )58,
        (yytype_uint8 const )73, (yytype_uint8 const )100, (yytype_uint8 const )107, (yytype_uint8 const )74,
        (yytype_uint8 const )75, (yytype_uint8 const )101, (yytype_uint8 const )110, (yytype_uint8 const )76,
        (yytype_uint8 const )49, (yytype_uint8 const )50, (yytype_uint8 const )101, (yytype_uint8 const )102,
        (yytype_uint8 const )113, (yytype_uint8 const )77, (yytype_uint8 const )59, (yytype_uint8 const )78,
        (yytype_uint8 const )61, (yytype_uint8 const )62, (yytype_uint8 const )63, (yytype_uint8 const )64,
        (yytype_uint8 const )65, (yytype_uint8 const )66, (yytype_uint8 const )61, (yytype_uint8 const )62,
        (yytype_uint8 const )63, (yytype_uint8 const )64, (yytype_uint8 const )65, (yytype_uint8 const )66,
        (yytype_uint8 const )101, (yytype_uint8 const )101, (yytype_uint8 const )92, (yytype_uint8 const )111,
        (yytype_uint8 const )90, (yytype_uint8 const )91, (yytype_uint8 const )106, (yytype_uint8 const )112,
        (yytype_uint8 const )88, (yytype_uint8 const )111, (yytype_uint8 const )5, (yytype_uint8 const )6,
        (yytype_uint8 const )7, (yytype_uint8 const )8, (yytype_uint8 const )88, (yytype_uint8 const )13,
        (yytype_uint8 const )14, (yytype_uint8 const )15, (yytype_uint8 const )16, (yytype_uint8 const )17,
        (yytype_uint8 const )18, (yytype_uint8 const )19, (yytype_uint8 const )20, (yytype_uint8 const )21,
        (yytype_uint8 const )22, (yytype_uint8 const )1, (yytype_uint8 const )23, (yytype_uint8 const )24,
        (yytype_uint8 const )25, (yytype_uint8 const )26, (yytype_uint8 const )27, (yytype_uint8 const )28,
        (yytype_uint8 const )29, (yytype_uint8 const )79, (yytype_uint8 const )30, (yytype_uint8 const )51,
        (yytype_uint8 const )52, (yytype_uint8 const )53, (yytype_uint8 const )54, (yytype_uint8 const )55,
        (yytype_uint8 const )56, (yytype_uint8 const )12, (yytype_uint8 const )57, (yytype_uint8 const )61,
        (yytype_uint8 const )62, (yytype_uint8 const )63, (yytype_uint8 const )64, (yytype_uint8 const )65,
        (yytype_uint8 const )66, (yytype_uint8 const )60, (yytype_uint8 const )48, (yytype_uint8 const )80,
        (yytype_uint8 const )47, (yytype_uint8 const )6, (yytype_uint8 const )83, (yytype_uint8 const )8,
        (yytype_uint8 const )81, (yytype_uint8 const )82, (yytype_uint8 const )26, (yytype_uint8 const )84,
        (yytype_uint8 const )85, (yytype_uint8 const )86, (yytype_uint8 const )87, (yytype_uint8 const )94,
        (yytype_uint8 const )95, (yytype_uint8 const )96, (yytype_uint8 const )89, (yytype_uint8 const )105,
        (yytype_uint8 const )97, (yytype_uint8 const )98, (yytype_uint8 const )99, (yytype_uint8 const )0,
        (yytype_uint8 const )108, (yytype_uint8 const )109, (yytype_uint8 const )101, (yytype_uint8 const )0,
        (yytype_uint8 const )88};
static yytype_int8 const yycheck[113] =
  { (yytype_int8 const )27, (yytype_int8 const )5, (yytype_int8 const )6, (yytype_int8 const )7,
        (yytype_int8 const )8, (yytype_int8 const )9, (yytype_int8 const )10, (yytype_int8 const )4,
        (yytype_int8 const )12, (yytype_int8 const )15, (yytype_int8 const )102, (yytype_int8 const )15,
        (yytype_int8 const )16, (yytype_int8 const )19, (yytype_int8 const )15, (yytype_int8 const )19,
        (yytype_int8 const )19, (yytype_int8 const )20, (yytype_int8 const )19, (yytype_int8 const )25,
        (yytype_int8 const )112, (yytype_int8 const )25, (yytype_int8 const )19, (yytype_int8 const )27,
        (yytype_int8 const )5, (yytype_int8 const )6, (yytype_int8 const )7, (yytype_int8 const )8,
        (yytype_int8 const )9, (yytype_int8 const )10, (yytype_int8 const )5, (yytype_int8 const )6,
        (yytype_int8 const )7, (yytype_int8 const )8, (yytype_int8 const )9, (yytype_int8 const )10,
        (yytype_int8 const )19, (yytype_int8 const )19, (yytype_int8 const )19, (yytype_int8 const )107,
        (yytype_int8 const )19, (yytype_int8 const )20, (yytype_int8 const )25, (yytype_int8 const )25,
        (yytype_int8 const )25, (yytype_int8 const )113, (yytype_int8 const )19, (yytype_int8 const )20,
        (yytype_int8 const )21, (yytype_int8 const )22, (yytype_int8 const )25, (yytype_int8 const )5,
        (yytype_int8 const )6, (yytype_int8 const )7, (yytype_int8 const )8, (yytype_int8 const )9,
        (yytype_int8 const )10, (yytype_int8 const )11, (yytype_int8 const )12, (yytype_int8 const )13,
        (yytype_int8 const )14, (yytype_int8 const )23, (yytype_int8 const )16, (yytype_int8 const )17,
        (yytype_int8 const )18, (yytype_int8 const )19, (yytype_int8 const )20, (yytype_int8 const )21,
        (yytype_int8 const )22, (yytype_int8 const )96, (yytype_int8 const )24, (yytype_int8 const )5,
        (yytype_int8 const )6, (yytype_int8 const )7, (yytype_int8 const )8, (yytype_int8 const )9,
        (yytype_int8 const )10, (yytype_int8 const )0, (yytype_int8 const )12, (yytype_int8 const )5,
        (yytype_int8 const )6, (yytype_int8 const )7, (yytype_int8 const )8, (yytype_int8 const )9,
        (yytype_int8 const )10, (yytype_int8 const )25, (yytype_int8 const )4, (yytype_int8 const )27,
        (yytype_int8 const )26, (yytype_int8 const )20, (yytype_int8 const )30, (yytype_int8 const )22,
        (yytype_int8 const )9, (yytype_int8 const )9, (yytype_int8 const )19, (yytype_int8 const )24,
        (yytype_int8 const )3, (yytype_int8 const )19, (yytype_int8 const )26, (yytype_int8 const )20,
        (yytype_int8 const )20, (yytype_int8 const )20, (yytype_int8 const )59, (yytype_int8 const )27,
        (yytype_int8 const )84, (yytype_int8 const )20, (yytype_int8 const )20, (yytype_int8 const )-1,
        (yytype_int8 const )20, (yytype_int8 const )20, (yytype_int8 const )19, (yytype_int8 const )-1,
        (yytype_int8 const )25};
static yytype_uint8 const yystos[114] =
  { (yytype_uint8 const )0, (yytype_uint8 const )23, (yytype_uint8 const )29, (yytype_uint8 const )30,
        (yytype_uint8 const )31, (yytype_uint8 const )19, (yytype_uint8 const )20, (yytype_uint8 const )21,
        (yytype_uint8 const )22, (yytype_uint8 const )48, (yytype_uint8 const )49, (yytype_uint8 const )50,
        (yytype_uint8 const )0, (yytype_uint8 const )5, (yytype_uint8 const )6, (yytype_uint8 const )7,
        (yytype_uint8 const )8, (yytype_uint8 const )9, (yytype_uint8 const )10, (yytype_uint8 const )11,
        (yytype_uint8 const )12, (yytype_uint8 const )13, (yytype_uint8 const )14, (yytype_uint8 const )16,
        (yytype_uint8 const )17, (yytype_uint8 const )18, (yytype_uint8 const )19, (yytype_uint8 const )20,
        (yytype_uint8 const )21, (yytype_uint8 const )22, (yytype_uint8 const )24, (yytype_uint8 const )32,
        (yytype_uint8 const )33, (yytype_uint8 const )34, (yytype_uint8 const )35, (yytype_uint8 const )36,
        (yytype_uint8 const )39, (yytype_uint8 const )40, (yytype_uint8 const )41, (yytype_uint8 const )42,
        (yytype_uint8 const )43, (yytype_uint8 const )44, (yytype_uint8 const )45, (yytype_uint8 const )46,
        (yytype_uint8 const )47, (yytype_uint8 const )51, (yytype_uint8 const )52, (yytype_uint8 const )26,
        (yytype_uint8 const )4, (yytype_uint8 const )19, (yytype_uint8 const )20, (yytype_uint8 const )5,
        (yytype_uint8 const )6, (yytype_uint8 const )7, (yytype_uint8 const )8, (yytype_uint8 const )9,
        (yytype_uint8 const )10, (yytype_uint8 const )12, (yytype_uint8 const )4, (yytype_uint8 const )19,
        (yytype_uint8 const )46, (yytype_uint8 const )5, (yytype_uint8 const )6, (yytype_uint8 const )7,
        (yytype_uint8 const )8, (yytype_uint8 const )9, (yytype_uint8 const )10, (yytype_uint8 const )5,
        (yytype_uint8 const )6, (yytype_uint8 const )7, (yytype_uint8 const )8, (yytype_uint8 const )9,
        (yytype_uint8 const )10, (yytype_uint8 const )12, (yytype_uint8 const )15, (yytype_uint8 const )16,
        (yytype_uint8 const )19, (yytype_uint8 const )25, (yytype_uint8 const )27, (yytype_uint8 const )38,
        (yytype_uint8 const )46, (yytype_uint8 const )9, (yytype_uint8 const )9, (yytype_uint8 const )46,
        (yytype_uint8 const )24, (yytype_uint8 const )3, (yytype_uint8 const )19, (yytype_uint8 const )26,
        (yytype_uint8 const )25, (yytype_uint8 const )53, (yytype_uint8 const )19, (yytype_uint8 const )20,
        (yytype_uint8 const )19, (yytype_uint8 const )53, (yytype_uint8 const )20, (yytype_uint8 const )20,
        (yytype_uint8 const )20, (yytype_uint8 const )36, (yytype_uint8 const )20, (yytype_uint8 const )20,
        (yytype_uint8 const )15, (yytype_uint8 const )19, (yytype_uint8 const )25, (yytype_uint8 const )37,
        (yytype_uint8 const )38, (yytype_uint8 const )27, (yytype_uint8 const )25, (yytype_uint8 const )50,
        (yytype_uint8 const )20, (yytype_uint8 const )20, (yytype_uint8 const )15, (yytype_uint8 const )37,
        (yytype_uint8 const )25, (yytype_uint8 const )50};
int yyparse(parser_control *pc ) ;
static table const meridian_table[5] = { {(char const *)"AM", 270, 0},
        {(char const *)"A.M.", 270, 0},
        {(char const *)"PM", 270, 1},
        {(char const *)"P.M.", 270, 1},
        {(char const *)((void *)0), 0, 0}};
static table const dst_table[1] = { {(char const *)"DST", 259, 0}};
static table const month_and_day_table[25] =
  { {(char const *)"JANUARY", 271, 1},
        {(char const *)"FEBRUARY", 271, 2},
        {(char const *)"MARCH", 271, 3},
        {(char const *)"APRIL", 271, 4},
        {(char const *)"MAY", 271, 5},
        {(char const *)"JUNE", 271, 6},
        {(char const *)"JULY", 271, 7},
        {(char const *)"AUGUST", 271, 8},
        {(char const *)"SEPTEMBER", 271, 9},
        {(char const *)"SEPT", 271, 9},
        {(char const *)"OCTOBER", 271, 10},
        {(char const *)"NOVEMBER", 271, 11},
        {(char const *)"DECEMBER", 271, 12},
        {(char const *)"SUNDAY", 267, 0},
        {(char const *)"MONDAY", 267, 1},
        {(char const *)"TUESDAY", 267, 2},
        {(char const *)"TUES", 267, 2},
        {(char const *)"WEDNESDAY", 267, 3},
        {(char const *)"WEDNES", 267, 3},
        {(char const *)"THURSDAY", 267, 4},
        {(char const *)"THUR", 267, 4},
        {(char const *)"THURS", 267, 4},
        {(char const *)"FRIDAY", 267, 5},
        {(char const *)"SATURDAY", 267, 6},
        {(char const *)((void *)0), 0, 0}};
static table const time_units_table[11] =
  { {(char const *)"YEAR", 260, 1},
        {(char const *)"MONTH", 261, 1},
        {(char const *)"FORTNIGHT", 265, 14},
        {(char const *)"WEEK", 265, 7},
        {(char const *)"DAY", 265, 1},
        {(char const *)"HOUR", 262, 1},
        {(char const *)"MINUTE", 263, 1},
        {(char const *)"MIN", 263, 1},
        {(char const *)"SECOND", 264, 1},
        {(char const *)"SEC", 264, 1},
        {(char const *)((void *)0), 0, 0}};
static table const relative_time_table[20] =
  { {(char const *)"TOMORROW", 266, 1},
        {(char const *)"YESTERDAY", 266, -1},
        {(char const *)"TODAY", 266, 0},
        {(char const *)"NOW", 266, 0},
        {(char const *)"LAST", 272, -1},
        {(char const *)"THIS", 272, 0},
        {(char const *)"NEXT", 272, 1},
        {(char const *)"FIRST", 272, 1},
        {(char const *)"THIRD", 272, 3},
        {(char const *)"FOURTH", 272, 4},
        {(char const *)"FIFTH", 272, 5},
        {(char const *)"SIXTH", 272, 6},
        {(char const *)"SEVENTH", 272, 7},
        {(char const *)"EIGHTH", 272, 8},
        {(char const *)"NINTH", 272, 9},
        {(char const *)"TENTH", 272, 10},
        {(char const *)"ELEVENTH", 272, 11},
        {(char const *)"TWELFTH", 272, 12},
        {(char const *)"AGO", 258, 1},
        {(char const *)((void *)0), 0, 0}};
static table const universal_time_zone_table[4] = { {(char const *)"GMT", 273, 0},
        {(char const *)"UT", 273, 0},
        {(char const *)"UTC", 273, 0},
        {(char const *)((void *)0), 0, 0}};
static table const time_zone_table[48] =
  { {(char const *)"WET", 273, 0},
        {(char const *)"WEST", 268, 0},
        {(char const *)"BST", 268, 0},
        {(char const *)"ART", 273, -180},
        {(char const *)"BRT", 273, -180},
        {(char const *)"BRST", 268, -180},
        {(char const *)"NST", 273, -210},
        {(char const *)"NDT", 268, -210},
        {(char const *)"AST", 273, -240},
        {(char const *)"ADT", 268, -240},
        {(char const *)"CLT", 273, -240},
        {(char const *)"CLST", 268, -240},
        {(char const *)"EST", 273, -300},
        {(char const *)"EDT", 268, -300},
        {(char const *)"CST", 273, -360},
        {(char const *)"CDT", 268, -360},
        {(char const *)"MST", 273, -420},
        {(char const *)"MDT", 268, -420},
        {(char const *)"PST", 273, -480},
        {(char const *)"PDT", 268, -480},
        {(char const *)"AKST", 273, -540},
        {(char const *)"AKDT", 268, -540},
        {(char const *)"HST", 273, -600},
        {(char const *)"HAST", 273, -600},
        {(char const *)"HADT", 268, -600},
        {(char const *)"SST", 273, -720},
        {(char const *)"WAT", 273, 60},
        {(char const *)"CET", 273, 60},
        {(char const *)"CEST", 268, 60},
        {(char const *)"MET", 273, 60},
        {(char const *)"MEZ", 273, 60},
        {(char const *)"MEST", 268, 60},
        {(char const *)"MESZ", 268, 60},
        {(char const *)"EET", 273, 120},
        {(char const *)"EEST", 268, 120},
        {(char const *)"CAT", 273, 120},
        {(char const *)"SAST", 273, 120},
        {(char const *)"EAT", 273, 180},
        {(char const *)"MSK", 273, 180},
        {(char const *)"MSD", 268, 180},
        {(char const *)"IST", 273, 330},
        {(char const *)"SGT", 273, 480},
        {(char const *)"KST", 273, 540},
        {(char const *)"JST", 273, 540},
        {(char const *)"GST", 273, 600},
        {(char const *)"NZST", 273, 720},
        {(char const *)"NZDT", 268, 720},
        {(char const *)((void *)0), 0, 0}};
static table const military_table[26] =
  { {(char const *)"A", 273, -60},
        {(char const *)"B", 273, -120},
        {(char const *)"C", 273, -180},
        {(char const *)"D", 273, -240},
        {(char const *)"E", 273, -300},
        {(char const *)"F", 273, -360},
        {(char const *)"G", 273, -420},
        {(char const *)"H", 273, -480},
        {(char const *)"I", 273, -540},
        {(char const *)"K", 273, -600},
        {(char const *)"L", 273, -660},
        {(char const *)"M", 273, -720},
        {(char const *)"N", 273, 60},
        {(char const *)"O", 273, 120},
        {(char const *)"P", 273, 180},
        {(char const *)"Q", 273, 240},
        {(char const *)"R", 273, 300},
        {(char const *)"S", 273, 360},
        {(char const *)"T", 'T', 0},
        {(char const *)"U", 273, 480},
        {(char const *)"V", 273, 540},
        {(char const *)"W", 273, 600},
        {(char const *)"X", 273, 660},
        {(char const *)"Y", 273, 720},
        {(char const *)"Z", 273, 0},
        {(char const *)((void *)0), 0, 0}};
#pragma merger(0,"/tmp/cil-WwMfVP89.i","-g,-O2")
double physmem_total(void) ;
double physmem_available(void) ;
#pragma merger(0,"/tmp/cil-on_zPMlc.i","-g,-O2")
_Bool posixtime(time_t *p , char const *s , unsigned int syntax_bits ) ;
#pragma merger(0,"/tmp/cil-ShGSTOeq.i","-g,-O2")
int posix2_version(void) ;
#pragma merger(0,"/tmp/cil-bzo9m3Ho.i","-g,-O2")
double printf_frexp(double x , int *expptr ) ;
extern double frexp(double __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern double ldexp(double __x , int __exponent ) __attribute__((__nothrow__)) ;
__inline extern int __signbit(double __x ) __attribute__((__nothrow__, __const__)) ;
__inline extern int __signbitf(float __x ) __attribute__((__nothrow__, __const__)) ;
__inline extern int __signbitl(long double __x ) __attribute__((__nothrow__, __const__)) ;
#pragma merger(0,"/tmp/cil-uah7zclW.i","-g,-O2")
long double printf_frexpl(long double x , int *expptr ) ;
extern long double frexpl(long double __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern long double ldexpl(long double __x , int __exponent ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-fQpo8Tdw.i","-g,-O2")
#pragma merger(0,"/tmp/cil-gaptO2Fa.i","-g,-O2")
char const *program_name ;
void set_program_name(char const *argv0 ) ;
extern char *program_invocation_name ;
extern char *program_invocation_short_name ;
extern int fputs(char const * __restrict __s , FILE * __restrict __stream ) ;
char const *program_name = (char const *)((void *)0);
#pragma merger(0,"/tmp/cil-6xF3RmjC.i","-g,-O2")
char const *proper_name(char const *name ) ;
char const *proper_name_utf8(char const *name_ascii , char const *name_utf8 ) ;
char *trim2(char const *s , int how ) ;
extern int iswalnum(wint_t __wc ) __attribute__((__nothrow__)) ;
char *xstr_iconv(char const *src , char const *from_codeset , char const *to_codeset ) ;
#pragma merger(0,"/tmp/cil-8tfy6zmw.i","-g,-O2")
#pragma merger(0,"/tmp/cil-oyrYr0EJ.i","-g,-O2")
char const *quoting_style_args[9] ;
enum quoting_style const quoting_style_vals[8] ;
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
int set_quoting_flags(struct quoting_options *o , int i ) ;
void set_custom_quoting(struct quoting_options *o , char const *left_quote , char const *right_quote ) ;
size_t quotearg_buffer(char *buffer , size_t buffersize , char const *arg , size_t argsize ,
                       struct quoting_options const *o ) ;
char *quotearg_alloc(char const *arg , size_t argsize , struct quoting_options const *o ) ;
char *quotearg_alloc_mem(char const *arg , size_t argsize , size_t *size , struct quoting_options const *o ) ;
char *quotearg_n(int n , char const *arg ) ;
char *quotearg(char const *arg ) ;
char *quotearg_n_mem(int n , char const *arg , size_t argsize ) ;
char *quotearg_mem(char const *arg , size_t argsize ) ;
char *quotearg_n_style_mem(int n , enum quoting_style s , char const *arg , size_t argsize ) ;
char *quotearg_style(enum quoting_style s , char const *arg ) ;
char *quotearg_style_mem(enum quoting_style s , char const *arg , size_t argsize ) ;
char *quotearg_char(char const *arg , char ch ) ;
char *quotearg_char_mem(char const *arg , size_t argsize , char ch ) ;
char *quotearg_colon_mem(char const *arg , size_t argsize ) ;
char *quotearg_n_custom(int n , char const *left_quote , char const *right_quote ,
                        char const *arg ) ;
char *quotearg_n_custom_mem(int n , char const *left_quote , char const *right_quote ,
                            char const *arg , size_t argsize ) ;
char *quotearg_custom(char const *left_quote , char const *right_quote , char const *arg ) ;
char *quotearg_custom_mem(char const *left_quote , char const *right_quote , char const *arg ,
                          size_t argsize ) ;
void quotearg_free(void) ;
__inline static char *xcharalloc(size_t n ) __attribute__((__malloc__, __alloc_size__(1))) ;
char const *quoting_style_args[9] =
  { (char const *)"literal", (char const *)"shell", (char const *)"shell-always", (char const *)"c",
        (char const *)"c-maybe", (char const *)"escape", (char const *)"locale", (char const *)"clocale",
        (char const *)0};
enum quoting_style const quoting_style_vals[8] =
  { (enum quoting_style const )0, (enum quoting_style const )1, (enum quoting_style const )2, (enum quoting_style const )3,
        (enum quoting_style const )4, (enum quoting_style const )5, (enum quoting_style const )6, (enum quoting_style const )7};
static struct quoting_options default_quoting_options ;
static char slot0[256] ;
static unsigned int nslots = 1U;
static struct slotvec slotvec0 = {sizeof(slot0), slot0};
static struct slotvec *slotvec = & slotvec0;
#pragma merger(0,"/tmp/cil-7HWZ0uWi.i","-g,-O2")
struct randread_source *randread_new(char const *name , size_t bytes_bound ) ;
void randread(struct randread_source *s , void *buf___1 , size_t size ) ;
int randread_free(struct randread_source *s ) ;
struct randint_source *randint_new(struct randread_source *source ) ;
struct randint_source *randint_all_new(char const *name , size_t bytes_bound ) ;
struct randread_source *randint_get_source(struct randint_source const *s ) __attribute__((__pure__)) ;
randint randint_genmax(struct randint_source *s , randint genmax ) ;
void randint_free(struct randint_source *s ) ;
int randint_all_free(struct randint_source *s ) ;
#pragma merger(0,"/tmp/cil-0BOtTqI0.i","-g,-O2")
size_t randperm_bound(size_t h , size_t n ) __attribute__((__const__)) ;
size_t *randperm_new(struct randint_source *r , size_t h , size_t n ) ;
static size_t ceil_lg(size_t n ) __attribute__((__const__)) ;
#pragma merger(0,"/tmp/cil-v3MUAwyu.i","-g,-O2")
void randread_set_handler(struct randread_source *s , void (*handler)(void const * ) ) ;
void randread_set_handler_arg(struct randread_source *s , void const *handler_arg ) ;
extern int setvbuf(FILE * __restrict __stream , char * __restrict __buf , int __modes ,
                   size_t __n ) __attribute__((__nothrow__)) ;
extern __pid_t getpid(void) __attribute__((__nothrow__)) ;
extern __pid_t getppid(void) __attribute__((__nothrow__)) ;
extern __uid_t getuid(void) __attribute__((__nothrow__)) ;
extern __gid_t getgid(void) __attribute__((__nothrow__)) ;
void isaac_seed(struct isaac_state *s ) ;
void isaac_refill(struct isaac_state *s , isaac_word *result ) ;
static void randread_error(void const *file_name___1 ) __attribute__((__noreturn__)) ;
#pragma merger(0,"/tmp/cil-44Mo5Xx5.i","-g,-O2")
#pragma merger(0,"/tmp/cil-y_NeEj3u.i","-g,-O2")
extern __off_t ( __attribute__((__warn_unused_result__)) ftello)(FILE *__stream ) ;
char *fread_file(FILE *stream , size_t *length ) ;
char *read_file(char const *filename , size_t *length ) ;
char *read_binary_file(char const *filename , size_t *length ) ;
#pragma merger(0,"/tmp/cil-mIT4Qyw4.i","-g,-O2")
void init_tokenbuffer(token_buffer *tokenbuffer ) ;
size_t readtoken(FILE *stream , char const *delim , size_t n_delim , token_buffer *tokenbuffer ) ;
size_t readtokens(FILE *stream , size_t projected_n_tokens , char const *delim ,
                  size_t n_delim , char ***tokens_out , size_t **token_lengths ) ;
static char const *saved_delim = (char const *)((void *)0);
static char isdelim[256] ;
#pragma merger(0,"/tmp/cil-oA7qXEd3.i","-g,-O2")
extern void _obstack_newchunk(struct obstack * , int ) ;
extern int _obstack_begin(struct obstack * , int , int , void *(*)(long ) , void (*)(void * ) ) ;
extern void obstack_free(struct obstack *obstack , void *block ) ;
void readtokens0_init(struct Tokens *t ) ;
void readtokens0_free(struct Tokens *t ) ;
_Bool readtokens0(FILE *in , struct Tokens *t ) ;
#pragma merger(0,"/tmp/cil-DPlbovAN.i","-g,-O2")
#pragma merger(0,"/tmp/cil-ohokMdhK.i","-g,-O2")
extern ssize_t ( __attribute__((__warn_unused_result__)) write)(int __fd , void const *__buf ,
                                                                size_t __n ) ;
#pragma merger(0,"/tmp/cil-cQzva3c7.i","-g,-O2")
#pragma merger(0,"/tmp/cil-0qLmlpro.i","-g,-O2")
int save_cwd(struct saved_cwd *cwd ) ;
int restore_cwd(struct saved_cwd const *cwd ) ;
void free_cwd(struct saved_cwd *cwd ) ;
extern int ( __attribute__((__warn_unused_result__)) fchdir)(int __fd ) __attribute__((__nothrow__)) ;
char *rpl_getcwd(char *buf___1 , size_t size ) ;
int chdir_long(char *dir ) ;
#pragma merger(0,"/tmp/cil-YVxi3MsA.i","-g,-O2")
char *streamsavedir(DIR *dirp ) ;
char *savedir(char const *dir ) ;
char *fdsavedir(int fd ) ;
#pragma merger(0,"/tmp/cil-5AtEW1rz.i","-g,-O2")
int savewd_restore(struct savewd *wd , int status ) ;
void savewd_finish(struct savewd *wd ) ;
int savewd_process_files(int n_files , char **file , int (*act)(char * , struct savewd * ,
                                                                void * ) , void *options ) ;
__inline extern int __sigismember(__sigset_t const *__set , int __sig ) ;
__inline extern int __sigaddset(__sigset_t *__set , int __sig ) ;
__inline extern int __sigdelset(__sigset_t *__set , int __sig ) ;
extern int raise(int __sig ) __attribute__((__nothrow__)) ;
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) chdir)(char const *__path ) __attribute__((__nothrow__)) ;
extern __pid_t fork(void) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-MsxcN7lb.i","-g,-O2")
int settime(struct timespec const *ts ) ;
extern int ( __attribute__((__nonnull__(1))) settimeofday)(struct timeval const *__tv ,
                                                           struct timezone const *__tz ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-5JpnMsaY.i","-g,-O2")
int gl_sockets_startup(int version __attribute__((__unused__)) ) ;
int gl_sockets_cleanup(void) ;
#pragma merger(0,"/tmp/cil-PHAu3dOE.i","-g,-O2")
int mkstemp_safer(char *templ ) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkstemp)(char *__template ) ;
#pragma merger(0,"/tmp/cil-Vgk3scc8.i","-g,-O2")
size_t nstrftime(char *s , size_t maxsize , char const *format , struct tm const *tp ,
                 int ut , int ns ) ;
#pragma merger(0,"/tmp/cil-0_WHvV_A.i","-g,-O2")
extern iconv_t iconv_open(char const *__tocode , char const *__fromcode ) ;
extern size_t iconv(iconv_t __cd , char ** __restrict __inbuf , size_t * __restrict __inbytesleft ,
                    char ** __restrict __outbuf , size_t * __restrict __outbytesleft ) ;
extern int iconv_close(iconv_t __cd ) ;
int mem_cd_iconv(char const *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) ;
char *str_cd_iconv(char const *src , iconv_t cd ) ;
char *str_iconv(char const *src , char const *from_codeset , char const *to_codeset ) ;
#pragma merger(0,"/tmp/cil-PT4ALSOV.i","-g,-O2")
#pragma merger(0,"/tmp/cil-ej3yjBll.i","-g,-O2")
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) ;
int gen_tempname_len(char *tmpl , int suffixlen , int flags , int kind , size_t x_suffix_len ) ;
static char const letters[63] =
  { (char const )'a', (char const )'b', (char const )'c', (char const )'d',
        (char const )'e', (char const )'f', (char const )'g', (char const )'h',
        (char const )'i', (char const )'j', (char const )'k', (char const )'l',
        (char const )'m', (char const )'n', (char const )'o', (char const )'p',
        (char const )'q', (char const )'r', (char const )'s', (char const )'t',
        (char const )'u', (char const )'v', (char const )'w', (char const )'x',
        (char const )'y', (char const )'z', (char const )'A', (char const )'B',
        (char const )'C', (char const )'D', (char const )'E', (char const )'F',
        (char const )'G', (char const )'H', (char const )'I', (char const )'J',
        (char const )'K', (char const )'L', (char const )'M', (char const )'N',
        (char const )'O', (char const )'P', (char const )'Q', (char const )'R',
        (char const )'S', (char const )'T', (char const )'U', (char const )'V',
        (char const )'W', (char const )'X', (char const )'Y', (char const )'Z',
        (char const )'0', (char const )'1', (char const )'2', (char const )'3',
        (char const )'4', (char const )'5', (char const )'6', (char const )'7',
        (char const )'8', (char const )'9', (char const )'\000'};
#pragma merger(0,"/tmp/cil-tTwHArME.i","-g,-O2")
#pragma merger(0,"/tmp/cil-xo72We8h.i","-g,-O2")
#pragma weak pthread_key_create
#pragma weak pthread_getspecific
#pragma weak pthread_setspecific
#pragma weak pthread_key_delete
#pragma weak pthread_self
#pragma weak pthread_cancel
#pragma merger(0,"/tmp/cil-ObCOUqiD.i","-g,-O2")
extern int iswspace(wint_t __wc ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-dAqw1FYr.i","-g,-O2")
long unicode_to_mb(unsigned int code , long (*success)(char const *buf , size_t buflen ,
                                                       void *callback_arg ) , long (*failure)(unsigned int code ,
                                                                                              char const *msg ,
                                                                                              void *callback_arg ) ,
                   void *callback_arg ) ;
void print_unicode_char(FILE *stream , unsigned int code , int exit_on_error ) ;
long fwrite_success_callback(char const *buf___1 , size_t buflen , void *callback_arg ) ;
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) ;
static int initialized ;
static int is_utf8 ;
static iconv_t utf8_to_local ;
#pragma merger(0,"/tmp/cil-AYi53tKk.i","-g,-O2")
#pragma merger(0,"/tmp/cil-ukxG3iMV.i","-g,-O2")
#pragma merger(0,"/tmp/cil-fayStalQ.i","-g,-O2")
int pipe_safer(int *fd ) ;
extern int ( __attribute__((__warn_unused_result__)) pipe)(int *__pipedes ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-EauEI7tM.i","-g,-O2")
int u8_mbtoucr(ucs4_t *puc , uint8_t const *s , size_t n ) ;
#pragma merger(0,"/tmp/cil-bFKmN8Ow.i","-g,-O2")
#pragma merger(0,"/tmp/cil-udMJcUwR.i","-g,-O2")
#pragma merger(0,"/tmp/cil-jSfps0FA.i","-g,-O2")
int uc_width(ucs4_t uc , char const *encoding ) ;
static unsigned char const nonspacing_table_data[1728] =
  { (unsigned char const )255, (unsigned char const )255, (unsigned char const )255, (unsigned char const )255,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )128,
        (unsigned char const )255, (unsigned char const )255, (unsigned char const )255, (unsigned char const )255,
        (unsigned char const )0, (unsigned char const )32, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )255, (unsigned char const )255, (unsigned char const )255, (unsigned char const )255,
        (unsigned char const )255, (unsigned char const )255, (unsigned char const )255, (unsigned char const )255,
        (unsigned char const )255, (unsigned char const )255, (unsigned char const )255, (unsigned char const )255,
        (unsigned char const )255, (unsigned char const )255, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )248, (unsigned char const )3, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )254, (unsigned char const )255,
        (unsigned char const )255, (unsigned char const )255, (unsigned char const )255, (unsigned char const )191,
        (unsigned char const )182, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )15, (unsigned char const )0, (unsigned char const )255, (unsigned char const )7,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )248, (unsigned char const )255, (unsigned char const )255,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )1, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )192, (unsigned char const )191,
        (unsigned char const )159, (unsigned char const )61, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )128, (unsigned char const )2, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )255, (unsigned char const )255,
        (unsigned char const )255, (unsigned char const )7, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )192, (unsigned char const )255, (unsigned char const )1, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )248, (unsigned char const )15, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )192, (unsigned char const )251,
        (unsigned char const )239, (unsigned char const )62, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )14,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )7, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )20,
        (unsigned char const )254, (unsigned char const )33, (unsigned char const )254, (unsigned char const )0,
        (unsigned char const )12, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )2, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )16,
        (unsigned char const )30, (unsigned char const )32, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )12, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )6, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )16,
        (unsigned char const )134, (unsigned char const )57, (unsigned char const )2, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )35, (unsigned char const )0,
        (unsigned char const )6, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )16,
        (unsigned char const )190, (unsigned char const )33, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )12, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )2, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )144,
        (unsigned char const )30, (unsigned char const )32, (unsigned char const )64, (unsigned char const )0,
        (unsigned char const )12, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )4, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )1, (unsigned char const )32, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )192,
        (unsigned char const )193, (unsigned char const )61, (unsigned char const )96, (unsigned char const )0,
        (unsigned char const )12, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )16,
        (unsigned char const )0, (unsigned char const )48, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )12, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )30, (unsigned char const )32, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )12, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )4, (unsigned char const )92, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )242, (unsigned char const )7,
        (unsigned char const )128, (unsigned char const )127, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )242, (unsigned char const )27,
        (unsigned char const )0, (unsigned char const )63, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )3,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )160, (unsigned char const )2,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )254, (unsigned char const )127,
        (unsigned char const )223, (unsigned char const )224, (unsigned char const )255, (unsigned char const )254,
        (unsigned char const )255, (unsigned char const )255, (unsigned char const )255, (unsigned char const )31,
        (unsigned char const )64, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )224, (unsigned char const )253, (unsigned char const )102,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )195,
        (unsigned char const )1, (unsigned char const )0, (unsigned char const )30, (unsigned char const )0,
        (unsigned char const )100, (unsigned char const )32, (unsigned char const )0, (unsigned char const )32,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )224,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )28, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )28, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )12, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )12, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )176, (unsigned char const )63,
        (unsigned char const )64, (unsigned char const )254, (unsigned char const )15, (unsigned char const )32,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )56, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )2, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )135, (unsigned char const )1, (unsigned char const )4, (unsigned char const )14,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )128, (unsigned char const )1,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )64, (unsigned char const )127,
        (unsigned char const )229, (unsigned char const )31, (unsigned char const )248, (unsigned char const )159,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )15, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )208, (unsigned char const )23,
        (unsigned char const )4, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )248, (unsigned char const )15, (unsigned char const )0,
        (unsigned char const )3, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )60, (unsigned char const )3, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )64, (unsigned char const )163, (unsigned char const )3, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )240, (unsigned char const )207, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )247, (unsigned char const )255,
        (unsigned char const )253, (unsigned char const )33, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )255, (unsigned char const )255, (unsigned char const )255, (unsigned char const )255,
        (unsigned char const )127, (unsigned char const )0, (unsigned char const )0, (unsigned char const )240,
        (unsigned char const )0, (unsigned char const )248, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )124, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )31, (unsigned char const )252, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )255, (unsigned char const )255,
        (unsigned char const )255, (unsigned char const )255, (unsigned char const )1, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )128, (unsigned char const )3, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )128,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )255, (unsigned char const )255, (unsigned char const )255, (unsigned char const )255,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )252, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )6,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )128, (unsigned char const )7, (unsigned char const )48,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )3, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )68, (unsigned char const )8, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )96, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )16, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )255, (unsigned char const )255, (unsigned char const )3, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )192, (unsigned char const )63, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )128, (unsigned char const )255, (unsigned char const )3, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )7, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )200, (unsigned char const )19,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )126, (unsigned char const )102, (unsigned char const )0,
        (unsigned char const )8, (unsigned char const )16, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )157, (unsigned char const )193,
        (unsigned char const )2, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )32, (unsigned char const )33, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )64,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )255, (unsigned char const )255, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )127, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )128,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )14,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )32,
        (unsigned char const )110, (unsigned char const )240, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )135,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )2, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )255,
        (unsigned char const )127, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )3, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )120, (unsigned char const )38,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )128, (unsigned char const )3, (unsigned char const )248, (unsigned char const )255,
        (unsigned char const )231, (unsigned char const )15, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )60, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )28, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0,
        (unsigned char const )0, (unsigned char const )0, (unsigned char const )0, (unsigned char const )0};
static signed char const nonspacing_table_ind[240] =
  { (signed char const )0, (signed char const )1, (signed char const )2, (signed char const )3,
        (signed char const )4, (signed char const )5, (signed char const )6, (signed char const )7,
        (signed char const )8, (signed char const )9, (signed char const )-1, (signed char const )10,
        (signed char const )11, (signed char const )12, (signed char const )13, (signed char const )-1,
        (signed char const )14, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )15, (signed char const )-1,
        (signed char const )16, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )17,
        (signed char const )18, (signed char const )19, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )20, (signed char const )-1, (signed char const )21,
        (signed char const )22, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )23, (signed char const )-1, (signed char const )-1,
        (signed char const )24, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1,
        (signed char const )25, (signed char const )26, (signed char const )-1, (signed char const )-1,
        (signed char const )-1, (signed char const )-1, (signed char const )-1, (signed char const )-1};
#pragma merger(0,"/tmp/cil-UapQNMTJ.i","-g,-O2")
char const *parse_user_spec(char const *spec , uid_t *uid , gid_t *gid , char **username ,
                              char **groupname ) ;
extern void endpwent(void) ;
strtol_error xstrtoul(char const *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const *valid_suffixes ) ;
static char const *parse_with_separator(char const *spec , char const *separator ,
                                          uid_t *uid , gid_t *gid , char **username ,
                                          char **groupname ) ;
static char const *E_invalid_user = (char const *)"invalid user";
static char const *E_invalid_group = (char const *)"invalid group";
static char const *E_bad_spec = (char const *)"invalid spec";
#pragma merger(0,"/tmp/cil-OAYRSfav.i","-g,-O2")
int utimecmp(char const *dst_name , struct stat const *dst_stat , struct stat const *src_stat ,
             int options ) ;
int utimens(char const *file , struct timespec const *timespec ) ;
int lutimens(char const *file , struct timespec const *timespec ) ;
static Hash_table *ht ;
static struct fs_res *new_dst_res ;
#pragma merger(0,"/tmp/cil-bm7B46So.i","-g,-O2")
int fdutimens(int fd , char const *file , struct timespec const *timespec ) ;
extern int ( __attribute__((__nonnull__(2))) utimensat)(int __fd , char const *__path ,
                                                        struct timespec const *__times ,
                                                        int __flags ) __attribute__((__nothrow__)) ;
extern int futimens(int __fd , struct timespec const *__times ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) utimes)(char const *__file , struct timeval const *__tvp ) __attribute__((__nothrow__)) ;
extern int futimesat(int __fd , char const *__file , struct timeval const *__tvp ) __attribute__((__nothrow__)) ;
static int utimensat_works_really ;
static int lutimensat_works_really ;
#pragma merger(0,"/tmp/cil-OdPuDETE.i","-g,-O2")
extern void error_at_line(int __status , int __errnum , char const *__fname , unsigned int __lineno ,
                          char const *__format , ...) ;
void verror(int status , int errnum , char const *format , va_list args ) ;
void verror_at_line(int status , int errnum , char const *file , unsigned int line_number ,
                    char const *format , va_list args ) ;
char *xvasprintf(char const *format , va_list args ) ;
#pragma merger(0,"/tmp/cil-dW3x2AAy.i","-g,-O2")
extern int fputs_unlocked(char const * __restrict __s , FILE * __restrict __stream ) ;
char const version_etc_copyright[47] ;
void version_etc_arn(FILE *stream , char const *command_name , char const *package ,
                     char const *version , char const **authors , size_t n_authors ) ;
void version_etc_ar(FILE *stream , char const *command_name , char const *package ,
                    char const *version , char const **authors ) ;
void version_etc(FILE *stream , char const *command_name , char const *package ,
                 char const *version , ...) __attribute__((__sentinel__)) ;
void emit_bug_reporting_address(void) ;
#pragma merger(0,"/tmp/cil-Si8yWYvD.i","-g,-O2")
char const version_etc_copyright[47] =
  { (char const )'C', (char const )'o', (char const )'p', (char const )'y',
        (char const )'r', (char const )'i', (char const )'g', (char const )'h',
        (char const )'t', (char const )' ', (char const )'%', (char const )'s',
        (char const )' ', (char const )'%', (char const )'d', (char const )' ',
        (char const )'F', (char const )'r', (char const )'e', (char const )'e',
        (char const )' ', (char const )'S', (char const )'o', (char const )'f',
        (char const )'t', (char const )'w', (char const )'a', (char const )'r',
        (char const )'e', (char const )' ', (char const )'F', (char const )'o',
        (char const )'u', (char const )'n', (char const )'d', (char const )'a',
        (char const )'t', (char const )'i', (char const )'o', (char const )'n',
        (char const )',', (char const )' ', (char const )'I', (char const )'n',
        (char const )'c', (char const )'.', (char const )'\000'};
#pragma merger(0,"/tmp/cil-Cj3v0GQE.i","-g,-O2")
_Bool can_write_any_file(void) ;
extern __uid_t geteuid(void) __attribute__((__nothrow__)) ;
static _Bool initialized___0 ;
static _Bool can_write ;
#pragma merger(0,"/tmp/cil-iOGAL1B7.i","-g,-O2")
void *xcalloc(size_t n , size_t s ) __attribute__((__malloc__, __alloc_size__(1,2))) ;
#pragma merger(0,"/tmp/cil-X6OZ7pH6.i","-g,-O2")
#pragma merger(0,"/tmp/cil-mmNHua13.i","-g,-O2")
void xfreopen(char const *filename , char const *mode , FILE *fp ) ;
#pragma merger(0,"/tmp/cil-wqz3SSph.i","-g,-O2")
#pragma merger(0,"/tmp/cil-JtQqgaHC.i","-g,-O2")
int xgetgroups(char const *username , gid_t gid , gid_t **groups ) ;
#pragma merger(0,"/tmp/cil-WUyzMmoR.i","-g,-O2")
char *xgethostname(void) ;
#pragma merger(0,"/tmp/cil-EHuAxUz6.i","-g,-O2")
int xmemcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) ;
int xmemcoll0(char const *s1 , size_t s1size , char const *s2 , size_t s2size ) ;
#pragma merger(0,"/tmp/cil-X04jO2dK.i","-g,-O2")
int xnanosleep(double seconds ) ;
int ( __attribute__((__nonnull__(1))) rpl_nanosleep)(struct timespec const *requested_delay ,
                                                     struct timespec *remaining_delay ) ;
#pragma merger(0,"/tmp/cil-F5OJFFqX.i","-g,-O2")
int ( __attribute__((__nonnull__(1,2))) rpl_vfprintf)(FILE *fp , char const *format ,
                                                      va_list args ) ;
int ( __attribute__((__nonnull__(1))) rpl_vprintf)(char const *format , va_list args ) ;
int xprintf(char const *format , ...) ;
int xvprintf(char const *format , va_list args ) ;
int xfprintf(FILE *stream , char const *format , ...) ;
int xvfprintf(FILE *stream , char const *format , va_list args ) ;
#pragma merger(0,"/tmp/cil-rFGD0xvs.i","-g,-O2")
char *xreadlink(char const *filename ) ;
#pragma merger(0,"/tmp/cil-fwBLKTOG.i","-g,-O2")
int xmem_cd_iconv(char const *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) ;
char *xstr_cd_iconv(char const *src , iconv_t cd ) ;
#pragma merger(0,"/tmp/cil-QswfcA0o.i","-g,-O2")
extern char *__strndup(char const *__string , size_t __n ) __attribute__((__nothrow__,
__malloc__)) ;
#pragma merger(0,"/tmp/cil-sQ7lJPYn.i","-g,-O2")
_Bool xstrtod(char const *str , char const **ptr , double *result , double (*convert)(char const * ,
                                                                                          char ** ) ) ;
#pragma merger(0,"/tmp/cil-y8pE2OpK.i","-g,-O2")
strtol_error xstrtoimax(char const *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const *valid_suffixes ) ;
#pragma merger(0,"/tmp/cil-5YJROW3B.i","-g,-O2")
strtol_error xstrtol(char const *s , char **ptr , int strtol_base , long *val ,
                     char const *valid_suffixes ) ;
#pragma merger(0,"/tmp/cil-kNCugwxZ.i","-g,-O2")
#pragma merger(0,"/tmp/cil-cK_l5WOB.i","-g,-O2")
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct rpl_option const *long_options___0 ,
                   char const *arg ) __attribute__((__noreturn__)) ;
#pragma merger(0,"/tmp/cil-SvEwqpk5.i","-g,-O2")
_Bool xstrtold(char const *str , char const **ptr , long double *result , long double (*convert)(char const * ,
                                                                                                     char ** ) ) ;
#pragma merger(0,"/tmp/cil-qOoIKJIK.i","-g,-O2")
#pragma merger(0,"/tmp/cil-i7V0Sdfw.i","-g,-O2")
int ( __attribute__((__nonnull__(1,2))) rpl_vasprintf)(char **resultp , char const *format ,
                                                       va_list args ) ;
#pragma merger(0,"/tmp/cil-zlGEj8wz.i","-g,-O2")
char *xasprintf(char const *format , ...) ;
#pragma merger(0,"/tmp/cil-h9IEoMLy.i","-g,-O2")
_Bool yesno(void) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) rpmatch)(char const *__response ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-pdMn5QIa.i","-g,-O2")
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max ) __attribute__((__const__)) ;
#pragma merger(0,"/tmp/cil-S3A2UTWN.i","-g,-O2")
char *asnprintf(char *resultbuf , size_t *lengthp , char const *format , ...) ;
char *vasnprintf(char *resultbuf , size_t *lengthp , char const *format , va_list args ) ;
#pragma merger(0,"/tmp/cil-xMV2BVsw.i","-g,-O2")
int ( __attribute__((__nonnull__(1,2))) rpl_asprintf)(char **resultp , char const *format
                                                      , ...) ;
#pragma merger(0,"/tmp/cil-5pB0uhfb.i","-g,-O2")
extern void *( __attribute__((__nonnull__(1))) memrchr)(void const *__s , int __c ,
                                                        size_t __n ) __attribute__((__pure__,
__nothrow__)) ;
#pragma merger(0,"/tmp/cil-qZKcFIMj.i","-g,-O2")
extern int fclose(FILE *__stream ) ;
extern int __freading(FILE *__fp ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-gGG66C9w.i","-g,-O2")
extern int fcntl(int __fd , int __cmd , ...) ;
static int have_dupfd_cloexec = 0;
#pragma merger(0,"/tmp/cil-qS5ThY6d.i","-g,-O2")
extern int fflush(FILE *__stream ) ;
#pragma merger(0,"/tmp/cil-ViNOjNKf.i","-g,-O2")
int ( __attribute__((__nonnull__(1))) fpurge)(FILE *fp ) ;
extern void __fpurge(FILE *__fp ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-9oWuAZ2F.i","-g,-O2")
int ( __attribute__((__nonnull__(1))) rpl_fseek)(FILE *fp , long offset , int whence ) ;
#pragma merger(0,"/tmp/cil-HrPkKFM6.i","-g,-O2")
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#pragma merger(0,"/tmp/cil-R1ze4WPc.i","-g,-O2")
int get_fs_usage(char const *file , char const *disk , struct fs_usage *fsp ) ;
extern int ( __attribute__((__nonnull__(1,2))) statfs)(char const *__file , struct statfs *__buf ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-sLvGW6en.i","-g,-O2")
FTSENT *( __attribute__((__warn_unused_result__)) fts_children)(FTS *sp , int instr ) __attribute__((__nothrow__)) ;
int ( __attribute__((__warn_unused_result__)) fts_close)(FTS *sp ) __attribute__((__nothrow__)) ;
FTS *( __attribute__((__warn_unused_result__)) fts_open)(char **argv , int options ,
                                                         int (*compar)(FTSENT const ** ,
                                                                       FTSENT const ** ) ) __attribute__((__nothrow__)) ;
FTSENT *( __attribute__((__warn_unused_result__)) fts_read)(FTS *sp ) __attribute__((__nothrow__)) ;
int fts_set(FTS *sp __attribute__((__unused__)) , FTSENT *p , int instr ) __attribute__((__nothrow__)) ;
static FTSENT *fts_alloc(FTS *sp , char const *name , size_t namelen ) ;
static FTSENT *fts_build(FTS *sp , int type ) ;
static void fts_lfree(FTSENT *head ) ;
static void fts_load(FTS *sp , FTSENT *p ) ;
static size_t fts_maxarglen(char **argv ) ;
static void fts_padjust(FTS *sp , FTSENT *head ) ;
static _Bool fts_palloc(FTS *sp , size_t more ) ;
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) ;
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) ;
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const *dir ) ;
extern int ( __attribute__((__nonnull__(2))) fstatfs)(int __fildes , struct statfs *__buf ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-1UFLmVhO.i","-g,-O2")
#pragma merger(0,"/tmp/cil-w5X3H3hU.i","-g,-O2")
extern void ( __attribute__((__nonnull__(1))) rewinddir)(DIR *__dirp ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-HFYXRuPi.i","-g,-O2")
#pragma merger(0,"/tmp/cil-UhKv4HE3.i","-g,-O2")
xtime_t gethrxtime(void) ;
#pragma merger(0,"/tmp/cil-mxQrEjpX.i","-g,-O2")
char *rpl_optarg ;
int rpl_optopt ;
int ( __attribute__((__nonnull__(2,3))) rpl_getopt)(int argc , char **argv , char const *optstring ) __attribute__((__nothrow__)) ;
int rpl_getopt_internal(int argc , char **argv , char const *optstring , struct rpl_option const *longopts ,
                        int *longind , int long_only , int posixly_correct ) ;
int _getopt_internal_r(int argc , char **argv , char const *optstring , struct rpl_option const *longopts ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct ) ;
int rpl_optind = 1;
int rpl_opterr = 1;
int rpl_optopt = '?';
static struct _getopt_data getopt_data ;
#pragma merger(0,"/tmp/cil-mXp2FDNA.i","-g,-O2")
int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long_only)(int argc , char **argv ,
                                                              char const *options ,
                                                              struct rpl_option const *long_options___0 ,
                                                              int *opt_index ) __attribute__((__nothrow__)) ;
int _getopt_long_r(int argc , char **argv , char const *options , struct rpl_option const *long_options___0 ,
                   int *opt_index , struct _getopt_data *d ) ;
int _getopt_long_only_r(int argc , char **argv , char const *options , struct rpl_option const *long_options___0 ,
                        int *opt_index , struct _getopt_data *d ) ;
#pragma merger(0,"/tmp/cil-n1wIBX1O.i","-g,-O2")
char *( __attribute__((__nonnull__(1))) gnu_getpass)(char const *prompt ) ;
extern int fflush_unlocked(FILE *__stream ) ;
extern int __fsetlocking(FILE *__fp , int __type ) __attribute__((__nothrow__)) ;
extern int tcgetattr(int __fd , struct termios *__termios_p ) __attribute__((__nothrow__)) ;
extern int tcsetattr(int __fd , int __optional_actions , struct termios const *__termios_p ) __attribute__((__nothrow__)) ;
static char *buf ;
static size_t bufsize ;
#pragma merger(0,"/tmp/cil-dCG56FmA.i","-g,-O2")
int isapipe(int fd ) ;
#pragma merger(0,"/tmp/cil-5AaP4Yzr.i","-g,-O2")
int rpl_isnanl(long double x ) ;
#pragma merger(0,"/tmp/cil-yrlUrfXI.i","-g,-O2")
extern int ( __attribute__((__warn_unused_result__, __nonnull__(2,4))) linkat)(int __fromfd ,
                                                                               char const *__from ,
                                                                               int __tofd ,
                                                                               char const *__to ,
                                                                               int __flags ) __attribute__((__nothrow__)) ;
int ( __attribute__((__nonnull__(2,4))) rpl_linkat)(int fd1 , char const *file1 ,
                                                    int fd2 , char const *file2 ,
                                                    int flag ) ;
static int have_follow_really ;
#pragma merger(0,"/tmp/cil-oc8GQ0MI.i","-g,-O2")
struct mount_entry *read_file_system_list(_Bool need_fs_type ) ;
extern FILE *setmntent(char const *__file , char const *__mode ) __attribute__((__nothrow__)) ;
extern struct mntent *getmntent(FILE *__stream ) __attribute__((__nothrow__)) ;
extern int endmntent(FILE *__stream ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-YCXQinTL.i","-g,-O2")
#pragma merger(0,"/tmp/cil-ctOsNzcD.i","-g,-O2")
char *openat_proc_name(char *buf___1 , int fd , char const *file ) ;
extern int ( __attribute__((__nonnull__(1))) access)(char const *__name , int __type ) __attribute__((__nothrow__)) ;
static int proc_status = 0;
#pragma merger(0,"/tmp/cil-SJ6wN4Jk.i","-g,-O2")
int printf_fetchargs(va_list args , arguments *a ) ;
static wchar_t const wide_null_string[7] = { (wchar_t const )'(', (wchar_t const )'N', (wchar_t const )'U', (wchar_t const )'L',
        (wchar_t const )'L', (wchar_t const )')', (wchar_t const )0};
#pragma merger(0,"/tmp/cil-RLvVxikX.i","-g,-O2")
int printf_parse(char const *format , char_directives *d , arguments *a ) ;
#pragma merger(0,"/tmp/cil-yaBcltoY.i","-g,-O2")
extern void setutxent(void) ;
extern void endutxent(void) ;
extern struct utmpx *getutxent(void) ;
extern int utmpxname(char const *__file ) ;
char *extract_trimmed_name(STRUCT_UTMP const *ut ) ;
int read_utmp(char const *file , size_t *n_entries , STRUCT_UTMP **utmp_buf , int options ) ;
extern int kill(__pid_t __pid , int __sig ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-ildXE4Yg.i","-g,-O2")
int ( __attribute__((__nonnull__(1))) rpl_remove)(char const *name ) ;
extern int ( __attribute__((__nonnull__(1))) unlink)(char const *__name ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) rmdir)(char const *__path ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-ypOvCriv.i","-g,-O2")
struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i ) ;
#pragma merger(0,"/tmp/cil-RFDffaud.i","-g,-O2")
int getfileconat(int fd , char const *file , char **con ) ;
int lgetfileconat(int fd , char const *file , char **con ) ;
int setfileconat(int fd , char const *file , char *con ) ;
int lsetfileconat(int fd , char const *file , char *con ) ;
#pragma merger(0,"/tmp/cil-YFsqIx7V.i","-g,-O2")
extern int __libc_current_sigrtmin(void) __attribute__((__nothrow__)) ;
extern int __libc_current_sigrtmax(void) __attribute__((__nothrow__)) ;
int sig2str(int signum , char *signame ) ;
int str2sig(char const *signame , int *signum ) ;
static struct numname numname_table[35] =
  { {1, {(char const )'H', (char const )'U', (char const )'P', (char const )'\000',
          (char const )(char)0, (char const )(char)0, (char const )(char)0,
          (char const )(char)0}},
        {2, {(char const )'I', (char const )'N', (char const )'T', (char const )'\000',
          (char const )(char)0, (char const )(char)0, (char const )(char)0,
          (char const )(char)0}},
        {3, {(char const )'Q', (char const )'U', (char const )'I', (char const )'T',
          (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {4,
      {(char const )'I', (char const )'L', (char const )'L', (char const )'\000',
       (char const )(char)0, (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {5,
      {(char const )'T', (char const )'R', (char const )'A', (char const )'P',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {6,
      {(char const )'A', (char const )'B', (char const )'R', (char const )'T',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {8,
      {(char const )'F', (char const )'P', (char const )'E', (char const )'\000',
       (char const )(char)0, (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {9,
      {(char const )'K', (char const )'I', (char const )'L', (char const )'L',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {11,
      {(char const )'S', (char const )'E', (char const )'G', (char const )'V',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {7,
      {(char const )'B', (char const )'U', (char const )'S', (char const )'\000',
       (char const )(char)0, (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {13,
      {(char const )'P', (char const )'I', (char const )'P', (char const )'E',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {14,
      {(char const )'A', (char const )'L', (char const )'R', (char const )'M',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {15,
      {(char const )'T', (char const )'E', (char const )'R', (char const )'M',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {10,
      {(char const )'U', (char const )'S', (char const )'R', (char const )'1',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {12,
      {(char const )'U', (char const )'S', (char const )'R', (char const )'2',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {17,
      {(char const )'C', (char const )'H', (char const )'L', (char const )'D',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {23,
      {(char const )'U', (char const )'R', (char const )'G', (char const )'\000',
       (char const )(char)0, (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {19,
      {(char const )'S', (char const )'T', (char const )'O', (char const )'P',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {20,
      {(char const )'T', (char const )'S', (char const )'T', (char const )'P',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {18,
      {(char const )'C', (char const )'O', (char const )'N', (char const )'T',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {21,
      {(char const )'T', (char const )'T', (char const )'I', (char const )'N',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {22,
      {(char const )'T', (char const )'T', (char const )'O', (char const )'U',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {31,
      {(char const )'S', (char const )'Y', (char const )'S', (char const )'\000',
       (char const )(char)0, (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {29,
      {(char const )'P', (char const )'O', (char const )'L', (char const )'L',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {26,
      {(char const )'V', (char const )'T', (char const )'A', (char const )'L',
       (char const )'R', (char const )'M', (char const )'\000', (char const )(char)0}},
        {27,
      {(char const )'P', (char const )'R', (char const )'O', (char const )'F',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {24,
      {(char const )'X', (char const )'C', (char const )'P', (char const )'U',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {25,
      {(char const )'X', (char const )'F', (char const )'S', (char const )'Z',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {6,
      {(char const )'I', (char const )'O', (char const )'T', (char const )'\000',
       (char const )(char)0, (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {17,
      {(char const )'C', (char const )'L', (char const )'D', (char const )'\000',
       (char const )(char)0, (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {30,
      {(char const )'P', (char const )'W', (char const )'R', (char const )'\000',
       (char const )(char)0, (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {28,
      {(char const )'W', (char const )'I', (char const )'N', (char const )'C',
       (char const )'H', (char const )'\000', (char const )(char)0, (char const )(char)0}},
        {29,
      {(char const )'I', (char const )'O', (char const )'\000', (char const )(char)0,
       (char const )(char)0, (char const )(char)0, (char const )(char)0, (char const )(char)0}},
        {16,
      {(char const )'S', (char const )'T', (char const )'K', (char const )'F',
       (char const )'L', (char const )'T', (char const )'\000', (char const )(char)0}},
        {0,
      {(char const )'E', (char const )'X', (char const )'I', (char const )'T',
       (char const )'\000', (char const )(char)0, (char const )(char)0, (char const )(char)0}}};
#pragma merger(0,"/tmp/cil-caAyaIV4.i","-g,-O2")
extern char *strerror(int __errnum ) __attribute__((__nothrow__)) ;
char *rpl_strerror(int n ) ;
static char buf___0[256] ;
static char const fmt[17] =
  { (char const )'U', (char const )'n', (char const )'k', (char const )'n',
        (char const )'o', (char const )'w', (char const )'n', (char const )' ',
        (char const )'e', (char const )'r', (char const )'r', (char const )'o',
        (char const )'r', (char const )' ', (char const )'%', (char const )'d',
        (char const )'\000'};
#pragma merger(0,"/tmp/cil-JBMaZE8g.i","-g,-O2")
static int local_utimensat(int fd , char const *file , struct timespec const *ts ,
                           int flag ) ;
static int utimensat_works_really___0 ;
#pragma merger(0,"/tmp/cil-9ObY4hGe.i","-g,-O2")
extern int __builtin_signbitl() ;
#pragma merger(0,"/tmp/cil-erGuNYNJ.i","-g,-O2")
#pragma merger(0,"/tmp/cil-8LxvdfxO.i","-g,-O2")
#pragma merger(0,"/tmp/cil-zqCZTQVt.i","-g,-O2")
#pragma merger(0,"/tmp/cil-5AJPyIUq.i","-g,-O2")
_Bool euidaccess_stat(struct stat const *st , int mode ) ;
extern __gid_t getegid(void) __attribute__((__nothrow__)) ;
extern int group_member(__gid_t __gid ) __attribute__((__nothrow__)) ;
#pragma merger(0,"/tmp/cil-Vxw0xUtd.i","-g,-O2")
int fd_reopen(int desired_fd , char const *file , int flags , mode_t mode ) ;
#pragma merger(0,"/tmp/cil-qAsTti2K.i","-g,-O2")
FTS *xfts_open(char **argv , int options , int (*compar)(FTSENT const ** , FTSENT const ** ) ) ;
_Bool cycle_warning_required(FTS const *fts , FTSENT const *ent ) __attribute__((__pure__)) ;
#pragma merger(0,"/tmp/cil-ifXXJfgr.i","-g,-O2")
int strintcmp(char const *a , char const *b ) __attribute__((__pure__)) ;
#pragma merger(0,"/tmp/cil-_niqOVMY.i","-g,-O2")
int __attribute__((__pure__)) strnumcmp(char const *a , char const *b , int decimal_point ,
                                         int thousands_sep ) ;
#pragma merger(0,"/tmp/cil-ka9am46b.i","")
char const *Version = (char const *)"8.13.14-081e2-dirty";
#pragma merger(0,"/tmp/cil-I8gAiErk.i","")
extern __sighandler_t signal(int __sig , void (*__handler)(int ) ) __attribute__((__nothrow__)) ;
extern __mode_t umask(__mode_t __mask ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2))) execvp)(char const *__file , char **__argv ) __attribute__((__nothrow__)) ;
extern int isatty(int __fd ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) atexit)(void (*__func)(void) ) __attribute__((__nothrow__)) ;
extern char *gettext(char const *__msgid ) __attribute__((__nothrow__, __format_arg__(1))) ;
extern char *textdomain(char const *__domainname ) __attribute__((__nothrow__)) ;
extern char *bindtextdomain(char const *__domainname , char const *__dirname ) __attribute__((__nothrow__)) ;

void *bsearch(void const *key , void const *ptr , size_t count , size_t size ,
              int (*comp)(void const * , void const * ) );
void *bsearch(void const *key , void const *ptr , size_t count , size_t size ,
              int (*comp)(void const * , void const * ) )
{
  size_t i ;
  void const *a ;
  int tmp ;
  {
  {
  i = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! (i < count)) {
      {
      goto while_break;
      }
    }
    {
    a = ptr + i * size;
    tmp = (*comp)(key, a);
    }
    if (tmp == 0) {
      {
      return ((void *)a);
      }
    }
    {
    i ++;
    }
  }
  while_break: ;
  }
  return ((void *)0);
}
}

__inline extern unsigned int gnu_dev_minor(unsigned long long __dev ) __attribute__((__nothrow__)) ;
__inline extern unsigned int gnu_dev_minor(unsigned long long __dev )
{
  {
  return ((unsigned int )((__dev & 255ULL) | (unsigned long long )((unsigned int )(__dev >> 12) & 4294967040U)));
}
}
__inline extern unsigned long long gnu_dev_makedev(unsigned int __major , unsigned int __minor ) __attribute__((__nothrow__)) ;
__inline extern unsigned long long gnu_dev_makedev(unsigned int __major , unsigned int __minor )
{
  {
  return (((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32));
}
}
__inline extern int ( __attribute__((__nonnull__(1,2))) stat)(char const *__path ,
                                                              struct stat *__statbuf ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1,2))) stat)(char const *__path ,
                                                              struct stat *__statbuf )
{
  int tmp ;
  {
  {
  tmp = __xstat(1, __path, __statbuf);
  }
  return (tmp);
}
}
__inline extern int ( __attribute__((__nonnull__(1,2))) lstat)(char const *__path ,
                                                               struct stat *__statbuf ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1,2))) lstat)(char const *__path ,
                                                               struct stat *__statbuf )
{
  int tmp ;
  {
  {
  tmp = __lxstat(1, __path, __statbuf);
  }
  return (tmp);
}
}
__inline extern int ( __attribute__((__nonnull__(2))) fstat)(int __fd , struct stat *__statbuf ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2))) fstat)(int __fd , struct stat *__statbuf )
{
  int tmp ;
  {
  {
  tmp = __fxstat(1, __fd, __statbuf);
  }
  return (tmp);
}
}
__inline extern int ( __attribute__((__nonnull__(2,3))) fstatat)(int __fd , char const *__filename ,
                                                                 struct stat *__statbuf ,
                                                                 int __flag ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2,3))) fstatat)(int __fd , char const *__filename ,
                                                                 struct stat *__statbuf ,
                                                                 int __flag )
{
  int tmp ;
  {
  {
  tmp = __fxstatat(1, __fd, __filename, __statbuf, __flag);
  }
  return (tmp);
}
}
__inline extern int ( __attribute__((__nonnull__(1))) mknod)(char const *__path ,
                                                             __mode_t __mode , __dev_t __dev ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1))) mknod)(char const *__path ,
                                                             __mode_t __mode , __dev_t __dev )
{
  int tmp ;
  {
  {
  tmp = __xmknod(0, __path, __mode, & __dev);
  }
  return (tmp);
}
}
__inline extern int ( __attribute__((__nonnull__(2))) mknodat)(int __fd , char const *__path ,
                                                               __mode_t __mode , __dev_t __dev ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2))) mknodat)(int __fd , char const *__path ,
                                                               __mode_t __mode , __dev_t __dev )
{
  int tmp ;
  {
  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  }
  return (tmp);
}
}
__inline extern int ( __attribute__((__nonnull__(1,2))) stat64)(char const *__path ,
                                                                struct stat64 *__statbuf ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1,2))) stat64)(char const *__path ,
                                                                struct stat64 *__statbuf )
{
  int tmp ;
  {
  {
  tmp = __xstat64(1, __path, __statbuf);
  }
  return (tmp);
}
}
__inline extern int ( __attribute__((__nonnull__(1,2))) lstat64)(char const *__path ,
                                                                 struct stat64 *__statbuf ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1,2))) lstat64)(char const *__path ,
                                                                 struct stat64 *__statbuf )
{
  int tmp ;
  {
  {
  tmp = __lxstat64(1, __path, __statbuf);
  }
  return (tmp);
}
}
__inline extern int ( __attribute__((__nonnull__(2))) fstat64)(int __fd , struct stat64 *__statbuf ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2))) fstat64)(int __fd , struct stat64 *__statbuf )
{
  int tmp ;
  {
  {
  tmp = __fxstat64(1, __fd, __statbuf);
  }
  return (tmp);
}
}
__inline extern int ( __attribute__((__nonnull__(2,3))) fstatat64)(int __fd , char const *__filename ,
                                                                   struct stat64 *__statbuf ,
                                                                   int __flag ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2,3))) fstatat64)(int __fd , char const *__filename ,
                                                                   struct stat64 *__statbuf ,
                                                                   int __flag )
{
  int tmp ;
  {
  {
  tmp = __fxstatat64(1, __fd, __filename, __statbuf, __flag);
  }
  return (tmp);
}
}
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1))) atof)(char const *__nptr ) __attribute__((__pure__,
__nothrow__)) ;
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1))) atof)(char const *__nptr )
{
  double tmp ;
  {
  {
  tmp = strtod((char const * __restrict )__nptr, (char ** __restrict )((char **)((void *)0)));
  }
  return (tmp);
}
}
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) atoi)(char const *__nptr ) __attribute__((__pure__,
__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) atoi)(char const *__nptr )
{
  long tmp ;
  {
  {
  tmp = strtol((char const * __restrict )__nptr, (char ** __restrict )((char **)((void *)0)),
               10);
  }
  return ((int )tmp);
}
}
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1))) atol)(char const *__nptr ) __attribute__((__pure__,
__nothrow__)) ;
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1))) atol)(char const *__nptr )
{
  long tmp ;
  {
  {
  tmp = strtol((char const * __restrict )__nptr, (char ** __restrict )((char **)((void *)0)),
               10);
  }
  return (tmp);
}
}
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1))) atoll)(char const *__nptr ) __attribute__((__pure__,
__nothrow__)) ;
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1))) atoll)(char const *__nptr )
{
  long long tmp ;
  {
  {
  tmp = strtoll((char const * __restrict )__nptr, (char ** __restrict )((char **)((void *)0)),
                10);
  }
  return (tmp);
}
}
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) realpath)(char const *__name ,
                                                                                                             char *__resolved ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) realpath)(char const *__name ,
                                                                                                             char *__resolved )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  {
  {
  tmp___1 = __builtin_object_size((void *)__resolved, 1);
  }
  if (tmp___1 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__resolved, 1);
    tmp___0 = __realpath_chk((char const * __restrict )__name, (char * __restrict )__resolved,
                             tmp);
    }
    return (tmp___0);
    }
  }
  {
  tmp___2 = __realpath_alias((char const * __restrict )__name, (char * __restrict )__resolved);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__nonnull__(2), __artificial__, __always_inline__)) ptsname_r)(int __fd ,
                                                                                                    char *__buf ,
                                                                                                    size_t __buflen ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2), __artificial__, __always_inline__)) ptsname_r)(int __fd ,
                                                                                                    char *__buf ,
                                                                                                    size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __ptsname_r_chk(__fd, __buf, __buflen, tmp);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    }
    if (__buflen > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __ptsname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
  return (tmp___5);
}
}
__inline extern int ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) wctomb)(char *__s ,
                                                                                                         wchar_t __wchar ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) wctomb)(char *__s ,
                                                                                                         wchar_t __wchar )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  {
  {
  tmp___1 = __builtin_object_size((void *)__s, 1);
  }
  if (tmp___1 != 0xffffffffffffffffUL) {
    {
    {
    tmp___2 = __builtin_object_size((void *)__s, 1);
    }
    if (16UL > tmp___2) {
      {
      {
      tmp = __builtin_object_size((void *)__s, 1);
      tmp___0 = __wctomb_chk(__s, __wchar, tmp);
      }
      return (tmp___0);
      }
    }
    }
  }
  {
  tmp___3 = __wctomb_alias(__s, __wchar);
  }
  return (tmp___3);
}
}
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                                      char const *__src ,
                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                                      char const *__src ,
                                                                                      size_t __len )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __mbstowcs_chk((wchar_t * __restrict )__dst, (char const * __restrict )__src,
                             __len, tmp / sizeof(wchar_t ));
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    }
    if (__len > tmp___3 / sizeof(wchar_t )) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __mbstowcs_chk_warn((wchar_t * __restrict )__dst, (char const * __restrict )__src,
                                    __len, tmp___1 / sizeof(wchar_t ));
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __mbstowcs_alias((wchar_t * __restrict )__dst, (char const * __restrict )__src,
                             __len);
  }
  return (tmp___5);
}
}
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) wcstombs)(char *__dst ,
                                                                                      wchar_t const *__src ,
                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) wcstombs)(char *__dst ,
                                                                                      wchar_t const *__src ,
                                                                                      size_t __len )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __wcstombs_chk((char * __restrict )__dst, (wchar_t const * __restrict )__src,
                             __len, tmp);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    }
    if (__len > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __wcstombs_chk_warn((char * __restrict )__dst, (wchar_t const * __restrict )__src,
                                    __len, tmp___1);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __wcstombs_alias((char * __restrict )__dst, (wchar_t const * __restrict )__src,
                             __len);
  }
  return (tmp___5);
}
}
__inline extern size_t __strcspn_c1(char const *__s , int __reject )
{
  register size_t __result ;
  {
  {
  __result = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if ((int const )*(__s + __result) != 0) {
      {
      if (! ((int const )*(__s + __result) != (int const )__reject)) {
        {
        goto while_break;
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
    {
    __result ++;
    }
  }
  while_break: ;
  }
  return (__result);
}
}
__inline extern size_t __strcspn_c2(char const *__s , int __reject1 , int __reject2 )
{
  register size_t __result ;
  {
  {
  __result = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if ((int const )*(__s + __result) != 0) {
      {
      if ((int const )*(__s + __result) != (int const )__reject1) {
        {
        if (! ((int const )*(__s + __result) != (int const )__reject2)) {
          {
          goto while_break;
          }
        }
        }
      } else {
        {
        goto while_break;
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
    {
    __result ++;
    }
  }
  while_break: ;
  }
  return (__result);
}
}
__inline extern size_t __strcspn_c3(char const *__s , int __reject1 , int __reject2 ,
                                    int __reject3 )
{
  register size_t __result ;
  {
  {
  __result = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if ((int const )*(__s + __result) != 0) {
      {
      if ((int const )*(__s + __result) != (int const )__reject1) {
        {
        if ((int const )*(__s + __result) != (int const )__reject2) {
          {
          if (! ((int const )*(__s + __result) != (int const )__reject3)) {
            {
            goto while_break;
            }
          }
          }
        } else {
          {
          goto while_break;
          }
        }
        }
      } else {
        {
        goto while_break;
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
    {
    __result ++;
    }
  }
  while_break: ;
  }
  return (__result);
}
}
__inline extern size_t __strspn_c1(char const *__s , int __accept )
{
  register size_t __result ;
  {
  {
  __result = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! ((int const )*(__s + __result) == (int const )__accept)) {
      {
      goto while_break;
      }
    }
    {
    __result ++;
    }
  }
  while_break: ;
  }
  return (__result);
}
}
__inline extern size_t __strspn_c2(char const *__s , int __accept1 , int __accept2 )
{
  register size_t __result ;
  {
  {
  __result = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (! ((int const )*(__s + __result) == (int const )__accept1)) {
      {
      if (! ((int const )*(__s + __result) == (int const )__accept2)) {
        {
        goto while_break;
        }
      }
      }
    }
    {
    __result ++;
    }
  }
  while_break: ;
  }
  return (__result);
}
}
__inline extern size_t __strspn_c3(char const *__s , int __accept1 , int __accept2 ,
                                   int __accept3 )
{
  register size_t __result ;
  {
  {
  __result = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (! ((int const )*(__s + __result) == (int const )__accept1)) {
      {
      if (! ((int const )*(__s + __result) == (int const )__accept2)) {
        {
        if (! ((int const )*(__s + __result) == (int const )__accept3)) {
          {
          goto while_break;
          }
        }
        }
      }
      }
    }
    {
    __result ++;
    }
  }
  while_break: ;
  }
  return (__result);
}
}
__inline extern char *__strpbrk_c2(char const *__s , int __accept1 , int __accept2 )
{
  char *tmp ;
  {
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if ((int const )*__s != 0) {
      {
      if ((int const )*__s != (int const )__accept1) {
        {
        if (! ((int const )*__s != (int const )__accept2)) {
          {
          goto while_break;
          }
        }
        }
      } else {
        {
        goto while_break;
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
    {
    __s ++;
    }
  }
  while_break: ;
  }
  if ((int const )*__s == 0) {
    {
    {
    tmp = (char *)((void *)0);
    }
    }
  } else {
    {
    {
    tmp = (char *)((size_t )__s);
    }
    }
  }
  return (tmp);
}
}
__inline extern char *__strpbrk_c3(char const *__s , int __accept1 , int __accept2 ,
                                   int __accept3 )
{
  char *tmp ;
  {
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if ((int const )*__s != 0) {
      {
      if ((int const )*__s != (int const )__accept1) {
        {
        if ((int const )*__s != (int const )__accept2) {
          {
          if (! ((int const )*__s != (int const )__accept3)) {
            {
            goto while_break;
            }
          }
          }
        } else {
          {
          goto while_break;
          }
        }
        }
      } else {
        {
        goto while_break;
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
    {
    __s ++;
    }
  }
  while_break: ;
  }
  if ((int const )*__s == 0) {
    {
    {
    tmp = (char *)((void *)0);
    }
    }
  } else {
    {
    {
    tmp = (char *)((size_t )__s);
    }
    }
  }
  return (tmp);
}
}
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp )
{
  char *__result ;
  char *tmp ;
  char *tmp___0 ;
  {
  if ((unsigned long )__s == (unsigned long )((void *)0)) {
    {
    {
    __s = *__nextp;
    }
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! ((int )*__s == (int )__sep)) {
      {
      goto while_break;
      }
    }
    {
    __s ++;
    }
  }
  while_break: ;
  }
  {
  __result = (char *)((void *)0);
  }
  if ((int )*__s != 0) {
    {
    {
    tmp = __s;
    __s ++;
    __result = tmp;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! ((int )*__s != 0)) {
        {
        goto while_break___0;
        }
      }
      {
      tmp___0 = __s;
      __s ++;
      }
      if ((int )*tmp___0 == (int )__sep) {
        {
        {
        *(__s + -1) = (char )'\000';
        }
        goto while_break___0;
        }
      }
    }
    while_break___0: ;
    }
    }
  }
  {
  *__nextp = __s;
  }
  return (__result);
}
}
__inline extern char *__strsep_1c(char **__s , char __reject )
{
  register char *__retval ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___2 ;
  {
  {
  __retval = *__s;
  }
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
    {
    {
    tmp___2 = __builtin_strchr(__retval, (int )__reject);
    tmp___0 = tmp___2;
    *__s = tmp___0;
    }
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      {
      {
      tmp = *__s;
      (*__s) ++;
      *tmp = (char )'\000';
      }
      }
    }
    }
  }
  return (__retval);
}
}
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 )
{
  register char *__retval ;
  register char *__cp ;
  char *tmp ;
  {
  {
  __retval = *__s;
  }
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
    {
    {
    __cp = __retval;
    }
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      if ((int )*__cp == 0) {
        {
        {
        __cp = (char *)((void *)0);
        }
        goto while_break;
        }
      }
      if ((int )*__cp == (int )__reject1) {
        {
        {
        tmp = __cp;
        __cp ++;
        *tmp = (char )'\000';
        }
        goto while_break;
        }
      } else {
        {
        if ((int )*__cp == (int )__reject2) {
          {
          {
          tmp = __cp;
          __cp ++;
          *tmp = (char )'\000';
          }
          goto while_break;
          }
        }
        }
      }
      {
      __cp ++;
      }
    }
    while_break: ;
    }
    {
    *__s = __cp;
    }
    }
  }
  return (__retval);
}
}
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 )
{
  register char *__retval ;
  register char *__cp ;
  char *tmp ;
  {
  {
  __retval = *__s;
  }
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
    {
    {
    __cp = __retval;
    }
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      if ((int )*__cp == 0) {
        {
        {
        __cp = (char *)((void *)0);
        }
        goto while_break;
        }
      }
      if ((int )*__cp == (int )__reject1) {
        {
        {
        tmp = __cp;
        __cp ++;
        *tmp = (char )'\000';
        }
        goto while_break;
        }
      } else {
        {
        if ((int )*__cp == (int )__reject2) {
          {
          {
          tmp = __cp;
          __cp ++;
          *tmp = (char )'\000';
          }
          goto while_break;
          }
        } else {
          {
          if ((int )*__cp == (int )__reject3) {
            {
            {
            tmp = __cp;
            __cp ++;
            *tmp = (char )'\000';
            }
            goto while_break;
            }
          }
          }
        }
        }
      }
      {
      __cp ++;
      }
    }
    while_break: ;
    }
    {
    *__s = __cp;
    }
    }
  }
  return (__retval);
}
}
__inline extern void *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) memcpy)(void *__dest ,
                                                                                                     void const *__src ,
                                                                                                     size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) memcpy)(void *__dest ,
                                                                                                     void const *__src ,
                                                                                                     size_t __len )
{
  unsigned long tmp ;
  void *tmp___0 ;
  {
  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memcpy_chk(__dest, __src, __len, tmp);
  }
  return (tmp___0);
}
}
__inline extern void *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) memmove)(void *__dest ,
                                                                                                      void const *__src ,
                                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) memmove)(void *__dest ,
                                                                                                      void const *__src ,
                                                                                                      size_t __len )
{
  unsigned long tmp ;
  void *tmp___0 ;
  {
  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memmove_chk(__dest, __src, __len, tmp);
  }
  return (tmp___0);
}
}
__inline extern void *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) mempcpy)(void *__dest ,
                                                                                                      void const *__src ,
                                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) mempcpy)(void *__dest ,
                                                                                                      void const *__src ,
                                                                                                      size_t __len )
{
  unsigned long tmp ;
  void *tmp___0 ;
  {
  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___mempcpy_chk(__dest, __src, __len, tmp);
  }
  return (tmp___0);
}
}
__inline extern void *( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) memset)(void *__dest ,
                                                                                                   int __ch ,
                                                                                                   size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void *( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) memset)(void *__dest ,
                                                                                                   int __ch ,
                                                                                                   size_t __len )
{
  unsigned long tmp ;
  void *tmp___0 ;
  {
  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memset_chk(__dest, __ch, __len, tmp);
  }
  return (tmp___0);
}
}
__inline extern void ( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) bcopy)(void const *__src ,
                                                                                                   void *__dest ,
                                                                                                   size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void ( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) bcopy)(void const *__src ,
                                                                                                   void *__dest ,
                                                                                                   size_t __len )
{
  unsigned long tmp ;
  {
  {
  tmp = __builtin_object_size(__dest, 0);
  __builtin___memmove_chk(__dest, __src, __len, tmp);
  }
  return;
}
}
__inline extern void ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) bzero)(void *__dest ,
                                                                                                 size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) bzero)(void *__dest ,
                                                                                                 size_t __len )
{
  unsigned long tmp ;
  {
  {
  tmp = __builtin_object_size(__dest, 0);
  __builtin___memset_chk(__dest, '\000', __len, tmp);
  }
  return;
}
}
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) strcpy)(char *__dest ,
                                                                                                     char const *__src ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) strcpy)(char *__dest ,
                                                                                                     char const *__src )
{
  unsigned long tmp ;
  char *tmp___0 ;
  {
  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strcpy_chk(__dest, __src, tmp);
  }
  return (tmp___0);
}
}
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) stpcpy)(char *__dest ,
                                                                                                     char const *__src ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) stpcpy)(char *__dest ,
                                                                                                     char const *__src )
{
  unsigned long tmp ;
  char *tmp___0 ;
  {
  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___stpcpy_chk(__dest, __src, tmp);
  }
  return (tmp___0);
}
}
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) strncpy)(char *__dest ,
                                                                                                      char const *__src ,
                                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) strncpy)(char *__dest ,
                                                                                                      char const *__src ,
                                                                                                      size_t __len )
{
  unsigned long tmp ;
  char *tmp___0 ;
  {
  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strncpy_chk(__dest, __src, __len, tmp);
  }
  return (tmp___0);
}
}
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) stpncpy)(char *__dest ,
                                                                                                      char const *__src ,
                                                                                                      size_t __n ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) stpncpy)(char *__dest ,
                                                                                                      char const *__src ,
                                                                                                      size_t __n )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___3 ;
  {
  {
  tmp___1 = __builtin_object_size((void *)__dest, 1);
  }
  if (tmp___1 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__dest, 1);
    tmp___0 = __stpncpy_chk(__dest, __src, __n, tmp);
    }
    return (tmp___0);
    }
  }
  {
  tmp___3 = __stpncpy_alias(__dest, __src, __n);
  }
  return (tmp___3);
}
}
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) strcat)(char *__dest ,
                                                                                                     char const *__src ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) strcat)(char *__dest ,
                                                                                                     char const *__src )
{
  unsigned long tmp ;
  char *tmp___0 ;
  {
  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strcat_chk(__dest, __src, tmp);
  }
  return (tmp___0);
}
}
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) strncat)(char *__dest ,
                                                                                                      char const *__src ,
                                                                                                      size_t __len ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __artificial__, __always_inline__)) strncat)(char *__dest ,
                                                                                                      char const *__src ,
                                                                                                      size_t __len )
{
  unsigned long tmp ;
  char *tmp___0 ;
  {
  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strncat_chk(__dest, __src, __len, tmp);
  }
  return (tmp___0);
}
}
int chmod_or_fchmod(char const *name , int desc , mode_t mode )
{
  int tmp ;
  int tmp___0 ;
  {
  if (desc != -1) {
    {
    {
    tmp = fchmod(desc, mode);
    }
    return (tmp);
    }
  } else {
    {
    {
    tmp___0 = chmod(name, mode);
    }
    return (tmp___0);
    }
  }
}
}
int qset_acl(char const *name , int desc , mode_t mode )
{
  int tmp ;
  {
  {
  tmp = chmod_or_fchmod(name, desc, mode);
  }
  return (tmp);
}
}
int set_acl(char const *name , int desc , mode_t mode )
{
  int r ;
  int tmp ;
  char const *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  {
  {
  tmp = qset_acl(name, desc, mode);
  r = tmp;
  }
  if (r != 0) {
    {
    {
    tmp___0 = quote(name);
    tmp___1 = dcgettext((char const *)((void *)0), (char const *)"setting permissions for %s",
                        5);
    tmp___2 = __errno_location();
    error(0, *tmp___2, (char const *)tmp___1, tmp___0);
    }
    }
  }
  return (r);
}
}
static int qcopy_acl(char const *src_name , int source_desc , char const *dst_name ,
                     int dest_desc , mode_t mode )
{
  int tmp ;
  {
  {
  tmp = qset_acl(dst_name, dest_desc, mode);
  }
  return (tmp);
}
}
int copy_acl(char const *src_name , int source_desc , char const *dst_name , int dest_desc ,
             mode_t mode )
{
  int ret ;
  int tmp ;
  char const *tmp___0 ;
  int *tmp___1 ;
  char const *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  {
  {
  tmp = qcopy_acl(src_name, source_desc, dst_name, dest_desc, mode);
  ret = tmp;
  }
  {
  if (ret == -2) {
    {
    goto case_neg_2;
    }
  }
  if (ret == -1) {
    {
    goto case_neg_1;
    }
  }
  goto switch_default;
  case_neg_2:
  {
  tmp___0 = quote(src_name);
  tmp___1 = __errno_location();
  error(0, *tmp___1, (char const *)"%s", tmp___0);
  }
  return (-1);
  case_neg_1:
  {
  tmp___2 = quote(dst_name);
  tmp___3 = dcgettext((char const *)((void *)0), (char const *)"preserving permissions for %s",
                      5);
  tmp___4 = __errno_location();
  error(0, *tmp___4, (char const *)tmp___3, tmp___2);
  }
  return (-1);
  switch_default:
  return (0);
  switch_break: ;
  }
}
}
int file_has_acl(char const *name , struct stat const *sb )
{
  {
  return (0);
}
}

__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) read)(int __fd ,
                                                                                                           void *__buf ,
                                                                                                           size_t __nbytes )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size(__buf, 0);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __read_chk(__fd, __buf, __nbytes, tmp);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size(__buf, 0);
    }
    if (__nbytes > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __read_chk_warn(__fd, __buf, __nbytes, tmp___1);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __read_alias(__fd, __buf, __nbytes);
  }
  return (tmp___5);
}
}
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) pread)(int __fd ,
                                                                                                            void *__buf ,
                                                                                                            size_t __nbytes ,
                                                                                                            __off_t __offset )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size(__buf, 0);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __pread_chk(__fd, __buf, __nbytes, __offset, tmp);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size(__buf, 0);
    }
    if (__nbytes > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __pread_chk_warn(__fd, __buf, __nbytes, __offset, tmp___1);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __pread_alias(__fd, __buf, __nbytes, __offset);
  }
  return (tmp___5);
}
}
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) pread64)(int __fd ,
                                                                                                              void *__buf ,
                                                                                                              size_t __nbytes ,
                                                                                                              __off64_t __offset )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size(__buf, 0);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __pread64_chk(__fd, __buf, __nbytes, __offset, tmp);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size(__buf, 0);
    }
    if (__nbytes > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __pread64_chk_warn(__fd, __buf, __nbytes, __offset, tmp___1);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __pread64_alias(__fd, __buf, __nbytes, __offset);
  }
  return (tmp___5);
}
}
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__artificial__, __always_inline__)) readlink)(char const *__path , char *__buf ,
                                              size_t __len ) __attribute__((__nothrow__)) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__artificial__, __always_inline__)) readlink)(char const *__path , char *__buf ,
                                              size_t __len )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __readlink_chk((char const * __restrict )__path, (char * __restrict )__buf,
                             __len, tmp);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    }
    if (__len > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __readlink_chk_warn((char const * __restrict )__path, (char * __restrict )__buf,
                                    __len, tmp___1);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __readlink_alias((char const * __restrict )__path, (char * __restrict )__buf,
                             __len);
  }
  return (tmp___5);
}
}
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__artificial__, __always_inline__)) readlinkat)(int __fd , char const *__path ,
                                                char *__buf , size_t __len ) __attribute__((__nothrow__)) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__artificial__, __always_inline__)) readlinkat)(int __fd , char const *__path ,
                                                char *__buf , size_t __len )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __readlinkat_chk(__fd, (char const * __restrict )__path, (char * __restrict )__buf,
                               __len, tmp);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    }
    if (__len > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __readlinkat_chk_warn(__fd, (char const * __restrict )__path, (char * __restrict )__buf,
                                      __len, tmp___1);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __readlinkat_alias(__fd, (char const * __restrict )__path, (char * __restrict )__buf,
                               __len);
  }
  return (tmp___5);
}
}
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) getcwd)(char *__buf ,
                                                                                                           size_t __size ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) getcwd)(char *__buf ,
                                                                                                           size_t __size )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getcwd_chk(__buf, __size, tmp);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    }
    if (__size > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __getcwd_chk_warn(__buf, __size, tmp___1);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __getcwd_alias(__buf, __size);
  }
  return (tmp___5);
}
}
__inline extern char __attribute__((__deprecated__)) *( __attribute__((__warn_unused_result__,
__nonnull__(1), __artificial__, __always_inline__)) getwd)(char *__buf ) __attribute__((__nothrow__,
__deprecated__)) ;
__inline extern char __attribute__((__deprecated__)) *( __attribute__((__warn_unused_result__,
__nonnull__(1), __artificial__, __always_inline__)) getwd)(char *__buf )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  {
  {
  tmp___1 = __builtin_object_size((void *)__buf, 1);
  }
  if (tmp___1 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getwd_chk(__buf, tmp);
    }
    return ((char __attribute__((__deprecated__)) *)tmp___0);
    }
  }
  {
  tmp___2 = __getwd_warn(__buf);
  }
  return ((char __attribute__((__deprecated__)) *)tmp___2);
}
}
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) confstr)(int __name ,
                                                                                     char *__buf ,
                                                                                     size_t __len ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) confstr)(int __name ,
                                                                                     char *__buf ,
                                                                                     size_t __len )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __confstr_chk(__name, __buf, __len, tmp);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    }
    if (tmp___3 < __len) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __confstr_chk_warn(__name, __buf, __len, tmp___1);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __confstr_alias(__name, __buf, __len);
  }
  return (tmp___5);
}
}
__inline extern int ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) getgroups)(int __size ,
                                                                                                            __gid_t *__list ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) getgroups)(int __size ,
                                                                                                            __gid_t *__list )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__list, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__list, 1);
    tmp___0 = __getgroups_chk(__size, __list, tmp);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__list, 1);
    }
    if ((unsigned long )__size * sizeof(__gid_t ) > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__list, 1);
      tmp___2 = __getgroups_chk_warn(__size, __list, tmp___1);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __getgroups_alias(__size, __list);
  }
  return (tmp___5);
}
}
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __artificial__,
__always_inline__)) ttyname_r)(int __fd , char *__buf , size_t __buflen ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __artificial__,
__always_inline__)) ttyname_r)(int __fd , char *__buf , size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __ttyname_r_chk(__fd, __buf, __buflen, tmp);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    }
    if (__buflen > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __ttyname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __ttyname_r_alias(__fd, __buf, __buflen);
  }
  return (tmp___5);
}
}
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) getlogin_r)(char *__buf ,
                                                                                                     size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getlogin_r_chk(__buf, __buflen, tmp);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    }
    if (__buflen > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __getlogin_r_chk_warn(__buf, __buflen, tmp___1);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __getlogin_r_alias(__buf, __buflen);
  }
  return (tmp___5);
}
}
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) gethostname)(char *__buf ,
                                                                                                      size_t __buflen ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) gethostname)(char *__buf ,
                                                                                                      size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __gethostname_chk(__buf, __buflen, tmp);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    }
    if (__buflen > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __gethostname_chk_warn(__buf, __buflen, tmp___1);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __gethostname_alias(__buf, __buflen);
  }
  return (tmp___5);
}
}
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __artificial__,
__always_inline__)) getdomainname)(char *__buf , size_t __buflen ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __artificial__,
__always_inline__)) getdomainname)(char *__buf , size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getdomainname_chk(__buf, __buflen, tmp);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    }
    if (__buflen > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __getdomainname_chk_warn(__buf, __buflen, tmp___1);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __getdomainname_alias(__buf, __buflen);
  }
  return (tmp___5);
}
}
char *areadlink(char const *filename )
{
  char *tmp ;
  {
  {
  tmp = careadlinkat(-100, filename, (char *)((void *)0), (size_t )0, (struct allocator const *)((void *)0),
                     & careadlinkatcwd);
  }
  return (tmp);
}
}
char *areadlink_with_size(char const *file , size_t size )
{
  size_t symlink_max ;
  size_t INITIAL_LIMIT_BOUND ;
  size_t initial_limit ;
  size_t tmp ;
  size_t buf_size ;
  size_t tmp___0 ;
  ssize_t r ;
  size_t link_length ;
  char *buffer ;
  void *tmp___1 ;
  ssize_t tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  ssize_t tmp___7 ;
  ssize_t tmp___8 ;
  {
  {
  symlink_max = (size_t )1024;
  INITIAL_LIMIT_BOUND = (size_t )8192;
  }
  if (symlink_max < INITIAL_LIMIT_BOUND) {
    {
    {
    tmp = symlink_max + 1UL;
    }
    }
  } else {
    {
    {
    tmp = INITIAL_LIMIT_BOUND;
    }
    }
  }
  {
  initial_limit = tmp;
  }
  if (size < initial_limit) {
    {
    {
    tmp___0 = size + 1UL;
    }
    }
  } else {
    {
    {
    tmp___0 = initial_limit;
    }
    }
  }
  {
  buf_size = tmp___0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___1 = malloc(buf_size);
    buffer = (char *)tmp___1;
    }
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
      {
      return ((char *)((void *)0));
      }
    }
    {
    tmp___8 = readlink((char const *)((char const * __restrict )file), (char *)((char * __restrict )buffer),
                       buf_size);
    tmp___7 = tmp___8;
    tmp___2 = tmp___7;
    r = tmp___2;
    link_length = (size_t )r;
    }
    if (r < 0L) {
      {
      {
      tmp___5 = __errno_location();
      }
      if (*tmp___5 != 34) {
        {
        {
        tmp___3 = __errno_location();
        saved_errno = *tmp___3;
        free((void *)buffer);
        tmp___4 = __errno_location();
        *tmp___4 = saved_errno;
        }
        return ((char *)((void *)0));
        }
      }
      }
    }
    if (link_length < buf_size) {
      {
      {
      *(buffer + link_length) = (char)0;
      }
      return (buffer);
      }
    }
    {
    free((void *)buffer);
    }
    if (buf_size <= 4611686018427387903UL) {
      {
      {
      buf_size *= 2UL;
      }
      }
    } else {
      {
      if (buf_size < 9223372036854775807UL) {
        {
        {
        buf_size = 9223372036854775807UL;
        }
        }
      } else {
        {
        {
        tmp___6 = __errno_location();
        *tmp___6 = 12;
        }
        return ((char *)((void *)0));
        }
      }
      }
    }
  }
  while_break: ;
  }
  return ((char *)0);
}
}
char *areadlinkat(int fd , char const *filename )
{
  char *tmp ;
  {
  {
  tmp = careadlinkat(fd, filename, (char *)((void *)0), (size_t )0, (struct allocator const *)((void *)0),
                     (ssize_t (*)(int , char const * , char * , size_t ))(& readlinkat));
  }
  return (tmp);
}
}
__inline extern int getchar(void)
{
  int tmp ;
  {
  {
  tmp = _IO_getc(stdin);
  }
  return (tmp);
}
}
__inline extern int fgetc_unlocked(FILE *__fp )
{
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  {
  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  }
  if (tmp___3) {
    {
    {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
    }
    }
  } else {
    {
    {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
    }
    }
  }
  return (tmp___2);
}
}
__inline extern int getchar_unlocked(void)
{
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  {
  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  }
  if (tmp___3) {
    {
    {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
    }
    }
  } else {
    {
    {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
    }
    }
  }
  return (tmp___2);
}
}
__inline extern int putchar(int __c )
{
  int tmp ;
  {
  {
  tmp = _IO_putc(__c, stdout);
  }
  return (tmp);
}
}
__inline extern int fputc_unlocked(int __c , FILE *__stream )
{
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  {
  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  }
  if (tmp___4) {
    {
    {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
    }
    }
  } else {
    {
    {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
    }
    }
  }
  return (tmp___3);
}
}
__inline extern int putchar_unlocked(int __c )
{
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  {
  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  }
  if (tmp___4) {
    {
    {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
    }
    }
  } else {
    {
    {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
    }
    }
  }
  return (tmp___3);
}
}
__inline extern __ssize_t ( __attribute__((__warn_unused_result__)) getline)(char **__lineptr ,
                                                                             size_t *__n ,
                                                                             FILE *__stream )
{
  __ssize_t tmp ;
  {
  {
  tmp = __getdelim((char ** __restrict )__lineptr, (size_t * __restrict )__n, '\n',
                   (FILE * __restrict )__stream);
  }
  return (tmp);
}
}
__inline extern int ( __attribute__((__warn_unused_result__)) feof_unlocked)(FILE *__stream ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__)) feof_unlocked)(FILE *__stream )
{
  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern int ( __attribute__((__warn_unused_result__)) ferror_unlocked)(FILE *__stream ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__)) ferror_unlocked)(FILE *__stream )
{
  {
  return ((__stream->_flags & 32) != 0);
}
}

__inline extern int ( __attribute__((__artificial__, __always_inline__)) vsnprintf)(char *__s ,
                                                                                    size_t __n ,
                                                                                    char const *__fmt ,
                                                                                    __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vsnprintf)(char *__s ,
                                                                                    size_t __n ,
                                                                                    char const *__fmt ,
                                                                                    __gnuc_va_list __ap )
{
  unsigned long tmp ;
  int tmp___0 ;
  {
  {
  tmp = __builtin_object_size((void *)__s, 1);
  tmp___0 = __builtin___vsnprintf_chk(__s, __n, 1, tmp, __fmt, __ap);
  }
  return (tmp___0);
}
}

__inline extern int ( __attribute__((__artificial__, __always_inline__)) vprintf)(char const *__fmt ,
                                                                                  __gnuc_va_list __ap )
{
  int tmp ;
  {
  {
  tmp = __vfprintf_chk((FILE * __restrict )stdout, 1, (char const * __restrict )__fmt,
                       __ap);
  }
  return (tmp);
}
}
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                   char const *__fmt ,
                                                                                   __gnuc_va_list __ap )
{
  int tmp ;
  {
  {
  tmp = __vfprintf_chk((FILE * __restrict )__stream, 1, (char const * __restrict )__fmt,
                       __ap);
  }
  return (tmp);
}
}

__inline extern int ( __attribute__((__artificial__, __always_inline__)) vdprintf)(int __fd ,
                                                                                   char const *__fmt ,
                                                                                   __gnuc_va_list __ap )
{
  int tmp ;
  {
  {
  tmp = __vdprintf_chk(__fd, 1, (char const * __restrict )__fmt, __ap);
  }
  return (tmp);
}
}
__inline extern int ( __attribute__((__artificial__, __always_inline__)) obstack_vprintf)(struct obstack *__obstack ,
                                                                                          char const *__fmt ,
                                                                                          __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) obstack_vprintf)(struct obstack *__obstack ,
                                                                                          char const *__fmt ,
                                                                                          __gnuc_va_list __ap )
{
  int tmp ;
  {
  {
  tmp = __obstack_vprintf_chk((struct obstack * __restrict )__obstack, 1, (char const * __restrict )__fmt,
                              __ap);
  }
  return (tmp);
}
}
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets)(char *__s ,
                                                                                                          int __n ,
                                                                                                          FILE *__stream )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__s, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __fgets_chk((char * __restrict )__s, tmp, __n, (FILE * __restrict )__stream);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__s, 1);
    }
    if ((size_t )__n > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__s, 1);
      tmp___2 = __fgets_chk_warn((char * __restrict )__s, tmp___1, __n, (FILE * __restrict )__stream);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __fgets_alias((char * __restrict )__s, __n, (FILE * __restrict )__stream);
  }
  return (tmp___5);
}
}
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread)(void *__ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE *__stream )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size(__ptr, 0);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size(__ptr, 0);
    tmp___0 = __fread_chk((void * __restrict )__ptr, tmp, __size, __n, (FILE * __restrict )__stream);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size(__ptr, 0);
    }
    if (__size * __n > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size(__ptr, 0);
      tmp___2 = __fread_chk_warn((void * __restrict )__ptr, tmp___1, __size, __n,
                                 (FILE * __restrict )__stream);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __fread_alias((void * __restrict )__ptr, __size, __n, (FILE * __restrict )__stream);
  }
  return (tmp___5);
}
}
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets_unlocked)(char *__s ,
                                                                                                                   int __n ,
                                                                                                                   FILE *__stream )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__s, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __fgets_unlocked_chk((char * __restrict )__s, tmp, __n, (FILE * __restrict )__stream);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__s, 1);
    }
    if ((size_t )__n > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__s, 1);
      tmp___2 = __fgets_unlocked_chk_warn((char * __restrict )__s, tmp___1, __n,
                                          (FILE * __restrict )__stream);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __fgets_unlocked_alias((char * __restrict )__s, __n, (FILE * __restrict )__stream);
  }
  return (tmp___5);
}
}
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread_unlocked)(void *__ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE *__stream )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___11 ;
  {
  {
  tmp___4 = __builtin_object_size(__ptr, 0);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size(__ptr, 0);
    tmp___0 = __fread_unlocked_chk((void * __restrict )__ptr, tmp, __size, __n, (FILE * __restrict )__stream);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size(__ptr, 0);
    }
    if (__size * __n > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size(__ptr, 0);
      tmp___2 = __fread_unlocked_chk_warn((void * __restrict )__ptr, tmp___1, __size,
                                          __n, (FILE * __restrict )__stream);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___11 = __fread_unlocked_alias((void * __restrict )__ptr, __size, __n, (FILE * __restrict )__stream);
  }
  return (tmp___11);
}
}
static void __argmatch_die(void)
{
  {
  {
  usage(1);
  }
  return;
}
}
ptrdiff_t argmatch(char const *arg , char const **arglist , char const *vallist ,
                   size_t valsize )
{
  size_t i ;
  size_t arglen ;
  ptrdiff_t matchind ;
  _Bool ambiguous ;
  int tmp ;
  size_t tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  {
  {
  matchind = (ptrdiff_t )-1;
  ambiguous = (_Bool)0;
  arglen = strlen(arg);
  i = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! *(arglist + i)) {
      {
      goto while_break;
      }
    }
    if (0) {
      {
      if (0) {
        {
        {
        __s1_len = __builtin_strlen((char const *)*(arglist + i));
        __s2_len = __builtin_strlen(arg);
        }
        if (! ((size_t )((void const *)(*(arglist + i) + 1)) - (size_t )((void const *)*(arglist + i)) == 1UL)) {
          {
          goto _L___0;
          }
        } else {
          {
          if (__s1_len >= 4UL) {
            {
            _L___0:
            if (! ((size_t )((void const *)(arg + 1)) - (size_t )((void const *)arg) == 1UL)) {
              {
              {
              tmp___9 = 1;
              }
              }
            } else {
              {
              if (__s2_len >= 4UL) {
                {
                {
                tmp___9 = 1;
                }
                }
              } else {
                {
                {
                tmp___9 = 0;
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            tmp___9 = 0;
            }
            }
          }
          }
        }
        if (tmp___9) {
          {
          {
          tmp___4 = __builtin_strcmp((char const *)*(arglist + i), arg);
          tmp___8 = tmp___4;
          }
          }
        } else {
          {
          {
          tmp___7 = __builtin_strcmp((char const *)*(arglist + i), arg);
          tmp___8 = tmp___7;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___7 = __builtin_strcmp((char const *)*(arglist + i), arg);
        tmp___8 = tmp___7;
        }
        }
      }
      {
      tmp___11 = tmp___8;
      }
      }
    } else {
      {
      {
      tmp___10 = strncmp((char const *)*(arglist + i), arg, arglen);
      tmp___11 = tmp___10;
      }
      }
    }
    if (! tmp___11) {
      {
      {
      tmp___0 = strlen((char const *)*(arglist + i));
      }
      if (tmp___0 == arglen) {
        {
        return ((ptrdiff_t )i);
        }
      } else {
        {
        if (matchind == -1L) {
          {
          {
          matchind = (ptrdiff_t )i;
          }
          }
        } else {
          {
          if ((unsigned long )vallist == (unsigned long )((void *)0)) {
            {
            {
            ambiguous = (_Bool)1;
            }
            }
          } else {
            {
            {
            tmp = memcmp((void const *)(vallist + valsize * (size_t )matchind),
                         (void const *)(vallist + valsize * i), valsize);
            }
            if (tmp) {
              {
              {
              ambiguous = (_Bool)1;
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    {
    i ++;
    }
  }
  while_break: ;
  }
  if (ambiguous) {
    {
    return ((ptrdiff_t )-2);
    }
  } else {
    {
    return (matchind);
    }
  }
}
}
void argmatch_invalid(char const *context , char const *value , ptrdiff_t problem )
{
  char const *format ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const *tmp___2 ;
  char *tmp___3 ;
  {
  if (problem == -1L) {
    {
    {
    tmp = dcgettext((char const *)((void *)0), (char const *)"invalid argument %s for %s",
                    5);
    tmp___1 = tmp;
    }
    }
  } else {
    {
    {
    tmp___0 = dcgettext((char const *)((void *)0), (char const *)"ambiguous argument %s for %s",
                        5);
    tmp___1 = tmp___0;
    }
    }
  }
  {
  format = (char const *)tmp___1;
  tmp___2 = quote_n(1, context);
  tmp___3 = quotearg_n_style(0, (enum quoting_style )6, value);
  error(0, 0, format, tmp___3, tmp___2);
  }
  return;
}
}
void argmatch_valid(char const **arglist , char const *vallist , size_t valsize )
{
  size_t i ;
  char const *last_val ;
  char *tmp ;
  int tmp___0 ;
  {
  {
  last_val = (char const *)((void *)0);
  tmp = dcgettext((char const *)((void *)0), (char const *)"Valid arguments are:",
                  5);
  fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )tmp));
  i = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! *(arglist + i)) {
      {
      goto while_break;
      }
    }
    if (i == 0UL) {
      {
      {
      fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )"\n  - `%s\'"),
              *(arglist + i));
      last_val = vallist + valsize * i;
      }
      }
    } else {
      {
      {
      tmp___0 = memcmp((void const *)last_val, (void const *)(vallist + valsize * i),
                       valsize);
      }
      if (tmp___0) {
        {
        {
        fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )"\n  - `%s\'"),
                *(arglist + i));
        last_val = vallist + valsize * i;
        }
        }
      } else {
        {
        {
        fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )", `%s\'"),
                *(arglist + i));
        }
        }
      }
      }
    }
    {
    i ++;
    }
  }
  while_break: ;
  }
  {
  fputc_unlocked('\n', stderr);
  }
  return;
}
}
ptrdiff_t __xargmatch_internal(char const *context , char const *arg , char const **arglist ,
                               char const *vallist , size_t valsize , void (*exit_fn)(void) )
{
  ptrdiff_t res ;
  ptrdiff_t tmp ;
  {
  {
  tmp = argmatch(arg, arglist, vallist, valsize);
  res = tmp;
  }
  if (res >= 0L) {
    {
    return (res);
    }
  }
  {
  argmatch_invalid(context, arg, res);
  argmatch_valid(arglist, vallist, valsize);
  (*exit_fn)();
  }
  return ((ptrdiff_t )-1);
}
}
char const *argmatch_to_argument(char const *value , char const **arglist ,
                                   char const *vallist , size_t valsize )
{
  size_t i ;
  int tmp ;
  {
  {
  i = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! *(arglist + i)) {
      {
      goto while_break;
      }
    }
    {
    tmp = memcmp((void const *)value, (void const *)(vallist + valsize * i), valsize);
    }
    if (! tmp) {
      {
      return ((char const *)*(arglist + i));
      }
    }
    {
    i ++;
    }
  }
  while_break: ;
  }
  return ((char const *)((void *)0));
}
}
struct argv_iterator *( __attribute__((__nonnull__(1))) argv_iter_init_argv)(char **argv )
{
  struct argv_iterator *ai ;
  void *tmp ;
  {
  {
  tmp = malloc(sizeof(*ai));
  ai = (struct argv_iterator *)tmp;
  }
  if (! ai) {
    {
    return ((struct argv_iterator *)((void *)0));
    }
  }
  {
  ai->fp = (FILE *)((void *)0);
  ai->arg_list = argv;
  ai->p = argv;
  }
  return (ai);
}
}
struct argv_iterator *( __attribute__((__nonnull__(1))) argv_iter_init_stream)(FILE *fp )
{
  struct argv_iterator *ai ;
  void *tmp ;
  {
  {
  tmp = malloc(sizeof(*ai));
  ai = (struct argv_iterator *)tmp;
  }
  if (! ai) {
    {
    return ((struct argv_iterator *)((void *)0));
    }
  }
  {
  ai->fp = fp;
  ai->tok = (char *)((void *)0);
  ai->buf_len = (size_t )0;
  ai->item_idx = (size_t )0;
  ai->arg_list = (char **)((void *)0);
  }
  return (ai);
}
}
char *( __attribute__((__nonnull__(1,2))) argv_iter)(struct argv_iterator *ai , enum argv_iter_err *err )
{
  ssize_t len ;
  __ssize_t tmp ;
  int tmp___1 ;
  char **tmp___2 ;
  {
  if (ai->fp) {
    {
    {
    tmp = getdelim((char ** __restrict )(& ai->tok), (size_t * __restrict )(& ai->buf_len),
                   '\000', (FILE * __restrict )ai->fp);
    len = tmp;
    }
    if (len < 0L) {
      {
      {
      tmp___1 = feof(ai->fp);
      }
      if (tmp___1) {
        {
        {
        *err = (enum argv_iter_err )2;
        }
        }
      } else {
        {
        {
        *err = (enum argv_iter_err )4;
        }
        }
      }
      return ((char *)((void *)0));
      }
    }
    {
    *err = (enum argv_iter_err )1;
    (ai->item_idx) ++;
    }
    return (ai->tok);
    }
  } else {
    {
    if ((unsigned long )*(ai->p) == (unsigned long )((void *)0)) {
      {
      {
      *err = (enum argv_iter_err )2;
      }
      return ((char *)((void *)0));
      }
    } else {
      {
      {
      *err = (enum argv_iter_err )1;
      tmp___2 = ai->p;
      (ai->p) ++;
      }
      return (*tmp___2);
      }
    }
    }
  }
}
}
size_t ( __attribute__((__nonnull__(1))) argv_iter_n_args)(struct argv_iterator const *ai )
{
  size_t tmp ;
  {
  if (ai->fp) {
    {
    {
    tmp = (size_t )ai->item_idx;
    }
    }
  } else {
    {
    {
    tmp = (size_t )((size_t const )(ai->p - ai->arg_list));
    }
    }
  }
  return (tmp);
}
}
void ( __attribute__((__nonnull__(1))) argv_iter_free)(struct argv_iterator *ai )
{
  {
  if (ai->fp) {
    {
    {
    free((void *)ai->tok);
    }
    }
  }
  {
  free((void *)ai);
  }
  return;
}
}
__inline static void *xnrealloc(void *p , size_t n , size_t s ) __attribute__((__alloc_size__(2,3))) ;
__inline static void *xnrealloc(void *p , size_t n , size_t s )
{
  int tmp ;
  void *tmp___0 ;
  {
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
    {
    {
    tmp = -1;
    }
    }
  } else {
    {
    {
    tmp = -2;
    }
    }
  }
  if ((size_t )tmp / s < n) {
    {
    {
    xalloc_die();
    }
    }
  }
  {
  tmp___0 = xrealloc(p, n * s);
  }
  return (tmp___0);
}
}
static void check_extension(char *file , size_t filelen , char e )
{
  char *base ;
  char *tmp ;
  size_t baselen ;
  size_t tmp___0 ;
  size_t baselen_max ;
  long name_max ;
  char tmp___1[sizeof(".")] ;
  int *tmp___2 ;
  long size ;
  int *tmp___3 ;
  {
  {
  tmp = last_component((char const *)file);
  base = tmp;
  tmp___0 = base_len((char const *)base);
  baselen = tmp___0;
  baselen_max = (size_t )255;
  }
  if (14UL < baselen) {
    {
    {
    memcpy((void *)((void * __restrict )(tmp___1)), (void const *)((void const * __restrict )base),
           sizeof("."));
    strcpy((char *)((char * __restrict )base), (char const *)((char const * __restrict )"."));
    tmp___2 = __errno_location();
    *tmp___2 = 0;
    name_max = pathconf((char const *)file, 3);
    }
    if (0L <= name_max) {
      {
      goto _L;
      }
    } else {
      {
      {
      tmp___3 = __errno_location();
      }
      if (*tmp___3 == 0) {
        {
        _L:
        {
        baselen_max = (size_t )name_max;
        size = (long )baselen_max;
        }
        if (name_max != size) {
          {
          {
          baselen_max = (size_t )-1;
          }
          }
        }
        }
      }
      }
    }
    {
    memcpy((void *)((void * __restrict )base), (void const *)((void const * __restrict )(tmp___1)),
           sizeof("."));
    }
    }
  }
  if (baselen_max < baselen) {
    {
    {
    baselen = (size_t )((file + filelen) - base);
    }
    if (baselen_max <= baselen) {
      {
      {
      baselen = baselen_max - 1UL;
      }
      }
    }
    {
    *(base + baselen) = e;
    *(base + (baselen + 1UL)) = (char )'\000';
    }
    }
  }
  return;
}
}
static enum numbered_backup_result numbered_backup(char **buffer , size_t buffer_size ,
                                                   size_t filelen )
{
  enum numbered_backup_result result ;
  DIR *dirp ;
  struct dirent *dp ;
  char *buf___1 ;
  size_t versionlenmax ;
  char *base ;
  char *tmp ;
  size_t base_offset ;
  size_t baselen ;
  size_t tmp___0 ;
  char tmp___1[sizeof(".")] ;
  char const *p ;
  char *q ;
  _Bool all_9s ;
  size_t versionlen ;
  size_t new_buflen ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  {
  {
  result = (enum numbered_backup_result )2;
  buf___1 = *buffer;
  versionlenmax = (size_t )1;
  tmp = last_component((char const *)buf___1);
  base = tmp;
  base_offset = (size_t )(base - buf___1);
  tmp___0 = base_len((char const *)base);
  baselen = tmp___0;
  memcpy((void *)((void * __restrict )(tmp___1)), (void const *)((void const * __restrict )base),
         sizeof("."));
  strcpy((char *)((char * __restrict )base), (char const *)((char const * __restrict )"."));
  dirp = opendir_safer((char const *)buf___1);
  memcpy((void *)((void * __restrict )base), (void const *)((void const * __restrict )(tmp___1)),
         sizeof("."));
  strcpy((char *)((char * __restrict )(base + baselen)), (char const *)((char const * __restrict )".~1~"));
  }
  if (! dirp) {
    {
    return (result);
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    dp = readdir(dirp);
    }
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
      {
      goto while_break;
      }
    }
    if (! (dp->d_ino != 0UL)) {
      {
      goto while_continue;
      }
    } else {
      {
      {
      tmp___2 = strlen((char const *)(dp->d_name));
      }
      if (tmp___2 < baselen + 4UL) {
        {
        goto while_continue;
        }
      }
      }
    }
    {
    tmp___3 = memcmp((void const *)(buf___1 + base_offset), (void const *)(dp->d_name),
                     baselen + 2UL);
    }
    if (tmp___3 != 0) {
      {
      goto while_continue;
      }
    }
    {
    p = (char const *)((dp->d_name + baselen) + 2);
    }
    if (49 <= (int )*p) {
      {
      if (! ((int const )*p <= 57)) {
        {
        goto while_continue;
        }
      }
      }
    } else {
      {
      goto while_continue;
      }
    }
    {
    all_9s = (_Bool )((int const )*p == 57);
    versionlen = (size_t )1;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! ((unsigned int )*(p + versionlen) - 48U <= 9U)) {
        {
        goto while_break___0;
        }
      }
      {
      all_9s = (_Bool )((int )all_9s & ((int const )*(p + versionlen) == 57));
      versionlen ++;
      }
    }
    while_break___0: ;
    }
    if ((int const )*(p + versionlen) == 126) {
      {
      if (! *(p + (versionlen + 1UL))) {
        {
        if (! (versionlenmax < versionlen)) {
          {
          if (versionlenmax == versionlen) {
            {
            {
            tmp___4 = memcmp((void const *)((buf___1 + filelen) + 2), (void const *)p,
                             versionlen);
            }
            if (! (tmp___4 <= 0)) {
              {
              goto while_continue;
              }
            }
            }
          } else {
            {
            goto while_continue;
            }
          }
          }
        }
        }
      } else {
        {
        goto while_continue;
        }
      }
      }
    } else {
      {
      goto while_continue;
      }
    }
    {
    versionlenmax = (size_t )all_9s + versionlen;
    }
    if (all_9s) {
      {
      {
      result = (enum numbered_backup_result )1;
      }
      }
    } else {
      {
      {
      result = (enum numbered_backup_result )0;
      }
      }
    }
    {
    new_buflen = ((filelen + 2UL) + versionlenmax) + 1UL;
    }
    if (buffer_size <= new_buflen) {
      {
      {
      tmp___5 = xnrealloc((void *)buf___1, (size_t )2, new_buflen);
      buf___1 = (char *)tmp___5;
      buffer_size = new_buflen * 2UL;
      }
      }
    }
    {
    q = buf___1 + filelen;
    tmp___6 = q;
    q ++;
    *tmp___6 = (char )'.';
    tmp___7 = q;
    q ++;
    *tmp___7 = (char )'~';
    *q = (char )'0';
    q += (int )all_9s;
    memcpy((void *)((void * __restrict )q), (void const *)((void const * __restrict )p),
           versionlen + 2UL);
    q += versionlen;
    }
    {
    while (1) {
      while_continue___1: ;
      if (! 1) {
        {
        goto while_break___1;
        }
      }
      {
      q --;
      }
      if (! ((int )*q == 57)) {
        {
        goto while_break___1;
        }
      }
      {
      *q = (char )'0';
      }
    }
    while_break___1: ;
    }
    {
    *q = (char )((int )*q + 1);
    }
  }
  while_break: ;
  }
  {
  closedir(dirp);
  *buffer = buf___1;
  }
  return (result);
}
}
char *find_backup_file_name(char const *file , enum backup_type backup_type )
{
  size_t filelen ;
  size_t tmp ;
  char *s ;
  size_t ssize ;
  _Bool simple ;
  size_t simple_backup_suffix_size ;
  size_t tmp___0 ;
  size_t backup_suffix_size_guess ;
  void *tmp___1 ;
  enum numbered_backup_result tmp___2 ;
  {
  {
  tmp = strlen(file);
  filelen = tmp;
  simple = (_Bool)1;
  tmp___0 = strlen(simple_backup_suffix);
  simple_backup_suffix_size = tmp___0 + 1UL;
  backup_suffix_size_guess = simple_backup_suffix_size;
  }
  if (backup_suffix_size_guess < 9UL) {
    {
    {
    backup_suffix_size_guess = (size_t )9;
    }
    }
  }
  {
  ssize = (filelen + backup_suffix_size_guess) + 1UL;
  tmp___1 = xmalloc(ssize);
  s = (char *)tmp___1;
  memcpy((void *)((void * __restrict )s), (void const *)((void const * __restrict )file),
         filelen + 1UL);
  }
  if ((unsigned int )backup_type != 1U) {
    {
    {
    tmp___2 = numbered_backup(& s, ssize, filelen);
    }
    {
    if ((int )tmp___2 == 0) {
      {
      goto case_0;
      }
    }
    if ((int )tmp___2 == 1) {
      {
      goto case_1;
      }
    }
    if ((int )tmp___2 == 2) {
      {
      goto case_2;
      }
    }
    goto switch_break;
    case_0:
    return (s);
    case_1:
    {
    simple = (_Bool)0;
    }
    goto switch_break;
    case_2:
    {
    simple = (_Bool )((unsigned int )backup_type == 2U);
    }
    goto switch_break;
    switch_break: ;
    }
    }
  }
  if (simple) {
    {
    {
    memcpy((void *)((void * __restrict )(s + filelen)), (void const *)((void const * __restrict )simple_backup_suffix),
           simple_backup_suffix_size);
    }
    }
  }
  {
  check_extension(s, filelen, (char )'~');
  }
  return (s);
}
}
enum backup_type get_version(char const *context , char const *version )
{
  ptrdiff_t tmp ;
  {
  if ((unsigned long )version == (unsigned long )((char const *)0)) {
    {
    return ((enum backup_type )2);
    }
  } else {
    {
    if ((int const )*version == 0) {
      {
      return ((enum backup_type )2);
      }
    } else {
      {
      {
      tmp = __xargmatch_internal(context, version, backup_args, (char const *)(backup_types),
                                 sizeof(backup_types[0]), argmatch_die);
      }
      return ((enum backup_type )backup_types[tmp]);
      }
    }
    }
  }
}
}
enum backup_type xget_version(char const *context , char const *version )
{
  enum backup_type tmp ;
  char *tmp___0 ;
  enum backup_type tmp___1 ;
  {
  if (version) {
    {
    if (*version) {
      {
      {
      tmp = get_version(context, version);
      }
      return (tmp);
      }
    } else {
      {
      {
      tmp___0 = getenv((char const *)"VERSION_CONTROL");
      tmp___1 = get_version((char const *)"$VERSION_CONTROL", (char const *)tmp___0);
      }
      return (tmp___1);
      }
    }
    }
  } else {
    {
    {
    tmp___0 = getenv((char const *)"VERSION_CONTROL");
    tmp___1 = get_version((char const *)"$VERSION_CONTROL", (char const *)tmp___0);
    }
    return (tmp___1);
    }
  }
}
}
__inline static unsigned char to_uchar(char ch )
{
  {
  return ((unsigned char )ch);
}
}
void base64_encode(char const *in , size_t inlen , char *out , size_t outlen )
{
  char * __restrict tmp ;
  unsigned char tmp___0 ;
  char * __restrict tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  int tmp___4 ;
  char * __restrict tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  int tmp___8 ;
  char * __restrict tmp___9 ;
  unsigned char tmp___10 ;
  {
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (inlen) {
      {
      if (! outlen) {
        {
        goto while_break;
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
    {
    tmp = (char * __restrict )out;
    out ++;
    tmp___0 = to_uchar((char )*(in + 0));
    *tmp = (char )b64str[((int )tmp___0 >> 2) & 63];
    outlen --;
    }
    if (! outlen) {
      {
      goto while_break;
      }
    }
    {
    tmp___1 = (char * __restrict )out;
    out ++;
    tmp___2 = to_uchar((char )*(in + 0));
    inlen --;
    }
    if (inlen) {
      {
      {
      tmp___3 = to_uchar((char )*(in + 1));
      tmp___4 = (int )tmp___3 >> 4;
      }
      }
    } else {
      {
      {
      tmp___4 = 0;
      }
      }
    }
    {
    *tmp___1 = (char )b64str[(((int )tmp___2 << 4) + tmp___4) & 63];
    outlen --;
    }
    if (! outlen) {
      {
      goto while_break;
      }
    }
    {
    tmp___5 = (char * __restrict )out;
    out ++;
    }
    if (inlen) {
      {
      {
      tmp___6 = to_uchar((char )*(in + 1));
      inlen --;
      }
      if (inlen) {
        {
        {
        tmp___7 = to_uchar((char )*(in + 2));
        tmp___8 = (int )tmp___7 >> 6;
        }
        }
      } else {
        {
        {
        tmp___8 = 0;
        }
        }
      }
      {
      *tmp___5 = (char )b64str[(((int )tmp___6 << 2) + tmp___8) & 63];
      }
      }
    } else {
      {
      {
      *tmp___5 = (char )'=';
      }
      }
    }
    {
    outlen --;
    }
    if (! outlen) {
      {
      goto while_break;
      }
    }
    {
    tmp___9 = (char * __restrict )out;
    out ++;
    }
    if (inlen) {
      {
      {
      tmp___10 = to_uchar((char )*(in + 2));
      *tmp___9 = (char )b64str[(int )tmp___10 & 63];
      }
      }
    } else {
      {
      {
      *tmp___9 = (char )'=';
      }
      }
    }
    {
    outlen --;
    }
    if (! outlen) {
      {
      goto while_break;
      }
    }
    if (inlen) {
      {
      {
      inlen --;
      }
      }
    }
    if (inlen) {
      {
      {
      in += 3;
      }
      }
    }
  }
  while_break: ;
  }
  if (outlen) {
    {
    {
    *out = (char )'\000';
    }
    }
  }
  return;
}
}
size_t base64_encode_alloc(char const *in , size_t inlen , char **out )
{
  size_t outlen ;
  void *tmp ;
  {
  {
  outlen = 1UL + ((inlen + 2UL) / 3UL) * 4UL;
  }
  if (inlen > outlen) {
    {
    {
    *out = (char *)((void *)0);
    }
    return ((size_t )0);
    }
  }
  {
  tmp = malloc(outlen);
  *out = (char *)tmp;
  }
  if (! *out) {
    {
    return (outlen);
    }
  }
  {
  base64_encode((char const *)((char const * __restrict )in), inlen, (char *)((char * __restrict )*out),
                outlen);
  }
  return (outlen - 1UL);
}
}
_Bool isbase64(char ch )
{
  unsigned char tmp ;
  {
  {
  tmp = to_uchar(ch);
  }
  return ((_Bool )(0 <= (int )b64[tmp]));
}
}
void base64_decode_ctx_init(struct base64_decode_context *ctx )
{
  {
  {
  ctx->i = 0U;
  }
  return;
}
}
__inline static char *get_4(struct base64_decode_context *ctx , char const * __restrict *in ,
                            char const * __restrict in_end , size_t *n_non_newline )
{
  char const *t ;
  void *tmp ;
  char const *p ;
  char c ;
  char const *tmp___0 ;
  unsigned int tmp___1 ;
  {
  if (ctx->i == 4U) {
    {
    {
    ctx->i = 0U;
    }
    }
  }
  if (ctx->i == 0U) {
    {
    {
    t = (char const *)*in;
    }
    if (4L <= in_end - *in) {
      {
      {
      tmp = memchr((void const *)t, '\n', (size_t )4);
      }
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        {
        {
        *in += 4;
        *n_non_newline = (size_t )4;
        }
        return ((char *)t);
        }
      }
      }
    }
    }
  }
  {
  p = (char const *)*in;
  }
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )p < (unsigned long )in_end)) {
      {
      goto while_break;
      }
    }
    {
    tmp___0 = p;
    p ++;
    c = (char )*tmp___0;
    }
    if ((int )c != 10) {
      {
      {
      tmp___1 = ctx->i;
      (ctx->i) ++;
      ctx->buf[tmp___1] = c;
      }
      if (ctx->i == 4U) {
        {
        goto while_break;
        }
      }
      }
    }
  }
  while_break: ;
  }
  {
  *in = (char const * __restrict )p;
  *n_non_newline = (size_t )ctx->i;
  }
  return (ctx->buf);
}
}
__inline static _Bool decode_4(char const * __restrict in , size_t inlen , char * __restrict *outp ,
                               size_t *outleft )
{
  char *out ;
  _Bool tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  _Bool tmp___4 ;
  char *tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  _Bool tmp___8 ;
  char *tmp___9 ;
  unsigned char tmp___10 ;
  unsigned char tmp___11 ;
  {
  {
  out = (char *)*outp;
  }
  if (inlen < 2UL) {
    {
    return ((_Bool)0);
    }
  }
  {
  tmp = isbase64((char )*(in + 0));
  }
  if (tmp) {
    {
    {
    tmp___0 = isbase64((char )*(in + 1));
    }
    if (! tmp___0) {
      {
      return ((_Bool)0);
      }
    }
    }
  } else {
    {
    return ((_Bool)0);
    }
  }
  if (*outleft) {
    {
    {
    tmp___1 = out;
    out ++;
    tmp___2 = to_uchar((char )*(in + 0));
    tmp___3 = to_uchar((char )*(in + 1));
    *tmp___1 = (char )(((int const )b64[tmp___2] << 2) | ((int const )b64[tmp___3] >> 4));
    (*outleft) --;
    }
    }
  }
  if (inlen == 2UL) {
    {
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      {
      *outp = (char * __restrict )out;
      }
      return ((_Bool)0);
      goto while_break;
    }
    while_break: ;
    }
    }
  }
  if ((int const )*(in + 2) == 61) {
    {
    if (inlen != 4UL) {
      {
      {
      while (1) {
        while_continue___0: ;
        if (! 1) {
          {
          goto while_break___0;
          }
        }
        {
        *outp = (char * __restrict )out;
        }
        return ((_Bool)0);
        goto while_break___0;
      }
      while_break___0: ;
      }
      }
    }
    if ((int const )*(in + 3) != 61) {
      {
      {
      while (1) {
        while_continue___1: ;
        if (! 1) {
          {
          goto while_break___1;
          }
        }
        {
        *outp = (char * __restrict )out;
        }
        return ((_Bool)0);
        goto while_break___1;
      }
      while_break___1: ;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___4 = isbase64((char )*(in + 2));
    }
    if (! tmp___4) {
      {
      {
      while (1) {
        while_continue___2: ;
        if (! 1) {
          {
          goto while_break___2;
          }
        }
        {
        *outp = (char * __restrict )out;
        }
        return ((_Bool)0);
        goto while_break___2;
      }
      while_break___2: ;
      }
      }
    }
    if (*outleft) {
      {
      {
      tmp___5 = out;
      out ++;
      tmp___6 = to_uchar((char )*(in + 1));
      tmp___7 = to_uchar((char )*(in + 2));
      *tmp___5 = (char )((((int const )b64[tmp___6] << 4) & 240) | ((int const )b64[tmp___7] >> 2));
      (*outleft) --;
      }
      }
    }
    if (inlen == 3UL) {
      {
      {
      while (1) {
        while_continue___3: ;
        if (! 1) {
          {
          goto while_break___3;
          }
        }
        {
        *outp = (char * __restrict )out;
        }
        return ((_Bool)0);
        goto while_break___3;
      }
      while_break___3: ;
      }
      }
    }
    if ((int const )*(in + 3) == 61) {
      {
      if (inlen != 4UL) {
        {
        {
        while (1) {
          while_continue___4: ;
          if (! 1) {
            {
            goto while_break___4;
            }
          }
          {
          *outp = (char * __restrict )out;
          }
          return ((_Bool)0);
          goto while_break___4;
        }
        while_break___4: ;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___8 = isbase64((char )*(in + 3));
      }
      if (! tmp___8) {
        {
        {
        while (1) {
          while_continue___5: ;
          if (! 1) {
            {
            goto while_break___5;
            }
          }
          {
          *outp = (char * __restrict )out;
          }
          return ((_Bool)0);
          goto while_break___5;
        }
        while_break___5: ;
        }
        }
      }
      if (*outleft) {
        {
        {
        tmp___9 = out;
        out ++;
        tmp___10 = to_uchar((char )*(in + 2));
        tmp___11 = to_uchar((char )*(in + 3));
        *tmp___9 = (char )((((int const )b64[tmp___10] << 6) & 192) | (int const )b64[tmp___11]);
        (*outleft) --;
        }
        }
      }
      }
    }
    }
  }
  {
  *outp = (char * __restrict )out;
  }
  return ((_Bool)1);
}
}
_Bool base64_decode_ctx(struct base64_decode_context *ctx , char const *in , size_t inlen ,
                        char *out , size_t *outlen )
{
  size_t outleft ;
  _Bool ignore_newlines ;
  _Bool flush_ctx ;
  unsigned int ctx_i ;
  size_t outleft_save ;
  _Bool tmp ;
  char const *in_end ;
  char const *non_nl ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  {
  {
  outleft = *outlen;
  ignore_newlines = (_Bool )((unsigned long )ctx != (unsigned long )((void *)0));
  flush_ctx = (_Bool)0;
  ctx_i = 0U;
  }
  if (ignore_newlines) {
    {
    {
    ctx_i = ctx->i;
    flush_ctx = (_Bool )(inlen == 0UL);
    }
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    outleft_save = outleft;
    }
    if (ctx_i == 0U) {
      {
      if (! flush_ctx) {
        {
        {
        while (1) {
          while_continue___0: ;
          if (! 1) {
            {
            goto while_break___0;
            }
          }
          {
          outleft_save = outleft;
          tmp = decode_4((char const * __restrict )in, inlen, (char * __restrict *)(& out),
                         & outleft);
          }
          if (! tmp) {
            {
            goto while_break___0;
            }
          }
          {
          in += 4;
          inlen -= 4UL;
          }
        }
        while_break___0: ;
        }
        }
      }
      }
    }
    if (inlen == 0UL) {
      {
      if (! flush_ctx) {
        {
        goto while_break;
        }
      }
      }
    }
    if (inlen) {
      {
      if ((int const )*in == 10) {
        {
        if (ignore_newlines) {
          {
          {
          in ++;
          inlen --;
          }
          goto while_continue;
          }
        }
        }
      }
      }
    }
    {
    out -= outleft_save - outleft;
    outleft = outleft_save;
    in_end = in + inlen;
    }
    if (ignore_newlines) {
      {
      {
      tmp___0 = get_4(ctx, (char const * __restrict *)(& in), (char const * __restrict )in_end,
                      & inlen);
      non_nl = (char const *)tmp___0;
      }
      }
    } else {
      {
      {
      non_nl = in;
      }
      }
    }
    if (inlen == 0UL) {
      {
      {
      inlen = (size_t )0;
      }
      goto while_break;
      }
    } else {
      {
      if (inlen < 4UL) {
        {
        if (! flush_ctx) {
          {
          if (ignore_newlines) {
            {
            {
            inlen = (size_t )0;
            }
            goto while_break;
            }
          }
          }
        }
        }
      }
      }
    }
    {
    tmp___1 = decode_4((char const * __restrict )non_nl, inlen, (char * __restrict *)(& out),
                       & outleft);
    }
    if (! tmp___1) {
      {
      goto while_break;
      }
    }
    {
    inlen = (size_t )(in_end - in);
    }
  }
  while_break: ;
  }
  {
  *outlen -= outleft;
  }
  return ((_Bool )(inlen == 0UL));
}
}
_Bool base64_decode_alloc_ctx(struct base64_decode_context *ctx , char const *in ,
                              size_t inlen , char **out , size_t *outlen )
{
  size_t needlen ;
  void *tmp ;
  _Bool tmp___0 ;
  {
  {
  needlen = 3UL * (inlen / 4UL) + 3UL;
  tmp = malloc(needlen);
  *out = (char *)tmp;
  }
  if (! *out) {
    {
    return ((_Bool)1);
    }
  }
  {
  tmp___0 = base64_decode_ctx(ctx, (char const *)((char const * __restrict )in),
                              inlen, (char *)((char * __restrict )*out), & needlen);
  }
  if (! tmp___0) {
    {
    {
    free((void *)*out);
    *out = (char *)((void *)0);
    }
    return ((_Bool)0);
    }
  }
  if (outlen) {
    {
    {
    *outlen = needlen;
    }
    }
  }
  return ((_Bool)1);
}
}
_Bool c_isascii(int c )
{
  int tmp ;
  {
  if (c >= 0) {
    {
    if (c <= 127) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  return ((_Bool )tmp);
}
}
_Bool c_isalnum(int c )
{
  int tmp ;
  {
  if (c >= 48) {
    {
    if (c <= 57) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      goto _L;
      }
    }
    }
  } else {
    {
    _L:
    if ((c & -33) >= 65) {
      {
      if ((c & -33) <= 90) {
        {
        {
        tmp = 1;
        }
        }
      } else {
        {
        {
        tmp = 0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    }
  }
  return ((_Bool )tmp);
}
}
_Bool c_isalpha(int c )
{
  int tmp ;
  {
  if ((c & -33) >= 65) {
    {
    if ((c & -33) <= 90) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  return ((_Bool )tmp);
}
}
_Bool c_isblank(int c )
{
  int tmp ;
  {
  if (c == 32) {
    {
    {
    tmp = 1;
    }
    }
  } else {
    {
    if (c == 9) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    }
  }
  return ((_Bool )tmp);
}
}
_Bool c_iscntrl(int c )
{
  int tmp ;
  {
  if ((c & -32) == 0) {
    {
    {
    tmp = 1;
    }
    }
  } else {
    {
    if (c == 127) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    }
  }
  return ((_Bool )tmp);
}
}
_Bool c_isdigit(int c )
{
  int tmp ;
  {
  if (c >= 48) {
    {
    if (c <= 57) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  return ((_Bool )tmp);
}
}
_Bool c_islower(int c )
{
  int tmp ;
  {
  if (c >= 97) {
    {
    if (c <= 122) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  return ((_Bool )tmp);
}
}
_Bool c_isgraph(int c )
{
  int tmp ;
  {
  if (c >= 33) {
    {
    if (c <= 126) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  return ((_Bool )tmp);
}
}
_Bool c_isprint(int c )
{
  int tmp ;
  {
  if (c >= 32) {
    {
    if (c <= 126) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  return ((_Bool )tmp);
}
}
_Bool c_ispunct(int c )
{
  int tmp ;
  {
  if (c >= 33) {
    {
    if (c <= 126) {
      {
      if (c >= 48) {
        {
        if (c <= 57) {
          {
          {
          tmp = 0;
          }
          }
        } else {
          {
          goto _L;
          }
        }
        }
      } else {
        {
        _L:
        if ((c & -33) >= 65) {
          {
          if ((c & -33) <= 90) {
            {
            {
            tmp = 0;
            }
            }
          } else {
            {
            {
            tmp = 1;
            }
            }
          }
          }
        } else {
          {
          {
          tmp = 1;
          }
          }
        }
        }
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  return ((_Bool )tmp);
}
}
_Bool c_isspace(int c )
{
  int tmp ;
  {
  if (c == 32) {
    {
    {
    tmp = 1;
    }
    }
  } else {
    {
    if (c == 9) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      if (c == 10) {
        {
        {
        tmp = 1;
        }
        }
      } else {
        {
        if (c == 11) {
          {
          {
          tmp = 1;
          }
          }
        } else {
          {
          if (c == 12) {
            {
            {
            tmp = 1;
            }
            }
          } else {
            {
            if (c == 13) {
              {
              {
              tmp = 1;
              }
              }
            } else {
              {
              {
              tmp = 0;
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  return ((_Bool )tmp);
}
}
_Bool c_isupper(int c )
{
  int tmp ;
  {
  if (c >= 65) {
    {
    if (c <= 90) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  return ((_Bool )tmp);
}
}
_Bool c_isxdigit(int c )
{
  int tmp ;
  {
  if (c >= 48) {
    {
    if (c <= 57) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      goto _L;
      }
    }
    }
  } else {
    {
    _L:
    if ((c & -33) >= 65) {
      {
      if ((c & -33) <= 70) {
        {
        {
        tmp = 1;
        }
        }
      } else {
        {
        {
        tmp = 0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    }
  }
  return ((_Bool )tmp);
}
}
int c_tolower(int c )
{
  int tmp ;
  {
  if (c >= 65) {
    {
    if (c <= 90) {
      {
      {
      tmp = (c - 65) + 97;
      }
      }
    } else {
      {
      {
      tmp = c;
      }
      }
    }
    }
  } else {
    {
    {
    tmp = c;
    }
    }
  }
  return (tmp);
}
}
int c_toupper(int c )
{
  int tmp ;
  {
  if (c >= 97) {
    {
    if (c <= 122) {
      {
      {
      tmp = (c - 97) + 65;
      }
      }
    } else {
      {
      {
      tmp = c;
      }
      }
    }
    }
  } else {
    {
    {
    tmp = c;
    }
    }
  }
  return (tmp);
}
}
int c_strcasecmp(char const *s1 , char const *s2 )
{
  register unsigned char const *p1 ;
  register unsigned char const *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int __c ;
  int tmp ;
  int __c___0 ;
  int tmp___0 ;
  {
  {
  p1 = (unsigned char const *)s1;
  p2 = (unsigned char const *)s2;
  }
  if ((unsigned long )p1 == (unsigned long )p2) {
    {
    return (0);
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    __c = (int )*p1;
    }
    if (__c >= 65) {
      {
      if (__c <= 90) {
        {
        {
        tmp = (__c - 65) + 97;
        }
        }
      } else {
        {
        {
        tmp = __c;
        }
        }
      }
      }
    } else {
      {
      {
      tmp = __c;
      }
      }
    }
    {
    c1 = (unsigned char )tmp;
    __c___0 = (int )*p2;
    }
    if (__c___0 >= 65) {
      {
      if (__c___0 <= 90) {
        {
        {
        tmp___0 = (__c___0 - 65) + 97;
        }
        }
      } else {
        {
        {
        tmp___0 = __c___0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___0 = __c___0;
      }
      }
    }
    {
    c2 = (unsigned char )tmp___0;
    }
    if ((int )c1 == 0) {
      {
      goto while_break;
      }
    }
    {
    p1 ++;
    p2 ++;
    }
    if (! ((int )c1 == (int )c2)) {
      {
      goto while_break;
      }
    }
  }
  while_break: ;
  }
  return ((int )c1 - (int )c2);
}
}
int c_strncasecmp(char const *s1 , char const *s2 , size_t n )
{
  register unsigned char const *p1 ;
  register unsigned char const *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int __c ;
  int tmp ;
  int __c___0 ;
  int tmp___0 ;
  {
  {
  p1 = (unsigned char const *)s1;
  p2 = (unsigned char const *)s2;
  }
  if ((unsigned long )p1 == (unsigned long )p2) {
    {
    return (0);
    }
  } else {
    {
    if (n == 0UL) {
      {
      return (0);
      }
    }
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    __c = (int )*p1;
    }
    if (__c >= 65) {
      {
      if (__c <= 90) {
        {
        {
        tmp = (__c - 65) + 97;
        }
        }
      } else {
        {
        {
        tmp = __c;
        }
        }
      }
      }
    } else {
      {
      {
      tmp = __c;
      }
      }
    }
    {
    c1 = (unsigned char )tmp;
    __c___0 = (int )*p2;
    }
    if (__c___0 >= 65) {
      {
      if (__c___0 <= 90) {
        {
        {
        tmp___0 = (__c___0 - 65) + 97;
        }
        }
      } else {
        {
        {
        tmp___0 = __c___0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___0 = __c___0;
      }
      }
    }
    {
    c2 = (unsigned char )tmp___0;
    n --;
    }
    if (n == 0UL) {
      {
      goto while_break;
      }
    } else {
      {
      if ((int )c1 == 0) {
        {
        goto while_break;
        }
      }
      }
    }
    {
    p1 ++;
    p2 ++;
    }
    if (! ((int )c1 == (int )c2)) {
      {
      goto while_break;
      }
    }
  }
  while_break: ;
  }
  return ((int )c1 - (int )c2);
}
}
__inline static locale_t c_locale(void)
{
  __locale_t tmp ;
  {
  if (! c_locale_cache) {
    {
    {
    tmp = newlocale(((((((((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 7)) | (1 << 8)) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12),
                    (char const *)"C", (locale_t )0);
    c_locale_cache = (locale_t volatile )tmp;
    }
    }
  }
  return ((locale_t )c_locale_cache);
}
}
double c_strtod(char const *nptr , char **endptr )
{
  double r ;
  locale_t locale ;
  locale_t tmp ;
  {
  {
  tmp = c_locale();
  locale = tmp;
  }
  if (! locale) {
    {
    if (endptr) {
      {
      {
      *endptr = (char *)nptr;
      }
      }
    }
    return ((double )0);
    }
  }
  {
  r = strtod_l((char const * __restrict )nptr, (char ** __restrict )endptr, locale);
  }
  return (r);
}
}
__inline static locale_t c_locale___0(void)
{
  __locale_t tmp ;
  {
  if (! c_locale_cache___0) {
    {
    {
    tmp = newlocale(((((((((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 7)) | (1 << 8)) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12),
                    (char const *)"C", (locale_t )0);
    c_locale_cache___0 = (locale_t volatile )tmp;
    }
    }
  }
  return ((locale_t )c_locale_cache___0);
}
}
long double c_strtold(char const *nptr , char **endptr )
{
  long double r ;
  locale_t locale ;
  locale_t tmp ;
  {
  {
  tmp = c_locale___0();
  locale = tmp;
  }
  if (! locale) {
    {
    if (endptr) {
      {
      {
      *endptr = (char *)nptr;
      }
      }
    }
    return ((long double )0);
    }
  }
  {
  r = strtold_l((char const * __restrict )nptr, (char ** __restrict )endptr, locale);
  }
  return (r);
}
}
__inline extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr , struct cmsghdr *__cmsg ) __attribute__((__nothrow__)) ;
__inline extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr , struct cmsghdr *__cmsg )
{
  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    {
    return ((struct cmsghdr *)0);
    }
  }
  {
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  }
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    {
    return ((struct cmsghdr *)0);
    }
  } else {
    {
    if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
      {
      return ((struct cmsghdr *)0);
      }
    }
    }
  }
  return (__cmsg);
}
}
__inline extern ssize_t ( __attribute__((__artificial__, __always_inline__)) recv)(int __fd ,
                                                                                   void *__buf ,
                                                                                   size_t __n ,
                                                                                   int __flags )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size(__buf, 0);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __recv_chk(__fd, __buf, __n, tmp, __flags);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size(__buf, 0);
    }
    if (__n > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __recv_chk_warn(__fd, __buf, __n, tmp___1, __flags);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __recv_alias(__fd, __buf, __n, __flags);
  }
  return (tmp___5);
}
}
__inline extern ssize_t ( __attribute__((__artificial__, __always_inline__)) recvfrom)(int __fd ,
                                                                                       void *__buf ,
                                                                                       size_t __n ,
                                                                                       int __flags ,
                                                                                       struct sockaddr *__cil_tmp14 ,
                                                                                       socklen_t *__addr_len )
{
  __SOCKADDR_ARG __addr ;
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  {
  {
  __addr.__sockaddr__ = (struct sockaddr * __restrict )__cil_tmp14;
  tmp___4 = __builtin_object_size(__buf, 0);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __recvfrom_chk(__fd, (void * __restrict )__buf, __n, tmp, __flags,
                             __addr.__sockaddr__, (socklen_t * __restrict )__addr_len);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size(__buf, 0);
    }
    if (__n > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __recvfrom_chk_warn(__fd, (void * __restrict )__buf, __n, tmp___1,
                                    __flags, __addr.__sockaddr__, (socklen_t * __restrict )__addr_len);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __recvfrom_alias(__fd, (void * __restrict )__buf, __n, __flags, __addr.__sockaddr__,
                             (socklen_t * __restrict )__addr_len);
  }
  return (tmp___5);
}
}
char *canon_host(char const *host )
{
  char *tmp ;
  {
  {
  tmp = canon_host_r(host, & last_cherror);
  }
  return (tmp);
}
}
char *canon_host_r(char const *host , int *cherror )
{
  char *retval ;
  struct addrinfo *res ;
  int status ;
  char const *tmp___11 ;
  char *tmp___12 ;
  {
  {
  retval = (char *)((void *)0);
  res = (struct addrinfo *)((void *)0);
  hints.ai_flags = 2;
  status = getaddrinfo((char const * __restrict )host, (char const * __restrict )((void *)0),
                       (struct addrinfo const * __restrict )(& hints), (struct addrinfo ** __restrict )(& res));
  }
  if (! status) {
    {
    if (res->ai_canonname) {
      {
      {
      tmp___11 = (char const *)res->ai_canonname;
      }
      }
    } else {
      {
      {
      tmp___11 = host;
      }
      }
    }
    {
    tmp___12 = __strdup(tmp___11);
    retval = tmp___12;
    }
    if (! retval) {
      {
      if (cherror) {
        {
        {
        *cherror = -10;
        }
        }
      }
      }
    }
    {
    freeaddrinfo(res);
    }
    }
  } else {
    {
    if (cherror) {
      {
      {
      *cherror = status;
      }
      }
    }
    }
  }
  return (retval);
}
}
char const *ch_strerror(void)
{
  char const *tmp ;
  {
  {
  tmp = gai_strerror(last_cherror);
  }
  return (tmp);
}
}
static _Bool seen_triple(Hash_table **ht___0 , char const *filename , struct stat const *st )
{
  size_t initial_capacity ;
  _Bool tmp ;
  {
  if ((unsigned long )*ht___0 == (unsigned long )((void *)0)) {
    {
    {
    initial_capacity = (size_t )7;
    *ht___0 = hash_initialize(initial_capacity, (Hash_tuning const *)((void *)0),
                              & triple_hash, & triple_compare_ino_str, & triple_free);
    }
    if ((unsigned long )*ht___0 == (unsigned long )((void *)0)) {
      {
      {
      xalloc_die();
      }
      }
    }
    }
  }
  {
  tmp = seen_file((Hash_table const *)*ht___0, filename, st);
  }
  if (tmp) {
    {
    return ((_Bool)1);
    }
  }
  {
  record_file(*ht___0, filename, st);
  }
  return ((_Bool)0);
}
}
char *canonicalize_filename_mode(char const *name , canonicalize_mode_t can_mode )
{
  char *rname ;
  char *dest ;
  char *extra_buf ;
  char const *start ;
  char const *end ;
  char const *rname_limit ;
  size_t extra_len ;
  Hash_table *ht___0 ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  char *p ;
  void *tmp___3 ;
  void *tmp___4 ;
  struct stat st ;
  char *tmp___6 ;
  ptrdiff_t dest_offset ;
  size_t new_size ;
  void *tmp___7 ;
  void *tmp___8 ;
  int *tmp___9 ;
  unsigned long tmp___19 ;
  int tmp___20 ;
  char *buf___1 ;
  size_t n ;
  size_t len ;
  _Bool tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___28 ;
  int *tmp___29 ;
  {
  {
  extra_buf = (char *)((void *)0);
  extra_len = (size_t )0;
  ht___0 = (Hash_table *)((void *)0);
  }
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
    {
    tmp = __errno_location();
    *tmp = 22;
    }
    return ((char *)((void *)0));
    }
  }
  if ((int const )*(name + 0) == 0) {
    {
    {
    tmp___0 = __errno_location();
    *tmp___0 = 2;
    }
    return ((char *)((void *)0));
    }
  }
  if ((int const )*(name + 0) != 47) {
    {
    {
    rname = xgetcwd();
    }
    if (! rname) {
      {
      return ((char *)((void *)0));
      }
    }
    {
    tmp___1 = __rawmemchr((void const *)rname, '\000');
    dest = (char *)tmp___1;
    }
    if (dest - rname < 4096L) {
      {
      {
      tmp___3 = xrealloc((void *)rname, (size_t )4096);
      p = (char *)tmp___3;
      dest = p + (dest - rname);
      rname = p;
      rname_limit = (char const *)(rname + 4096);
      }
      }
    } else {
      {
      {
      rname_limit = (char const *)dest;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___4 = xmalloc((size_t )4096);
    rname = (char *)tmp___4;
    rname_limit = (char const *)(rname + 4096);
    *(rname + 0) = (char )'/';
    dest = rname + 1;
    }
    }
  }
  {
  start = name;
  }
  {
  while (1) {
    while_continue: ;
    if (! *start) {
      {
      goto while_break;
      }
    }
    {
    while (1) {
      while_continue___0: ;
      if (! ((int const )*start == 47)) {
        {
        goto while_break___0;
        }
      }
      {
      start ++;
      }
    }
    while_break___0: ;
    }
    {
    end = start;
    }
    {
    while (1) {
      while_continue___1: ;
      if (! 1) {
        {
        goto while_break___1;
        }
      }
      if (*end) {
        {
        if (! ((int const )*end != 47)) {
          {
          goto while_break___1;
          }
        }
        }
      } else {
        {
        goto while_break___1;
        }
      }
      {
      end ++;
      }
    }
    while_break___1: ;
    }
    if (end - start == 0L) {
      {
      goto while_break;
      }
    } else {
      {
      if (end - start == 1L) {
        {
        if (! ((int const )*(start + 0) == 46)) {
          {
          goto _L___1;
          }
        }
        }
      } else {
        {
        _L___1:
        if (end - start == 2L) {
          {
          if ((int const )*(start + 0) == 46) {
            {
            if ((int const )*(start + 1) == 46) {
              {
              if ((unsigned long )dest > (unsigned long )(rname + 1)) {
                {
                {
                while (1) {
                  while_continue___2: ;
                  if (! 1) {
                    {
                    goto while_break___2;
                    }
                  }
                  {
                  dest --;
                  }
                  if (! ((int )*(dest + -1) != 47)) {
                    {
                    goto while_break___2;
                    }
                  }
                }
                while_break___2: ;
                }
                }
              }
              }
            } else {
              {
              goto _L___0;
              }
            }
            }
          } else {
            {
            goto _L___0;
            }
          }
          }
        } else {
          {
          _L___0:
          if ((int )*(dest + -1) != 47) {
            {
            {
            tmp___6 = dest;
            dest ++;
            *tmp___6 = (char )'/';
            }
            }
          }
          if ((unsigned long )(dest + (end - start)) >= (unsigned long )rname_limit) {
            {
            {
            dest_offset = dest - rname;
            new_size = (size_t )(rname_limit - (char const *)rname);
            }
            if ((end - start) + 1L > 4096L) {
              {
              {
              new_size += (size_t )((end - start) + 1L);
              }
              }
            } else {
              {
              {
              new_size += 4096UL;
              }
              }
            }
            {
            tmp___7 = xrealloc((void *)rname, new_size);
            rname = (char *)tmp___7;
            rname_limit = (char const *)(rname + new_size);
            dest = rname + dest_offset;
            }
            }
          }
          {
          tmp___8 = memcpy((void *)((void * __restrict )dest), (void const *)((void const * __restrict )start),
                           (size_t )(end - start));
          dest = (char *)tmp___8;
          dest += end - start;
          *dest = (char )'\000';
          tmp___20 = lstat((char const *)((char const * __restrict )rname), (struct stat *)((struct stat * __restrict )(& st)));
          }
          if (tmp___20 != 0) {
            {
            {
            tmp___9 = __errno_location();
            saved_errno = *tmp___9;
            }
            if ((unsigned int )can_mode == 0U) {
              {
              goto error;
              }
            }
            if ((unsigned int )can_mode == 1U) {
              {
              {
              tmp___19 = __builtin_strspn(end, (char const *)"/");
              }
              if (*(end + tmp___19)) {
                {
                goto error;
                }
              } else {
                {
                if (saved_errno != 2) {
                  {
                  goto error;
                  }
                }
                }
              }
              goto __Cont;
              }
            }
            {
            st.st_mode = (__mode_t )0;
            }
            }
          }
          if ((st.st_mode & 61440U) == 40960U) {
            {
            {
            tmp___21 = seen_triple(& ht___0, name, (struct stat const *)(& st));
            }
            if (tmp___21) {
              {
              if ((unsigned int )can_mode == 2U) {
                {
                goto __Cont;
                }
              }
              {
              saved_errno = 40;
              }
              goto error;
              }
            }
            {
            buf___1 = areadlink_with_size((char const *)rname, (size_t )st.st_size);
            }
            if (! buf___1) {
              {
              if ((unsigned int )can_mode == 2U) {
                {
                {
                tmp___22 = __errno_location();
                }
                if (*tmp___22 != 12) {
                  {
                  goto __Cont;
                  }
                }
                }
              }
              {
              tmp___23 = __errno_location();
              saved_errno = *tmp___23;
              }
              goto error;
              }
            }
            {
            n = strlen((char const *)buf___1);
            len = strlen(end);
            }
            if (! extra_len) {
              {
              if ((n + len) + 1UL > 4096UL) {
                {
                {
                extra_len = (n + len) + 1UL;
                }
                }
              } else {
                {
                {
                extra_len = (size_t )4096;
                }
                }
              }
              {
              tmp___24 = xmalloc(extra_len);
              extra_buf = (char *)tmp___24;
              }
              }
            } else {
              {
              if ((n + len) + 1UL > extra_len) {
                {
                {
                extra_len = (n + len) + 1UL;
                tmp___25 = xrealloc((void *)extra_buf, extra_len);
                extra_buf = (char *)tmp___25;
                }
                }
              }
              }
            }
            {
            memmove((void *)(extra_buf + n), (void const *)end, len + 1UL);
            tmp___26 = memcpy((void *)((void * __restrict )extra_buf), (void const *)((void const * __restrict )buf___1),
                              n);
            end = (char const *)tmp___26;
            name = end;
            }
            if ((int )*(buf___1 + 0) == 47) {
              {
              {
              dest = rname + 1;
              }
              }
            } else {
              {
              if ((unsigned long )dest > (unsigned long )(rname + 1)) {
                {
                {
                while (1) {
                  while_continue___3: ;
                  if (! 1) {
                    {
                    goto while_break___3;
                    }
                  }
                  {
                  dest --;
                  }
                  if (! ((int )*(dest + -1) != 47)) {
                    {
                    goto while_break___3;
                    }
                  }
                }
                while_break___3: ;
                }
                }
              }
              }
            }
            {
            free((void *)buf___1);
            }
            }
          } else {
            {
            if (! ((st.st_mode & 61440U) == 16384U)) {
              {
              if (*end) {
                {
                if ((unsigned int )can_mode != 2U) {
                  {
                  {
                  saved_errno = 20;
                  }
                  goto error;
                  }
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    __Cont:
    {
    start = end;
    }
  }
  while_break: ;
  }
  if ((unsigned long )dest > (unsigned long )(rname + 1)) {
    {
    if ((int )*(dest + -1) == 47) {
      {
      {
      dest --;
      }
      }
    }
    }
  }
  {
  *dest = (char )'\000';
  }
  if ((unsigned long )rname_limit != (unsigned long )(dest + 1)) {
    {
    {
    tmp___28 = xrealloc((void *)rname, (size_t )((dest - rname) + 1L));
    rname = (char *)tmp___28;
    }
    }
  }
  {
  free((void *)extra_buf);
  }
  if (ht___0) {
    {
    {
    hash_free(ht___0);
    }
    }
  }
  return (rname);
  error:
  {
  free((void *)extra_buf);
  free((void *)rname);
  }
  if (ht___0) {
    {
    {
    hash_free(ht___0);
    }
    }
  }
  {
  tmp___29 = __errno_location();
  *tmp___29 = saved_errno;
  }
  return ((char *)((void *)0));
}
}
ssize_t careadlinkatcwd(int fd , char const *filename , char *buffer , size_t buffer_size )
{
  ssize_t tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  {
  if (fd != -100) {
    {
    {
    abort();
    }
    }
  }
  {
  tmp___1 = readlink((char const *)((char const * __restrict )filename), (char *)((char * __restrict )buffer),
                     buffer_size);
  tmp___0 = tmp___1;
  tmp = tmp___0;
  }
  return (tmp);
}
}
char *careadlinkat(int fd , char const *filename , char *buffer , size_t buffer_size ,
                   struct allocator const *alloc , ssize_t (*preadlinkat)(int ,
                                                                            char const * ,
                                                                            char * ,
                                                                            size_t ) )
{
  char *buf___1 ;
  size_t buf_size ;
  size_t buf_size_max ;
  char stack_buf[1024] ;
  ssize_t link_length ;
  ssize_t tmp ;
  size_t link_size ;
  int readlinkat_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  char *b ;
  void *tmp___3 ;
  char *b___0 ;
  void *tmp___4 ;
  int *tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  {
  {
  buf_size_max = 0x8000000000000000UL;
  }
  if (! alloc) {
    {
    {
    alloc = & stdlib_allocator;
    }
    }
  }
  if (! buffer_size) {
    {
    {
    buffer = stack_buf;
    buffer_size = sizeof(stack_buf);
    }
    }
  }
  {
  buf___1 = buffer;
  buf_size = buffer_size;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp = (*preadlinkat)(fd, filename, buf___1, buf_size);
    link_length = tmp;
    }
    if (link_length < 0L) {
      {
      {
      tmp___0 = __errno_location();
      readlinkat_errno = *tmp___0;
      }
      if (readlinkat_errno != 34) {
        {
        if ((unsigned long )buf___1 != (unsigned long )buffer) {
          {
          {
          (*(alloc->free))((void *)buf___1);
          tmp___1 = __errno_location();
          *tmp___1 = readlinkat_errno;
          }
          }
        }
        return ((char *)((void *)0));
        }
      }
      }
    }
    {
    link_size = (size_t )link_length;
    }
    if (link_size < buf_size) {
      {
      {
      tmp___2 = link_size;
      link_size ++;
      *(buf___1 + tmp___2) = (char )'\000';
      }
      if ((unsigned long )buf___1 == (unsigned long )(stack_buf)) {
        {
        {
        tmp___3 = (*(alloc->allocate))(link_size);
        b = (char *)tmp___3;
        buf_size = link_size;
        }
        if (! b) {
          {
          goto while_break;
          }
        }
        {
        memcpy((void *)((void * __restrict )b), (void const *)((void const * __restrict )buf___1),
               link_size);
        buf___1 = b;
        }
        }
      } else {
        {
        if (link_size < buf_size) {
          {
          if ((unsigned long )buf___1 != (unsigned long )buffer) {
            {
            if (alloc->reallocate) {
              {
              {
              tmp___4 = (*(alloc->reallocate))((void *)buf___1, link_size);
              b___0 = (char *)tmp___4;
              }
              if (b___0) {
                {
                {
                buf___1 = b___0;
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      return (buf___1);
      }
    }
    if ((unsigned long )buf___1 != (unsigned long )buffer) {
      {
      {
      (*(alloc->free))((void *)buf___1);
      }
      }
    }
    if (buf_size <= buf_size_max / 2UL) {
      {
      {
      buf_size *= 2UL;
      }
      }
    } else {
      {
      if (buf_size < buf_size_max) {
        {
        {
        buf_size = buf_size_max;
        }
        }
      } else {
        {
        if (buf_size_max < 0xffffffffffffffffUL) {
          {
          {
          tmp___5 = __errno_location();
          *tmp___5 = 36;
          }
          return ((char *)((void *)0));
          }
        } else {
          {
          goto while_break;
          }
        }
        }
      }
      }
    }
    {
    tmp___6 = (*(alloc->allocate))(buf_size);
    buf___1 = (char *)tmp___6;
    }
    if (! buf___1) {
      {
      goto while_break;
      }
    }
  }
  while_break: ;
  }
  if (alloc->die) {
    {
    {
    (*(alloc->die))(buf_size);
    }
    }
  }
  {
  tmp___7 = __errno_location();
  *tmp___7 = 12;
  }
  return ((char *)((void *)0));
}
}
int set_cloexec_flag(int desc , _Bool value )
{
  int flags ;
  int tmp ;
  int newflags ;
  int tmp___0 ;
  int tmp___1 ;
  {
  {
  tmp = rpl_fcntl(desc, 1, 0);
  flags = tmp;
  }
  if (0 <= flags) {
    {
    if (value) {
      {
      { if(!(value == (_Bool)1)) { reach_error(); abort(); } };
      {
      tmp___0 = flags | 1;
      }
      }
    } else {
      {
      {
      tmp___0 = flags & -2;
      }
      }
    }
    {
    { if(!(value == (_Bool)1)) { reach_error(); abort(); } };
    {
    newflags = tmp___0;
    }
    }
    if (flags == newflags) {
      {
      return (0);
      }
    } else {
      {
      {
      tmp___1 = rpl_fcntl(desc, 2, newflags);
      }
      if (tmp___1 != -1) {
        {
        { if(!(tmp___1 != -1)) { reach_error(); abort(); } };
        return (0);
        }
      }
      }
    }
    }
  }
  {
  { if(!(value == (_Bool)1)) { reach_error(); abort(); } };
  return (-1);
  }
}
}
int dup_cloexec(int fd )
{
  int tmp ;
  {
  {
  tmp = rpl_fcntl(fd, 1030, 0);
  }
  return (tmp);
}
}
int close_stream(FILE *stream )
{
  _Bool some_pending ;
  size_t tmp ;
  _Bool prev_fail ;
  int tmp___0 ;
  _Bool fclose_fail ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  {
  {
  tmp = __fpending(stream);
  some_pending = (_Bool )(tmp != 0UL);
  tmp___0 = ferror_unlocked(stream);
  prev_fail = (_Bool )(tmp___0 != 0);
  tmp___1 = rpl_fclose(stream);
  fclose_fail = (_Bool )(tmp___1 != 0);
  }
  if (prev_fail) {
    {
    goto _L___0;
    }
  } else {
    {
    { if(!(prev_fail == (_Bool)0)) { reach_error(); abort(); } };
    if (fclose_fail) {
      {
      { if(!(fclose_fail != (_Bool)0)) { reach_error(); abort(); } };
      if (some_pending) {
        {
        goto _L___0;
        }
      } else {
        {
        { if(!(some_pending == (_Bool)0)) { reach_error(); abort(); } };
        {
        tmp___3 = __errno_location();
        }
        if (*tmp___3 != 9) {
          {
          _L___0:
          if (! fclose_fail) {
            {
            { if(!(fclose_fail == (_Bool)0)) { reach_error(); abort(); } };
            {
            tmp___2 = __errno_location();
            *tmp___2 = 0;
            }
            }
          }
          return (-1);
          }
        }
        }
      }
      }
    }
    }
  }
  {
  { if(!(prev_fail == (_Bool)0)) { reach_error(); abort(); } };
  return (0);
  }
}
}
void close_stdin_set_file_name(char const *file )
{
  {
  {
  file_name = file;
  }
  return;
}
}
void close_stdin(void)
{
  _Bool fail ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char const *close_error ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  {
  {
  fail = (_Bool)0;
  tmp___1 = freadahead(stdin);
  }
  if (tmp___1 > 0UL) {
    {
    {
    tmp = rpl_fseeko(stdin, (off_t )0, 1);
    }
    if (tmp == 0) {
      {
      {
      tmp___0 = rpl_fflush(stdin);
      }
      if (tmp___0 != 0) {
        {
        {
        fail = (_Bool)1;
        }
        }
      }
      }
    }
    }
  }
  {
  tmp___2 = close_stream(stdin);
  }
  if (tmp___2 != 0) {
    {
    {
    fail = (_Bool)1;
    }
    }
  }
  if (fail) {
    {
    {
    tmp___3 = dcgettext((char const *)((void *)0), (char const *)"error closing file",
                        5);
    close_error = (char const *)tmp___3;
    }
    if (file_name) {
      {
      {
      tmp___4 = quotearg_colon(file_name);
      tmp___5 = __errno_location();
      error(0, *tmp___5, (char const *)"%s: %s", tmp___4, close_error);
      }
      }
    } else {
      {
      {
      tmp___6 = __errno_location();
      error(0, *tmp___6, (char const *)"%s", close_error);
      }
      }
    }
    }
  }
  {
  close_stdout();
  }
  if (fail) {
    {
    {
    _exit((int )exit_failure);
    }
    }
  }
  return;
}
}
void close_stdout_set_file_name(char const *file )
{
  {
  {
  file_name___0 = file;
  }
  return;
}
}
void close_stdout_set_ignore_EPIPE(_Bool ignore )
{
  {
  {
  ignore_EPIPE = ignore;
  }
  return;
}
}
void close_stdout(void)
{
  char const *write_error ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  {
  {
  tmp___3 = close_stream(stdout);
  }
  if (tmp___3 != 0) {
    {
    { if(!(tmp___3 != 0)) { reach_error(); abort(); } };
    if (ignore_EPIPE) {
      {
      {
      tmp___4 = __errno_location();
      }
      if (! (*tmp___4 == 32)) {
        {
        goto _L;
        }
      }
      }
    } else {
      {
      _L:
      {
      { if(!(tmp___3 != 0)) { reach_error(); abort(); } };
      {
      tmp = dcgettext((char const *)((void *)0), (char const *)"write error",
                      5);
      write_error = (char const *)tmp;
      }
      }
      if (file_name___0) {
        {
        {
        tmp___0 = quotearg_colon(file_name___0);
        tmp___1 = __errno_location();
        error(0, *tmp___1, (char const *)"%s: %s", tmp___0, write_error);
        { if(!(tmp___3 != 0)) { reach_error(); abort(); } };
        }
        }
      } else {
        {
        { if(!(file_name___0 == 0)) { reach_error(); abort(); } };
        {
        tmp___2 = __errno_location();
        error(0, *tmp___2, (char const *)"%s", write_error);
        { if(!(tmp___3 != 0)) { reach_error(); abort(); } };
        }
        }
      }
      {
      { if(!(tmp___3 != 0)) { reach_error(); abort(); } };
      {
      _exit((int )exit_failure);
      }
      }
      }
    }
    }
  }
  {
  tmp___5 = close_stream(stderr);
  }
  if (tmp___5 != 0) {
    {
    { if(!(tmp___5 != 0)) { reach_error(); abort(); } };
    {
    _exit((int )exit_failure);
    }
    }
  }
  return;
}
}
void md5_init_ctx(struct md5_ctx *ctx ) __attribute__((__nothrow__)) ;
void md5_init_ctx(struct md5_ctx *ctx )
{
  uint32_t tmp ;
  {
  {
  ctx->A = (uint32_t )1732584193;
  ctx->B = 4023233417U;
  ctx->C = 2562383102U;
  ctx->D = (uint32_t )271733878;
  tmp = (uint32_t )0;
  ctx->total[1] = tmp;
  ctx->total[0] = tmp;
  ctx->buflen = (uint32_t )0;
  }
  return;
}
}
__inline static void set_uint32(char *cp , uint32_t v )
{
  {
  {
  memcpy((void *)((void * __restrict )cp), (void const *)((void const * __restrict )(& v)),
         sizeof(v));
  }
  return;
}
}
void *md5_read_ctx(struct md5_ctx const *ctx , void *resbuf ) __attribute__((__nothrow__)) ;
void *md5_read_ctx(struct md5_ctx const *ctx , void *resbuf )
{
  char *r ;
  {
  {
  r = (char *)resbuf;
  set_uint32(r + 0UL, (uint32_t )ctx->A);
  set_uint32(r + sizeof(ctx->B), (uint32_t )ctx->B);
  set_uint32(r + 2UL * sizeof(ctx->C), (uint32_t )ctx->C);
  set_uint32(r + 3UL * sizeof(ctx->D), (uint32_t )ctx->D);
  }
  return (resbuf);
}
}
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) __attribute__((__nothrow__)) ;
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf )
{
  uint32_t bytes ;
  size_t size ;
  int tmp ;
  void *tmp___0 ;
  {
  {
  bytes = ctx->buflen;
  }
  if (bytes < 56U) {
    {
    {
    tmp = 16;
    }
    }
  } else {
    {
    {
    tmp = 32;
    }
    }
  }
  {
  size = (size_t )tmp;
  ctx->total[0] += bytes;
  }
  if (ctx->total[0] < bytes) {
    {
    {
    (ctx->total[1]) ++;
    }
    }
  }
  {
  ctx->buffer[size - 2UL] = ctx->total[0] << 3;
  ctx->buffer[size - 1UL] = (ctx->total[1] << 3) | (ctx->total[0] >> 29);
  memcpy((void *)((void * __restrict )((char *)(ctx->buffer) + bytes)), (void const *)((void const * __restrict )(fillbuf)),
         (size - 2UL) * 4UL - (size_t )bytes);
  md5_process_block((void const *)(ctx->buffer), size * 4UL, ctx);
  tmp___0 = md5_read_ctx((struct md5_ctx const *)ctx, resbuf);
  }
  return (tmp___0);
}
}
int md5_stream(FILE *stream , void *resblock ) __attribute__((__nothrow__)) ;
int md5_stream(FILE *stream , void *resblock )
{
  struct md5_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  {
  {
  tmp = malloc((size_t )32840);
  buffer = (char *)tmp;
  }
  if (! buffer) {
    {
    return (1);
    }
  }
  {
  md5_init_ctx(& ctx);
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    sum = (size_t )0;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      {
      tmp___4 = fread_unlocked((void *)((void * __restrict )(buffer + sum)), (size_t )1,
                               32768UL - sum, (FILE *)((FILE * __restrict )stream));
      tmp___3 = tmp___4;
      tmp___0 = tmp___3;
      n = tmp___0;
      sum += n;
      }
      if (sum == 32768UL) {
        {
        goto while_break___0;
        }
      }
      if (n == 0UL) {
        {
        {
        tmp___1 = ferror_unlocked(stream);
        }
        if (tmp___1) {
          {
          {
          free((void *)buffer);
          }
          return (1);
          }
        }
        goto process_partial_block;
        }
      }
      {
      tmp___2 = feof_unlocked(stream);
      }
      if (tmp___2) {
        {
        goto process_partial_block;
        }
      }
    }
    while_break___0: ;
    }
    {
    md5_process_block((void const *)buffer, (size_t )32768, & ctx);
    }
  }
  while_break: ;
  }
  process_partial_block:
  if (sum > 0UL) {
    {
    {
    md5_process_bytes((void const *)buffer, sum, & ctx);
    }
    }
  }
  {
  md5_finish_ctx(& ctx, resblock);
  free((void *)buffer);
  }
  return (0);
}
}
void *md5_buffer(char const *buffer , size_t len , void *resblock ) __attribute__((__nothrow__)) ;
void *md5_buffer(char const *buffer , size_t len , void *resblock )
{
  struct md5_ctx ctx ;
  void *tmp ;
  {
  {
  md5_init_ctx(& ctx);
  md5_process_bytes((void const *)buffer, len, & ctx);
  tmp = md5_finish_ctx(& ctx, resblock);
  }
  return (tmp);
}
}
void md5_process_bytes(void const *buffer , size_t len , struct md5_ctx *ctx ) __attribute__((__nothrow__)) ;
void md5_process_bytes(void const *buffer , size_t len , struct md5_ctx *ctx )
{
  size_t left_over ;
  size_t add ;
  size_t tmp ;
  size_t left_over___0 ;
  {
  if (ctx->buflen != 0U) {
    {
    {
    left_over = (size_t )ctx->buflen;
    }
    if (128UL - left_over > len) {
      {
      {
      tmp = len;
      }
      }
    } else {
      {
      {
      tmp = 128UL - left_over;
      }
      }
    }
    {
    add = tmp;
    memcpy((void *)((void * __restrict )((char *)(ctx->buffer) + left_over)), (void const *)((void const * __restrict )buffer),
           add);
    ctx->buflen = (uint32_t )((size_t )ctx->buflen + add);
    }
    if (ctx->buflen > 64U) {
      {
      {
      md5_process_block((void const *)(ctx->buffer), (size_t )(ctx->buflen & 4294967232U),
                        ctx);
      ctx->buflen &= 63U;
      memcpy((void *)((void * __restrict )(ctx->buffer)), (void const *)((void const * __restrict )((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL))),
             (size_t )ctx->buflen);
      }
      }
    }
    {
    buffer = (void const *)((char const *)buffer + add);
    len -= add;
    }
    }
  }
  if (len >= 64UL) {
    {
    {
    md5_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
    buffer = (void const *)((char const *)buffer + (len & 0xffffffffffffffc0UL));
    len &= 63UL;
    }
    }
  }
  if (len > 0UL) {
    {
    {
    left_over___0 = (size_t )ctx->buflen;
    memcpy((void *)((void * __restrict )((char *)(ctx->buffer) + left_over___0)),
           (void const *)((void const * __restrict )buffer), len);
    left_over___0 += len;
    }
    if (left_over___0 >= 64UL) {
      {
      {
      md5_process_block((void const *)(ctx->buffer), (size_t )64, ctx);
      left_over___0 -= 64UL;
      memcpy((void *)((void * __restrict )(ctx->buffer)), (void const *)((void const * __restrict )(& ctx->buffer[16])),
             left_over___0);
      }
      }
    }
    {
    ctx->buflen = (uint32_t )left_over___0;
    }
    }
  }
  return;
}
}
void md5_process_block(void const *buffer , size_t len , struct md5_ctx *ctx ) __attribute__((__nothrow__)) ;
void md5_process_block(void const *buffer , size_t len , struct md5_ctx *ctx )
{
  uint32_t correct_words[16] ;
  uint32_t const *words ;
  size_t nwords ;
  uint32_t const *endp ;
  uint32_t A ;
  uint32_t B ;
  uint32_t C ;
  uint32_t D ;
  uint32_t *cwp ;
  uint32_t A_save ;
  uint32_t B_save ;
  uint32_t C_save ;
  uint32_t D_save ;
  uint32_t *tmp ;
  uint32_t tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t *tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t *tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t *tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t *tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t *tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t *tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t *tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t *tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t *tmp___25 ;
  uint32_t tmp___26 ;
  uint32_t *tmp___27 ;
  uint32_t tmp___28 ;
  uint32_t *tmp___29 ;
  uint32_t tmp___30 ;
  {
  {
  words = (uint32_t const *)buffer;
  nwords = len / sizeof(uint32_t );
  endp = words + nwords;
  A = ctx->A;
  B = ctx->B;
  C = ctx->C;
  D = ctx->D;
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + len);
  }
  if ((size_t )ctx->total[0] < len) {
    {
    {
    (ctx->total[1]) ++;
    }
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )words < (unsigned long )endp)) {
      {
      goto while_break;
      }
    }
    {
    cwp = correct_words;
    A_save = A;
    B_save = B;
    C_save = C;
    D_save = D;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      {
      tmp = cwp;
      cwp ++;
      tmp___0 = (uint32_t )*words;
      *tmp = tmp___0;
      A += ((D ^ (B & (C ^ D))) + tmp___0) + 3614090360U;
      words ++;
      A = (A << 7) | (A >> 25);
      A += B;
      }
      goto while_break___0;
    }
    while_break___0: ;
    }
    {
    while (1) {
      while_continue___1: ;
      if (! 1) {
        {
        goto while_break___1;
        }
      }
      {
      tmp___1 = cwp;
      cwp ++;
      tmp___2 = (uint32_t )*words;
      *tmp___1 = tmp___2;
      D += ((C ^ (A & (B ^ C))) + tmp___2) + 3905402710U;
      words ++;
      D = (D << 12) | (D >> 20);
      D += A;
      }
      goto while_break___1;
    }
    while_break___1: ;
    }
    {
    while (1) {
      while_continue___2: ;
      if (! 1) {
        {
        goto while_break___2;
        }
      }
      {
      tmp___3 = cwp;
      cwp ++;
      tmp___4 = (uint32_t )*words;
      *tmp___3 = tmp___4;
      C += ((B ^ (D & (A ^ B))) + tmp___4) + 606105819U;
      words ++;
      C = (C << 17) | (C >> 15);
      C += D;
      }
      goto while_break___2;
    }
    while_break___2: ;
    }
    {
    while (1) {
      while_continue___3: ;
      if (! 1) {
        {
        goto while_break___3;
        }
      }
      {
      tmp___5 = cwp;
      cwp ++;
      tmp___6 = (uint32_t )*words;
      *tmp___5 = tmp___6;
      B += ((A ^ (C & (D ^ A))) + tmp___6) + 3250441966U;
      words ++;
      B = (B << 22) | (B >> 10);
      B += C;
      }
      goto while_break___3;
    }
    while_break___3: ;
    }
    {
    while (1) {
      while_continue___4: ;
      if (! 1) {
        {
        goto while_break___4;
        }
      }
      {
      tmp___7 = cwp;
      cwp ++;
      tmp___8 = (uint32_t )*words;
      *tmp___7 = tmp___8;
      A += ((D ^ (B & (C ^ D))) + tmp___8) + 4118548399U;
      words ++;
      A = (A << 7) | (A >> 25);
      A += B;
      }
      goto while_break___4;
    }
    while_break___4: ;
    }
    {
    while (1) {
      while_continue___5: ;
      if (! 1) {
        {
        goto while_break___5;
        }
      }
      {
      tmp___9 = cwp;
      cwp ++;
      tmp___10 = (uint32_t )*words;
      *tmp___9 = tmp___10;
      D += ((C ^ (A & (B ^ C))) + tmp___10) + 1200080426U;
      words ++;
      D = (D << 12) | (D >> 20);
      D += A;
      }
      goto while_break___5;
    }
    while_break___5: ;
    }
    {
    while (1) {
      while_continue___6: ;
      if (! 1) {
        {
        goto while_break___6;
        }
      }
      {
      tmp___11 = cwp;
      cwp ++;
      tmp___12 = (uint32_t )*words;
      *tmp___11 = tmp___12;
      C += ((B ^ (D & (A ^ B))) + tmp___12) + 2821735955U;
      words ++;
      C = (C << 17) | (C >> 15);
      C += D;
      }
      goto while_break___6;
    }
    while_break___6: ;
    }
    {
    while (1) {
      while_continue___7: ;
      if (! 1) {
        {
        goto while_break___7;
        }
      }
      {
      tmp___13 = cwp;
      cwp ++;
      tmp___14 = (uint32_t )*words;
      *tmp___13 = tmp___14;
      B += ((A ^ (C & (D ^ A))) + tmp___14) + 4249261313U;
      words ++;
      B = (B << 22) | (B >> 10);
      B += C;
      }
      goto while_break___7;
    }
    while_break___7: ;
    }
    {
    while (1) {
      while_continue___8: ;
      if (! 1) {
        {
        goto while_break___8;
        }
      }
      {
      tmp___15 = cwp;
      cwp ++;
      tmp___16 = (uint32_t )*words;
      *tmp___15 = tmp___16;
      A += ((D ^ (B & (C ^ D))) + tmp___16) + 1770035416U;
      words ++;
      A = (A << 7) | (A >> 25);
      A += B;
      }
      goto while_break___8;
    }
    while_break___8: ;
    }
    {
    while (1) {
      while_continue___9: ;
      if (! 1) {
        {
        goto while_break___9;
        }
      }
      {
      tmp___17 = cwp;
      cwp ++;
      tmp___18 = (uint32_t )*words;
      *tmp___17 = tmp___18;
      D += ((C ^ (A & (B ^ C))) + tmp___18) + 2336552879U;
      words ++;
      D = (D << 12) | (D >> 20);
      D += A;
      }
      goto while_break___9;
    }
    while_break___9: ;
    }
    {
    while (1) {
      while_continue___10: ;
      if (! 1) {
        {
        goto while_break___10;
        }
      }
      {
      tmp___19 = cwp;
      cwp ++;
      tmp___20 = (uint32_t )*words;
      *tmp___19 = tmp___20;
      C += ((B ^ (D & (A ^ B))) + tmp___20) + 4294925233U;
      words ++;
      C = (C << 17) | (C >> 15);
      C += D;
      }
      goto while_break___10;
    }
    while_break___10: ;
    }
    {
    while (1) {
      while_continue___11: ;
      if (! 1) {
        {
        goto while_break___11;
        }
      }
      {
      tmp___21 = cwp;
      cwp ++;
      tmp___22 = (uint32_t )*words;
      *tmp___21 = tmp___22;
      B += ((A ^ (C & (D ^ A))) + tmp___22) + 2304563134U;
      words ++;
      B = (B << 22) | (B >> 10);
      B += C;
      }
      goto while_break___11;
    }
    while_break___11: ;
    }
    {
    while (1) {
      while_continue___12: ;
      if (! 1) {
        {
        goto while_break___12;
        }
      }
      {
      tmp___23 = cwp;
      cwp ++;
      tmp___24 = (uint32_t )*words;
      *tmp___23 = tmp___24;
      A += ((D ^ (B & (C ^ D))) + tmp___24) + 1804603682U;
      words ++;
      A = (A << 7) | (A >> 25);
      A += B;
      }
      goto while_break___12;
    }
    while_break___12: ;
    }
    {
    while (1) {
      while_continue___13: ;
      if (! 1) {
        {
        goto while_break___13;
        }
      }
      {
      tmp___25 = cwp;
      cwp ++;
      tmp___26 = (uint32_t )*words;
      *tmp___25 = tmp___26;
      D += ((C ^ (A & (B ^ C))) + tmp___26) + 4254626195U;
      words ++;
      D = (D << 12) | (D >> 20);
      D += A;
      }
      goto while_break___13;
    }
    while_break___13: ;
    }
    {
    while (1) {
      while_continue___14: ;
      if (! 1) {
        {
        goto while_break___14;
        }
      }
      {
      tmp___27 = cwp;
      cwp ++;
      tmp___28 = (uint32_t )*words;
      *tmp___27 = tmp___28;
      C += ((B ^ (D & (A ^ B))) + tmp___28) + 2792965006U;
      words ++;
      C = (C << 17) | (C >> 15);
      C += D;
      }
      goto while_break___14;
    }
    while_break___14: ;
    }
    {
    while (1) {
      while_continue___15: ;
      if (! 1) {
        {
        goto while_break___15;
        }
      }
      {
      tmp___29 = cwp;
      cwp ++;
      tmp___30 = (uint32_t )*words;
      *tmp___29 = tmp___30;
      B += ((A ^ (C & (D ^ A))) + tmp___30) + 1236535329U;
      words ++;
      B = (B << 22) | (B >> 10);
      B += C;
      }
      goto while_break___15;
    }
    while_break___15: ;
    }
    {
    while (1) {
      while_continue___16: ;
      if (! 1) {
        {
        goto while_break___16;
        }
      }
      {
      A += ((C ^ (D & (B ^ C))) + correct_words[1]) + 4129170786U;
      A = (A << 5) | (A >> 27);
      A += B;
      }
      goto while_break___16;
    }
    while_break___16: ;
    }
    {
    while (1) {
      while_continue___17: ;
      if (! 1) {
        {
        goto while_break___17;
        }
      }
      {
      D += ((B ^ (C & (A ^ B))) + correct_words[6]) + 3225465664U;
      D = (D << 9) | (D >> 23);
      D += A;
      }
      goto while_break___17;
    }
    while_break___17: ;
    }
    {
    while (1) {
      while_continue___18: ;
      if (! 1) {
        {
        goto while_break___18;
        }
      }
      {
      C += ((A ^ (B & (D ^ A))) + correct_words[11]) + 643717713U;
      C = (C << 14) | (C >> 18);
      C += D;
      }
      goto while_break___18;
    }
    while_break___18: ;
    }
    {
    while (1) {
      while_continue___19: ;
      if (! 1) {
        {
        goto while_break___19;
        }
      }
      {
      B += ((D ^ (A & (C ^ D))) + correct_words[0]) + 3921069994U;
      B = (B << 20) | (B >> 12);
      B += C;
      }
      goto while_break___19;
    }
    while_break___19: ;
    }
    {
    while (1) {
      while_continue___20: ;
      if (! 1) {
        {
        goto while_break___20;
        }
      }
      {
      A += ((C ^ (D & (B ^ C))) + correct_words[5]) + 3593408605U;
      A = (A << 5) | (A >> 27);
      A += B;
      }
      goto while_break___20;
    }
    while_break___20: ;
    }
    {
    while (1) {
      while_continue___21: ;
      if (! 1) {
        {
        goto while_break___21;
        }
      }
      {
      D += ((B ^ (C & (A ^ B))) + correct_words[10]) + 38016083U;
      D = (D << 9) | (D >> 23);
      D += A;
      }
      goto while_break___21;
    }
    while_break___21: ;
    }
    {
    while (1) {
      while_continue___22: ;
      if (! 1) {
        {
        goto while_break___22;
        }
      }
      {
      C += ((A ^ (B & (D ^ A))) + correct_words[15]) + 3634488961U;
      C = (C << 14) | (C >> 18);
      C += D;
      }
      goto while_break___22;
    }
    while_break___22: ;
    }
    {
    while (1) {
      while_continue___23: ;
      if (! 1) {
        {
        goto while_break___23;
        }
      }
      {
      B += ((D ^ (A & (C ^ D))) + correct_words[4]) + 3889429448U;
      B = (B << 20) | (B >> 12);
      B += C;
      }
      goto while_break___23;
    }
    while_break___23: ;
    }
    {
    while (1) {
      while_continue___24: ;
      if (! 1) {
        {
        goto while_break___24;
        }
      }
      {
      A += ((C ^ (D & (B ^ C))) + correct_words[9]) + 568446438U;
      A = (A << 5) | (A >> 27);
      A += B;
      }
      goto while_break___24;
    }
    while_break___24: ;
    }
    {
    while (1) {
      while_continue___25: ;
      if (! 1) {
        {
        goto while_break___25;
        }
      }
      {
      D += ((B ^ (C & (A ^ B))) + correct_words[14]) + 3275163606U;
      D = (D << 9) | (D >> 23);
      D += A;
      }
      goto while_break___25;
    }
    while_break___25: ;
    }
    {
    while (1) {
      while_continue___26: ;
      if (! 1) {
        {
        goto while_break___26;
        }
      }
      {
      C += ((A ^ (B & (D ^ A))) + correct_words[3]) + 4107603335U;
      C = (C << 14) | (C >> 18);
      C += D;
      }
      goto while_break___26;
    }
    while_break___26: ;
    }
    {
    while (1) {
      while_continue___27: ;
      if (! 1) {
        {
        goto while_break___27;
        }
      }
      {
      B += ((D ^ (A & (C ^ D))) + correct_words[8]) + 1163531501U;
      B = (B << 20) | (B >> 12);
      B += C;
      }
      goto while_break___27;
    }
    while_break___27: ;
    }
    {
    while (1) {
      while_continue___28: ;
      if (! 1) {
        {
        goto while_break___28;
        }
      }
      {
      A += ((C ^ (D & (B ^ C))) + correct_words[13]) + 2850285829U;
      A = (A << 5) | (A >> 27);
      A += B;
      }
      goto while_break___28;
    }
    while_break___28: ;
    }
    {
    while (1) {
      while_continue___29: ;
      if (! 1) {
        {
        goto while_break___29;
        }
      }
      {
      D += ((B ^ (C & (A ^ B))) + correct_words[2]) + 4243563512U;
      D = (D << 9) | (D >> 23);
      D += A;
      }
      goto while_break___29;
    }
    while_break___29: ;
    }
    {
    while (1) {
      while_continue___30: ;
      if (! 1) {
        {
        goto while_break___30;
        }
      }
      {
      C += ((A ^ (B & (D ^ A))) + correct_words[7]) + 1735328473U;
      C = (C << 14) | (C >> 18);
      C += D;
      }
      goto while_break___30;
    }
    while_break___30: ;
    }
    {
    while (1) {
      while_continue___31: ;
      if (! 1) {
        {
        goto while_break___31;
        }
      }
      {
      B += ((D ^ (A & (C ^ D))) + correct_words[12]) + 2368359562U;
      B = (B << 20) | (B >> 12);
      B += C;
      }
      goto while_break___31;
    }
    while_break___31: ;
    }
    {
    while (1) {
      while_continue___32: ;
      if (! 1) {
        {
        goto while_break___32;
        }
      }
      {
      A += (((B ^ C) ^ D) + correct_words[5]) + 4294588738U;
      A = (A << 4) | (A >> 28);
      A += B;
      }
      goto while_break___32;
    }
    while_break___32: ;
    }
    {
    while (1) {
      while_continue___33: ;
      if (! 1) {
        {
        goto while_break___33;
        }
      }
      {
      D += (((A ^ B) ^ C) + correct_words[8]) + 2272392833U;
      D = (D << 11) | (D >> 21);
      D += A;
      }
      goto while_break___33;
    }
    while_break___33: ;
    }
    {
    while (1) {
      while_continue___34: ;
      if (! 1) {
        {
        goto while_break___34;
        }
      }
      {
      C += (((D ^ A) ^ B) + correct_words[11]) + 1839030562U;
      C = (C << 16) | (C >> 16);
      C += D;
      }
      goto while_break___34;
    }
    while_break___34: ;
    }
    {
    while (1) {
      while_continue___35: ;
      if (! 1) {
        {
        goto while_break___35;
        }
      }
      {
      B += (((C ^ D) ^ A) + correct_words[14]) + 4259657740U;
      B = (B << 23) | (B >> 9);
      B += C;
      }
      goto while_break___35;
    }
    while_break___35: ;
    }
    {
    while (1) {
      while_continue___36: ;
      if (! 1) {
        {
        goto while_break___36;
        }
      }
      {
      A += (((B ^ C) ^ D) + correct_words[1]) + 2763975236U;
      A = (A << 4) | (A >> 28);
      A += B;
      }
      goto while_break___36;
    }
    while_break___36: ;
    }
    {
    while (1) {
      while_continue___37: ;
      if (! 1) {
        {
        goto while_break___37;
        }
      }
      {
      D += (((A ^ B) ^ C) + correct_words[4]) + 1272893353U;
      D = (D << 11) | (D >> 21);
      D += A;
      }
      goto while_break___37;
    }
    while_break___37: ;
    }
    {
    while (1) {
      while_continue___38: ;
      if (! 1) {
        {
        goto while_break___38;
        }
      }
      {
      C += (((D ^ A) ^ B) + correct_words[7]) + 4139469664U;
      C = (C << 16) | (C >> 16);
      C += D;
      }
      goto while_break___38;
    }
    while_break___38: ;
    }
    {
    while (1) {
      while_continue___39: ;
      if (! 1) {
        {
        goto while_break___39;
        }
      }
      {
      B += (((C ^ D) ^ A) + correct_words[10]) + 3200236656U;
      B = (B << 23) | (B >> 9);
      B += C;
      }
      goto while_break___39;
    }
    while_break___39: ;
    }
    {
    while (1) {
      while_continue___40: ;
      if (! 1) {
        {
        goto while_break___40;
        }
      }
      {
      A += (((B ^ C) ^ D) + correct_words[13]) + 681279174U;
      A = (A << 4) | (A >> 28);
      A += B;
      }
      goto while_break___40;
    }
    while_break___40: ;
    }
    {
    while (1) {
      while_continue___41: ;
      if (! 1) {
        {
        goto while_break___41;
        }
      }
      {
      D += (((A ^ B) ^ C) + correct_words[0]) + 3936430074U;
      D = (D << 11) | (D >> 21);
      D += A;
      }
      goto while_break___41;
    }
    while_break___41: ;
    }
    {
    while (1) {
      while_continue___42: ;
      if (! 1) {
        {
        goto while_break___42;
        }
      }
      {
      C += (((D ^ A) ^ B) + correct_words[3]) + 3572445317U;
      C = (C << 16) | (C >> 16);
      C += D;
      }
      goto while_break___42;
    }
    while_break___42: ;
    }
    {
    while (1) {
      while_continue___43: ;
      if (! 1) {
        {
        goto while_break___43;
        }
      }
      {
      B += (((C ^ D) ^ A) + correct_words[6]) + 76029189U;
      B = (B << 23) | (B >> 9);
      B += C;
      }
      goto while_break___43;
    }
    while_break___43: ;
    }
    {
    while (1) {
      while_continue___44: ;
      if (! 1) {
        {
        goto while_break___44;
        }
      }
      {
      A += (((B ^ C) ^ D) + correct_words[9]) + 3654602809U;
      A = (A << 4) | (A >> 28);
      A += B;
      }
      goto while_break___44;
    }
    while_break___44: ;
    }
    {
    while (1) {
      while_continue___45: ;
      if (! 1) {
        {
        goto while_break___45;
        }
      }
      {
      D += (((A ^ B) ^ C) + correct_words[12]) + 3873151461U;
      D = (D << 11) | (D >> 21);
      D += A;
      }
      goto while_break___45;
    }
    while_break___45: ;
    }
    {
    while (1) {
      while_continue___46: ;
      if (! 1) {
        {
        goto while_break___46;
        }
      }
      {
      C += (((D ^ A) ^ B) + correct_words[15]) + 530742520U;
      C = (C << 16) | (C >> 16);
      C += D;
      }
      goto while_break___46;
    }
    while_break___46: ;
    }
    {
    while (1) {
      while_continue___47: ;
      if (! 1) {
        {
        goto while_break___47;
        }
      }
      {
      B += (((C ^ D) ^ A) + correct_words[2]) + 3299628645U;
      B = (B << 23) | (B >> 9);
      B += C;
      }
      goto while_break___47;
    }
    while_break___47: ;
    }
    {
    while (1) {
      while_continue___48: ;
      if (! 1) {
        {
        goto while_break___48;
        }
      }
      {
      A += ((C ^ (B | ~ D)) + correct_words[0]) + 4096336452U;
      A = (A << 6) | (A >> 26);
      A += B;
      }
      goto while_break___48;
    }
    while_break___48: ;
    }
    {
    while (1) {
      while_continue___49: ;
      if (! 1) {
        {
        goto while_break___49;
        }
      }
      {
      D += ((B ^ (A | ~ C)) + correct_words[7]) + 1126891415U;
      D = (D << 10) | (D >> 22);
      D += A;
      }
      goto while_break___49;
    }
    while_break___49: ;
    }
    {
    while (1) {
      while_continue___50: ;
      if (! 1) {
        {
        goto while_break___50;
        }
      }
      {
      C += ((A ^ (D | ~ B)) + correct_words[14]) + 2878612391U;
      C = (C << 15) | (C >> 17);
      C += D;
      }
      goto while_break___50;
    }
    while_break___50: ;
    }
    {
    while (1) {
      while_continue___51: ;
      if (! 1) {
        {
        goto while_break___51;
        }
      }
      {
      B += ((D ^ (C | ~ A)) + correct_words[5]) + 4237533241U;
      B = (B << 21) | (B >> 11);
      B += C;
      }
      goto while_break___51;
    }
    while_break___51: ;
    }
    {
    while (1) {
      while_continue___52: ;
      if (! 1) {
        {
        goto while_break___52;
        }
      }
      {
      A += ((C ^ (B | ~ D)) + correct_words[12]) + 1700485571U;
      A = (A << 6) | (A >> 26);
      A += B;
      }
      goto while_break___52;
    }
    while_break___52: ;
    }
    {
    while (1) {
      while_continue___53: ;
      if (! 1) {
        {
        goto while_break___53;
        }
      }
      {
      D += ((B ^ (A | ~ C)) + correct_words[3]) + 2399980690U;
      D = (D << 10) | (D >> 22);
      D += A;
      }
      goto while_break___53;
    }
    while_break___53: ;
    }
    {
    while (1) {
      while_continue___54: ;
      if (! 1) {
        {
        goto while_break___54;
        }
      }
      {
      C += ((A ^ (D | ~ B)) + correct_words[10]) + 4293915773U;
      C = (C << 15) | (C >> 17);
      C += D;
      }
      goto while_break___54;
    }
    while_break___54: ;
    }
    {
    while (1) {
      while_continue___55: ;
      if (! 1) {
        {
        goto while_break___55;
        }
      }
      {
      B += ((D ^ (C | ~ A)) + correct_words[1]) + 2240044497U;
      B = (B << 21) | (B >> 11);
      B += C;
      }
      goto while_break___55;
    }
    while_break___55: ;
    }
    {
    while (1) {
      while_continue___56: ;
      if (! 1) {
        {
        goto while_break___56;
        }
      }
      {
      A += ((C ^ (B | ~ D)) + correct_words[8]) + 1873313359U;
      A = (A << 6) | (A >> 26);
      A += B;
      }
      goto while_break___56;
    }
    while_break___56: ;
    }
    {
    while (1) {
      while_continue___57: ;
      if (! 1) {
        {
        goto while_break___57;
        }
      }
      {
      D += ((B ^ (A | ~ C)) + correct_words[15]) + 4264355552U;
      D = (D << 10) | (D >> 22);
      D += A;
      }
      goto while_break___57;
    }
    while_break___57: ;
    }
    {
    while (1) {
      while_continue___58: ;
      if (! 1) {
        {
        goto while_break___58;
        }
      }
      {
      C += ((A ^ (D | ~ B)) + correct_words[6]) + 2734768916U;
      C = (C << 15) | (C >> 17);
      C += D;
      }
      goto while_break___58;
    }
    while_break___58: ;
    }
    {
    while (1) {
      while_continue___59: ;
      if (! 1) {
        {
        goto while_break___59;
        }
      }
      {
      B += ((D ^ (C | ~ A)) + correct_words[13]) + 1309151649U;
      B = (B << 21) | (B >> 11);
      B += C;
      }
      goto while_break___59;
    }
    while_break___59: ;
    }
    {
    while (1) {
      while_continue___60: ;
      if (! 1) {
        {
        goto while_break___60;
        }
      }
      {
      A += ((C ^ (B | ~ D)) + correct_words[4]) + 4149444226U;
      A = (A << 6) | (A >> 26);
      A += B;
      }
      goto while_break___60;
    }
    while_break___60: ;
    }
    {
    while (1) {
      while_continue___61: ;
      if (! 1) {
        {
        goto while_break___61;
        }
      }
      {
      D += ((B ^ (A | ~ C)) + correct_words[11]) + 3174756917U;
      D = (D << 10) | (D >> 22);
      D += A;
      }
      goto while_break___61;
    }
    while_break___61: ;
    }
    {
    while (1) {
      while_continue___62: ;
      if (! 1) {
        {
        goto while_break___62;
        }
      }
      {
      C += ((A ^ (D | ~ B)) + correct_words[2]) + 718787259U;
      C = (C << 15) | (C >> 17);
      C += D;
      }
      goto while_break___62;
    }
    while_break___62: ;
    }
    {
    while (1) {
      while_continue___63: ;
      if (! 1) {
        {
        goto while_break___63;
        }
      }
      {
      B += ((D ^ (C | ~ A)) + correct_words[9]) + 3951481745U;
      B = (B << 21) | (B >> 11);
      B += C;
      }
      goto while_break___63;
    }
    while_break___63: ;
    }
    {
    A += A_save;
    B += B_save;
    C += C_save;
    D += D_save;
    }
  }
  while_break: ;
  }
  {
  ctx->A = A;
  ctx->B = B;
  ctx->C = C;
  ctx->D = D;
  }
  return;
}
}
void sha1_init_ctx(struct sha1_ctx *ctx )
{
  uint32_t tmp ;
  {
  {
  ctx->A = (uint32_t )1732584193;
  ctx->B = 4023233417U;
  ctx->C = 2562383102U;
  ctx->D = (uint32_t )271733878;
  ctx->E = 3285377520U;
  tmp = (uint32_t )0;
  ctx->total[1] = tmp;
  ctx->total[0] = tmp;
  ctx->buflen = (uint32_t )0;
  }
  return;
}
}
void *sha1_read_ctx(struct sha1_ctx const *ctx , void *resbuf )
{
  char *r ;
  {
  {
  r = (char *)resbuf;
  set_uint32(r + 0UL, (uint32_t )((((ctx->A << 24) | ((ctx->A & 65280U) << 8)) | ((ctx->A >> 8) & 65280U)) | (ctx->A >> 24)));
  set_uint32(r + sizeof(ctx->B), (uint32_t )((((ctx->B << 24) | ((ctx->B & 65280U) << 8)) | ((ctx->B >> 8) & 65280U)) | (ctx->B >> 24)));
  set_uint32(r + 2UL * sizeof(ctx->C), (uint32_t )((((ctx->C << 24) | ((ctx->C & 65280U) << 8)) | ((ctx->C >> 8) & 65280U)) | (ctx->C >> 24)));
  set_uint32(r + 3UL * sizeof(ctx->D), (uint32_t )((((ctx->D << 24) | ((ctx->D & 65280U) << 8)) | ((ctx->D >> 8) & 65280U)) | (ctx->D >> 24)));
  set_uint32(r + 4UL * sizeof(ctx->E), (uint32_t )((((ctx->E << 24) | ((ctx->E & 65280U) << 8)) | ((ctx->E >> 8) & 65280U)) | (ctx->E >> 24)));
  }
  return (resbuf);
}
}
void *sha1_finish_ctx(struct sha1_ctx *ctx , void *resbuf )
{
  uint32_t bytes ;
  size_t size ;
  int tmp ;
  void *tmp___0 ;
  {
  {
  bytes = ctx->buflen;
  }
  if (bytes < 56U) {
    {
    {
    tmp = 16;
    }
    }
  } else {
    {
    {
    tmp = 32;
    }
    }
  }
  {
  size = (size_t )tmp;
  ctx->total[0] += bytes;
  }
  if (ctx->total[0] < bytes) {
    {
    {
    (ctx->total[1]) ++;
    }
    }
  }
  {
  ctx->buffer[size - 2UL] = (((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) & 65280U) << 8)) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 8) & 65280U)) | (((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 24);
  ctx->buffer[size - 1UL] = ((((ctx->total[0] << 3) << 24) | (((ctx->total[0] << 3) & 65280U) << 8)) | (((ctx->total[0] << 3) >> 8) & 65280U)) | ((ctx->total[0] << 3) >> 24);
  memcpy((void *)((void * __restrict )((char *)(ctx->buffer) + bytes)), (void const *)((void const * __restrict )(fillbuf___0)),
         (size - 2UL) * 4UL - (size_t )bytes);
  sha1_process_block((void const *)(ctx->buffer), size * 4UL, ctx);
  tmp___0 = sha1_read_ctx((struct sha1_ctx const *)ctx, resbuf);
  }
  return (tmp___0);
}
}
int sha1_stream(FILE *stream , void *resblock )
{
  struct sha1_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  {
  {
  tmp = malloc((size_t )32840);
  buffer = (char *)tmp;
  }
  if (! buffer) {
    {
    return (1);
    }
  }
  {
  sha1_init_ctx(& ctx);
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    sum = (size_t )0;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      {
      tmp___4 = fread_unlocked((void *)((void * __restrict )(buffer + sum)), (size_t )1,
                               32768UL - sum, (FILE *)((FILE * __restrict )stream));
      tmp___3 = tmp___4;
      tmp___0 = tmp___3;
      n = tmp___0;
      sum += n;
      }
      if (sum == 32768UL) {
        {
        goto while_break___0;
        }
      }
      if (n == 0UL) {
        {
        {
        tmp___1 = ferror_unlocked(stream);
        }
        if (tmp___1) {
          {
          {
          free((void *)buffer);
          }
          return (1);
          }
        }
        goto process_partial_block;
        }
      }
      {
      tmp___2 = feof_unlocked(stream);
      }
      if (tmp___2) {
        {
        goto process_partial_block;
        }
      }
    }
    while_break___0: ;
    }
    {
    sha1_process_block((void const *)buffer, (size_t )32768, & ctx);
    }
  }
  while_break: ;
  }
  process_partial_block:
  {
  }
  if (sum > 0UL) {
    {
    {
    sha1_process_bytes((void const *)buffer, sum, & ctx);
    }
    }
  }
  {
  sha1_finish_ctx(& ctx, resblock);
  free((void *)buffer);
  }
  return (0);
}
}
void *sha1_buffer(char const *buffer , size_t len , void *resblock )
{
  struct sha1_ctx ctx ;
  void *tmp ;
  {
  {
  sha1_init_ctx(& ctx);
  sha1_process_bytes((void const *)buffer, len, & ctx);
  tmp = sha1_finish_ctx(& ctx, resblock);
  }
  return (tmp);
}
}
void sha1_process_bytes(void const *buffer , size_t len , struct sha1_ctx *ctx )
{
  size_t left_over ;
  size_t add ;
  size_t tmp ;
  size_t left_over___0 ;
  {
  if (ctx->buflen != 0U) {
    {
    {
    left_over = (size_t )ctx->buflen;
    }
    if (128UL - left_over > len) {
      {
      {
      tmp = len;
      }
      }
    } else {
      {
      {
      tmp = 128UL - left_over;
      }
      }
    }
    {
    add = tmp;
    memcpy((void *)((void * __restrict )((char *)(ctx->buffer) + left_over)), (void const *)((void const * __restrict )buffer),
           add);
    ctx->buflen = (uint32_t )((size_t )ctx->buflen + add);
    }
    if (ctx->buflen > 64U) {
      {
      {
      sha1_process_block((void const *)(ctx->buffer), (size_t )(ctx->buflen & 4294967232U),
                         ctx);
      ctx->buflen &= 63U;
      memcpy((void *)((void * __restrict )(ctx->buffer)), (void const *)((void const * __restrict )((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL))),
             (size_t )ctx->buflen);
      }
      }
    }
    {
    buffer = (void const *)((char const *)buffer + add);
    len -= add;
    }
    }
  }
  if (len >= 64UL) {
    {
    {
    sha1_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
    buffer = (void const *)((char const *)buffer + (len & 0xffffffffffffffc0UL));
    len &= 63UL;
    }
    }
  }
  if (len > 0UL) {
    {
    {
    left_over___0 = (size_t )ctx->buflen;
    memcpy((void *)((void * __restrict )((char *)(ctx->buffer) + left_over___0)),
           (void const *)((void const * __restrict )buffer), len);
    left_over___0 += len;
    }
    if (left_over___0 >= 64UL) {
      {
      {
      sha1_process_block((void const *)(ctx->buffer), (size_t )64, ctx);
      left_over___0 -= 64UL;
      memcpy((void *)((void * __restrict )(ctx->buffer)), (void const *)((void const * __restrict )(& ctx->buffer[16])),
             left_over___0);
      }
      }
    }
    {
    ctx->buflen = (uint32_t )left_over___0;
    }
    }
  }
  return;
}
}
void sha1_process_block(void const *buffer , size_t len , struct sha1_ctx *ctx )
{
  uint32_t const *words ;
  size_t nwords ;
  uint32_t const *endp ;
  uint32_t x[16] ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t tm ;
  int t ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  {
  {
  words = (uint32_t const *)buffer;
  nwords = len / sizeof(uint32_t );
  endp = words + nwords;
  a = ctx->A;
  b = ctx->B;
  c = ctx->C;
  d = ctx->D;
  e = ctx->E;
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + len);
  }
  if ((size_t )ctx->total[0] < len) {
    {
    {
    (ctx->total[1]) ++;
    }
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )words < (unsigned long )endp)) {
      {
      goto while_break;
      }
    }
    {
    t = 0;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! (t < 16)) {
        {
        goto while_break___0;
        }
      }
      {
      x[t] = (uint32_t )((((*words << 24) | ((*words & 65280U) << 8)) | ((*words >> 8) & 65280U)) | (*words >> 24));
      words ++;
      t ++;
      }
    }
    while_break___0: ;
    }
    {
    while (1) {
      while_continue___1: ;
      if (! 1) {
        {
        goto while_break___1;
        }
      }
      {
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[0];
      b = (b << 30) | (b >> 2);
      }
      goto while_break___1;
    }
    while_break___1: ;
    }
    {
    while (1) {
      while_continue___2: ;
      if (! 1) {
        {
        goto while_break___2;
        }
      }
      {
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[1];
      a = (a << 30) | (a >> 2);
      }
      goto while_break___2;
    }
    while_break___2: ;
    }
    {
    while (1) {
      while_continue___3: ;
      if (! 1) {
        {
        goto while_break___3;
        }
      }
      {
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[2];
      e = (e << 30) | (e >> 2);
      }
      goto while_break___3;
    }
    while_break___3: ;
    }
    {
    while (1) {
      while_continue___4: ;
      if (! 1) {
        {
        goto while_break___4;
        }
      }
      {
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[3];
      d = (d << 30) | (d >> 2);
      }
      goto while_break___4;
    }
    while_break___4: ;
    }
    {
    while (1) {
      while_continue___5: ;
      if (! 1) {
        {
        goto while_break___5;
        }
      }
      {
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[4];
      c = (c << 30) | (c >> 2);
      }
      goto while_break___5;
    }
    while_break___5: ;
    }
    {
    while (1) {
      while_continue___6: ;
      if (! 1) {
        {
        goto while_break___6;
        }
      }
      {
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[5];
      b = (b << 30) | (b >> 2);
      }
      goto while_break___6;
    }
    while_break___6: ;
    }
    {
    while (1) {
      while_continue___7: ;
      if (! 1) {
        {
        goto while_break___7;
        }
      }
      {
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[6];
      a = (a << 30) | (a >> 2);
      }
      goto while_break___7;
    }
    while_break___7: ;
    }
    {
    while (1) {
      while_continue___8: ;
      if (! 1) {
        {
        goto while_break___8;
        }
      }
      {
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[7];
      e = (e << 30) | (e >> 2);
      }
      goto while_break___8;
    }
    while_break___8: ;
    }
    {
    while (1) {
      while_continue___9: ;
      if (! 1) {
        {
        goto while_break___9;
        }
      }
      {
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[8];
      d = (d << 30) | (d >> 2);
      }
      goto while_break___9;
    }
    while_break___9: ;
    }
    {
    while (1) {
      while_continue___10: ;
      if (! 1) {
        {
        goto while_break___10;
        }
      }
      {
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[9];
      c = (c << 30) | (c >> 2);
      }
      goto while_break___10;
    }
    while_break___10: ;
    }
    {
    while (1) {
      while_continue___11: ;
      if (! 1) {
        {
        goto while_break___11;
        }
      }
      {
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[10];
      b = (b << 30) | (b >> 2);
      }
      goto while_break___11;
    }
    while_break___11: ;
    }
    {
    while (1) {
      while_continue___12: ;
      if (! 1) {
        {
        goto while_break___12;
        }
      }
      {
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[11];
      a = (a << 30) | (a >> 2);
      }
      goto while_break___12;
    }
    while_break___12: ;
    }
    {
    while (1) {
      while_continue___13: ;
      if (! 1) {
        {
        goto while_break___13;
        }
      }
      {
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[12];
      e = (e << 30) | (e >> 2);
      }
      goto while_break___13;
    }
    while_break___13: ;
    }
    {
    while (1) {
      while_continue___14: ;
      if (! 1) {
        {
        goto while_break___14;
        }
      }
      {
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[13];
      d = (d << 30) | (d >> 2);
      }
      goto while_break___14;
    }
    while_break___14: ;
    }
    {
    while (1) {
      while_continue___15: ;
      if (! 1) {
        {
        goto while_break___15;
        }
      }
      {
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[14];
      c = (c << 30) | (c >> 2);
      }
      goto while_break___15;
    }
    while_break___15: ;
    }
    {
    while (1) {
      while_continue___16: ;
      if (! 1) {
        {
        goto while_break___16;
        }
      }
      {
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[15];
      b = (b << 30) | (b >> 2);
      }
      goto while_break___16;
    }
    while_break___16: ;
    }
    {
    while (1) {
      while_continue___17: ;
      if (! 1) {
        {
        goto while_break___17;
        }
      }
      {
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
      x[0] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[0];
      a = (a << 30) | (a >> 2);
      }
      goto while_break___17;
    }
    while_break___17: ;
    }
    {
    while (1) {
      while_continue___18: ;
      if (! 1) {
        {
        goto while_break___18;
        }
      }
      {
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
      x[1] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[1];
      e = (e << 30) | (e >> 2);
      }
      goto while_break___18;
    }
    while_break___18: ;
    }
    {
    while (1) {
      while_continue___19: ;
      if (! 1) {
        {
        goto while_break___19;
        }
      }
      {
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
      x[2] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[2];
      d = (d << 30) | (d >> 2);
      }
      goto while_break___19;
    }
    while_break___19: ;
    }
    {
    while (1) {
      while_continue___20: ;
      if (! 1) {
        {
        goto while_break___20;
        }
      }
      {
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
      x[3] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[3];
      c = (c << 30) | (c >> 2);
      }
      goto while_break___20;
    }
    while_break___20: ;
    }
    {
    while (1) {
      while_continue___21: ;
      if (! 1) {
        {
        goto while_break___21;
        }
      }
      {
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
      x[4] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[4];
      b = (b << 30) | (b >> 2);
      }
      goto while_break___21;
    }
    while_break___21: ;
    }
    {
    while (1) {
      while_continue___22: ;
      if (! 1) {
        {
        goto while_break___22;
        }
      }
      {
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
      x[5] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[5];
      a = (a << 30) | (a >> 2);
      }
      goto while_break___22;
    }
    while_break___22: ;
    }
    {
    while (1) {
      while_continue___23: ;
      if (! 1) {
        {
        goto while_break___23;
        }
      }
      {
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
      x[6] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[6];
      e = (e << 30) | (e >> 2);
      }
      goto while_break___23;
    }
    while_break___23: ;
    }
    {
    while (1) {
      while_continue___24: ;
      if (! 1) {
        {
        goto while_break___24;
        }
      }
      {
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
      x[7] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[7];
      d = (d << 30) | (d >> 2);
      }
      goto while_break___24;
    }
    while_break___24: ;
    }
    {
    while (1) {
      while_continue___25: ;
      if (! 1) {
        {
        goto while_break___25;
        }
      }
      {
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
      x[8] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[8];
      c = (c << 30) | (c >> 2);
      }
      goto while_break___25;
    }
    while_break___25: ;
    }
    {
    while (1) {
      while_continue___26: ;
      if (! 1) {
        {
        goto while_break___26;
        }
      }
      {
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
      x[9] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[9];
      b = (b << 30) | (b >> 2);
      }
      goto while_break___26;
    }
    while_break___26: ;
    }
    {
    while (1) {
      while_continue___27: ;
      if (! 1) {
        {
        goto while_break___27;
        }
      }
      {
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
      x[10] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[10];
      a = (a << 30) | (a >> 2);
      }
      goto while_break___27;
    }
    while_break___27: ;
    }
    {
    while (1) {
      while_continue___28: ;
      if (! 1) {
        {
        goto while_break___28;
        }
      }
      {
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
      x[11] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[11];
      e = (e << 30) | (e >> 2);
      }
      goto while_break___28;
    }
    while_break___28: ;
    }
    {
    while (1) {
      while_continue___29: ;
      if (! 1) {
        {
        goto while_break___29;
        }
      }
      {
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
      x[12] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[12];
      d = (d << 30) | (d >> 2);
      }
      goto while_break___29;
    }
    while_break___29: ;
    }
    {
    while (1) {
      while_continue___30: ;
      if (! 1) {
        {
        goto while_break___30;
        }
      }
      {
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
      x[13] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[13];
      c = (c << 30) | (c >> 2);
      }
      goto while_break___30;
    }
    while_break___30: ;
    }
    {
    while (1) {
      while_continue___31: ;
      if (! 1) {
        {
        goto while_break___31;
        }
      }
      {
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
      x[14] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[14];
      b = (b << 30) | (b >> 2);
      }
      goto while_break___31;
    }
    while_break___31: ;
    }
    {
    while (1) {
      while_continue___32: ;
      if (! 1) {
        {
        goto while_break___32;
        }
      }
      {
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
      x[15] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[15];
      a = (a << 30) | (a >> 2);
      }
      goto while_break___32;
    }
    while_break___32: ;
    }
    {
    while (1) {
      while_continue___33: ;
      if (! 1) {
        {
        goto while_break___33;
        }
      }
      {
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
      x[0] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[0];
      e = (e << 30) | (e >> 2);
      }
      goto while_break___33;
    }
    while_break___33: ;
    }
    {
    while (1) {
      while_continue___34: ;
      if (! 1) {
        {
        goto while_break___34;
        }
      }
      {
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
      x[1] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[1];
      d = (d << 30) | (d >> 2);
      }
      goto while_break___34;
    }
    while_break___34: ;
    }
    {
    while (1) {
      while_continue___35: ;
      if (! 1) {
        {
        goto while_break___35;
        }
      }
      {
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
      x[2] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[2];
      c = (c << 30) | (c >> 2);
      }
      goto while_break___35;
    }
    while_break___35: ;
    }
    {
    while (1) {
      while_continue___36: ;
      if (! 1) {
        {
        goto while_break___36;
        }
      }
      {
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
      x[3] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[3];
      b = (b << 30) | (b >> 2);
      }
      goto while_break___36;
    }
    while_break___36: ;
    }
    {
    while (1) {
      while_continue___37: ;
      if (! 1) {
        {
        goto while_break___37;
        }
      }
      {
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
      x[4] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[4];
      a = (a << 30) | (a >> 2);
      }
      goto while_break___37;
    }
    while_break___37: ;
    }
    {
    while (1) {
      while_continue___38: ;
      if (! 1) {
        {
        goto while_break___38;
        }
      }
      {
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
      x[5] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[5];
      e = (e << 30) | (e >> 2);
      }
      goto while_break___38;
    }
    while_break___38: ;
    }
    {
    while (1) {
      while_continue___39: ;
      if (! 1) {
        {
        goto while_break___39;
        }
      }
      {
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
      x[6] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[6];
      d = (d << 30) | (d >> 2);
      }
      goto while_break___39;
    }
    while_break___39: ;
    }
    {
    while (1) {
      while_continue___40: ;
      if (! 1) {
        {
        goto while_break___40;
        }
      }
      {
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
      x[7] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[7];
      c = (c << 30) | (c >> 2);
      }
      goto while_break___40;
    }
    while_break___40: ;
    }
    {
    while (1) {
      while_continue___41: ;
      if (! 1) {
        {
        goto while_break___41;
        }
      }
      {
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
      x[8] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[8];
      b = (b << 30) | (b >> 2);
      }
      goto while_break___41;
    }
    while_break___41: ;
    }
    {
    while (1) {
      while_continue___42: ;
      if (! 1) {
        {
        goto while_break___42;
        }
      }
      {
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
      x[9] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[9];
      a = (a << 30) | (a >> 2);
      }
      goto while_break___42;
    }
    while_break___42: ;
    }
    {
    while (1) {
      while_continue___43: ;
      if (! 1) {
        {
        goto while_break___43;
        }
      }
      {
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
      x[10] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[10];
      e = (e << 30) | (e >> 2);
      }
      goto while_break___43;
    }
    while_break___43: ;
    }
    {
    while (1) {
      while_continue___44: ;
      if (! 1) {
        {
        goto while_break___44;
        }
      }
      {
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
      x[11] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[11];
      d = (d << 30) | (d >> 2);
      }
      goto while_break___44;
    }
    while_break___44: ;
    }
    {
    while (1) {
      while_continue___45: ;
      if (! 1) {
        {
        goto while_break___45;
        }
      }
      {
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
      x[12] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[12];
      c = (c << 30) | (c >> 2);
      }
      goto while_break___45;
    }
    while_break___45: ;
    }
    {
    while (1) {
      while_continue___46: ;
      if (! 1) {
        {
        goto while_break___46;
        }
      }
      {
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
      x[13] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[13];
      b = (b << 30) | (b >> 2);
      }
      goto while_break___46;
    }
    while_break___46: ;
    }
    {
    while (1) {
      while_continue___47: ;
      if (! 1) {
        {
        goto while_break___47;
        }
      }
      {
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
      x[14] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[14];
      a = (a << 30) | (a >> 2);
      }
      goto while_break___47;
    }
    while_break___47: ;
    }
    {
    while (1) {
      while_continue___48: ;
      if (! 1) {
        {
        goto while_break___48;
        }
      }
      {
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
      x[15] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[15];
      e = (e << 30) | (e >> 2);
      }
      goto while_break___48;
    }
    while_break___48: ;
    }
    {
    while (1) {
      while_continue___49: ;
      if (! 1) {
        {
        goto while_break___49;
        }
      }
      {
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
      x[0] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[0];
      d = (d << 30) | (d >> 2);
      }
      goto while_break___49;
    }
    while_break___49: ;
    }
    {
    while (1) {
      while_continue___50: ;
      if (! 1) {
        {
        goto while_break___50;
        }
      }
      {
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
      x[1] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[1];
      c = (c << 30) | (c >> 2);
      }
      goto while_break___50;
    }
    while_break___50: ;
    }
    {
    while (1) {
      while_continue___51: ;
      if (! 1) {
        {
        goto while_break___51;
        }
      }
      {
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
      x[2] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[2];
      b = (b << 30) | (b >> 2);
      }
      goto while_break___51;
    }
    while_break___51: ;
    }
    {
    while (1) {
      while_continue___52: ;
      if (! 1) {
        {
        goto while_break___52;
        }
      }
      {
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
      x[3] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[3];
      a = (a << 30) | (a >> 2);
      }
      goto while_break___52;
    }
    while_break___52: ;
    }
    {
    while (1) {
      while_continue___53: ;
      if (! 1) {
        {
        goto while_break___53;
        }
      }
      {
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
      x[4] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[4];
      e = (e << 30) | (e >> 2);
      }
      goto while_break___53;
    }
    while_break___53: ;
    }
    {
    while (1) {
      while_continue___54: ;
      if (! 1) {
        {
        goto while_break___54;
        }
      }
      {
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
      x[5] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[5];
      d = (d << 30) | (d >> 2);
      }
      goto while_break___54;
    }
    while_break___54: ;
    }
    {
    while (1) {
      while_continue___55: ;
      if (! 1) {
        {
        goto while_break___55;
        }
      }
      {
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
      x[6] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[6];
      c = (c << 30) | (c >> 2);
      }
      goto while_break___55;
    }
    while_break___55: ;
    }
    {
    while (1) {
      while_continue___56: ;
      if (! 1) {
        {
        goto while_break___56;
        }
      }
      {
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
      x[7] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[7];
      b = (b << 30) | (b >> 2);
      }
      goto while_break___56;
    }
    while_break___56: ;
    }
    {
    while (1) {
      while_continue___57: ;
      if (! 1) {
        {
        goto while_break___57;
        }
      }
      {
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
      x[8] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[8];
      a = (a << 30) | (a >> 2);
      }
      goto while_break___57;
    }
    while_break___57: ;
    }
    {
    while (1) {
      while_continue___58: ;
      if (! 1) {
        {
        goto while_break___58;
        }
      }
      {
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
      x[9] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[9];
      e = (e << 30) | (e >> 2);
      }
      goto while_break___58;
    }
    while_break___58: ;
    }
    {
    while (1) {
      while_continue___59: ;
      if (! 1) {
        {
        goto while_break___59;
        }
      }
      {
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
      x[10] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[10];
      d = (d << 30) | (d >> 2);
      }
      goto while_break___59;
    }
    while_break___59: ;
    }
    {
    while (1) {
      while_continue___60: ;
      if (! 1) {
        {
        goto while_break___60;
        }
      }
      {
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
      x[11] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[11];
      c = (c << 30) | (c >> 2);
      }
      goto while_break___60;
    }
    while_break___60: ;
    }
    {
    while (1) {
      while_continue___61: ;
      if (! 1) {
        {
        goto while_break___61;
        }
      }
      {
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
      x[12] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[12];
      b = (b << 30) | (b >> 2);
      }
      goto while_break___61;
    }
    while_break___61: ;
    }
    {
    while (1) {
      while_continue___62: ;
      if (! 1) {
        {
        goto while_break___62;
        }
      }
      {
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
      x[13] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[13];
      a = (a << 30) | (a >> 2);
      }
      goto while_break___62;
    }
    while_break___62: ;
    }
    {
    while (1) {
      while_continue___63: ;
      if (! 1) {
        {
        goto while_break___63;
        }
      }
      {
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
      x[14] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[14];
      e = (e << 30) | (e >> 2);
      }
      goto while_break___63;
    }
    while_break___63: ;
    }
    {
    while (1) {
      while_continue___64: ;
      if (! 1) {
        {
        goto while_break___64;
        }
      }
      {
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
      x[15] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[15];
      d = (d << 30) | (d >> 2);
      }
      goto while_break___64;
    }
    while_break___64: ;
    }
    {
    while (1) {
      while_continue___65: ;
      if (! 1) {
        {
        goto while_break___65;
        }
      }
      {
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
      x[0] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[0];
      c = (c << 30) | (c >> 2);
      }
      goto while_break___65;
    }
    while_break___65: ;
    }
    {
    while (1) {
      while_continue___66: ;
      if (! 1) {
        {
        goto while_break___66;
        }
      }
      {
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
      x[1] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[1];
      b = (b << 30) | (b >> 2);
      }
      goto while_break___66;
    }
    while_break___66: ;
    }
    {
    while (1) {
      while_continue___67: ;
      if (! 1) {
        {
        goto while_break___67;
        }
      }
      {
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
      x[2] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[2];
      a = (a << 30) | (a >> 2);
      }
      goto while_break___67;
    }
    while_break___67: ;
    }
    {
    while (1) {
      while_continue___68: ;
      if (! 1) {
        {
        goto while_break___68;
        }
      }
      {
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
      x[3] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[3];
      e = (e << 30) | (e >> 2);
      }
      goto while_break___68;
    }
    while_break___68: ;
    }
    {
    while (1) {
      while_continue___69: ;
      if (! 1) {
        {
        goto while_break___69;
        }
      }
      {
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
      x[4] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[4];
      d = (d << 30) | (d >> 2);
      }
      goto while_break___69;
    }
    while_break___69: ;
    }
    {
    while (1) {
      while_continue___70: ;
      if (! 1) {
        {
        goto while_break___70;
        }
      }
      {
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
      x[5] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[5];
      c = (c << 30) | (c >> 2);
      }
      goto while_break___70;
    }
    while_break___70: ;
    }
    {
    while (1) {
      while_continue___71: ;
      if (! 1) {
        {
        goto while_break___71;
        }
      }
      {
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
      x[6] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[6];
      b = (b << 30) | (b >> 2);
      }
      goto while_break___71;
    }
    while_break___71: ;
    }
    {
    while (1) {
      while_continue___72: ;
      if (! 1) {
        {
        goto while_break___72;
        }
      }
      {
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
      x[7] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[7];
      a = (a << 30) | (a >> 2);
      }
      goto while_break___72;
    }
    while_break___72: ;
    }
    {
    while (1) {
      while_continue___73: ;
      if (! 1) {
        {
        goto while_break___73;
        }
      }
      {
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
      x[8] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[8];
      e = (e << 30) | (e >> 2);
      }
      goto while_break___73;
    }
    while_break___73: ;
    }
    {
    while (1) {
      while_continue___74: ;
      if (! 1) {
        {
        goto while_break___74;
        }
      }
      {
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
      x[9] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[9];
      d = (d << 30) | (d >> 2);
      }
      goto while_break___74;
    }
    while_break___74: ;
    }
    {
    while (1) {
      while_continue___75: ;
      if (! 1) {
        {
        goto while_break___75;
        }
      }
      {
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
      x[10] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[10];
      c = (c << 30) | (c >> 2);
      }
      goto while_break___75;
    }
    while_break___75: ;
    }
    {
    while (1) {
      while_continue___76: ;
      if (! 1) {
        {
        goto while_break___76;
        }
      }
      {
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
      x[11] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[11];
      b = (b << 30) | (b >> 2);
      }
      goto while_break___76;
    }
    while_break___76: ;
    }
    {
    while (1) {
      while_continue___77: ;
      if (! 1) {
        {
        goto while_break___77;
        }
      }
      {
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
      x[12] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[12];
      a = (a << 30) | (a >> 2);
      }
      goto while_break___77;
    }
    while_break___77: ;
    }
    {
    while (1) {
      while_continue___78: ;
      if (! 1) {
        {
        goto while_break___78;
        }
      }
      {
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
      x[13] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[13];
      e = (e << 30) | (e >> 2);
      }
      goto while_break___78;
    }
    while_break___78: ;
    }
    {
    while (1) {
      while_continue___79: ;
      if (! 1) {
        {
        goto while_break___79;
        }
      }
      {
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
      x[14] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[14];
      d = (d << 30) | (d >> 2);
      }
      goto while_break___79;
    }
    while_break___79: ;
    }
    {
    while (1) {
      while_continue___80: ;
      if (! 1) {
        {
        goto while_break___80;
        }
      }
      {
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
      x[15] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[15];
      c = (c << 30) | (c >> 2);
      }
      goto while_break___80;
    }
    while_break___80: ;
    }
    {
    tmp = ctx->A + a;
    ctx->A = tmp;
    a = tmp;
    tmp___0 = ctx->B + b;
    ctx->B = tmp___0;
    b = tmp___0;
    tmp___1 = ctx->C + c;
    ctx->C = tmp___1;
    c = tmp___1;
    tmp___2 = ctx->D + d;
    ctx->D = tmp___2;
    d = tmp___2;
    tmp___3 = ctx->E + e;
    ctx->E = tmp___3;
    e = tmp___3;
    }
  }
  while_break: ;
  }
  return;
}
}
void sha256_init_ctx(struct sha256_ctx *ctx )
{
  uint32_t tmp ;
  {
  {
  ctx->state[0] = (uint32_t )1779033703UL;
  ctx->state[1] = (uint32_t )3144134277UL;
  ctx->state[2] = (uint32_t )1013904242UL;
  ctx->state[3] = (uint32_t )2773480762UL;
  ctx->state[4] = (uint32_t )1359893119UL;
  ctx->state[5] = (uint32_t )2600822924UL;
  ctx->state[6] = (uint32_t )528734635UL;
  ctx->state[7] = (uint32_t )1541459225UL;
  tmp = (uint32_t )0;
  ctx->total[1] = tmp;
  ctx->total[0] = tmp;
  ctx->buflen = (size_t )0;
  }
  return;
}
}
void sha224_init_ctx(struct sha256_ctx *ctx )
{
  uint32_t tmp ;
  {
  {
  ctx->state[0] = (uint32_t )3238371032UL;
  ctx->state[1] = (uint32_t )914150663UL;
  ctx->state[2] = (uint32_t )812702999UL;
  ctx->state[3] = (uint32_t )4144912697UL;
  ctx->state[4] = (uint32_t )4290775857UL;
  ctx->state[5] = (uint32_t )1750603025UL;
  ctx->state[6] = (uint32_t )1694076839UL;
  ctx->state[7] = (uint32_t )3204075428UL;
  tmp = (uint32_t )0;
  ctx->total[1] = tmp;
  ctx->total[0] = tmp;
  ctx->buflen = (size_t )0;
  }
  return;
}
}
void *sha256_read_ctx(struct sha256_ctx const *ctx , void *resbuf )
{
  int i ;
  char *r ;
  {
  {
  r = (char *)resbuf;
  i = 0;
  }
  {
  while (1) {
    while_continue: ;
    if (! (i < 8)) {
      {
      goto while_break;
      }
    }
    {
    set_uint32(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 24) | ((ctx->state[i] & 65280U) << 8)) | ((ctx->state[i] >> 8) & 65280U)) | (ctx->state[i] >> 24));
    i ++;
    }
  }
  while_break: ;
  }
  return (resbuf);
}
}
void *sha224_read_ctx(struct sha256_ctx const *ctx , void *resbuf )
{
  int i ;
  char *r ;
  {
  {
  r = (char *)resbuf;
  i = 0;
  }
  {
  while (1) {
    while_continue: ;
    if (! (i < 7)) {
      {
      goto while_break;
      }
    }
    {
    set_uint32(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 24) | ((ctx->state[i] & 65280U) << 8)) | ((ctx->state[i] >> 8) & 65280U)) | (ctx->state[i] >> 24));
    i ++;
    }
  }
  while_break: ;
  }
  return (resbuf);
}
}
static void sha256_conclude_ctx(struct sha256_ctx *ctx )
{
  size_t bytes ;
  size_t size ;
  int tmp ;
  {
  {
  bytes = ctx->buflen;
  }
  if (bytes < 56UL) {
    {
    {
    tmp = 16;
    }
    }
  } else {
    {
    {
    tmp = 32;
    }
    }
  }
  {
  size = (size_t )tmp;
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + bytes);
  }
  if ((size_t )ctx->total[0] < bytes) {
    {
    {
    (ctx->total[1]) ++;
    }
    }
  }
  {
  set_uint32((char *)(& ctx->buffer[size - 2UL]), (((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) & 65280U) << 8)) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 8) & 65280U)) | (((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 24));
  set_uint32((char *)(& ctx->buffer[size - 1UL]), ((((ctx->total[0] << 3) << 24) | (((ctx->total[0] << 3) & 65280U) << 8)) | (((ctx->total[0] << 3) >> 8) & 65280U)) | ((ctx->total[0] << 3) >> 24));
  memcpy((void *)((void * __restrict )((char *)(ctx->buffer) + bytes)), (void const *)((void const * __restrict )(fillbuf___1)),
         (size - 2UL) * 4UL - bytes);
  sha256_process_block((void const *)(ctx->buffer), size * 4UL, ctx);
  }
  return;
}
}
void *sha256_finish_ctx(struct sha256_ctx *ctx , void *resbuf )
{
  void *tmp ;
  {
  {
  sha256_conclude_ctx(ctx);
  tmp = sha256_read_ctx((struct sha256_ctx const *)ctx, resbuf);
  }
  return (tmp);
}
}
void *sha224_finish_ctx(struct sha256_ctx *ctx , void *resbuf )
{
  void *tmp ;
  {
  {
  sha256_conclude_ctx(ctx);
  tmp = sha224_read_ctx((struct sha256_ctx const *)ctx, resbuf);
  }
  return (tmp);
}
}
int sha256_stream(FILE *stream , void *resblock )
{
  struct sha256_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  {
  {
  tmp = malloc((size_t )32840);
  buffer = (char *)tmp;
  }
  if (! buffer) {
    {
    return (1);
    }
  }
  {
  sha256_init_ctx(& ctx);
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    sum = (size_t )0;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      {
      tmp___4 = fread_unlocked((void *)((void * __restrict )(buffer + sum)), (size_t )1,
                               32768UL - sum, (FILE *)((FILE * __restrict )stream));
      tmp___3 = tmp___4;
      tmp___0 = tmp___3;
      n = tmp___0;
      sum += n;
      }
      if (sum == 32768UL) {
        {
        goto while_break___0;
        }
      }
      if (n == 0UL) {
        {
        {
        tmp___1 = ferror_unlocked(stream);
        }
        if (tmp___1) {
          {
          {
          free((void *)buffer);
          }
          return (1);
          }
        }
        goto process_partial_block;
        }
      }
      {
      tmp___2 = feof_unlocked(stream);
      }
      if (tmp___2) {
        {
        goto process_partial_block;
        }
      }
    }
    while_break___0: ;
    }
    {
    sha256_process_block((void const *)buffer, (size_t )32768, & ctx);
    }
  }
  while_break: ;
  }
  process_partial_block:
  {
  }
  if (sum > 0UL) {
    {
    {
    sha256_process_bytes((void const *)buffer, sum, & ctx);
    }
    }
  }
  {
  sha256_finish_ctx(& ctx, resblock);
  free((void *)buffer);
  }
  return (0);
}
}
int sha224_stream(FILE *stream , void *resblock )
{
  struct sha256_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  {
  {
  tmp = malloc((size_t )32840);
  buffer = (char *)tmp;
  }
  if (! buffer) {
    {
    return (1);
    }
  }
  {
  sha224_init_ctx(& ctx);
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    sum = (size_t )0;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      {
      tmp___4 = fread_unlocked((void *)((void * __restrict )(buffer + sum)), (size_t )1,
                               32768UL - sum, (FILE *)((FILE * __restrict )stream));
      tmp___3 = tmp___4;
      tmp___0 = tmp___3;
      n = tmp___0;
      sum += n;
      }
      if (sum == 32768UL) {
        {
        goto while_break___0;
        }
      }
      if (n == 0UL) {
        {
        {
        tmp___1 = ferror_unlocked(stream);
        }
        if (tmp___1) {
          {
          {
          free((void *)buffer);
          }
          return (1);
          }
        }
        goto process_partial_block;
        }
      }
      {
      tmp___2 = feof_unlocked(stream);
      }
      if (tmp___2) {
        {
        goto process_partial_block;
        }
      }
    }
    while_break___0: ;
    }
    {
    sha256_process_block((void const *)buffer, (size_t )32768, & ctx);
    }
  }
  while_break: ;
  }
  process_partial_block:
  {
  }
  if (sum > 0UL) {
    {
    {
    sha256_process_bytes((void const *)buffer, sum, & ctx);
    }
    }
  }
  {
  sha224_finish_ctx(& ctx, resblock);
  free((void *)buffer);
  }
  return (0);
}
}
void *sha256_buffer(char const *buffer , size_t len , void *resblock )
{
  struct sha256_ctx ctx ;
  void *tmp ;
  {
  {
  sha256_init_ctx(& ctx);
  sha256_process_bytes((void const *)buffer, len, & ctx);
  tmp = sha256_finish_ctx(& ctx, resblock);
  }
  return (tmp);
}
}
void *sha224_buffer(char const *buffer , size_t len , void *resblock )
{
  struct sha256_ctx ctx ;
  void *tmp ;
  {
  {
  sha224_init_ctx(& ctx);
  sha256_process_bytes((void const *)buffer, len, & ctx);
  tmp = sha224_finish_ctx(& ctx, resblock);
  }
  return (tmp);
}
}
void sha256_process_bytes(void const *buffer , size_t len , struct sha256_ctx *ctx )
{
  size_t left_over ;
  size_t add ;
  size_t tmp ;
  size_t left_over___0 ;
  {
  if (ctx->buflen != 0UL) {
    {
    {
    left_over = ctx->buflen;
    }
    if (128UL - left_over > len) {
      {
      {
      tmp = len;
      }
      }
    } else {
      {
      {
      tmp = 128UL - left_over;
      }
      }
    }
    {
    add = tmp;
    memcpy((void *)((void * __restrict )((char *)(ctx->buffer) + left_over)), (void const *)((void const * __restrict )buffer),
           add);
    ctx->buflen += add;
    }
    if (ctx->buflen > 64UL) {
      {
      {
      sha256_process_block((void const *)(ctx->buffer), ctx->buflen & 0xffffffffffffffc0UL,
                           ctx);
      ctx->buflen &= 63UL;
      memcpy((void *)((void * __restrict )(ctx->buffer)), (void const *)((void const * __restrict )((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL))),
             ctx->buflen);
      }
      }
    }
    {
    buffer = (void const *)((char const *)buffer + add);
    len -= add;
    }
    }
  }
  if (len >= 64UL) {
    {
    {
    sha256_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
    buffer = (void const *)((char const *)buffer + (len & 0xffffffffffffffc0UL));
    len &= 63UL;
    }
    }
  }
  if (len > 0UL) {
    {
    {
    left_over___0 = ctx->buflen;
    memcpy((void *)((void * __restrict )((char *)(ctx->buffer) + left_over___0)),
           (void const *)((void const * __restrict )buffer), len);
    left_over___0 += len;
    }
    if (left_over___0 >= 64UL) {
      {
      {
      sha256_process_block((void const *)(ctx->buffer), (size_t )64, ctx);
      left_over___0 -= 64UL;
      memcpy((void *)((void * __restrict )(ctx->buffer)), (void const *)((void const * __restrict )(& ctx->buffer[16])),
             left_over___0);
      }
      }
    }
    {
    ctx->buflen = left_over___0;
    }
    }
  }
  return;
}
}
void sha256_process_block(void const *buffer , size_t len , struct sha256_ctx *ctx )
{
  uint32_t const *words ;
  size_t nwords ;
  uint32_t const *endp ;
  uint32_t x[16] ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t f ;
  uint32_t g ;
  uint32_t h ;
  uint32_t tm ;
  uint32_t t0 ;
  uint32_t t1 ;
  int t ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  {
  {
  words = (uint32_t const *)buffer;
  nwords = len / sizeof(uint32_t );
  endp = words + nwords;
  a = ctx->state[0];
  b = ctx->state[1];
  c = ctx->state[2];
  d = ctx->state[3];
  e = ctx->state[4];
  f = ctx->state[5];
  g = ctx->state[6];
  h = ctx->state[7];
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + len);
  }
  if ((size_t )ctx->total[0] < len) {
    {
    {
    (ctx->total[1]) ++;
    }
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )words < (unsigned long )endp)) {
      {
      goto while_break;
      }
    }
    {
    t = 0;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! (t < 16)) {
        {
        goto while_break___0;
        }
      }
      {
      x[t] = (uint32_t )((((*words << 24) | ((*words & 65280U) << 8)) | ((*words >> 8) & 65280U)) | (*words >> 24));
      words ++;
      t ++;
      }
    }
    while_break___0: ;
    }
    {
    while (1) {
      while_continue___1: ;
      if (! 1) {
        {
        goto while_break___1;
        }
      }
      {
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[0]) + x[0];
      d += t1;
      h = t0 + t1;
      }
      goto while_break___1;
    }
    while_break___1: ;
    }
    {
    while (1) {
      while_continue___2: ;
      if (! 1) {
        {
        goto while_break___2;
        }
      }
      {
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[1]) + x[1];
      c += t1;
      g = t0 + t1;
      }
      goto while_break___2;
    }
    while_break___2: ;
    }
    {
    while (1) {
      while_continue___3: ;
      if (! 1) {
        {
        goto while_break___3;
        }
      }
      {
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[2]) + x[2];
      b += t1;
      f = t0 + t1;
      }
      goto while_break___3;
    }
    while_break___3: ;
    }
    {
    while (1) {
      while_continue___4: ;
      if (! 1) {
        {
        goto while_break___4;
        }
      }
      {
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[3]) + x[3];
      a += t1;
      e = t0 + t1;
      }
      goto while_break___4;
    }
    while_break___4: ;
    }
    {
    while (1) {
      while_continue___5: ;
      if (! 1) {
        {
        goto while_break___5;
        }
      }
      {
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[4]) + x[4];
      h += t1;
      d = t0 + t1;
      }
      goto while_break___5;
    }
    while_break___5: ;
    }
    {
    while (1) {
      while_continue___6: ;
      if (! 1) {
        {
        goto while_break___6;
        }
      }
      {
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[5]) + x[5];
      g += t1;
      c = t0 + t1;
      }
      goto while_break___6;
    }
    while_break___6: ;
    }
    {
    while (1) {
      while_continue___7: ;
      if (! 1) {
        {
        goto while_break___7;
        }
      }
      {
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[6]) + x[6];
      f += t1;
      b = t0 + t1;
      }
      goto while_break___7;
    }
    while_break___7: ;
    }
    {
    while (1) {
      while_continue___8: ;
      if (! 1) {
        {
        goto while_break___8;
        }
      }
      {
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[7]) + x[7];
      e += t1;
      a = t0 + t1;
      }
      goto while_break___8;
    }
    while_break___8: ;
    }
    {
    while (1) {
      while_continue___9: ;
      if (! 1) {
        {
        goto while_break___9;
        }
      }
      {
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[8]) + x[8];
      d += t1;
      h = t0 + t1;
      }
      goto while_break___9;
    }
    while_break___9: ;
    }
    {
    while (1) {
      while_continue___10: ;
      if (! 1) {
        {
        goto while_break___10;
        }
      }
      {
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[9]) + x[9];
      c += t1;
      g = t0 + t1;
      }
      goto while_break___10;
    }
    while_break___10: ;
    }
    {
    while (1) {
      while_continue___11: ;
      if (! 1) {
        {
        goto while_break___11;
        }
      }
      {
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[10]) + x[10];
      b += t1;
      f = t0 + t1;
      }
      goto while_break___11;
    }
    while_break___11: ;
    }
    {
    while (1) {
      while_continue___12: ;
      if (! 1) {
        {
        goto while_break___12;
        }
      }
      {
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[11]) + x[11];
      a += t1;
      e = t0 + t1;
      }
      goto while_break___12;
    }
    while_break___12: ;
    }
    {
    while (1) {
      while_continue___13: ;
      if (! 1) {
        {
        goto while_break___13;
        }
      }
      {
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[12]) + x[12];
      h += t1;
      d = t0 + t1;
      }
      goto while_break___13;
    }
    while_break___13: ;
    }
    {
    while (1) {
      while_continue___14: ;
      if (! 1) {
        {
        goto while_break___14;
        }
      }
      {
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[13]) + x[13];
      g += t1;
      c = t0 + t1;
      }
      goto while_break___14;
    }
    while_break___14: ;
    }
    {
    while (1) {
      while_continue___15: ;
      if (! 1) {
        {
        goto while_break___15;
        }
      }
      {
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[14]) + x[14];
      f += t1;
      b = t0 + t1;
      }
      goto while_break___15;
    }
    while_break___15: ;
    }
    {
    while (1) {
      while_continue___16: ;
      if (! 1) {
        {
        goto while_break___16;
        }
      }
      {
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[15]) + x[15];
      e += t1;
      a = t0 + t1;
      }
      goto while_break___16;
    }
    while_break___16: ;
    }
    {
    while (1) {
      while_continue___17: ;
      if (! 1) {
        {
        goto while_break___17;
        }
      }
      {
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
      x[0] = tm;
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[16]) + x[0];
      d += t1;
      h = t0 + t1;
      }
      goto while_break___17;
    }
    while_break___17: ;
    }
    {
    while (1) {
      while_continue___18: ;
      if (! 1) {
        {
        goto while_break___18;
        }
      }
      {
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
      x[1] = tm;
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[17]) + x[1];
      c += t1;
      g = t0 + t1;
      }
      goto while_break___18;
    }
    while_break___18: ;
    }
    {
    while (1) {
      while_continue___19: ;
      if (! 1) {
        {
        goto while_break___19;
        }
      }
      {
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
      x[2] = tm;
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[18]) + x[2];
      b += t1;
      f = t0 + t1;
      }
      goto while_break___19;
    }
    while_break___19: ;
    }
    {
    while (1) {
      while_continue___20: ;
      if (! 1) {
        {
        goto while_break___20;
        }
      }
      {
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
      x[3] = tm;
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[19]) + x[3];
      a += t1;
      e = t0 + t1;
      }
      goto while_break___20;
    }
    while_break___20: ;
    }
    {
    while (1) {
      while_continue___21: ;
      if (! 1) {
        {
        goto while_break___21;
        }
      }
      {
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
      x[4] = tm;
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[20]) + x[4];
      h += t1;
      d = t0 + t1;
      }
      goto while_break___21;
    }
    while_break___21: ;
    }
    {
    while (1) {
      while_continue___22: ;
      if (! 1) {
        {
        goto while_break___22;
        }
      }
      {
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
      x[5] = tm;
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[21]) + x[5];
      g += t1;
      c = t0 + t1;
      }
      goto while_break___22;
    }
    while_break___22: ;
    }
    {
    while (1) {
      while_continue___23: ;
      if (! 1) {
        {
        goto while_break___23;
        }
      }
      {
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
      x[6] = tm;
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[22]) + x[6];
      f += t1;
      b = t0 + t1;
      }
      goto while_break___23;
    }
    while_break___23: ;
    }
    {
    while (1) {
      while_continue___24: ;
      if (! 1) {
        {
        goto while_break___24;
        }
      }
      {
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
      x[7] = tm;
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[23]) + x[7];
      e += t1;
      a = t0 + t1;
      }
      goto while_break___24;
    }
    while_break___24: ;
    }
    {
    while (1) {
      while_continue___25: ;
      if (! 1) {
        {
        goto while_break___25;
        }
      }
      {
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
      x[8] = tm;
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[24]) + x[8];
      d += t1;
      h = t0 + t1;
      }
      goto while_break___25;
    }
    while_break___25: ;
    }
    {
    while (1) {
      while_continue___26: ;
      if (! 1) {
        {
        goto while_break___26;
        }
      }
      {
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
      x[9] = tm;
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[25]) + x[9];
      c += t1;
      g = t0 + t1;
      }
      goto while_break___26;
    }
    while_break___26: ;
    }
    {
    while (1) {
      while_continue___27: ;
      if (! 1) {
        {
        goto while_break___27;
        }
      }
      {
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
      x[10] = tm;
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[26]) + x[10];
      b += t1;
      f = t0 + t1;
      }
      goto while_break___27;
    }
    while_break___27: ;
    }
    {
    while (1) {
      while_continue___28: ;
      if (! 1) {
        {
        goto while_break___28;
        }
      }
      {
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
      x[11] = tm;
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[27]) + x[11];
      a += t1;
      e = t0 + t1;
      }
      goto while_break___28;
    }
    while_break___28: ;
    }
    {
    while (1) {
      while_continue___29: ;
      if (! 1) {
        {
        goto while_break___29;
        }
      }
      {
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
      x[12] = tm;
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[28]) + x[12];
      h += t1;
      d = t0 + t1;
      }
      goto while_break___29;
    }
    while_break___29: ;
    }
    {
    while (1) {
      while_continue___30: ;
      if (! 1) {
        {
        goto while_break___30;
        }
      }
      {
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
      x[13] = tm;
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[29]) + x[13];
      g += t1;
      c = t0 + t1;
      }
      goto while_break___30;
    }
    while_break___30: ;
    }
    {
    while (1) {
      while_continue___31: ;
      if (! 1) {
        {
        goto while_break___31;
        }
      }
      {
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
      x[14] = tm;
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[30]) + x[14];
      f += t1;
      b = t0 + t1;
      }
      goto while_break___31;
    }
    while_break___31: ;
    }
    {
    while (1) {
      while_continue___32: ;
      if (! 1) {
        {
        goto while_break___32;
        }
      }
      {
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
      x[15] = tm;
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[31]) + x[15];
      e += t1;
      a = t0 + t1;
      }
      goto while_break___32;
    }
    while_break___32: ;
    }
    {
    while (1) {
      while_continue___33: ;
      if (! 1) {
        {
        goto while_break___33;
        }
      }
      {
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
      x[0] = tm;
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[32]) + x[0];
      d += t1;
      h = t0 + t1;
      }
      goto while_break___33;
    }
    while_break___33: ;
    }
    {
    while (1) {
      while_continue___34: ;
      if (! 1) {
        {
        goto while_break___34;
        }
      }
      {
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
      x[1] = tm;
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[33]) + x[1];
      c += t1;
      g = t0 + t1;
      }
      goto while_break___34;
    }
    while_break___34: ;
    }
    {
    while (1) {
      while_continue___35: ;
      if (! 1) {
        {
        goto while_break___35;
        }
      }
      {
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
      x[2] = tm;
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[34]) + x[2];
      b += t1;
      f = t0 + t1;
      }
      goto while_break___35;
    }
    while_break___35: ;
    }
    {
    while (1) {
      while_continue___36: ;
      if (! 1) {
        {
        goto while_break___36;
        }
      }
      {
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
      x[3] = tm;
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[35]) + x[3];
      a += t1;
      e = t0 + t1;
      }
      goto while_break___36;
    }
    while_break___36: ;
    }
    {
    while (1) {
      while_continue___37: ;
      if (! 1) {
        {
        goto while_break___37;
        }
      }
      {
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
      x[4] = tm;
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[36]) + x[4];
      h += t1;
      d = t0 + t1;
      }
      goto while_break___37;
    }
    while_break___37: ;
    }
    {
    while (1) {
      while_continue___38: ;
      if (! 1) {
        {
        goto while_break___38;
        }
      }
      {
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
      x[5] = tm;
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[37]) + x[5];
      g += t1;
      c = t0 + t1;
      }
      goto while_break___38;
    }
    while_break___38: ;
    }
    {
    while (1) {
      while_continue___39: ;
      if (! 1) {
        {
        goto while_break___39;
        }
      }
      {
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
      x[6] = tm;
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[38]) + x[6];
      f += t1;
      b = t0 + t1;
      }
      goto while_break___39;
    }
    while_break___39: ;
    }
    {
    while (1) {
      while_continue___40: ;
      if (! 1) {
        {
        goto while_break___40;
        }
      }
      {
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
      x[7] = tm;
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[39]) + x[7];
      e += t1;
      a = t0 + t1;
      }
      goto while_break___40;
    }
    while_break___40: ;
    }
    {
    while (1) {
      while_continue___41: ;
      if (! 1) {
        {
        goto while_break___41;
        }
      }
      {
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
      x[8] = tm;
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[40]) + x[8];
      d += t1;
      h = t0 + t1;
      }
      goto while_break___41;
    }
    while_break___41: ;
    }
    {
    while (1) {
      while_continue___42: ;
      if (! 1) {
        {
        goto while_break___42;
        }
      }
      {
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
      x[9] = tm;
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[41]) + x[9];
      c += t1;
      g = t0 + t1;
      }
      goto while_break___42;
    }
    while_break___42: ;
    }
    {
    while (1) {
      while_continue___43: ;
      if (! 1) {
        {
        goto while_break___43;
        }
      }
      {
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
      x[10] = tm;
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[42]) + x[10];
      b += t1;
      f = t0 + t1;
      }
      goto while_break___43;
    }
    while_break___43: ;
    }
    {
    while (1) {
      while_continue___44: ;
      if (! 1) {
        {
        goto while_break___44;
        }
      }
      {
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
      x[11] = tm;
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[43]) + x[11];
      a += t1;
      e = t0 + t1;
      }
      goto while_break___44;
    }
    while_break___44: ;
    }
    {
    while (1) {
      while_continue___45: ;
      if (! 1) {
        {
        goto while_break___45;
        }
      }
      {
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
      x[12] = tm;
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[44]) + x[12];
      h += t1;
      d = t0 + t1;
      }
      goto while_break___45;
    }
    while_break___45: ;
    }
    {
    while (1) {
      while_continue___46: ;
      if (! 1) {
        {
        goto while_break___46;
        }
      }
      {
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
      x[13] = tm;
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[45]) + x[13];
      g += t1;
      c = t0 + t1;
      }
      goto while_break___46;
    }
    while_break___46: ;
    }
    {
    while (1) {
      while_continue___47: ;
      if (! 1) {
        {
        goto while_break___47;
        }
      }
      {
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
      x[14] = tm;
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[46]) + x[14];
      f += t1;
      b = t0 + t1;
      }
      goto while_break___47;
    }
    while_break___47: ;
    }
    {
    while (1) {
      while_continue___48: ;
      if (! 1) {
        {
        goto while_break___48;
        }
      }
      {
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
      x[15] = tm;
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[47]) + x[15];
      e += t1;
      a = t0 + t1;
      }
      goto while_break___48;
    }
    while_break___48: ;
    }
    {
    while (1) {
      while_continue___49: ;
      if (! 1) {
        {
        goto while_break___49;
        }
      }
      {
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
      x[0] = tm;
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[48]) + x[0];
      d += t1;
      h = t0 + t1;
      }
      goto while_break___49;
    }
    while_break___49: ;
    }
    {
    while (1) {
      while_continue___50: ;
      if (! 1) {
        {
        goto while_break___50;
        }
      }
      {
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
      x[1] = tm;
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[49]) + x[1];
      c += t1;
      g = t0 + t1;
      }
      goto while_break___50;
    }
    while_break___50: ;
    }
    {
    while (1) {
      while_continue___51: ;
      if (! 1) {
        {
        goto while_break___51;
        }
      }
      {
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
      x[2] = tm;
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[50]) + x[2];
      b += t1;
      f = t0 + t1;
      }
      goto while_break___51;
    }
    while_break___51: ;
    }
    {
    while (1) {
      while_continue___52: ;
      if (! 1) {
        {
        goto while_break___52;
        }
      }
      {
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
      x[3] = tm;
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[51]) + x[3];
      a += t1;
      e = t0 + t1;
      }
      goto while_break___52;
    }
    while_break___52: ;
    }
    {
    while (1) {
      while_continue___53: ;
      if (! 1) {
        {
        goto while_break___53;
        }
      }
      {
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
      x[4] = tm;
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[52]) + x[4];
      h += t1;
      d = t0 + t1;
      }
      goto while_break___53;
    }
    while_break___53: ;
    }
    {
    while (1) {
      while_continue___54: ;
      if (! 1) {
        {
        goto while_break___54;
        }
      }
      {
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
      x[5] = tm;
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[53]) + x[5];
      g += t1;
      c = t0 + t1;
      }
      goto while_break___54;
    }
    while_break___54: ;
    }
    {
    while (1) {
      while_continue___55: ;
      if (! 1) {
        {
        goto while_break___55;
        }
      }
      {
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
      x[6] = tm;
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[54]) + x[6];
      f += t1;
      b = t0 + t1;
      }
      goto while_break___55;
    }
    while_break___55: ;
    }
    {
    while (1) {
      while_continue___56: ;
      if (! 1) {
        {
        goto while_break___56;
        }
      }
      {
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
      x[7] = tm;
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[55]) + x[7];
      e += t1;
      a = t0 + t1;
      }
      goto while_break___56;
    }
    while_break___56: ;
    }
    {
    while (1) {
      while_continue___57: ;
      if (! 1) {
        {
        goto while_break___57;
        }
      }
      {
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
      x[8] = tm;
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[56]) + x[8];
      d += t1;
      h = t0 + t1;
      }
      goto while_break___57;
    }
    while_break___57: ;
    }
    {
    while (1) {
      while_continue___58: ;
      if (! 1) {
        {
        goto while_break___58;
        }
      }
      {
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
      x[9] = tm;
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[57]) + x[9];
      c += t1;
      g = t0 + t1;
      }
      goto while_break___58;
    }
    while_break___58: ;
    }
    {
    while (1) {
      while_continue___59: ;
      if (! 1) {
        {
        goto while_break___59;
        }
      }
      {
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
      x[10] = tm;
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[58]) + x[10];
      b += t1;
      f = t0 + t1;
      }
      goto while_break___59;
    }
    while_break___59: ;
    }
    {
    while (1) {
      while_continue___60: ;
      if (! 1) {
        {
        goto while_break___60;
        }
      }
      {
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
      x[11] = tm;
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[59]) + x[11];
      a += t1;
      e = t0 + t1;
      }
      goto while_break___60;
    }
    while_break___60: ;
    }
    {
    while (1) {
      while_continue___61: ;
      if (! 1) {
        {
        goto while_break___61;
        }
      }
      {
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
      x[12] = tm;
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[60]) + x[12];
      h += t1;
      d = t0 + t1;
      }
      goto while_break___61;
    }
    while_break___61: ;
    }
    {
    while (1) {
      while_continue___62: ;
      if (! 1) {
        {
        goto while_break___62;
        }
      }
      {
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
      x[13] = tm;
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[61]) + x[13];
      g += t1;
      c = t0 + t1;
      }
      goto while_break___62;
    }
    while_break___62: ;
    }
    {
    while (1) {
      while_continue___63: ;
      if (! 1) {
        {
        goto while_break___63;
        }
      }
      {
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
      x[14] = tm;
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[62]) + x[14];
      f += t1;
      b = t0 + t1;
      }
      goto while_break___63;
    }
    while_break___63: ;
    }
    {
    while (1) {
      while_continue___64: ;
      if (! 1) {
        {
        goto while_break___64;
        }
      }
      {
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
      x[15] = tm;
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[63]) + x[15];
      e += t1;
      a = t0 + t1;
      }
      goto while_break___64;
    }
    while_break___64: ;
    }
    {
    tmp = ctx->state[0] + a;
    ctx->state[0] = tmp;
    a = tmp;
    tmp___0 = ctx->state[1] + b;
    ctx->state[1] = tmp___0;
    b = tmp___0;
    tmp___1 = ctx->state[2] + c;
    ctx->state[2] = tmp___1;
    c = tmp___1;
    tmp___2 = ctx->state[3] + d;
    ctx->state[3] = tmp___2;
    d = tmp___2;
    tmp___3 = ctx->state[4] + e;
    ctx->state[4] = tmp___3;
    e = tmp___3;
    tmp___4 = ctx->state[5] + f;
    ctx->state[5] = tmp___4;
    f = tmp___4;
    tmp___5 = ctx->state[6] + g;
    ctx->state[6] = tmp___5;
    g = tmp___5;
    tmp___6 = ctx->state[7] + h;
    ctx->state[7] = tmp___6;
    h = tmp___6;
    }
  }
  while_break: ;
  }
  return;
}
}
void sha512_init_ctx(struct sha512_ctx *ctx )
{
  u64 tmp ;
  {
  {
  ctx->state[0] = (1779033703UL << 32) + 4089235720UL;
  ctx->state[1] = (3144134277UL << 32) + 2227873595UL;
  ctx->state[2] = (1013904242UL << 32) + 4271175723UL;
  ctx->state[3] = (2773480762UL << 32) + 1595750129UL;
  ctx->state[4] = (1359893119UL << 32) + 2917565137UL;
  ctx->state[5] = (2600822924UL << 32) + 725511199UL;
  ctx->state[6] = (528734635UL << 32) + 4215389547UL;
  ctx->state[7] = (1541459225UL << 32) + 327033209UL;
  tmp = (u64 )0;
  ctx->total[1] = tmp;
  ctx->total[0] = tmp;
  ctx->buflen = (size_t )0;
  }
  return;
}
}
void sha384_init_ctx(struct sha512_ctx *ctx )
{
  u64 tmp ;
  {
  {
  ctx->state[0] = (3418070365UL << 32) + 3238371032UL;
  ctx->state[1] = (1654270250UL << 32) + 914150663UL;
  ctx->state[2] = (2438529370UL << 32) + 812702999UL;
  ctx->state[3] = (355462360UL << 32) + 4144912697UL;
  ctx->state[4] = (1731405415UL << 32) + 4290775857UL;
  ctx->state[5] = (2394180231UL << 32) + 1750603025UL;
  ctx->state[6] = (3675008525UL << 32) + 1694076839UL;
  ctx->state[7] = (1203062813UL << 32) + 3204075428UL;
  tmp = (u64 )0;
  ctx->total[1] = tmp;
  ctx->total[0] = tmp;
  ctx->buflen = (size_t )0;
  }
  return;
}
}
__inline static void set_uint64(char *cp , u64 v )
{
  {
  {
  memcpy((void *)((void * __restrict )cp), (void const *)((void const * __restrict )(& v)),
         sizeof(v));
  }
  return;
}
}
void *sha512_read_ctx(struct sha512_ctx const *ctx , void *resbuf )
{
  int i ;
  char *r ;
  {
  {
  r = (char *)resbuf;
  i = 0;
  }
  {
  while (1) {
    while_continue: ;
    if (! (i < 8)) {
      {
      goto while_break;
      }
    }
    {
    set_uint64(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 56) | ((ctx->state[i] & 65280UL) << 40)) | (((ctx->state[i] & 16711680UL) << 24) | ((ctx->state[i] & 4278190080UL) << 8))) | ((((ctx->state[i] >> 8) & 4278190080UL) | ((ctx->state[i] >> 24) & 16711680UL)) | (((ctx->state[i] >> 40) & 65280UL) | (ctx->state[i] >> 56))));
    i ++;
    }
  }
  while_break: ;
  }
  return (resbuf);
}
}
void *sha384_read_ctx(struct sha512_ctx const *ctx , void *resbuf )
{
  int i ;
  char *r ;
  {
  {
  r = (char *)resbuf;
  i = 0;
  }
  {
  while (1) {
    while_continue: ;
    if (! (i < 6)) {
      {
      goto while_break;
      }
    }
    {
    set_uint64(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 56) | ((ctx->state[i] & 65280UL) << 40)) | (((ctx->state[i] & 16711680UL) << 24) | ((ctx->state[i] & 4278190080UL) << 8))) | ((((ctx->state[i] >> 8) & 4278190080UL) | ((ctx->state[i] >> 24) & 16711680UL)) | (((ctx->state[i] >> 40) & 65280UL) | (ctx->state[i] >> 56))));
    i ++;
    }
  }
  while_break: ;
  }
  return (resbuf);
}
}
static void sha512_conclude_ctx(struct sha512_ctx *ctx )
{
  size_t bytes ;
  size_t size ;
  int tmp ;
  {
  {
  bytes = ctx->buflen;
  }
  if (bytes < 112UL) {
    {
    {
    tmp = 16;
    }
    }
  } else {
    {
    {
    tmp = 32;
    }
    }
  }
  {
  size = (size_t )tmp;
  ctx->total[0] += bytes;
  }
  if (ctx->total[0] < bytes) {
    {
    {
    (ctx->total[1]) ++;
    }
    }
  }
  {
  set_uint64((char *)(& ctx->buffer[size - 2UL]), (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) << 56) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 65280UL) << 40)) | (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 16711680UL) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 4278190080UL) << 8))) | ((((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 8) & 4278190080UL) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 24) & 16711680UL)) | (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 40) & 65280UL) | (((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 56))));
  set_uint64((char *)(& ctx->buffer[size - 1UL]), ((((ctx->total[0] << 3) << 56) | (((ctx->total[0] << 3) & 65280UL) << 40)) | ((((ctx->total[0] << 3) & 16711680UL) << 24) | (((ctx->total[0] << 3) & 4278190080UL) << 8))) | (((((ctx->total[0] << 3) >> 8) & 4278190080UL) | (((ctx->total[0] << 3) >> 24) & 16711680UL)) | ((((ctx->total[0] << 3) >> 40) & 65280UL) | ((ctx->total[0] << 3) >> 56))));
  memcpy((void *)((void * __restrict )((char *)(ctx->buffer) + bytes)), (void const *)((void const * __restrict )(fillbuf___2)),
         (size - 2UL) * 8UL - bytes);
  sha512_process_block((void const *)(ctx->buffer), size * 8UL, ctx);
  }
  return;
}
}
void *sha512_finish_ctx(struct sha512_ctx *ctx , void *resbuf )
{
  void *tmp ;
  {
  {
  sha512_conclude_ctx(ctx);
  tmp = sha512_read_ctx((struct sha512_ctx const *)ctx, resbuf);
  }
  return (tmp);
}
}
void *sha384_finish_ctx(struct sha512_ctx *ctx , void *resbuf )
{
  void *tmp ;
  {
  {
  sha512_conclude_ctx(ctx);
  tmp = sha384_read_ctx((struct sha512_ctx const *)ctx, resbuf);
  }
  return (tmp);
}
}
int sha512_stream(FILE *stream , void *resblock )
{
  struct sha512_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  {
  {
  tmp = malloc((size_t )32840);
  buffer = (char *)tmp;
  }
  if (! buffer) {
    {
    return (1);
    }
  }
  {
  sha512_init_ctx(& ctx);
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    sum = (size_t )0;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      {
      tmp___4 = fread_unlocked((void *)((void * __restrict )(buffer + sum)), (size_t )1,
                               32768UL - sum, (FILE *)((FILE * __restrict )stream));
      tmp___3 = tmp___4;
      tmp___0 = tmp___3;
      n = tmp___0;
      sum += n;
      }
      if (sum == 32768UL) {
        {
        goto while_break___0;
        }
      }
      if (n == 0UL) {
        {
        {
        tmp___1 = ferror_unlocked(stream);
        }
        if (tmp___1) {
          {
          {
          free((void *)buffer);
          }
          return (1);
          }
        }
        goto process_partial_block;
        }
      }
      {
      tmp___2 = feof_unlocked(stream);
      }
      if (tmp___2) {
        {
        goto process_partial_block;
        }
      }
    }
    while_break___0: ;
    }
    {
    sha512_process_block((void const *)buffer, (size_t )32768, & ctx);
    }
  }
  while_break: ;
  }
  process_partial_block:
  {
  }
  if (sum > 0UL) {
    {
    {
    sha512_process_bytes((void const *)buffer, sum, & ctx);
    }
    }
  }
  {
  sha512_finish_ctx(& ctx, resblock);
  free((void *)buffer);
  }
  return (0);
}
}
int sha384_stream(FILE *stream , void *resblock )
{
  struct sha512_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  {
  {
  tmp = malloc((size_t )32840);
  buffer = (char *)tmp;
  }
  if (! buffer) {
    {
    return (1);
    }
  }
  {
  sha384_init_ctx(& ctx);
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    sum = (size_t )0;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      {
      tmp___4 = fread_unlocked((void *)((void * __restrict )(buffer + sum)), (size_t )1,
                               32768UL - sum, (FILE *)((FILE * __restrict )stream));
      tmp___3 = tmp___4;
      tmp___0 = tmp___3;
      n = tmp___0;
      sum += n;
      }
      if (sum == 32768UL) {
        {
        goto while_break___0;
        }
      }
      if (n == 0UL) {
        {
        {
        tmp___1 = ferror_unlocked(stream);
        }
        if (tmp___1) {
          {
          {
          free((void *)buffer);
          }
          return (1);
          }
        }
        goto process_partial_block;
        }
      }
      {
      tmp___2 = feof_unlocked(stream);
      }
      if (tmp___2) {
        {
        goto process_partial_block;
        }
      }
    }
    while_break___0: ;
    }
    {
    sha512_process_block((void const *)buffer, (size_t )32768, & ctx);
    }
  }
  while_break: ;
  }
  process_partial_block:
  {
  }
  if (sum > 0UL) {
    {
    {
    sha512_process_bytes((void const *)buffer, sum, & ctx);
    }
    }
  }
  {
  sha384_finish_ctx(& ctx, resblock);
  free((void *)buffer);
  }
  return (0);
}
}
void *sha512_buffer(char const *buffer , size_t len , void *resblock )
{
  struct sha512_ctx ctx ;
  void *tmp ;
  {
  {
  sha512_init_ctx(& ctx);
  sha512_process_bytes((void const *)buffer, len, & ctx);
  tmp = sha512_finish_ctx(& ctx, resblock);
  }
  return (tmp);
}
}
void *sha384_buffer(char const *buffer , size_t len , void *resblock )
{
  struct sha512_ctx ctx ;
  void *tmp ;
  {
  {
  sha384_init_ctx(& ctx);
  sha512_process_bytes((void const *)buffer, len, & ctx);
  tmp = sha384_finish_ctx(& ctx, resblock);
  }
  return (tmp);
}
}
void sha512_process_bytes(void const *buffer , size_t len , struct sha512_ctx *ctx )
{
  size_t left_over ;
  size_t add ;
  size_t tmp ;
  size_t left_over___0 ;
  {
  if (ctx->buflen != 0UL) {
    {
    {
    left_over = ctx->buflen;
    }
    if (256UL - left_over > len) {
      {
      {
      tmp = len;
      }
      }
    } else {
      {
      {
      tmp = 256UL - left_over;
      }
      }
    }
    {
    add = tmp;
    memcpy((void *)((void * __restrict )((char *)(ctx->buffer) + left_over)), (void const *)((void const * __restrict )buffer),
           add);
    ctx->buflen += add;
    }
    if (ctx->buflen > 128UL) {
      {
      {
      sha512_process_block((void const *)(ctx->buffer), ctx->buflen & 0xffffffffffffff80UL,
                           ctx);
      ctx->buflen &= 127UL;
      memcpy((void *)((void * __restrict )(ctx->buffer)), (void const *)((void const * __restrict )((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffff80UL))),
             ctx->buflen);
      }
      }
    }
    {
    buffer = (void const *)((char const *)buffer + add);
    len -= add;
    }
    }
  }
  if (len >= 128UL) {
    {
    {
    sha512_process_block(buffer, len & 0xffffffffffffff80UL, ctx);
    buffer = (void const *)((char const *)buffer + (len & 0xffffffffffffff80UL));
    len &= 127UL;
    }
    }
  }
  if (len > 0UL) {
    {
    {
    left_over___0 = ctx->buflen;
    memcpy((void *)((void * __restrict )((char *)(ctx->buffer) + left_over___0)),
           (void const *)((void const * __restrict )buffer), len);
    left_over___0 += len;
    }
    if (left_over___0 >= 128UL) {
      {
      {
      sha512_process_block((void const *)(ctx->buffer), (size_t )128, ctx);
      left_over___0 -= 128UL;
      memcpy((void *)((void * __restrict )(ctx->buffer)), (void const *)((void const * __restrict )(& ctx->buffer[16])),
             left_over___0);
      }
      }
    }
    {
    ctx->buflen = left_over___0;
    }
    }
  }
  return;
}
}
void sha512_process_block(void const *buffer , size_t len , struct sha512_ctx *ctx )
{
  u64 const *words ;
  u64 const *endp ;
  u64 x[16] ;
  u64 a ;
  u64 b ;
  u64 c ;
  u64 d ;
  u64 e ;
  u64 f ;
  u64 g ;
  u64 h ;
  int t ;
  u64 t0 ;
  u64 t1 ;
  u64 t0___0 ;
  u64 t1___0 ;
  u64 t0___1 ;
  u64 t1___1 ;
  u64 t0___2 ;
  u64 t1___2 ;
  u64 t0___3 ;
  u64 t1___3 ;
  u64 t0___4 ;
  u64 t1___4 ;
  u64 t0___5 ;
  u64 t1___5 ;
  u64 t0___6 ;
  u64 t1___6 ;
  u64 t0___7 ;
  u64 t1___7 ;
  u64 t0___8 ;
  u64 t1___8 ;
  u64 t0___9 ;
  u64 t1___9 ;
  u64 t0___10 ;
  u64 t1___10 ;
  u64 t0___11 ;
  u64 t1___11 ;
  u64 t0___12 ;
  u64 t1___12 ;
  u64 t0___13 ;
  u64 t1___13 ;
  u64 t0___14 ;
  u64 t1___14 ;
  u64 t0___15 ;
  u64 t1___15 ;
  u64 t0___16 ;
  u64 t1___16 ;
  u64 t0___17 ;
  u64 t1___17 ;
  u64 t0___18 ;
  u64 t1___18 ;
  u64 t0___19 ;
  u64 t1___19 ;
  u64 t0___20 ;
  u64 t1___20 ;
  u64 t0___21 ;
  u64 t1___21 ;
  u64 t0___22 ;
  u64 t1___22 ;
  u64 t0___23 ;
  u64 t1___23 ;
  u64 t0___24 ;
  u64 t1___24 ;
  u64 t0___25 ;
  u64 t1___25 ;
  u64 t0___26 ;
  u64 t1___26 ;
  u64 t0___27 ;
  u64 t1___27 ;
  u64 t0___28 ;
  u64 t1___28 ;
  u64 t0___29 ;
  u64 t1___29 ;
  u64 t0___30 ;
  u64 t1___30 ;
  u64 t0___31 ;
  u64 t1___31 ;
  u64 t0___32 ;
  u64 t1___32 ;
  u64 t0___33 ;
  u64 t1___33 ;
  u64 t0___34 ;
  u64 t1___34 ;
  u64 t0___35 ;
  u64 t1___35 ;
  u64 t0___36 ;
  u64 t1___36 ;
  u64 t0___37 ;
  u64 t1___37 ;
  u64 t0___38 ;
  u64 t1___38 ;
  u64 t0___39 ;
  u64 t1___39 ;
  u64 t0___40 ;
  u64 t1___40 ;
  u64 t0___41 ;
  u64 t1___41 ;
  u64 t0___42 ;
  u64 t1___42 ;
  u64 t0___43 ;
  u64 t1___43 ;
  u64 t0___44 ;
  u64 t1___44 ;
  u64 t0___45 ;
  u64 t1___45 ;
  u64 t0___46 ;
  u64 t1___46 ;
  u64 t0___47 ;
  u64 t1___47 ;
  u64 t0___48 ;
  u64 t1___48 ;
  u64 t0___49 ;
  u64 t1___49 ;
  u64 t0___50 ;
  u64 t1___50 ;
  u64 t0___51 ;
  u64 t1___51 ;
  u64 t0___52 ;
  u64 t1___52 ;
  u64 t0___53 ;
  u64 t1___53 ;
  u64 t0___54 ;
  u64 t1___54 ;
  u64 t0___55 ;
  u64 t1___55 ;
  u64 t0___56 ;
  u64 t1___56 ;
  u64 t0___57 ;
  u64 t1___57 ;
  u64 t0___58 ;
  u64 t1___58 ;
  u64 t0___59 ;
  u64 t1___59 ;
  u64 t0___60 ;
  u64 t1___60 ;
  u64 t0___61 ;
  u64 t1___61 ;
  u64 t0___62 ;
  u64 t1___62 ;
  u64 t0___63 ;
  u64 t1___63 ;
  u64 t0___64 ;
  u64 t1___64 ;
  u64 t0___65 ;
  u64 t1___65 ;
  u64 t0___66 ;
  u64 t1___66 ;
  u64 t0___67 ;
  u64 t1___67 ;
  u64 t0___68 ;
  u64 t1___68 ;
  u64 t0___69 ;
  u64 t1___69 ;
  u64 t0___70 ;
  u64 t1___70 ;
  u64 t0___71 ;
  u64 t1___71 ;
  u64 t0___72 ;
  u64 t1___72 ;
  u64 t0___73 ;
  u64 t1___73 ;
  u64 t0___74 ;
  u64 t1___74 ;
  u64 t0___75 ;
  u64 t1___75 ;
  u64 t0___76 ;
  u64 t1___76 ;
  u64 t0___77 ;
  u64 t1___77 ;
  u64 t0___78 ;
  u64 t1___78 ;
  u64 tmp ;
  u64 tmp___0 ;
  u64 tmp___1 ;
  u64 tmp___2 ;
  u64 tmp___3 ;
  u64 tmp___4 ;
  u64 tmp___5 ;
  u64 tmp___6 ;
  {
  {
  words = (u64 const *)buffer;
  endp = words + len / sizeof(u64 );
  a = ctx->state[0];
  b = ctx->state[1];
  c = ctx->state[2];
  d = ctx->state[3];
  e = ctx->state[4];
  f = ctx->state[5];
  g = ctx->state[6];
  h = ctx->state[7];
  ctx->total[0] += len;
  }
  if (ctx->total[0] < len) {
    {
    {
    (ctx->total[1]) ++;
    }
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )words < (unsigned long )endp)) {
      {
      goto while_break;
      }
    }
    {
    t = 0;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! (t < 16)) {
        {
        goto while_break___0;
        }
      }
      {
      x[t] = (u64 )((((*words << 56) | ((*words & 65280UL) << 40)) | (((*words & 16711680UL) << 24) | ((*words & 4278190080UL) << 8))) | ((((*words >> 8) & 4278190080UL) | ((*words >> 24) & 16711680UL)) | (((*words >> 40) & 65280UL) | (*words >> 56))));
      words ++;
      t ++;
      }
    }
    while_break___0: ;
    }
    {
    while (1) {
      while_continue___1: ;
      if (! 1) {
        {
        goto while_break___1;
        }
      }
      {
      t0 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      t1 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[0] + (u64 const )x[0])));
      d += t1;
      h = t0 + t1;
      }
      goto while_break___1;
    }
    while_break___1: ;
    }
    {
    while (1) {
      while_continue___2: ;
      if (! 1) {
        {
        goto while_break___2;
        }
      }
      {
      t0___0 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      t1___0 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[1] + (u64 const )x[1])));
      c += t1___0;
      g = t0___0 + t1___0;
      }
      goto while_break___2;
    }
    while_break___2: ;
    }
    {
    while (1) {
      while_continue___3: ;
      if (! 1) {
        {
        goto while_break___3;
        }
      }
      {
      t0___1 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      t1___1 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[2] + (u64 const )x[2])));
      b += t1___1;
      f = t0___1 + t1___1;
      }
      goto while_break___3;
    }
    while_break___3: ;
    }
    {
    while (1) {
      while_continue___4: ;
      if (! 1) {
        {
        goto while_break___4;
        }
      }
      {
      t0___2 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      t1___2 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[3] + (u64 const )x[3])));
      a += t1___2;
      e = t0___2 + t1___2;
      }
      goto while_break___4;
    }
    while_break___4: ;
    }
    {
    while (1) {
      while_continue___5: ;
      if (! 1) {
        {
        goto while_break___5;
        }
      }
      {
      t0___3 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      t1___3 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[4] + (u64 const )x[4])));
      h += t1___3;
      d = t0___3 + t1___3;
      }
      goto while_break___5;
    }
    while_break___5: ;
    }
    {
    while (1) {
      while_continue___6: ;
      if (! 1) {
        {
        goto while_break___6;
        }
      }
      {
      t0___4 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      t1___4 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[5] + (u64 const )x[5])));
      g += t1___4;
      c = t0___4 + t1___4;
      }
      goto while_break___6;
    }
    while_break___6: ;
    }
    {
    while (1) {
      while_continue___7: ;
      if (! 1) {
        {
        goto while_break___7;
        }
      }
      {
      t0___5 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      t1___5 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[6] + (u64 const )x[6])));
      f += t1___5;
      b = t0___5 + t1___5;
      }
      goto while_break___7;
    }
    while_break___7: ;
    }
    {
    while (1) {
      while_continue___8: ;
      if (! 1) {
        {
        goto while_break___8;
        }
      }
      {
      t0___6 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      t1___6 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[7] + (u64 const )x[7])));
      e += t1___6;
      a = t0___6 + t1___6;
      }
      goto while_break___8;
    }
    while_break___8: ;
    }
    {
    while (1) {
      while_continue___9: ;
      if (! 1) {
        {
        goto while_break___9;
        }
      }
      {
      t0___7 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      t1___7 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[8] + (u64 const )x[8])));
      d += t1___7;
      h = t0___7 + t1___7;
      }
      goto while_break___9;
    }
    while_break___9: ;
    }
    {
    while (1) {
      while_continue___10: ;
      if (! 1) {
        {
        goto while_break___10;
        }
      }
      {
      t0___8 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      t1___8 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[9] + (u64 const )x[9])));
      c += t1___8;
      g = t0___8 + t1___8;
      }
      goto while_break___10;
    }
    while_break___10: ;
    }
    {
    while (1) {
      while_continue___11: ;
      if (! 1) {
        {
        goto while_break___11;
        }
      }
      {
      t0___9 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      t1___9 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[10] + (u64 const )x[10])));
      b += t1___9;
      f = t0___9 + t1___9;
      }
      goto while_break___11;
    }
    while_break___11: ;
    }
    {
    while (1) {
      while_continue___12: ;
      if (! 1) {
        {
        goto while_break___12;
        }
      }
      {
      t0___10 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      t1___10 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[11] + (u64 const )x[11])));
      a += t1___10;
      e = t0___10 + t1___10;
      }
      goto while_break___12;
    }
    while_break___12: ;
    }
    {
    while (1) {
      while_continue___13: ;
      if (! 1) {
        {
        goto while_break___13;
        }
      }
      {
      t0___11 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      t1___11 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[12] + (u64 const )x[12])));
      h += t1___11;
      d = t0___11 + t1___11;
      }
      goto while_break___13;
    }
    while_break___13: ;
    }
    {
    while (1) {
      while_continue___14: ;
      if (! 1) {
        {
        goto while_break___14;
        }
      }
      {
      t0___12 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      t1___12 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[13] + (u64 const )x[13])));
      g += t1___12;
      c = t0___12 + t1___12;
      }
      goto while_break___14;
    }
    while_break___14: ;
    }
    {
    while (1) {
      while_continue___15: ;
      if (! 1) {
        {
        goto while_break___15;
        }
      }
      {
      t0___13 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      t1___13 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[14] + (u64 const )x[14])));
      f += t1___13;
      b = t0___13 + t1___13;
      }
      goto while_break___15;
    }
    while_break___15: ;
    }
    {
    while (1) {
      while_continue___16: ;
      if (! 1) {
        {
        goto while_break___16;
        }
      }
      {
      t0___14 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      t1___14 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[15] + (u64 const )x[15])));
      e += t1___14;
      a = t0___14 + t1___14;
      }
      goto while_break___16;
    }
    while_break___16: ;
    }
    {
    while (1) {
      while_continue___17: ;
      if (! 1) {
        {
        goto while_break___17;
        }
      }
      {
      t0___15 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
      t1___15 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[16] + (u64 const )x[0])));
      d += t1___15;
      h = t0___15 + t1___15;
      }
      goto while_break___17;
    }
    while_break___17: ;
    }
    {
    while (1) {
      while_continue___18: ;
      if (! 1) {
        {
        goto while_break___18;
        }
      }
      {
      t0___16 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
      t1___16 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[17] + (u64 const )x[1])));
      c += t1___16;
      g = t0___16 + t1___16;
      }
      goto while_break___18;
    }
    while_break___18: ;
    }
    {
    while (1) {
      while_continue___19: ;
      if (! 1) {
        {
        goto while_break___19;
        }
      }
      {
      t0___17 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
      t1___17 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[18] + (u64 const )x[2])));
      b += t1___17;
      f = t0___17 + t1___17;
      }
      goto while_break___19;
    }
    while_break___19: ;
    }
    {
    while (1) {
      while_continue___20: ;
      if (! 1) {
        {
        goto while_break___20;
        }
      }
      {
      t0___18 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
      t1___18 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[19] + (u64 const )x[3])));
      a += t1___18;
      e = t0___18 + t1___18;
      }
      goto while_break___20;
    }
    while_break___20: ;
    }
    {
    while (1) {
      while_continue___21: ;
      if (! 1) {
        {
        goto while_break___21;
        }
      }
      {
      t0___19 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
      t1___19 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[20] + (u64 const )x[4])));
      h += t1___19;
      d = t0___19 + t1___19;
      }
      goto while_break___21;
    }
    while_break___21: ;
    }
    {
    while (1) {
      while_continue___22: ;
      if (! 1) {
        {
        goto while_break___22;
        }
      }
      {
      t0___20 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
      t1___20 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[21] + (u64 const )x[5])));
      g += t1___20;
      c = t0___20 + t1___20;
      }
      goto while_break___22;
    }
    while_break___22: ;
    }
    {
    while (1) {
      while_continue___23: ;
      if (! 1) {
        {
        goto while_break___23;
        }
      }
      {
      t0___21 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
      t1___21 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[22] + (u64 const )x[6])));
      f += t1___21;
      b = t0___21 + t1___21;
      }
      goto while_break___23;
    }
    while_break___23: ;
    }
    {
    while (1) {
      while_continue___24: ;
      if (! 1) {
        {
        goto while_break___24;
        }
      }
      {
      t0___22 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
      t1___22 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[23] + (u64 const )x[7])));
      e += t1___22;
      a = t0___22 + t1___22;
      }
      goto while_break___24;
    }
    while_break___24: ;
    }
    {
    while (1) {
      while_continue___25: ;
      if (! 1) {
        {
        goto while_break___25;
        }
      }
      {
      t0___23 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
      t1___23 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[24] + (u64 const )x[8])));
      d += t1___23;
      h = t0___23 + t1___23;
      }
      goto while_break___25;
    }
    while_break___25: ;
    }
    {
    while (1) {
      while_continue___26: ;
      if (! 1) {
        {
        goto while_break___26;
        }
      }
      {
      t0___24 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
      t1___24 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[25] + (u64 const )x[9])));
      c += t1___24;
      g = t0___24 + t1___24;
      }
      goto while_break___26;
    }
    while_break___26: ;
    }
    {
    while (1) {
      while_continue___27: ;
      if (! 1) {
        {
        goto while_break___27;
        }
      }
      {
      t0___25 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
      t1___25 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[26] + (u64 const )x[10])));
      b += t1___25;
      f = t0___25 + t1___25;
      }
      goto while_break___27;
    }
    while_break___27: ;
    }
    {
    while (1) {
      while_continue___28: ;
      if (! 1) {
        {
        goto while_break___28;
        }
      }
      {
      t0___26 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
      t1___26 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[27] + (u64 const )x[11])));
      a += t1___26;
      e = t0___26 + t1___26;
      }
      goto while_break___28;
    }
    while_break___28: ;
    }
    {
    while (1) {
      while_continue___29: ;
      if (! 1) {
        {
        goto while_break___29;
        }
      }
      {
      t0___27 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
      t1___27 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[28] + (u64 const )x[12])));
      h += t1___27;
      d = t0___27 + t1___27;
      }
      goto while_break___29;
    }
    while_break___29: ;
    }
    {
    while (1) {
      while_continue___30: ;
      if (! 1) {
        {
        goto while_break___30;
        }
      }
      {
      t0___28 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
      t1___28 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[29] + (u64 const )x[13])));
      g += t1___28;
      c = t0___28 + t1___28;
      }
      goto while_break___30;
    }
    while_break___30: ;
    }
    {
    while (1) {
      while_continue___31: ;
      if (! 1) {
        {
        goto while_break___31;
        }
      }
      {
      t0___29 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
      t1___29 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[30] + (u64 const )x[14])));
      f += t1___29;
      b = t0___29 + t1___29;
      }
      goto while_break___31;
    }
    while_break___31: ;
    }
    {
    while (1) {
      while_continue___32: ;
      if (! 1) {
        {
        goto while_break___32;
        }
      }
      {
      t0___30 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
      t1___30 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[31] + (u64 const )x[15])));
      e += t1___30;
      a = t0___30 + t1___30;
      }
      goto while_break___32;
    }
    while_break___32: ;
    }
    {
    while (1) {
      while_continue___33: ;
      if (! 1) {
        {
        goto while_break___33;
        }
      }
      {
      t0___31 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
      t1___31 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[32] + (u64 const )x[0])));
      d += t1___31;
      h = t0___31 + t1___31;
      }
      goto while_break___33;
    }
    while_break___33: ;
    }
    {
    while (1) {
      while_continue___34: ;
      if (! 1) {
        {
        goto while_break___34;
        }
      }
      {
      t0___32 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
      t1___32 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[33] + (u64 const )x[1])));
      c += t1___32;
      g = t0___32 + t1___32;
      }
      goto while_break___34;
    }
    while_break___34: ;
    }
    {
    while (1) {
      while_continue___35: ;
      if (! 1) {
        {
        goto while_break___35;
        }
      }
      {
      t0___33 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
      t1___33 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[34] + (u64 const )x[2])));
      b += t1___33;
      f = t0___33 + t1___33;
      }
      goto while_break___35;
    }
    while_break___35: ;
    }
    {
    while (1) {
      while_continue___36: ;
      if (! 1) {
        {
        goto while_break___36;
        }
      }
      {
      t0___34 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
      t1___34 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[35] + (u64 const )x[3])));
      a += t1___34;
      e = t0___34 + t1___34;
      }
      goto while_break___36;
    }
    while_break___36: ;
    }
    {
    while (1) {
      while_continue___37: ;
      if (! 1) {
        {
        goto while_break___37;
        }
      }
      {
      t0___35 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
      t1___35 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[36] + (u64 const )x[4])));
      h += t1___35;
      d = t0___35 + t1___35;
      }
      goto while_break___37;
    }
    while_break___37: ;
    }
    {
    while (1) {
      while_continue___38: ;
      if (! 1) {
        {
        goto while_break___38;
        }
      }
      {
      t0___36 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
      t1___36 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[37] + (u64 const )x[5])));
      g += t1___36;
      c = t0___36 + t1___36;
      }
      goto while_break___38;
    }
    while_break___38: ;
    }
    {
    while (1) {
      while_continue___39: ;
      if (! 1) {
        {
        goto while_break___39;
        }
      }
      {
      t0___37 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
      t1___37 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[38] + (u64 const )x[6])));
      f += t1___37;
      b = t0___37 + t1___37;
      }
      goto while_break___39;
    }
    while_break___39: ;
    }
    {
    while (1) {
      while_continue___40: ;
      if (! 1) {
        {
        goto while_break___40;
        }
      }
      {
      t0___38 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
      t1___38 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[39] + (u64 const )x[7])));
      e += t1___38;
      a = t0___38 + t1___38;
      }
      goto while_break___40;
    }
    while_break___40: ;
    }
    {
    while (1) {
      while_continue___41: ;
      if (! 1) {
        {
        goto while_break___41;
        }
      }
      {
      t0___39 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
      t1___39 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[40] + (u64 const )x[8])));
      d += t1___39;
      h = t0___39 + t1___39;
      }
      goto while_break___41;
    }
    while_break___41: ;
    }
    {
    while (1) {
      while_continue___42: ;
      if (! 1) {
        {
        goto while_break___42;
        }
      }
      {
      t0___40 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
      t1___40 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[41] + (u64 const )x[9])));
      c += t1___40;
      g = t0___40 + t1___40;
      }
      goto while_break___42;
    }
    while_break___42: ;
    }
    {
    while (1) {
      while_continue___43: ;
      if (! 1) {
        {
        goto while_break___43;
        }
      }
      {
      t0___41 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
      t1___41 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[42] + (u64 const )x[10])));
      b += t1___41;
      f = t0___41 + t1___41;
      }
      goto while_break___43;
    }
    while_break___43: ;
    }
    {
    while (1) {
      while_continue___44: ;
      if (! 1) {
        {
        goto while_break___44;
        }
      }
      {
      t0___42 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
      t1___42 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[43] + (u64 const )x[11])));
      a += t1___42;
      e = t0___42 + t1___42;
      }
      goto while_break___44;
    }
    while_break___44: ;
    }
    {
    while (1) {
      while_continue___45: ;
      if (! 1) {
        {
        goto while_break___45;
        }
      }
      {
      t0___43 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
      t1___43 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[44] + (u64 const )x[12])));
      h += t1___43;
      d = t0___43 + t1___43;
      }
      goto while_break___45;
    }
    while_break___45: ;
    }
    {
    while (1) {
      while_continue___46: ;
      if (! 1) {
        {
        goto while_break___46;
        }
      }
      {
      t0___44 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
      t1___44 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[45] + (u64 const )x[13])));
      g += t1___44;
      c = t0___44 + t1___44;
      }
      goto while_break___46;
    }
    while_break___46: ;
    }
    {
    while (1) {
      while_continue___47: ;
      if (! 1) {
        {
        goto while_break___47;
        }
      }
      {
      t0___45 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
      t1___45 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[46] + (u64 const )x[14])));
      f += t1___45;
      b = t0___45 + t1___45;
      }
      goto while_break___47;
    }
    while_break___47: ;
    }
    {
    while (1) {
      while_continue___48: ;
      if (! 1) {
        {
        goto while_break___48;
        }
      }
      {
      t0___46 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
      t1___46 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[47] + (u64 const )x[15])));
      e += t1___46;
      a = t0___46 + t1___46;
      }
      goto while_break___48;
    }
    while_break___48: ;
    }
    {
    while (1) {
      while_continue___49: ;
      if (! 1) {
        {
        goto while_break___49;
        }
      }
      {
      t0___47 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
      t1___47 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[48] + (u64 const )x[0])));
      d += t1___47;
      h = t0___47 + t1___47;
      }
      goto while_break___49;
    }
    while_break___49: ;
    }
    {
    while (1) {
      while_continue___50: ;
      if (! 1) {
        {
        goto while_break___50;
        }
      }
      {
      t0___48 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
      t1___48 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[49] + (u64 const )x[1])));
      c += t1___48;
      g = t0___48 + t1___48;
      }
      goto while_break___50;
    }
    while_break___50: ;
    }
    {
    while (1) {
      while_continue___51: ;
      if (! 1) {
        {
        goto while_break___51;
        }
      }
      {
      t0___49 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
      t1___49 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[50] + (u64 const )x[2])));
      b += t1___49;
      f = t0___49 + t1___49;
      }
      goto while_break___51;
    }
    while_break___51: ;
    }
    {
    while (1) {
      while_continue___52: ;
      if (! 1) {
        {
        goto while_break___52;
        }
      }
      {
      t0___50 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
      t1___50 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[51] + (u64 const )x[3])));
      a += t1___50;
      e = t0___50 + t1___50;
      }
      goto while_break___52;
    }
    while_break___52: ;
    }
    {
    while (1) {
      while_continue___53: ;
      if (! 1) {
        {
        goto while_break___53;
        }
      }
      {
      t0___51 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
      t1___51 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[52] + (u64 const )x[4])));
      h += t1___51;
      d = t0___51 + t1___51;
      }
      goto while_break___53;
    }
    while_break___53: ;
    }
    {
    while (1) {
      while_continue___54: ;
      if (! 1) {
        {
        goto while_break___54;
        }
      }
      {
      t0___52 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
      t1___52 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[53] + (u64 const )x[5])));
      g += t1___52;
      c = t0___52 + t1___52;
      }
      goto while_break___54;
    }
    while_break___54: ;
    }
    {
    while (1) {
      while_continue___55: ;
      if (! 1) {
        {
        goto while_break___55;
        }
      }
      {
      t0___53 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
      t1___53 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[54] + (u64 const )x[6])));
      f += t1___53;
      b = t0___53 + t1___53;
      }
      goto while_break___55;
    }
    while_break___55: ;
    }
    {
    while (1) {
      while_continue___56: ;
      if (! 1) {
        {
        goto while_break___56;
        }
      }
      {
      t0___54 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
      t1___54 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[55] + (u64 const )x[7])));
      e += t1___54;
      a = t0___54 + t1___54;
      }
      goto while_break___56;
    }
    while_break___56: ;
    }
    {
    while (1) {
      while_continue___57: ;
      if (! 1) {
        {
        goto while_break___57;
        }
      }
      {
      t0___55 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
      t1___55 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[56] + (u64 const )x[8])));
      d += t1___55;
      h = t0___55 + t1___55;
      }
      goto while_break___57;
    }
    while_break___57: ;
    }
    {
    while (1) {
      while_continue___58: ;
      if (! 1) {
        {
        goto while_break___58;
        }
      }
      {
      t0___56 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
      t1___56 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[57] + (u64 const )x[9])));
      c += t1___56;
      g = t0___56 + t1___56;
      }
      goto while_break___58;
    }
    while_break___58: ;
    }
    {
    while (1) {
      while_continue___59: ;
      if (! 1) {
        {
        goto while_break___59;
        }
      }
      {
      t0___57 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
      t1___57 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[58] + (u64 const )x[10])));
      b += t1___57;
      f = t0___57 + t1___57;
      }
      goto while_break___59;
    }
    while_break___59: ;
    }
    {
    while (1) {
      while_continue___60: ;
      if (! 1) {
        {
        goto while_break___60;
        }
      }
      {
      t0___58 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
      t1___58 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[59] + (u64 const )x[11])));
      a += t1___58;
      e = t0___58 + t1___58;
      }
      goto while_break___60;
    }
    while_break___60: ;
    }
    {
    while (1) {
      while_continue___61: ;
      if (! 1) {
        {
        goto while_break___61;
        }
      }
      {
      t0___59 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
      t1___59 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[60] + (u64 const )x[12])));
      h += t1___59;
      d = t0___59 + t1___59;
      }
      goto while_break___61;
    }
    while_break___61: ;
    }
    {
    while (1) {
      while_continue___62: ;
      if (! 1) {
        {
        goto while_break___62;
        }
      }
      {
      t0___60 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
      t1___60 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[61] + (u64 const )x[13])));
      g += t1___60;
      c = t0___60 + t1___60;
      }
      goto while_break___62;
    }
    while_break___62: ;
    }
    {
    while (1) {
      while_continue___63: ;
      if (! 1) {
        {
        goto while_break___63;
        }
      }
      {
      t0___61 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
      t1___61 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[62] + (u64 const )x[14])));
      f += t1___61;
      b = t0___61 + t1___61;
      }
      goto while_break___63;
    }
    while_break___63: ;
    }
    {
    while (1) {
      while_continue___64: ;
      if (! 1) {
        {
        goto while_break___64;
        }
      }
      {
      t0___62 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
      t1___62 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[63] + (u64 const )x[15])));
      e += t1___62;
      a = t0___62 + t1___62;
      }
      goto while_break___64;
    }
    while_break___64: ;
    }
    {
    while (1) {
      while_continue___65: ;
      if (! 1) {
        {
        goto while_break___65;
        }
      }
      {
      t0___63 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
      t1___63 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[64] + (u64 const )x[0])));
      d += t1___63;
      h = t0___63 + t1___63;
      }
      goto while_break___65;
    }
    while_break___65: ;
    }
    {
    while (1) {
      while_continue___66: ;
      if (! 1) {
        {
        goto while_break___66;
        }
      }
      {
      t0___64 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
      t1___64 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[65] + (u64 const )x[1])));
      c += t1___64;
      g = t0___64 + t1___64;
      }
      goto while_break___66;
    }
    while_break___66: ;
    }
    {
    while (1) {
      while_continue___67: ;
      if (! 1) {
        {
        goto while_break___67;
        }
      }
      {
      t0___65 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
      t1___65 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[66] + (u64 const )x[2])));
      b += t1___65;
      f = t0___65 + t1___65;
      }
      goto while_break___67;
    }
    while_break___67: ;
    }
    {
    while (1) {
      while_continue___68: ;
      if (! 1) {
        {
        goto while_break___68;
        }
      }
      {
      t0___66 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
      t1___66 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[67] + (u64 const )x[3])));
      a += t1___66;
      e = t0___66 + t1___66;
      }
      goto while_break___68;
    }
    while_break___68: ;
    }
    {
    while (1) {
      while_continue___69: ;
      if (! 1) {
        {
        goto while_break___69;
        }
      }
      {
      t0___67 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
      t1___67 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[68] + (u64 const )x[4])));
      h += t1___67;
      d = t0___67 + t1___67;
      }
      goto while_break___69;
    }
    while_break___69: ;
    }
    {
    while (1) {
      while_continue___70: ;
      if (! 1) {
        {
        goto while_break___70;
        }
      }
      {
      t0___68 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
      t1___68 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[69] + (u64 const )x[5])));
      g += t1___68;
      c = t0___68 + t1___68;
      }
      goto while_break___70;
    }
    while_break___70: ;
    }
    {
    while (1) {
      while_continue___71: ;
      if (! 1) {
        {
        goto while_break___71;
        }
      }
      {
      t0___69 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
      t1___69 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[70] + (u64 const )x[6])));
      f += t1___69;
      b = t0___69 + t1___69;
      }
      goto while_break___71;
    }
    while_break___71: ;
    }
    {
    while (1) {
      while_continue___72: ;
      if (! 1) {
        {
        goto while_break___72;
        }
      }
      {
      t0___70 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
      t1___70 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[71] + (u64 const )x[7])));
      e += t1___70;
      a = t0___70 + t1___70;
      }
      goto while_break___72;
    }
    while_break___72: ;
    }
    {
    while (1) {
      while_continue___73: ;
      if (! 1) {
        {
        goto while_break___73;
        }
      }
      {
      t0___71 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
      t1___71 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[72] + (u64 const )x[8])));
      d += t1___71;
      h = t0___71 + t1___71;
      }
      goto while_break___73;
    }
    while_break___73: ;
    }
    {
    while (1) {
      while_continue___74: ;
      if (! 1) {
        {
        goto while_break___74;
        }
      }
      {
      t0___72 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
      t1___72 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[73] + (u64 const )x[9])));
      c += t1___72;
      g = t0___72 + t1___72;
      }
      goto while_break___74;
    }
    while_break___74: ;
    }
    {
    while (1) {
      while_continue___75: ;
      if (! 1) {
        {
        goto while_break___75;
        }
      }
      {
      t0___73 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
      t1___73 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[74] + (u64 const )x[10])));
      b += t1___73;
      f = t0___73 + t1___73;
      }
      goto while_break___75;
    }
    while_break___75: ;
    }
    {
    while (1) {
      while_continue___76: ;
      if (! 1) {
        {
        goto while_break___76;
        }
      }
      {
      t0___74 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
      t1___74 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[75] + (u64 const )x[11])));
      a += t1___74;
      e = t0___74 + t1___74;
      }
      goto while_break___76;
    }
    while_break___76: ;
    }
    {
    while (1) {
      while_continue___77: ;
      if (! 1) {
        {
        goto while_break___77;
        }
      }
      {
      t0___75 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
      t1___75 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[76] + (u64 const )x[12])));
      h += t1___75;
      d = t0___75 + t1___75;
      }
      goto while_break___77;
    }
    while_break___77: ;
    }
    {
    while (1) {
      while_continue___78: ;
      if (! 1) {
        {
        goto while_break___78;
        }
      }
      {
      t0___76 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
      t1___76 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[77] + (u64 const )x[13])));
      g += t1___76;
      c = t0___76 + t1___76;
      }
      goto while_break___78;
    }
    while_break___78: ;
    }
    {
    while (1) {
      while_continue___79: ;
      if (! 1) {
        {
        goto while_break___79;
        }
      }
      {
      t0___77 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
      t1___77 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[78] + (u64 const )x[14])));
      f += t1___77;
      b = t0___77 + t1___77;
      }
      goto while_break___79;
    }
    while_break___79: ;
    }
    {
    while (1) {
      while_continue___80: ;
      if (! 1) {
        {
        goto while_break___80;
        }
      }
      {
      t0___78 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
      t1___78 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[79] + (u64 const )x[15])));
      e += t1___78;
      a = t0___78 + t1___78;
      }
      goto while_break___80;
    }
    while_break___80: ;
    }
    {
    tmp = ctx->state[0] + a;
    ctx->state[0] = tmp;
    a = tmp;
    tmp___0 = ctx->state[1] + b;
    ctx->state[1] = tmp___0;
    b = tmp___0;
    tmp___1 = ctx->state[2] + c;
    ctx->state[2] = tmp___1;
    c = tmp___1;
    tmp___2 = ctx->state[3] + d;
    ctx->state[3] = tmp___2;
    d = tmp___2;
    tmp___3 = ctx->state[4] + e;
    ctx->state[4] = tmp___3;
    e = tmp___3;
    tmp___4 = ctx->state[5] + f;
    ctx->state[5] = tmp___4;
    f = tmp___4;
    tmp___5 = ctx->state[6] + g;
    ctx->state[6] = tmp___5;
    g = tmp___5;
    tmp___6 = ctx->state[7] + h;
    ctx->state[7] = tmp___6;
    h = tmp___6;
    }
  }
  while_break: ;
  }
  return;
}
}
__inline static _Bool is_zero_or_power_of_two(uintmax_t i )
{
  {
  return ((_Bool )((i & (i - 1UL)) == 0UL));
}
}
void cycle_check_init(struct cycle_check_state *state )
{
  {
  {
  state->chdir_counter = (uintmax_t )0;
  state->magic = 9827862;
  }
  return;
}
}
_Bool cycle_check(struct cycle_check_state *state , struct stat const *sb )
{
  _Bool tmp ;
  {
  if (! (state->magic == 9827862)) {
    {
    {
    __assert_fail((char const *)"state->magic == 9827862", (char const *)"cycle-check.c",
                  60U, (char const *)"cycle_check");
    }
    }
  }
  if (state->chdir_counter) {
    {
    if (sb->st_ino == (__ino_t )((__ino_t const )state->dev_ino.st_ino)) {
      {
      if (sb->st_dev == (__dev_t )((__dev_t const )state->dev_ino.st_dev)) {
        {
        return ((_Bool)1);
        }
      }
      }
    }
    }
  }
  {
  (state->chdir_counter) ++;
  tmp = is_zero_or_power_of_two(state->chdir_counter);
  }
  if (tmp) {
    {
    if (state->chdir_counter == 0UL) {
      {
      return ((_Bool)1);
      }
    }
    {
    state->dev_ino.st_dev = (dev_t )sb->st_dev;
    state->dev_ino.st_ino = (ino_t )sb->st_ino;
    }
    }
  }
  return ((_Bool)0);
}
}
static size_t di_ent_hash(void const *x , size_t table_size )
{
  struct di_ent const *p ;
  dev_t dev ;
  size_t h ;
  unsigned int i ;
  unsigned int n_words ;
  {
  {
  p = (struct di_ent const *)x;
  dev = (dev_t )p->dev;
  h = dev;
  n_words = (unsigned int )(sizeof(dev) / sizeof(h) + (unsigned long )(sizeof(dev) % sizeof(h) != 0UL));
  i = 1U;
  }
  {
  while (1) {
    while_continue: ;
    if (! (i < n_words)) {
      {
      goto while_break;
      }
    }
    {
    h ^= dev >> (8UL * sizeof(h)) * (unsigned long )i;
    i ++;
    }
  }
  while_break: ;
  }
  return (h % table_size);
}
}
static _Bool di_ent_compare(void const *x , void const *y )
{
  struct di_ent const *a ;
  struct di_ent const *b ;
  {
  {
  a = (struct di_ent const *)x;
  b = (struct di_ent const *)y;
  }
  return ((_Bool )(a->dev == b->dev));
}
}
static void di_ent_free(void *v )
{
  struct di_ent *a ;
  {
  {
  a = (struct di_ent *)v;
  hash_free(a->ino_set);
  free((void *)a);
  }
  return;
}
}
struct di_set *di_set_alloc(void)
{
  struct di_set *dis ;
  void *tmp ;
  {
  {
  tmp = malloc(sizeof(*dis));
  dis = (struct di_set *)tmp;
  }
  if (dis) {
    {
    {
    dis->dev_map = hash_initialize((size_t )11, (Hash_tuning const *)((void *)0),
                                   & di_ent_hash, & di_ent_compare, & di_ent_free);
    }
    if (! dis->dev_map) {
      {
      {
      free((void *)dis);
      }
      return ((struct di_set *)((void *)0));
      }
    }
    {
    dis->ino_map = (struct ino_map *)((void *)0);
    dis->probe = (struct di_ent *)((void *)0);
    }
    }
  }
  return (dis);
}
}
void ( __attribute__((__nonnull__(1))) di_set_free)(struct di_set *dis )
{
  {
  {
  hash_free(dis->dev_map);
  free((void *)dis->ino_map);
  free((void *)dis->probe);
  free((void *)dis);
  }
  return;
}
}
static size_t di_ino_hash(void const *i , size_t table_size )
{
  {
  return ((hashint )i % table_size);
}
}
static struct hash_table *map_device(struct di_set *dis , dev_t dev )
{
  struct di_ent *ent ;
  struct di_ent *probe ;
  void *tmp ;
  void *tmp___0 ;
  {
  {
  probe = dis->probe;
  }
  if (probe) {
    {
    if (probe->dev == dev) {
      {
      return (probe->ino_set);
      }
    }
    }
  } else {
    {
    {
    tmp = malloc(sizeof(*probe));
    probe = (struct di_ent *)tmp;
    dis->probe = probe;
    }
    if (! probe) {
      {
      return ((struct hash_table *)((void *)0));
      }
    }
    }
  }
  {
  probe->dev = dev;
  tmp___0 = hash_insert(dis->dev_map, (void const *)probe);
  ent = (struct di_ent *)tmp___0;
  }
  if (! ent) {
    {
    return ((struct hash_table *)((void *)0));
    }
  }
  if ((unsigned long )ent != (unsigned long )probe) {
    {
    {
    probe->ino_set = ent->ino_set;
    }
    }
  } else {
    {
    {
    dis->probe = (struct di_ent *)((void *)0);
    probe->ino_set = hash_initialize((size_t )1021, (Hash_tuning const *)((void *)0),
                                     & di_ino_hash, (_Bool (*)(void const * , void const * ))((void *)0),
                                     (void (*)(void * ))((void *)0));
    }
    }
  }
  return (probe->ino_set);
}
}
static hashint map_inode_number(struct di_set *dis , ino_t ino )
{
  size_t tmp ;
  {
  if (0UL < ino) {
    {
    if (ino < 9223372036854775807UL) {
      {
      return (ino);
      }
    }
    }
  }
  if (! dis->ino_map) {
    {
    {
    dis->ino_map = ino_map_alloc(9223372036854775807UL);
    }
    if (! dis->ino_map) {
      {
      return ((size_t )-1);
      }
    }
    }
  }
  {
  tmp = ino_map_insert(dis->ino_map, ino);
  }
  return (tmp);
}
}
int ( __attribute__((__nonnull__(1))) di_set_insert)(struct di_set *dis , dev_t dev ,
                                                     ino_t ino )
{
  hashint i ;
  struct hash_table *ino_set ;
  struct hash_table *tmp ;
  int tmp___0 ;
  {
  {
  tmp = map_device(dis, dev);
  ino_set = tmp;
  }
  if (! ino_set) {
    {
    return (-1);
    }
  }
  {
  i = map_inode_number(dis, ino);
  }
  if (i == 0xffffffffffffffffUL) {
    {
    return (-1);
    }
  }
  {
  tmp___0 = hash_insert0(ino_set, (void const *)i, (void const **)((void *)0));
  }
  return (tmp___0);
}
}
int ( __attribute__((__nonnull__(1))) di_set_lookup)(struct di_set *dis , dev_t dev ,
                                                     ino_t ino )
{
  hashint i ;
  struct hash_table *ino_set ;
  struct hash_table *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  {
  {
  tmp = map_device(dis, dev);
  ino_set = tmp;
  }
  if (! ino_set) {
    {
    return (-1);
    }
  }
  {
  i = map_inode_number(dis, ino);
  }
  if (i == 0xffffffffffffffffUL) {
    {
    return (-1);
    }
  }
  {
  tmp___0 = hash_lookup((Hash_table const *)ino_set, (void const *)i);
  }
  if (tmp___0) {
    {
    {
    tmp___1 = 1;
    }
    }
  } else {
    {
    {
    tmp___1 = 0;
    }
    }
  }
  return (tmp___1);
}
}
DIR *opendir_safer(char const *name )
{
  DIR *dp ;
  DIR *tmp ;
  int fd ;
  int tmp___0 ;
  DIR *newdp ;
  int e ;
  int f ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  {
  {
  tmp = opendir(name);
  dp = tmp;
  }
  if (dp) {
    {
    {
    tmp___0 = dirfd(dp);
    fd = tmp___0;
    }
    if (0 <= fd) {
      {
      if (fd <= 2) {
        {
        {
        tmp___1 = dup_safer(fd);
        f = tmp___1;
        }
        if (f < 0) {
          {
          {
          tmp___2 = __errno_location();
          e = *tmp___2;
          newdp = (DIR *)((void *)0);
          }
          }
        } else {
          {
          {
          newdp = fdopendir(f);
          tmp___3 = __errno_location();
          e = *tmp___3;
          }
          if (! newdp) {
            {
            {
            close(f);
            }
            }
          }
          }
        }
        {
        closedir(dp);
        tmp___4 = __errno_location();
        *tmp___4 = e;
        dp = newdp;
        }
        }
      }
      }
    }
    }
  }
  return (dp);
}
}
char *dir_name(char const *file )
{
  char *result ;
  char *tmp ;
  {
  {
  tmp = mdir_name(file);
  result = tmp;
  }
  if (! result) {
    {
    {
    xalloc_die();
    }
    }
  }
  return (result);
}
}
char *base_name(char const *name )
{
  char const *base ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;
  {
  {
  tmp = last_component(name);
  base = (char const *)tmp;
  }
  if (! *base) {
    {
    {
    tmp___0 = base_len(name);
    tmp___1 = xstrndup(name, tmp___0);
    }
    return (tmp___1);
    }
  }
  {
  length = base_len(base);
  }
  if ((int const )*(base + length) == 47) {
    {
    {
    length ++;
    }
    }
  }
  {
  tmp___3 = xstrndup(base, length);
  }
  return (tmp___3);
}
}
size_t dir_len(char const *file )
{
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  {
  {
  prefix_length = (size_t )0;
  }
  if (prefix_length != 0UL) {
    {
    {
    tmp___0 = 0;
    }
    }
  } else {
    {
    if ((int const )*(file + 0) == 47) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    {
    tmp___0 = tmp;
    }
    }
  }
  {
  prefix_length += (size_t )tmp___0;
  tmp___1 = last_component(file);
  length = (size_t )(tmp___1 - (char *)file);
  }
  {
  while (1) {
    while_continue: ;
    if (! (prefix_length < length)) {
      {
      goto while_break;
      }
    }
    if (! ((int const )*(file + (length - 1UL)) == 47)) {
      {
      goto while_break;
      }
    }
    {
    length --;
    }
  }
  while_break: ;
  }
  return (length);
}
}
char *mdir_name(char const *file )
{
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;
  {
  {
  tmp = dir_len(file);
  length = tmp;
  }
  if (length == 0UL) {
    {
    {
    tmp___0 = 1;
    }
    }
  } else {
    {
    {
    tmp___0 = 0;
    }
    }
  }
  {
  append_dot = (_Bool )tmp___0;
  tmp___1 = malloc((length + (size_t )append_dot) + 1UL);
  dir = (char *)tmp___1;
  }
  if (! dir) {
    {
    return ((char *)((void *)0));
    }
  }
  {
  memcpy((void *)((void * __restrict )dir), (void const *)((void const * __restrict )file),
         length);
  }
  if (append_dot) {
    {
    {
    tmp___2 = length;
    length ++;
    *(dir + tmp___2) = (char )'.';
    }
    }
  }
  {
  *(dir + length) = (char )'\000';
  }
  return (dir);
}
}
char *last_component(char const *name )
{
  char const *base ;
  char const *p ;
  _Bool saw_slash ;
  {
  {
  base = name + 0;
  saw_slash = (_Bool)0;
  { if(!(saw_slash == (_Bool)0)) { reach_error(); abort(); } };
  }
  {
  while (1) {
    while_continue: ;
    if (! ((int const )*base == 47)) {
      {
      goto while_break;
      }
    }
    {
    base ++;
    }
  }
  while_break: ;
  }
  {
  p = base;
  }
  {
  while (1) {
    while_continue___0: ;
    if (! *p) {
      {
      goto while_break___0;
      }
    }
    if ((int const )*p == 47) {
      {
      {
      saw_slash = (_Bool)1;
      }
      }
    } else {
      {
      if (saw_slash) {
        {
        { if(!(saw_slash != (_Bool)0)) { reach_error(); abort(); } };
        {
        base = p;
        saw_slash = (_Bool)0;
        }
        }
      }
      }
    }
    {
    p ++;
    }
  }
  while_break___0: ;
  }
  return ((char *)base);
}
}
size_t base_len(char const *name )
{
  size_t len ;
  size_t prefix_len ;
  {
  {
  prefix_len = (size_t )0;
  { if(!(prefix_len == 0UL)) { reach_error(); abort(); } };
  len = strlen(name);
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (1UL < len) {
      {
      { if(!(len != 0UL)) { reach_error(); abort(); } };
      if (! ((int const )*(name + (len - 1UL)) == 47)) {
        {
        goto while_break;
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
    goto __Cont;
    __Cont:
    {
    len --;
    }
  }
  while_break: ;
  }
  return (len);
}
}
_Bool strip_trailing_slashes(char *file )
{
  char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;
  {
  {
  tmp = last_component((char const *)file);
  base = tmp;
  }
  if (! *base) {
    {
    {
    base = file;
    }
    }
  }
  {
  tmp___0 = base_len((char const *)base);
  base_lim = base + tmp___0;
  had_slash = (_Bool )((int )*base_lim != 0);
  *base_lim = (char )'\000';
  }
  return (had_slash);
}
}
int dtoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , double x )
{
  char format[sizeof("%-+ 0*.*Lg")] ;
  double abs_x ;
  double tmp ;
  int prec ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int n ;
  int tmp___5 ;
  double tmp___6 ;
  {
  if (x < (double )0) {
    {
    {
    tmp = - x;
    }
    }
  } else {
    {
    {
    tmp = x;
    }
    }
  }
  {
  abs_x = tmp;
  p = format;
  tmp___0 = p;
  p ++;
  *tmp___0 = (char )'%';
  *p = (char )'-';
  p += (flags & 1) != 0;
  *p = (char )'+';
  p += (flags & 2) != 0;
  *p = (char )' ';
  p += (flags & 4) != 0;
  *p = (char )'0';
  p += (flags & 8) != 0;
  tmp___1 = p;
  p ++;
  *tmp___1 = (char )'*';
  tmp___2 = p;
  p ++;
  *tmp___2 = (char )'.';
  tmp___3 = p;
  p ++;
  *tmp___3 = (char )'*';
  *p = (char )'L';
  p += 0;
  tmp___4 = p;
  p ++;
  }
  if (flags & 16) {
    {
    {
    *tmp___4 = (char )'G';
    }
    }
  } else {
    {
    {
    *tmp___4 = (char )'g';
    }
    }
  }
  {
  *p = (char )'\000';
  }
  if (abs_x < (double )2.22507385850720138309e-308L) {
    {
    {
    prec = 1;
    }
    }
  } else {
    {
    {
    prec = 15;
    }
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___5 = snprintf((char *)((char * __restrict )buf___1), bufsize___0, (char const *)((char const * __restrict )(format)),
                       width, prec, x);
    n = tmp___5;
    }
    if (n < 0) {
      {
      return (n);
      }
    } else {
      {
      if (17 <= prec) {
        {
        return (n);
        }
      } else {
        {
        if ((size_t )n < bufsize___0) {
          {
          {
          tmp___6 = strtod((char const * __restrict )buf___1, (char ** __restrict )((void *)0));
          }
          if (tmp___6 == x) {
            {
            return (n);
            }
          }
          }
        }
        }
      }
      }
    }
    {
    prec ++;
    }
  }
  while_break: ;
  }
  return (0);
}
}
struct timespec dtotimespec(double sec )
{
  double min_representable ;
  double max_representable ;
  struct timespec r ;
  time_t s ;
  double frac ;
  long ns ;
  {
  {
  min_representable = (double )(~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L));
  max_representable = ((double )(((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L) * (double )1000000000 + (double )999999999) / (double )1000000000;
  }
  if (! (min_representable < sec)) {
    {
    {
    r.tv_sec = ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L);
    r.tv_nsec = 0L;
    }
    }
  } else {
    {
    if (! (sec < max_representable)) {
      {
      {
      r.tv_sec = ((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L;
      r.tv_nsec = 999999999L;
      }
      }
    } else {
      {
      {
      s = (time_t )sec;
      frac = (double )1000000000 * (sec - (double )s);
      ns = (long )frac;
      ns += (long )((double )ns < frac);
      s += ns / 1000000000L;
      ns %= 1000000000L;
      }
      if (ns < 0L) {
        {
        {
        s --;
        ns += 1000000000L;
        }
        }
      }
      {
      r.tv_sec = s;
      r.tv_nsec = ns;
      }
      }
    }
    }
  }
  return (r);
}
}
__inline extern int tolower(int __c ) __attribute__((__nothrow__)) ;
__inline extern int tolower(int __c )
{
  __int32_t const **tmp ;
  __int32_t tmp___0 ;
  {
  if (__c >= -128) {
    {
    if (__c < 256) {
      {
      {
      tmp = __ctype_tolower_loc();
      tmp___0 = (__int32_t )*(*tmp + __c);
      }
      }
    } else {
      {
      {
      tmp___0 = (__int32_t )((__int32_t const )__c);
      }
      }
    }
    }
  } else {
    {
    {
    tmp___0 = (__int32_t )((__int32_t const )__c);
    }
    }
  }
  return (tmp___0);
}
}
__inline extern int toupper(int __c ) __attribute__((__nothrow__)) ;
__inline extern int toupper(int __c )
{
  __int32_t const **tmp ;
  __int32_t tmp___0 ;
  {
  if (__c >= -128) {
    {
    if (__c < 256) {
      {
      {
      tmp = __ctype_toupper_loc();
      tmp___0 = (__int32_t )*(*tmp + __c);
      }
      }
    } else {
      {
      {
      tmp___0 = (__int32_t )((__int32_t const )__c);
      }
      }
    }
    }
  } else {
    {
    {
    tmp___0 = (__int32_t )((__int32_t const )__c);
    }
    }
  }
  return (tmp___0);
}
}
__inline extern wint_t btowc(int __c ) __attribute__((__nothrow__)) ;
__inline extern wint_t btowc(int __c )
{
  wint_t tmp ;
  {
  {
  tmp = __btowc_alias(__c);
  }
  return (tmp);
}
}
__inline extern int wctob(wint_t __wc ) __attribute__((__nothrow__)) ;
__inline extern int wctob(wint_t __wc )
{
  int tmp ;
  {
  {
  tmp = __wctob_alias(__wc);
  }
  return (tmp);
}
}
__inline extern size_t mbrlen(char const *__s , size_t __n , mbstate_t *__ps ) __attribute__((__nothrow__)) ;
__inline extern size_t mbrlen(char const *__s , size_t __n , mbstate_t *__ps )
{
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  {
  if ((unsigned long )__ps != (unsigned long )((void *)0)) {
    {
    {
    tmp = mbrtowc((wchar_t * __restrict )((void *)0), (char const * __restrict )__s,
                  __n, __ps);
    tmp___1 = tmp;
    }
    }
  } else {
    {
    {
    tmp___0 = __mbrlen((char const * __restrict )__s, __n, (mbstate_t * __restrict )((void *)0));
    tmp___1 = tmp___0;
    }
    }
  }
  return (tmp___1);
}
}
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wmemcpy)(wchar_t *__s1 ,
                                                                                       wchar_t const *__s2 ,
                                                                                       size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wmemcpy)(wchar_t *__s1 ,
                                                                                       wchar_t const *__s2 ,
                                                                                       size_t __n )
{
  unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__s1, 0);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__s1, 0);
    tmp___0 = __wmemcpy_chk((wchar_t * __restrict )__s1, (wchar_t const * __restrict )__s2,
                            __n, tmp / sizeof(wchar_t ));
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__s1, 0);
    }
    if (__n > tmp___3 / sizeof(wchar_t )) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__s1, 0);
      tmp___2 = __wmemcpy_chk_warn((wchar_t * __restrict )__s1, (wchar_t const * __restrict )__s2,
                                   __n, tmp___1 / sizeof(wchar_t ));
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __wmemcpy_alias((wchar_t * __restrict )__s1, (wchar_t const * __restrict )__s2,
                            __n);
  }
  return (tmp___5);
}
}
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wmemmove)(wchar_t *__s1 ,
                                                                                        wchar_t const *__s2 ,
                                                                                        size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wmemmove)(wchar_t *__s1 ,
                                                                                        wchar_t const *__s2 ,
                                                                                        size_t __n )
{
  unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__s1, 0);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__s1, 0);
    tmp___0 = __wmemmove_chk(__s1, __s2, __n, tmp / sizeof(wchar_t ));
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__s1, 0);
    }
    if (__n > tmp___3 / sizeof(wchar_t )) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__s1, 0);
      tmp___2 = __wmemmove_chk_warn(__s1, __s2, __n, tmp___1 / sizeof(wchar_t ));
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __wmemmove_alias(__s1, __s2, __n);
  }
  return (tmp___5);
}
}
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wmempcpy)(wchar_t *__s1 ,
                                                                                        wchar_t const *__s2 ,
                                                                                        size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wmempcpy)(wchar_t *__s1 ,
                                                                                        wchar_t const *__s2 ,
                                                                                        size_t __n )
{
  unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__s1, 0);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__s1, 0);
    tmp___0 = __wmempcpy_chk((wchar_t * __restrict )__s1, (wchar_t const * __restrict )__s2,
                             __n, tmp / sizeof(wchar_t ));
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__s1, 0);
    }
    if (__n > tmp___3 / sizeof(wchar_t )) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__s1, 0);
      tmp___2 = __wmempcpy_chk_warn((wchar_t * __restrict )__s1, (wchar_t const * __restrict )__s2,
                                    __n, tmp___1 / sizeof(wchar_t ));
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __wmempcpy_alias((wchar_t * __restrict )__s1, (wchar_t const * __restrict )__s2,
                             __n);
  }
  return (tmp___5);
}
}
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wmemset)(wchar_t *__s ,
                                                                                       wchar_t __c ,
                                                                                       size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wmemset)(wchar_t *__s ,
                                                                                       wchar_t __c ,
                                                                                       size_t __n )
{
  unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__s, 0);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__s, 0);
    tmp___0 = __wmemset_chk(__s, __c, __n, tmp / sizeof(wchar_t ));
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__s, 0);
    }
    if (__n > tmp___3 / sizeof(wchar_t )) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__s, 0);
      tmp___2 = __wmemset_chk_warn(__s, __c, __n, tmp___1 / sizeof(wchar_t ));
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __wmemset_alias(__s, __c, __n);
  }
  return (tmp___5);
}
}
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcscpy)(wchar_t *__dest ,
                                                                                      wchar_t const *__src ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcscpy)(wchar_t *__dest ,
                                                                                      wchar_t const *__src )
{
  unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  {
  {
  tmp___1 = __builtin_object_size((void *)__dest, 1);
  }
  if (tmp___1 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__dest, 1);
    tmp___0 = __wcscpy_chk((wchar_t * __restrict )__dest, (wchar_t const * __restrict )__src,
                           tmp / sizeof(wchar_t ));
    }
    return (tmp___0);
    }
  }
  {
  tmp___2 = __wcscpy_alias((wchar_t * __restrict )__dest, (wchar_t const * __restrict )__src);
  }
  return (tmp___2);
}
}
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcpcpy)(wchar_t *__dest ,
                                                                                      wchar_t const *__src ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcpcpy)(wchar_t *__dest ,
                                                                                      wchar_t const *__src )
{
  unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  {
  {
  tmp___1 = __builtin_object_size((void *)__dest, 1);
  }
  if (tmp___1 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__dest, 1);
    tmp___0 = __wcpcpy_chk((wchar_t * __restrict )__dest, (wchar_t const * __restrict )__src,
                           tmp / sizeof(wchar_t ));
    }
    return (tmp___0);
    }
  }
  {
  tmp___2 = __wcpcpy_alias((wchar_t * __restrict )__dest, (wchar_t const * __restrict )__src);
  }
  return (tmp___2);
}
}
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcsncpy)(wchar_t *__dest ,
                                                                                       wchar_t const *__src ,
                                                                                       size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcsncpy)(wchar_t *__dest ,
                                                                                       wchar_t const *__src ,
                                                                                       size_t __n )
{
  unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__dest, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__dest, 1);
    tmp___0 = __wcsncpy_chk((wchar_t * __restrict )__dest, (wchar_t const * __restrict )__src,
                            __n, tmp / sizeof(wchar_t ));
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__dest, 1);
    }
    if (__n > tmp___3 / sizeof(wchar_t )) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__dest, 1);
      tmp___2 = __wcsncpy_chk_warn((wchar_t * __restrict )__dest, (wchar_t const * __restrict )__src,
                                   __n, tmp___1 / sizeof(wchar_t ));
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __wcsncpy_alias((wchar_t * __restrict )__dest, (wchar_t const * __restrict )__src,
                            __n);
  }
  return (tmp___5);
}
}
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcpncpy)(wchar_t *__dest ,
                                                                                       wchar_t const *__src ,
                                                                                       size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcpncpy)(wchar_t *__dest ,
                                                                                       wchar_t const *__src ,
                                                                                       size_t __n )
{
  unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__dest, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__dest, 1);
    tmp___0 = __wcpncpy_chk((wchar_t * __restrict )__dest, (wchar_t const * __restrict )__src,
                            __n, tmp / sizeof(wchar_t ));
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__dest, 1);
    }
    if (__n > tmp___3 / sizeof(wchar_t )) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__dest, 1);
      tmp___2 = __wcpncpy_chk_warn((wchar_t * __restrict )__dest, (wchar_t const * __restrict )__src,
                                   __n, tmp___1 / sizeof(wchar_t ));
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __wcpncpy_alias((wchar_t * __restrict )__dest, (wchar_t const * __restrict )__src,
                            __n);
  }
  return (tmp___5);
}
}
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcscat)(wchar_t *__dest ,
                                                                                      wchar_t const *__src ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcscat)(wchar_t *__dest ,
                                                                                      wchar_t const *__src )
{
  unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  {
  {
  tmp___1 = __builtin_object_size((void *)__dest, 1);
  }
  if (tmp___1 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__dest, 1);
    tmp___0 = __wcscat_chk((wchar_t * __restrict )__dest, (wchar_t const * __restrict )__src,
                           tmp / sizeof(wchar_t ));
    }
    return (tmp___0);
    }
  }
  {
  tmp___2 = __wcscat_alias((wchar_t * __restrict )__dest, (wchar_t const * __restrict )__src);
  }
  return (tmp___2);
}
}
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcsncat)(wchar_t *__dest ,
                                                                                       wchar_t const *__src ,
                                                                                       size_t __n ) __attribute__((__nothrow__)) ;
__inline extern wchar_t *( __attribute__((__artificial__, __always_inline__)) wcsncat)(wchar_t *__dest ,
                                                                                       wchar_t const *__src ,
                                                                                       size_t __n )
{
  unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  {
  {
  tmp___1 = __builtin_object_size((void *)__dest, 1);
  }
  if (tmp___1 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__dest, 1);
    tmp___0 = __wcsncat_chk((wchar_t * __restrict )__dest, (wchar_t const * __restrict )__src,
                            __n, tmp / sizeof(wchar_t ));
    }
    return (tmp___0);
    }
  }
  {
  tmp___2 = __wcsncat_alias((wchar_t * __restrict )__dest, (wchar_t const * __restrict )__src,
                            __n);
  }
  return (tmp___2);
}
}

__inline extern int ( __attribute__((__artificial__, __always_inline__)) vswprintf)(wchar_t *__s ,
                                                                                    size_t __n ,
                                                                                    wchar_t const *__fmt ,
                                                                                    __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vswprintf)(wchar_t *__s ,
                                                                                    size_t __n ,
                                                                                    wchar_t const *__fmt ,
                                                                                    __gnuc_va_list __ap )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  {
  {
  tmp___1 = __builtin_object_size((void *)__s, 1);
  }
  if (tmp___1 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __vswprintf_chk((wchar_t * __restrict )__s, __n, 1, tmp / sizeof(wchar_t ),
                              (wchar_t const * __restrict )__fmt, __ap);
    }
    return (tmp___0);
    }
  } else {
    {
    {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __vswprintf_chk((wchar_t * __restrict )__s, __n, 1, tmp / sizeof(wchar_t ),
                              (wchar_t const * __restrict )__fmt, __ap);
    }
    return (tmp___0);
    }
  }
  {
  tmp___2 = __vswprintf_alias((wchar_t * __restrict )__s, __n, (wchar_t const * __restrict )__fmt,
                              __ap);
  }
  return (tmp___2);
}
}

__inline extern int ( __attribute__((__artificial__, __always_inline__)) vwprintf)(wchar_t const *__fmt ,
                                                                                   __gnuc_va_list __ap )
{
  int tmp ;
  {
  {
  tmp = __vwprintf_chk(1, (wchar_t const * __restrict )__fmt, __ap);
  }
  return (tmp);
}
}
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfwprintf)(__FILE *__stream ,
                                                                                    wchar_t const *__fmt ,
                                                                                    __gnuc_va_list __ap )
{
  int tmp ;
  {
  {
  tmp = __vfwprintf_chk((__FILE * __restrict )__stream, 1, (wchar_t const * __restrict )__fmt,
                        __ap);
  }
  return (tmp);
}
}
__inline extern wchar_t *( __attribute__((__warn_unused_result__, __artificial__,
__always_inline__)) fgetws)(wchar_t *__s , int __n , __FILE *__stream )
{
  unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__s, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __fgetws_chk((wchar_t * __restrict )__s, tmp / sizeof(wchar_t ), __n,
                           (__FILE * __restrict )__stream);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__s, 1);
    }
    if ((size_t )__n > tmp___3 / sizeof(wchar_t )) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__s, 1);
      tmp___2 = __fgetws_chk_warn((wchar_t * __restrict )__s, tmp___1 / sizeof(wchar_t ),
                                  __n, (__FILE * __restrict )__stream);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __fgetws_alias((wchar_t * __restrict )__s, __n, (__FILE * __restrict )__stream);
  }
  return (tmp___5);
}
}
__inline extern wchar_t *( __attribute__((__warn_unused_result__, __artificial__,
__always_inline__)) fgetws_unlocked)(wchar_t *__s , int __n , __FILE *__stream )
{
  unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__s, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __fgetws_unlocked_chk((wchar_t * __restrict )__s, tmp / sizeof(wchar_t ),
                                    __n, (__FILE * __restrict )__stream);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__s, 1);
    }
    if ((size_t )__n > tmp___3 / sizeof(wchar_t )) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__s, 1);
      tmp___2 = __fgetws_unlocked_chk_warn((wchar_t * __restrict )__s, tmp___1 / sizeof(wchar_t ),
                                           __n, (__FILE * __restrict )__stream);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __fgetws_unlocked_alias((wchar_t * __restrict )__s, __n, (__FILE * __restrict )__stream);
  }
  return (tmp___5);
}
}
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) wcrtomb)(char *__s ,
                                                                                                             wchar_t __wchar ,
                                                                                                             mbstate_t *__ps ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) wcrtomb)(char *__s ,
                                                                                                             wchar_t __wchar ,
                                                                                                             mbstate_t *__ps )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  size_t tmp___3 ;
  {
  {
  tmp___1 = __builtin_object_size((void *)__s, 1);
  }
  if (tmp___1 != 0xffffffffffffffffUL) {
    {
    {
    tmp___2 = __builtin_object_size((void *)__s, 1);
    }
    if (16UL > tmp___2) {
      {
      {
      tmp = __builtin_object_size((void *)__s, 1);
      tmp___0 = __wcrtomb_chk((char * __restrict )__s, __wchar, (mbstate_t * __restrict )__ps,
                              tmp);
      }
      return (tmp___0);
      }
    }
    }
  }
  {
  tmp___3 = __wcrtomb_alias((char * __restrict )__s, __wchar, (mbstate_t * __restrict )__ps);
  }
  return (tmp___3);
}
}
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) mbsrtowcs)(wchar_t *__dst ,
                                                                                       char const **__src ,
                                                                                       size_t __len ,
                                                                                       mbstate_t *__ps ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) mbsrtowcs)(wchar_t *__dst ,
                                                                                       char const **__src ,
                                                                                       size_t __len ,
                                                                                       mbstate_t *__ps )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __mbsrtowcs_chk((wchar_t * __restrict )__dst, (char const ** __restrict )__src,
                              __len, (mbstate_t * __restrict )__ps, tmp / sizeof(wchar_t ));
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    }
    if (__len > tmp___3 / sizeof(wchar_t )) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __mbsrtowcs_chk_warn((wchar_t * __restrict )__dst, (char const ** __restrict )__src,
                                     __len, (mbstate_t * __restrict )__ps, tmp___1 / sizeof(wchar_t ));
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __mbsrtowcs_alias((wchar_t * __restrict )__dst, (char const ** __restrict )__src,
                              __len, (mbstate_t * __restrict )__ps);
  }
  return (tmp___5);
}
}
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) wcsrtombs)(char *__dst ,
                                                                                       wchar_t const **__src ,
                                                                                       size_t __len ,
                                                                                       mbstate_t *__ps ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) wcsrtombs)(char *__dst ,
                                                                                       wchar_t const **__src ,
                                                                                       size_t __len ,
                                                                                       mbstate_t *__ps )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __wcsrtombs_chk((char * __restrict )__dst, (wchar_t const ** __restrict )__src,
                              __len, (mbstate_t * __restrict )__ps, tmp);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    }
    if (__len > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __wcsrtombs_chk_warn((char * __restrict )__dst, (wchar_t const ** __restrict )__src,
                                     __len, (mbstate_t * __restrict )__ps, tmp___1);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __wcsrtombs_alias((char * __restrict )__dst, (wchar_t const ** __restrict )__src,
                              __len, (mbstate_t * __restrict )__ps);
  }
  return (tmp___5);
}
}
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) mbsnrtowcs)(wchar_t *__dst ,
                                                                                        char const **__src ,
                                                                                        size_t __nmc ,
                                                                                        size_t __len ,
                                                                                        mbstate_t *__ps ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) mbsnrtowcs)(wchar_t *__dst ,
                                                                                        char const **__src ,
                                                                                        size_t __nmc ,
                                                                                        size_t __len ,
                                                                                        mbstate_t *__ps )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __mbsnrtowcs_chk((wchar_t * __restrict )__dst, (char const ** __restrict )__src,
                               __nmc, __len, (mbstate_t * __restrict )__ps, tmp / sizeof(wchar_t ));
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    }
    if (__len > tmp___3 / sizeof(wchar_t )) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __mbsnrtowcs_chk_warn((wchar_t * __restrict )__dst, (char const ** __restrict )__src,
                                      __nmc, __len, (mbstate_t * __restrict )__ps,
                                      tmp___1 / sizeof(wchar_t ));
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __mbsnrtowcs_alias((wchar_t * __restrict )__dst, (char const ** __restrict )__src,
                               __nmc, __len, (mbstate_t * __restrict )__ps);
  }
  return (tmp___5);
}
}
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) wcsnrtombs)(char *__dst ,
                                                                                        wchar_t const **__src ,
                                                                                        size_t __nwc ,
                                                                                        size_t __len ,
                                                                                        mbstate_t *__ps ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__artificial__, __always_inline__)) wcsnrtombs)(char *__dst ,
                                                                                        wchar_t const **__src ,
                                                                                        size_t __nwc ,
                                                                                        size_t __len ,
                                                                                        mbstate_t *__ps )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;
  {
  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  }
  if (tmp___4 != 0xffffffffffffffffUL) {
    {
    {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __wcsnrtombs_chk((char * __restrict )__dst, (wchar_t const ** __restrict )__src,
                               __nwc, __len, (mbstate_t * __restrict )__ps, tmp);
    }
    return (tmp___0);
    {
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    }
    if (__len > tmp___3) {
      {
      {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __wcsnrtombs_chk_warn((char * __restrict )__dst, (wchar_t const ** __restrict )__src,
                                      __nwc, __len, (mbstate_t * __restrict )__ps,
                                      tmp___1);
      }
      return (tmp___2);
      }
    }
    }
  }
  {
  tmp___5 = __wcsnrtombs_alias((char * __restrict )__dst, (wchar_t const ** __restrict )__src,
                               __nwc, __len, (mbstate_t * __restrict )__ps);
  }
  return (tmp___5);
}
}
__inline static _Bool is_basic(char c )
{
  {
  return ((_Bool )((is_basic_table[(int )((unsigned char )c) >> 5] >> ((int )((unsigned char )c) & 31)) & 1U));
}
}
__inline static void mbuiter_multi_next(struct mbuiter_multi *iter )
{
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  {
  if (iter->next_done) {
    {
    return;
    }
  }
  if (iter->in_shift) {
    {
    goto with_shift;
    }
  }
  {
  tmp___3 = is_basic((char )*(iter->cur.ptr));
  }
  if (tmp___3) {
    {
    {
    iter->cur.bytes = (size_t )1;
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
    iter->cur.wc_valid = (_Bool)1;
    }
    }
  } else {
    {
    {
    tmp = mbsinit((mbstate_t const *)(& iter->state));
    }
    if (! tmp) {
      {
      {
      __assert_fail((char const *)"mbsinit (&iter->state)", (char const *)"mbuiter.h",
                    142U, (char const *)"mbuiter_multi_next");
      }
      }
    }
    {
    iter->in_shift = (_Bool)1;
    }
    with_shift:
    {
    tmp___0 = __ctype_get_mb_cur_max();
    tmp___1 = strnlen1(iter->cur.ptr, tmp___0);
    iter->cur.bytes = mbrtowc((wchar_t * __restrict )(& iter->cur.wc), (char const * __restrict )iter->cur.ptr,
                              tmp___1, & iter->state);
    }
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
      {
      {
      iter->cur.bytes = (size_t )1;
      iter->cur.wc_valid = (_Bool)0;
      }
      }
    } else {
      {
      if (iter->cur.bytes == 0xfffffffffffffffeUL) {
        {
        {
        iter->cur.bytes = strlen(iter->cur.ptr);
        iter->cur.wc_valid = (_Bool)0;
        }
        }
      } else {
        {
        if (iter->cur.bytes == 0UL) {
          {
          {
          iter->cur.bytes = (size_t )1;
          }
          if (! ((int const )*(iter->cur.ptr) == 0)) {
            {
            {
            __assert_fail((char const *)"*iter->cur.ptr == \'\\0\'", (char const *)"mbuiter.h",
                          170U, (char const *)"mbuiter_multi_next");
            }
            }
          }
          if (! (iter->cur.wc == 0)) {
            {
            {
            __assert_fail((char const *)"iter->cur.wc == 0", (char const *)"mbuiter.h",
                          171U, (char const *)"mbuiter_multi_next");
            }
            }
          }
          }
        }
        {
        iter->cur.wc_valid = (_Bool)1;
        tmp___2 = mbsinit((mbstate_t const *)(& iter->state));
        }
        if (tmp___2) {
          {
          {
          iter->in_shift = (_Bool)0;
          }
          }
        }
        }
      }
      }
    }
    }
  }
  {
  iter->next_done = (_Bool)1;
  }
  return;
}
}
__inline static void *x2nrealloc(void *p , size_t *pn , size_t s )
{
  size_t n ;
  void *tmp ;
  {
  {
  n = *pn;
  }
  if (! p) {
    {
    if (! n) {
      {
      {
      n = 128UL / s;
      n += (size_t )(! n);
      }
      }
    }
    }
  } else {
    {
    if (0xaaaaaaaaaaaaaaaaUL / s <= n) {
      {
      {
      xalloc_die();
      }
      }
    }
    {
    n += (n + 1UL) / 2UL;
    }
    }
  }
  {
  *pn = n;
  tmp = xrealloc(p, n * s);
  }
  return (tmp);
}
}
_Bool fnmatch_pattern_has_wildcards(char const *str , int options )
{
  char const *cset ;
  size_t n ;
  unsigned long tmp___9 ;
  {
  {
  cset = (char const *)"\\?*[]";
  }
  if (options & (1 << 1)) {
    {
    {
    cset ++;
    }
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! *str) {
      {
      goto while_break;
      }
    }
    {
    tmp___9 = __builtin_strcspn(str, cset);
    n = tmp___9;
    }
    if ((int const )*(str + n) == 0) {
      {
      goto while_break;
      }
    } else {
      {
      if ((int const )*(str + n) == 92) {
        {
        {
        str += n + 1UL;
        }
        if (*str) {
          {
          {
          str ++;
          }
          }
        }
        }
      } else {
        {
        return ((_Bool)1);
        }
      }
      }
    }
  }
  while_break: ;
  }
  return ((_Bool)0);
}
}
static void unescape_pattern(char *str )
{
  int inset ;
  char *q ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  {
  {
  inset = 0;
  q = str;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (inset) {
      {
      if ((int )*q == 93) {
        {
        {
        inset = 0;
        }
        }
      }
      }
    } else {
      {
      if ((int )*q == 91) {
        {
        {
        inset = 1;
        }
        }
      } else {
        {
        if ((int )*q == 92) {
          {
          {
          q ++;
          }
          }
        }
        }
      }
      }
    }
    {
    tmp = str;
    str ++;
    tmp___1 = q;
    q ++;
    tmp___0 = *tmp___1;
    *tmp = tmp___0;
    }
    if (! tmp___0) {
      {
      goto while_break;
      }
    }
  }
  while_break: ;
  }
  return;
}
}
struct exclude *new_exclude(void)
{
  struct exclude *tmp ;
  void *tmp___0 ;
  {
  {
  tmp___0 = xzalloc(sizeof(*tmp));
  }
  return ((struct exclude *)tmp___0);
}
}
static size_t string_hasher(void const *data , size_t n_buckets )
{
  char const *p ;
  size_t tmp ;
  {
  {
  p = (char const *)data;
  tmp = hash_string(p, n_buckets);
  }
  return (tmp);
}
}
static size_t string_hasher_ci(void const *data , size_t n_buckets )
{
  char const *p ;
  mbui_iterator_t iter ;
  size_t value ;
  mbchar_t m ;
  wchar_t wc ;
  wint_t tmp ;
  int tmp___0 ;
  {
  {
  p = (char const *)data;
  value = (size_t )0;
  iter.cur.ptr = p;
  iter.in_shift = (_Bool)0;
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
  iter.next_done = (_Bool)0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    mbuiter_multi_next(& iter);
    }
    if (iter.cur.wc_valid) {
      {
      if (iter.cur.wc == 0) {
        {
        {
        tmp___0 = 0;
        }
        }
      } else {
        {
        {
        tmp___0 = 1;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___0 = 1;
      }
      }
    }
    if (! tmp___0) {
      {
      goto while_break;
      }
    }
    {
    m = iter.cur;
    }
    if (m.wc_valid) {
      {
      {
      tmp = towlower((wint_t )m.wc);
      wc = (wchar_t )tmp;
      }
      }
    } else {
      {
      {
      wc = (wchar_t )*(m.ptr);
      }
      }
    }
    {
    value = (value * 31UL + (size_t )wc) % n_buckets;
    iter.cur.ptr += iter.cur.bytes;
    iter.next_done = (_Bool)0;
    }
  }
  while_break: ;
  }
  return (value);
}
}
static _Bool string_compare(void const *data1 , void const *data2 )
{
  char const *p1 ;
  char const *p2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  {
  {
  p1 = (char const *)data1;
  p2 = (char const *)data2;
  }
  if (0) {
    {
    {
    __s1_len = __builtin_strlen(p1);
    __s2_len = __builtin_strlen(p2);
    }
    if (! ((size_t )((void const *)(p1 + 1)) - (size_t )((void const *)p1) == 1UL)) {
      {
      goto _L___0;
      }
    } else {
      {
      if (__s1_len >= 4UL) {
        {
        _L___0:
        if (! ((size_t )((void const *)(p2 + 1)) - (size_t )((void const *)p2) == 1UL)) {
          {
          {
          tmp___5 = 1;
          }
          }
        } else {
          {
          if (__s2_len >= 4UL) {
            {
            {
            tmp___5 = 1;
            }
            }
          } else {
            {
            {
            tmp___5 = 0;
            }
            }
          }
          }
        }
        }
      } else {
        {
        {
        tmp___5 = 0;
        }
        }
      }
      }
    }
    if (tmp___5) {
      {
      {
      tmp___0 = __builtin_strcmp(p1, p2);
      tmp___4 = tmp___0;
      }
      }
    } else {
      {
      {
      tmp___3 = __builtin_strcmp(p1, p2);
      tmp___4 = tmp___3;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___3 = __builtin_strcmp(p1, p2);
    tmp___4 = tmp___3;
    }
    }
  }
  return ((_Bool )(tmp___4 == 0));
}
}
static _Bool string_compare_ci(void const *data1 , void const *data2 )
{
  char const *p1 ;
  char const *p2 ;
  int tmp ;
  {
  {
  p1 = (char const *)data1;
  p2 = (char const *)data2;
  tmp = mbscasecmp(p1, p2);
  }
  return ((_Bool )(tmp == 0));
}
}
static void string_free(void *data )
{
  {
  {
  free(data);
  }
  return;
}
}
static struct exclude_segment *new_exclude_segment(struct exclude *ex , enum exclude_type type ,
                                                   int options )
{
  struct exclude_segment *sp ;
  void *tmp ;
  _Bool (*tmp___0)(void const *data1 , void const *data2 ) ;
  size_t (*tmp___1)(void const *data , size_t n_buckets ) ;
  {
  {
  tmp = xzalloc(sizeof(struct exclude_segment ));
  sp = (struct exclude_segment *)tmp;
  sp->type = type;
  sp->options = options;
  }
  {
  if ((int )type == 1) {
    {
    goto case_1;
    }
  }
  if ((int )type == 0) {
    {
    goto case_0;
    }
  }
  goto switch_break;
  case_1:
  goto switch_break;
  case_0:
  if (options & (1 << 4)) {
    {
    {
    tmp___0 = & string_compare_ci;
    }
    }
  } else {
    {
    {
    tmp___0 = & string_compare;
    }
    }
  }
  if (options & (1 << 4)) {
    {
    {
    tmp___1 = & string_hasher_ci;
    }
    }
  } else {
    {
    {
    tmp___1 = & string_hasher;
    }
    }
  }
  {
  sp->v.table = hash_initialize((size_t )0, (Hash_tuning const *)((void *)0), tmp___1,
                                tmp___0, & string_free);
  }
  goto switch_break;
  switch_break: ;
  }
  if (ex->tail) {
    {
    {
    (ex->tail)->next = sp;
    }
    }
  } else {
    {
    {
    ex->head = sp;
    }
    }
  }
  {
  ex->tail = sp;
  }
  return (sp);
}
}
static void free_exclude_segment(struct exclude_segment *seg )
{
  {
  {
  if ((int )seg->type == 1) {
    {
    goto case_1;
    }
  }
  if ((int )seg->type == 0) {
    {
    goto case_0;
    }
  }
  goto switch_break;
  case_1:
  {
  free((void *)seg->v.pat.exclude);
  }
  goto switch_break;
  case_0:
  {
  hash_free(seg->v.table);
  }
  goto switch_break;
  switch_break: ;
  }
  {
  free((void *)seg);
  }
  return;
}
}
void free_exclude(struct exclude *ex )
{
  struct exclude_segment *seg ;
  struct exclude_segment *next ;
  {
  {
  seg = ex->head;
  }
  {
  while (1) {
    while_continue: ;
    if (! seg) {
      {
      goto while_break;
      }
    }
    {
    next = seg->next;
    free_exclude_segment(seg);
    seg = next;
    }
  }
  while_break: ;
  }
  {
  free((void *)ex);
  }
  return;
}
}
static int fnmatch_no_wildcards(char const *pattern , char const *f , int options )
{
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t patlen ;
  size_t tmp___8 ;
  int r ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *fcopy ;
  char *tmp___22 ;
  char *p ;
  int r___0 ;
  char *tmp___23 ;
  char *tmp___25 ;
  {
  if (! (options & (1 << 3))) {
    {
    if (options & (1 << 4)) {
      {
      {
      tmp = mbscasecmp(pattern, f);
      tmp___7 = tmp;
      }
      }
    } else {
      {
      if (0) {
        {
        {
        __s1_len = __builtin_strlen(pattern);
        __s2_len = __builtin_strlen(f);
        }
        if (! ((size_t )((void const *)(pattern + 1)) - (size_t )((void const *)pattern) == 1UL)) {
          {
          goto _L___0;
          }
        } else {
          {
          if (__s1_len >= 4UL) {
            {
            _L___0:
            if (! ((size_t )((void const *)(f + 1)) - (size_t )((void const *)f) == 1UL)) {
              {
              {
              tmp___6 = 1;
              }
              }
            } else {
              {
              if (__s2_len >= 4UL) {
                {
                {
                tmp___6 = 1;
                }
                }
              } else {
                {
                {
                tmp___6 = 0;
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            tmp___6 = 0;
            }
            }
          }
          }
        }
        if (tmp___6) {
          {
          {
          tmp___1 = __builtin_strcmp(pattern, f);
          tmp___5 = tmp___1;
          }
          }
        } else {
          {
          {
          tmp___4 = __builtin_strcmp(pattern, f);
          tmp___5 = tmp___4;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___4 = __builtin_strcmp(pattern, f);
        tmp___5 = tmp___4;
        }
        }
      }
      {
      tmp___7 = tmp___5;
      }
      }
    }
    return (tmp___7);
    }
  } else {
    {
    if (! (options & (1 << 4))) {
      {
      {
      tmp___8 = strlen(pattern);
      patlen = tmp___8;
      }
      if (0) {
        {
        if (0) {
          {
          {
          __s1_len___0 = __builtin_strlen(pattern);
          __s2_len___0 = __builtin_strlen(f);
          }
          if (! ((size_t )((void const *)(pattern + 1)) - (size_t )((void const *)pattern) == 1UL)) {
            {
            goto _L___2;
            }
          } else {
            {
            if (__s1_len___0 >= 4UL) {
              {
              _L___2:
              if (! ((size_t )((void const *)(f + 1)) - (size_t )((void const *)f) == 1UL)) {
                {
                {
                tmp___17 = 1;
                }
                }
              } else {
                {
                if (__s2_len___0 >= 4UL) {
                  {
                  {
                  tmp___17 = 1;
                  }
                  }
                } else {
                  {
                  {
                  tmp___17 = 0;
                  }
                  }
                }
                }
              }
              }
            } else {
              {
              {
              tmp___17 = 0;
              }
              }
            }
            }
          }
          if (tmp___17) {
            {
            {
            tmp___12 = __builtin_strcmp(pattern, f);
            tmp___16 = tmp___12;
            }
            }
          } else {
            {
            {
            tmp___15 = __builtin_strcmp(pattern, f);
            tmp___16 = tmp___15;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___15 = __builtin_strcmp(pattern, f);
          tmp___16 = tmp___15;
          }
          }
        }
        {
        tmp___19 = tmp___16;
        }
        }
      } else {
        {
        {
        tmp___18 = strncmp(pattern, f, patlen);
        tmp___19 = tmp___18;
        }
        }
      }
      {
      r = tmp___19;
      }
      if (! r) {
        {
        {
        r = (int )*(f + patlen);
        }
        if (r == 47) {
          {
          {
          r = 0;
          }
          }
        }
        }
      }
      return (r);
      }
    } else {
      {
      {
      tmp___22 = xstrdup(f);
      fcopy = tmp___22;
      p = fcopy;
      }
      {
      while (1) {
        while_continue: ;
        if (! 1) {
          {
          goto while_break;
          }
        }
        {
        tmp___25 = __builtin_strchr(p, '/');
        p = tmp___25;
        }
        if (p) {
          {
          {
          *p = (char )'\000';
          }
          }
        }
        {
        r___0 = mbscasecmp(pattern, (char const *)fcopy);
        }
        if (! p) {
          {
          goto while_break;
          }
        } else {
          {
          if (r___0 <= 0) {
            {
            goto while_break;
            }
          }
          }
        }
        {
        tmp___23 = p;
        p ++;
        *tmp___23 = (char )'/';
        }
      }
      while_break: ;
      }
      {
      free((void *)fcopy);
      }
      return (r___0);
      }
    }
    }
  }
}
}
_Bool exclude_fnmatch(char const *pattern , char const *f , int options )
{
  int (*matcher)(char const * , char const * , int ) ;
  int (*tmp)(char const *__pattern , char const *__name , int __flags ) ;
  _Bool matched ;
  int tmp___0 ;
  char const *p ;
  int tmp___1 ;
  {
  if (options & (1 << 28)) {
    {
    {
    tmp = & fnmatch;
    }
    }
  } else {
    {
    {
    tmp = & fnmatch_no_wildcards;
    }
    }
  }
  {
  matcher = tmp;
  tmp___0 = (*matcher)(pattern, f, options);
  matched = (_Bool )(tmp___0 == 0);
  }
  if (! (options & (1 << 30))) {
    {
    {
    p = f;
    }
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      if (*p) {
        {
        if (! (! matched)) {
          {
          goto while_break;
          }
        }
        }
      } else {
        {
        goto while_break;
        }
      }
      if ((int const )*p == 47) {
        {
        if ((int const )*(p + 1) != 47) {
          {
          {
          tmp___1 = (*matcher)(pattern, p + 1, options);
          matched = (_Bool )(tmp___1 == 0);
          }
          }
        }
        }
      }
      {
      p ++;
      }
    }
    while_break: ;
    }
    }
  }
  return (matched);
}
}
static _Bool excluded_file_pattern_p(struct exclude_segment const *seg , char const *f )
{
  size_t exclude_count ;
  struct patopts const *exclude ;
  size_t i ;
  _Bool excluded ;
  char const *pattern ;
  int options ;
  _Bool tmp ;
  {
  {
  exclude_count = (size_t )seg->v.pat.exclude_count;
  exclude = (struct patopts const *)seg->v.pat.exclude;
  excluded = (_Bool )(! (! ((exclude + 0)->options & (int )((int const )(1 << 29)))));
  i = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! (i < exclude_count)) {
      {
      goto while_break;
      }
    }
    {
    pattern = (char const *)(exclude + i)->pattern;
    options = (int )(exclude + i)->options;
    tmp = exclude_fnmatch(pattern, f, options);
    }
    if (tmp) {
      {
      return ((_Bool )(! excluded));
      }
    }
    {
    i ++;
    }
  }
  while_break: ;
  }
  return (excluded);
}
}
static _Bool excluded_file_name_p(struct exclude_segment const *seg , char const *f ,
                                  char *buffer )
{
  int options ;
  _Bool excluded ;
  Hash_table *table___0 ;
  void *tmp ;
  char *p ;
  char *tmp___0 ;
  char *tmp___2 ;
  {
  {
  options = (int )seg->options;
  excluded = (_Bool )(! (! (options & (1 << 29))));
  table___0 = (Hash_table *)seg->v.table;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    strcpy((char *)((char * __restrict )buffer), (char const *)((char const * __restrict )f));
    }
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      {
      tmp = hash_lookup((Hash_table const *)table___0, (void const *)buffer);
      }
      if (tmp) {
        {
        return ((_Bool )(! excluded));
        }
      }
      if (options & (1 << 3)) {
        {
        {
        tmp___0 = strrchr((char const *)buffer, '/');
        p = tmp___0;
        }
        if (p) {
          {
          {
          *p = (char)0;
          }
          goto while_continue___0;
          }
        }
        }
      }
      goto while_break___0;
    }
    while_break___0: ;
    }
    if (! (options & (1 << 30))) {
      {
      {
      tmp___2 = __builtin_strchr((char *)f, '/');
      f = (char const *)tmp___2;
      }
      if (f) {
        {
        {
        f ++;
        }
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
    if (! f) {
      {
      goto while_break;
      }
    }
  }
  while_break: ;
  }
  return (excluded);
}
}
_Bool excluded_file_name(struct exclude const *ex , char const *f )
{
  struct exclude_segment *seg ;
  _Bool excluded ;
  char *filename ;
  _Bool rc ;
  size_t tmp ;
  void *tmp___0 ;
  {
  {
  filename = (char *)((void *)0);
  }
  if (! ex->head) {
    {
    return ((_Bool)0);
    }
  }
  {
  excluded = (_Bool )(! (! ((ex->head)->options & (1 << 29))));
  seg = (struct exclude_segment *)ex->head;
  }
  {
  while (1) {
    while_continue: ;
    if (! seg) {
      {
      goto while_break;
      }
    }
    {
    if ((int )seg->type == 1) {
      {
      goto case_1;
      }
    }
    if ((int )seg->type == 0) {
      {
      goto case_0;
      }
    }
    goto switch_default;
    case_1:
    {
    rc = excluded_file_pattern_p((struct exclude_segment const *)seg, f);
    }
    goto switch_break;
    case_0:
    if (! filename) {
      {
      {
      tmp = strlen(f);
      tmp___0 = xmalloc(tmp + 1UL);
      filename = (char *)tmp___0;
      }
      }
    }
    {
    rc = excluded_file_name_p((struct exclude_segment const *)seg, f, filename);
    }
    goto switch_break;
    switch_default:
    {
    abort();
    }
    switch_break: ;
    }
    if ((int )rc != (int )excluded) {
      {
      {
      excluded = rc;
      }
      goto while_break;
      }
    }
    {
    seg = seg->next;
    }
  }
  while_break: ;
  }
  {
  free((void *)filename);
  }
  return (excluded);
}
}
void add_exclude(struct exclude *ex , char const *pattern , int options )
{
  struct exclude_segment *seg ;
  struct exclude_pattern *pat ;
  struct patopts *patopts ;
  void *tmp ;
  size_t tmp___0 ;
  char *str ;
  char *p ;
  void *tmp___1 ;
  _Bool tmp___2 ;
  {
  if (options & (1 << 28)) {
    {
    {
    tmp___2 = fnmatch_pattern_has_wildcards(pattern, options);
    }
    if (tmp___2) {
      {
      if (ex->tail) {
        {
        if ((unsigned int )(ex->tail)->type == 1U) {
          {
          if (((ex->tail)->options & (1 << 29)) == (options & (1 << 29))) {
            {
            {
            seg = ex->tail;
            }
            }
          } else {
            {
            {
            seg = new_exclude_segment(ex, (enum exclude_type )1, options);
            }
            }
          }
          }
        } else {
          {
          {
          seg = new_exclude_segment(ex, (enum exclude_type )1, options);
          }
          }
        }
        }
      } else {
        {
        {
        seg = new_exclude_segment(ex, (enum exclude_type )1, options);
        }
        }
      }
      {
      pat = & seg->v.pat;
      }
      if (pat->exclude_count == pat->exclude_alloc) {
        {
        {
        tmp = x2nrealloc((void *)pat->exclude, & pat->exclude_alloc, sizeof(*(pat->exclude)));
        pat->exclude = (struct patopts *)tmp;
        }
        }
      }
      {
      tmp___0 = pat->exclude_count;
      (pat->exclude_count) ++;
      patopts = pat->exclude + tmp___0;
      patopts->pattern = pattern;
      patopts->options = options;
      }
      }
    } else {
      {
      goto _L;
      }
    }
    }
  } else {
    {
    _L:
    if (ex->tail) {
      {
      if ((unsigned int )(ex->tail)->type == 0U) {
        {
        if (((ex->tail)->options & ((((1 << 29) | (1 << 30)) | (1 << 3)) | (1 << 4))) == (options & ((((1 << 29) | (1 << 30)) | (1 << 3)) | (1 << 4)))) {
          {
          {
          seg = ex->tail;
          }
          }
        } else {
          {
          {
          seg = new_exclude_segment(ex, (enum exclude_type )0, options);
          }
          }
        }
        }
      } else {
        {
        {
        seg = new_exclude_segment(ex, (enum exclude_type )0, options);
        }
        }
      }
      }
    } else {
      {
      {
      seg = new_exclude_segment(ex, (enum exclude_type )0, options);
      }
      }
    }
    {
    str = xstrdup(pattern);
    }
    if (options & (1 << 28)) {
      {
      {
      unescape_pattern(str);
      }
      }
    }
    {
    tmp___1 = hash_insert(seg->v.table, (void const *)str);
    p = (char *)tmp___1;
    }
    if ((unsigned long )p != (unsigned long )str) {
      {
      {
      free((void *)str);
      }
      }
    }
    }
  }
  return;
}
}
int add_exclude_file(void (*add_func)(struct exclude * , char const * , int ) ,
                     struct exclude *ex , char const *file_name___1 , int options ,
                     char line_end )
{
  _Bool use_stdin ;
  int tmp ;
  FILE *in ;
  char *buf___1 ;
  char *p ;
  char const *pattern ;
  char const *lim ;
  size_t buf_alloc ;
  size_t buf_count ;
  int c ;
  int e ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  char *pattern_end ;
  unsigned short const **tmp___8 ;
  unsigned short const **tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  {
  if ((int const )*(file_name___1 + 0) == 45) {
    {
    if (! *(file_name___1 + 1)) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  {
  use_stdin = (_Bool )tmp;
  buf___1 = (char *)((void *)0);
  buf_alloc = (size_t )0;
  buf_count = (size_t )0;
  e = 0;
  }
  if (use_stdin) {
    {
    {
    in = stdin;
    }
    }
  } else {
    {
    {
    in = fopen((char const * __restrict )file_name___1, (char const * __restrict )"r");
    }
    if (! in) {
      {
      return (-1);
      }
    }
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    c = getc_unlocked(in);
    }
    if (! (c != -1)) {
      {
      goto while_break;
      }
    }
    if (buf_count == buf_alloc) {
      {
      {
      tmp___0 = x2realloc((void *)buf___1, & buf_alloc);
      buf___1 = (char *)tmp___0;
      }
      }
    }
    {
    tmp___1 = buf_count;
    buf_count ++;
    *(buf___1 + tmp___1) = (char )c;
    }
  }
  while_break: ;
  }
  {
  tmp___3 = ferror_unlocked(in);
  }
  if (tmp___3) {
    {
    {
    tmp___2 = __errno_location();
    e = *tmp___2;
    }
    }
  }
  if (! use_stdin) {
    {
    {
    tmp___5 = rpl_fclose(in);
    }
    if (tmp___5 != 0) {
      {
      {
      tmp___4 = __errno_location();
      e = *tmp___4;
      }
      }
    }
    }
  }
  {
  tmp___6 = xrealloc((void *)buf___1, buf_count + 1UL);
  buf___1 = (char *)tmp___6;
  *(buf___1 + buf_count) = line_end;
  }
  if (buf_count == 0UL) {
    {
    {
    tmp___7 = 0;
    }
    }
  } else {
    {
    if ((int )*(buf___1 + (buf_count - 1UL)) == (int )line_end) {
      {
      {
      tmp___7 = 0;
      }
      }
    } else {
      {
      {
      tmp___7 = 1;
      }
      }
    }
    }
  }
  {
  lim = (char const *)((buf___1 + buf_count) + tmp___7);
  pattern = (char const *)buf___1;
  p = buf___1;
  }
  {
  while (1) {
    while_continue___0: ;
    if (! ((unsigned long )p < (unsigned long )lim)) {
      {
      goto while_break___0;
      }
    }
    if ((int )*p == (int )line_end) {
      {
      {
      pattern_end = p;
      tmp___9 = __ctype_b_loc();
      }
      if ((int const )*(*tmp___9 + (int )((unsigned char )line_end)) & 8192) {
        {
        {
        while (1) {
          while_continue___1: ;
          if (! 1) {
            {
            goto while_break___1;
            }
          }
          if ((unsigned long )pattern_end == (unsigned long )pattern) {
            {
            goto next_pattern;
            }
          } else {
            {
            {
            tmp___8 = __ctype_b_loc();
            }
            if (! ((int const )*(*tmp___8 + (int )((unsigned char )*(pattern_end + -1))) & 8192)) {
              {
              goto while_break___1;
              }
            }
            }
          }
          {
          pattern_end --;
          }
        }
        while_break___1: ;
        }
        }
      }
      {
      *pattern_end = (char )'\000';
      (*add_func)(ex, pattern, options);
      }
      next_pattern:
      {
      pattern = (char const *)(p + 1);
      }
      }
    }
    {
    p ++;
    }
  }
  while_break___0: ;
  }
  {
  tmp___10 = __errno_location();
  *tmp___10 = e;
  }
  if (e) {
    {
    {
    tmp___11 = -1;
    }
    }
  } else {
    {
    {
    tmp___11 = 0;
    }
    }
  }
  return (tmp___11);
}
}
void fdadvise(int fd , off_t offset , off_t len , fadvice_t advice )
{
  int __x ;
  int tmp ;
  {
  {
  tmp = posix_fadvise(fd, offset, len, (int )advice);
  __x = tmp;
  }
  return;
}
}
void fadvise(FILE *fp , fadvice_t advice )
{
  int tmp ;
  {
  if (fp) {
    {
    {
    tmp = fileno(fp);
    fdadvise(tmp, (off_t )0, (off_t )0, advice);
    }
    }
  }
  return;
}
}
int creat_safer(char const *file , mode_t mode )
{
  int tmp ;
  int tmp___0 ;
  {
  {
  tmp = creat(file, mode);
  tmp___0 = fd_safer(tmp);
  }
  return (tmp___0);
}
}
int open_safer(char const *file , int flags , ...)
{
  mode_t mode ;
  va_list ap ;
  int tmp ;
  int tmp___0 ;
  mode_t tmp___1 ;
  {
  {
  mode = (mode_t )0;
  }
  if (flags & 64) {
    {
    {
    __builtin_va_start(ap, flags);
    tmp___1 = __builtin_va_arg(ap, mode_t );
    mode = tmp___1;
    __builtin_va_end(ap);
    }
    }
  }
  {
  tmp = open(file, flags, mode);
  tmp___0 = fd_safer(tmp);
  }
  return (tmp___0);
}
}
int fd_safer_flag(int fd , int flag )
{
  int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;
  {
  if (0 <= fd) {
    {
    if (fd <= 2) {
      {
      {
      tmp = dup_safer_flag(fd, flag);
      f = tmp;
      tmp___0 = __errno_location();
      e = *tmp___0;
      close(fd);
      tmp___1 = __errno_location();
      *tmp___1 = e;
      fd = f;
      }
      }
    }
    }
  }
  return (fd);
}
}
int dup_safer_flag(int fd , int flag )
{
  int tmp ;
  int tmp___0 ;
  {
  if (flag & 524288) {
    {
    {
    tmp = 1030;
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  {
  tmp___0 = rpl_fcntl(fd, tmp, 3);
  }
  return (tmp___0);
}
}
int fdutimensat(int fd , int dir , char const *file , struct timespec const *ts ,
                int atflag )
{
  int result ;
  int *tmp ;
  int *tmp___0 ;
  {
  {
  result = 1;
  }
  if (0 <= fd) {
    {
    {
    result = rpl_futimens(fd, ts);
    }
    }
  }
  if (file) {
    {
    if (fd < 0) {
      {
      {
      result = rpl_utimensat(dir, file, ts, atflag);
      }
      }
    } else {
      {
      if (result == -1) {
        {
        {
        tmp = __errno_location();
        }
        if (*tmp == 38) {
          {
          {
          result = rpl_utimensat(dir, file, ts, atflag);
          }
          }
        }
        }
      }
      }
    }
    }
  }
  if (result == 1) {
    {
    {
    tmp___0 = __errno_location();
    *tmp___0 = 9;
    result = -1;
    }
    }
  }
  return (result);
}
}
void ( __attribute__((__nonnull__(2,3))) record_file)(Hash_table *ht___0 , char const *file ,
                                                      struct stat const *stats )
{
  struct F_triple *ent ;
  void *tmp ;
  struct F_triple *ent_from_table ;
  void *tmp___0 ;
  {
  if ((unsigned long )ht___0 == (unsigned long )((void *)0)) {
    {
    return;
    }
  }
  {
  tmp = xmalloc(sizeof(*ent));
  ent = (struct F_triple *)tmp;
  ent->name = xstrdup(file);
  ent->st_ino = (ino_t )stats->st_ino;
  ent->st_dev = (dev_t )stats->st_dev;
  tmp___0 = hash_insert(ht___0, (void const *)ent);
  ent_from_table = (struct F_triple *)tmp___0;
  }
  if ((unsigned long )ent_from_table == (unsigned long )((void *)0)) {
    {
    {
    xalloc_die();
    }
    }
  }
  if ((unsigned long )ent_from_table != (unsigned long )ent) {
    {
    {
    triple_free((void *)ent);
    }
    }
  }
  return;
}
}
_Bool seen_file(Hash_table const *ht___0 , char const *file , struct stat const *stats )
{
  struct F_triple new_ent ;
  void *tmp ;
  int tmp___0 ;
  {
  if ((unsigned long )ht___0 == (unsigned long )((void *)0)) {
    {
    return ((_Bool)0);
    }
  }
  {
  new_ent.name = (char *)file;
  new_ent.st_ino = (ino_t )stats->st_ino;
  new_ent.st_dev = (dev_t )stats->st_dev;
  tmp = hash_lookup(ht___0, (void const *)(& new_ent));
  }
  if (tmp) {
    {
    {
    tmp___0 = 1;
    }
    }
  } else {
    {
    {
    tmp___0 = 0;
    }
    }
  }
  return ((_Bool )tmp___0);
}
}
char const *file_type(struct stat const *st )
{
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___12 ;
  {
  if ((st->st_mode & 61440U) == 32768U) {
    {
    if (st->st_size == 0L) {
      {
      {
      tmp = dcgettext((char const *)((void *)0), (char const *)"regular empty file",
                      5);
      tmp___1 = tmp;
      }
      }
    } else {
      {
      {
      tmp___0 = dcgettext((char const *)((void *)0), (char const *)"regular file",
                          5);
      tmp___1 = tmp___0;
      }
      }
    }
    return ((char const *)tmp___1);
    }
  }
  if ((st->st_mode & 61440U) == 16384U) {
    {
    {
    tmp___2 = dcgettext((char const *)((void *)0), (char const *)"directory",
                        5);
    }
    return ((char const *)tmp___2);
    }
  }
  if ((st->st_mode & 61440U) == 24576U) {
    {
    {
    tmp___3 = dcgettext((char const *)((void *)0), (char const *)"block special file",
                        5);
    }
    return ((char const *)tmp___3);
    }
  }
  if ((st->st_mode & 61440U) == 8192U) {
    {
    {
    tmp___4 = dcgettext((char const *)((void *)0), (char const *)"character special file",
                        5);
    }
    return ((char const *)tmp___4);
    }
  }
  if ((st->st_mode & 61440U) == 4096U) {
    {
    {
    tmp___5 = dcgettext((char const *)((void *)0), (char const *)"fifo", 5);
    }
    return ((char const *)tmp___5);
    }
  }
  if ((st->st_mode & 61440U) == 40960U) {
    {
    {
    tmp___6 = dcgettext((char const *)((void *)0), (char const *)"symbolic link",
                        5);
    }
    return ((char const *)tmp___6);
    }
  }
  if ((st->st_mode & 61440U) == 49152U) {
    {
    {
    tmp___7 = dcgettext((char const *)((void *)0), (char const *)"socket", 5);
    }
    return ((char const *)tmp___7);
    }
  }
  if (st->st_mode - st->st_mode) {
    {
    {
    tmp___8 = dcgettext((char const *)((void *)0), (char const *)"message queue",
                        5);
    }
    return ((char const *)tmp___8);
    }
  }
  if (st->st_mode - st->st_mode) {
    {
    {
    tmp___9 = dcgettext((char const *)((void *)0), (char const *)"semaphore",
                        5);
    }
    return ((char const *)tmp___9);
    }
  }
  if (st->st_mode - st->st_mode) {
    {
    {
    tmp___10 = dcgettext((char const *)((void *)0), (char const *)"shared memory object",
                         5);
    }
    return ((char const *)tmp___10);
    }
  }
  {
  tmp___12 = dcgettext((char const *)((void *)0), (char const *)"weird file",
                       5);
  }
  return ((char const *)tmp___12);
}
}
static char ftypelet(mode_t bits )
{
  {
  if ((bits & 61440U) == 32768U) {
    {
    return ((char )'-');
    }
  }
  if ((bits & 61440U) == 16384U) {
    {
    return ((char )'d');
    }
  }
  if ((bits & 61440U) == 24576U) {
    {
    return ((char )'b');
    }
  }
  if ((bits & 61440U) == 8192U) {
    {
    return ((char )'c');
    }
  }
  if ((bits & 61440U) == 40960U) {
    {
    return ((char )'l');
    }
  }
  if ((bits & 61440U) == 4096U) {
    {
    return ((char )'p');
    }
  }
  if ((bits & 61440U) == 49152U) {
    {
    return ((char )'s');
    }
  }
  return ((char )'?');
}
}
void strmode(mode_t mode , char *str )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  {
  *(str + 0) = ftypelet(mode);
  }
  if (mode & 256U) {
    {
    {
    *(str + 1) = (char )'r';
    }
    }
  } else {
    {
    {
    *(str + 1) = (char )'-';
    }
    }
  }
  if (mode & 128U) {
    {
    {
    *(str + 2) = (char )'w';
    }
    }
  } else {
    {
    {
    *(str + 2) = (char )'-';
    }
    }
  }
  if (mode & 2048U) {
    {
    if (mode & 64U) {
      {
      {
      tmp = 's';
      }
      }
    } else {
      {
      {
      tmp = 'S';
      }
      }
    }
    {
    *(str + 3) = (char )tmp;
    }
    }
  } else {
    {
    if (mode & 64U) {
      {
      {
      tmp___0 = 'x';
      }
      }
    } else {
      {
      {
      tmp___0 = '-';
      }
      }
    }
    {
    *(str + 3) = (char )tmp___0;
    }
    }
  }
  if (mode & (unsigned int )(256 >> 3)) {
    {
    {
    *(str + 4) = (char )'r';
    }
    }
  } else {
    {
    {
    *(str + 4) = (char )'-';
    }
    }
  }
  if (mode & (unsigned int )(128 >> 3)) {
    {
    {
    *(str + 5) = (char )'w';
    }
    }
  } else {
    {
    {
    *(str + 5) = (char )'-';
    }
    }
  }
  if (mode & 1024U) {
    {
    if (mode & (unsigned int )(64 >> 3)) {
      {
      {
      tmp___1 = 's';
      }
      }
    } else {
      {
      {
      tmp___1 = 'S';
      }
      }
    }
    {
    *(str + 6) = (char )tmp___1;
    }
    }
  } else {
    {
    if (mode & (unsigned int )(64 >> 3)) {
      {
      {
      tmp___2 = 'x';
      }
      }
    } else {
      {
      {
      tmp___2 = '-';
      }
      }
    }
    {
    *(str + 6) = (char )tmp___2;
    }
    }
  }
  if (mode & (unsigned int )((256 >> 3) >> 3)) {
    {
    {
    *(str + 7) = (char )'r';
    }
    }
  } else {
    {
    {
    *(str + 7) = (char )'-';
    }
    }
  }
  if (mode & (unsigned int )((128 >> 3) >> 3)) {
    {
    {
    *(str + 8) = (char )'w';
    }
    }
  } else {
    {
    {
    *(str + 8) = (char )'-';
    }
    }
  }
  if (mode & 512U) {
    {
    if (mode & (unsigned int )((64 >> 3) >> 3)) {
      {
      {
      tmp___3 = 't';
      }
      }
    } else {
      {
      {
      tmp___3 = 'T';
      }
      }
    }
    {
    *(str + 9) = (char )tmp___3;
    }
    }
  } else {
    {
    if (mode & (unsigned int )((64 >> 3) >> 3)) {
      {
      {
      tmp___4 = 'x';
      }
      }
    } else {
      {
      {
      tmp___4 = '-';
      }
      }
    }
    {
    *(str + 9) = (char )tmp___4;
    }
    }
  }
  {
  *(str + 10) = (char )' ';
  *(str + 11) = (char )'\000';
  }
  return;
}
}
void filemodestring(struct stat const *statp , char *str )
{
  {
  {
  strmode((mode_t )statp->st_mode, str);
  }
  if (statp->st_mode - statp->st_mode) {
    {
    {
    *(str + 0) = (char )'F';
    }
    }
  } else {
    {
    if (statp->st_mode - statp->st_mode) {
      {
      {
      *(str + 0) = (char )'Q';
      }
      }
    } else {
      {
      if (statp->st_mode - statp->st_mode) {
        {
        {
        *(str + 0) = (char )'S';
        }
        }
      }
      }
    }
    }
  }
  return;
}
}
char *file_name_concat(char const *dir , char const *abase , char **base_in_result )
{
  char *p ;
  char *tmp ;
  {
  {
  tmp = mfile_name_concat(dir, abase, base_in_result);
  p = tmp;
  }
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
    {
    xalloc_die();
    { if(!(base_in_result == 0)) { reach_error(); abort(); } };
    }
    }
  }
  {
  { if(!(base_in_result == 0)) { reach_error(); abort(); } };
  return (p);
  }
}
}
static char const *longest_relative_suffix(char const *f )
{
  {
  {
  f += 0;
  }
  {
  while (1) {
    while_continue: ;
    if (! ((int const )*f == 47)) {
      {
      goto while_break;
      }
    }
    goto __Cont;
    __Cont:
    {
    f ++;
    }
  }
  while_break: ;
  }
  return (f);
}
}
char *mfile_name_concat(char const *dir , char const *abase , char **base_in_result )
{
  char const *dirbase ;
  char *tmp ;
  size_t dirbaselen ;
  size_t tmp___0 ;
  size_t dirlen ;
  size_t needs_separator ;
  int tmp___1 ;
  char const *base ;
  char const *tmp___2 ;
  size_t baselen ;
  size_t tmp___3 ;
  char *p_concat ;
  void *tmp___4 ;
  char *p ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  {
  {
  tmp = last_component(dir);
  dirbase = (char const *)tmp;
  tmp___0 = base_len(dirbase);
  dirbaselen = tmp___0;
  dirlen = (size_t )(dirbase - dir) + dirbaselen;
  }
  if (dirbaselen) {
    {
    { if(!(dirbaselen != 0UL)) { reach_error(); abort(); } };
    if (! ((int const )*(dirbase + (dirbaselen - 1UL)) == 47)) {
      {
      { if(!(dirbaselen != 0UL)) { reach_error(); abort(); } };
      {
      tmp___1 = 1;
      }
      }
    } else {
      {
      { if(!(dirbaselen != 0UL)) { reach_error(); abort(); } };
      {
      tmp___1 = 0;
      }
      }
    }
    }
  } else {
    {
    { if(!(dirbaselen == 0UL)) { reach_error(); abort(); } };
    {
    tmp___1 = 0;
    }
    }
  }
  {
  needs_separator = (size_t )tmp___1;
  tmp___2 = longest_relative_suffix(abase);
  base = tmp___2;
  tmp___3 = strlen(base);
  baselen = tmp___3;
  tmp___4 = malloc(((dirlen + needs_separator) + baselen) + 1UL);
  p_concat = (char *)tmp___4;
  }
  if ((unsigned long )p_concat == (unsigned long )((void *)0)) {
    {
    return ((char *)((void *)0));
    }
  }
  {
  tmp___5 = mempcpy((void *)((void * __restrict )p_concat), (void const *)((void const * __restrict )dir),
                    dirlen);
  p = (char *)tmp___5;
  *p = (char )'/';
  p += needs_separator;
  }
  if (base_in_result) {
    {
    if ((int const )*(abase + 0) == 47) {
      {
      {
      tmp___6 = 1;
      }
      }
    } else {
      {
      {
      tmp___6 = 0;
      }
      }
    }
    {
    *base_in_result = p - tmp___6;
    }
    }
  }
  {
  { if(!(base_in_result == 0)) { reach_error(); abort(); } };
  {
  tmp___7 = mempcpy((void *)((void * __restrict )p), (void const *)((void const * __restrict )base),
                    baselen);
  p = (char *)tmp___7;
  *p = (char )'\000';
  }
  }
  return (p_concat);
}
}
static char const *match_suffix(char const **str )
{
  char const *match ;
  _Bool read_alpha ;
  int __c ;
  int tmp ;
  int __c___0 ;
  int tmp___0 ;
  {
  {
  match = (char const *)((void *)0);
  read_alpha = (_Bool)0;
  }
  {
  while (1) {
    while_continue: ;
    if (! *(*str)) {
      {
      goto while_break;
      }
    }
    if (read_alpha) {
      {
      {
      read_alpha = (_Bool)0;
      __c = (int )*(*str);
      }
      if ((__c & -33) >= 65) {
        {
        if ((__c & -33) <= 90) {
          {
          {
          tmp = 1;
          }
          }
        } else {
          {
          {
          tmp = 0;
          }
          }
        }
        }
      } else {
        {
        {
        tmp = 0;
        }
        }
      }
      if (! tmp) {
        {
        if (126 != (int )*(*str)) {
          {
          {
          match = (char const *)((void *)0);
          }
          }
        }
        }
      }
      }
    } else {
      {
      if (46 == (int )*(*str)) {
        {
        {
        read_alpha = (_Bool)1;
        }
        if (! match) {
          {
          {
          match = *str;
          }
          }
        }
        }
      } else {
        {
        {
        __c___0 = (int )*(*str);
        }
        if (__c___0 >= 48) {
          {
          if (__c___0 <= 57) {
            {
            {
            tmp___0 = 1;
            }
            }
          } else {
            {
            goto _L;
            }
          }
          }
        } else {
          {
          _L:
          if ((__c___0 & -33) >= 65) {
            {
            if ((__c___0 & -33) <= 90) {
              {
              {
              tmp___0 = 1;
              }
              }
            } else {
              {
              {
              tmp___0 = 0;
              }
              }
            }
            }
          } else {
            {
            {
            tmp___0 = 0;
            }
            }
          }
          }
        }
        if (! tmp___0) {
          {
          if (126 != (int )*(*str)) {
            {
            {
            match = (char const *)((void *)0);
            }
            }
          }
          }
        }
        }
      }
      }
    }
    {
    (*str) ++;
    }
  }
  while_break: ;
  }
  return (match);
}
}
__inline static int order(unsigned char c )
{
  int __c ;
  int tmp ;
  int __c___0 ;
  int tmp___0 ;
  {
  {
  __c___0 = (int )c;
  }
  if (__c___0 >= 48) {
    {
    if (__c___0 <= 57) {
      {
      {
      tmp___0 = 1;
      }
      }
    } else {
      {
      {
      tmp___0 = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___0 = 0;
    }
    }
  }
  if (tmp___0) {
    {
    return (0);
    }
  } else {
    {
    {
    __c = (int )c;
    }
    if ((__c & -33) >= 65) {
      {
      if ((__c & -33) <= 90) {
        {
        {
        tmp = 1;
        }
        }
      } else {
        {
        {
        tmp = 0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    if (tmp) {
      {
      return ((int )c);
      }
    } else {
      {
      if ((int )c == 126) {
        {
        return (-1);
        }
      } else {
        {
        return (((int )c + 255) + 1);
        }
      }
      }
    }
    }
  }
}
}
static int verrevcmp(char const *s1 , size_t s1_len , char const *s2 , size_t s2_len )
{
  size_t s1_pos ;
  size_t s2_pos ;
  int first_diff ;
  int s1_c ;
  int tmp ;
  int tmp___0 ;
  int s2_c ;
  int tmp___1 ;
  int tmp___2 ;
  int __c ;
  int tmp___3 ;
  int __c___0 ;
  int tmp___4 ;
  int __c___1 ;
  int tmp___5 ;
  int __c___2 ;
  int tmp___6 ;
  int __c___3 ;
  int tmp___7 ;
  int __c___4 ;
  int tmp___8 ;
  {
  {
  s1_pos = (size_t )0;
  s2_pos = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (! (s1_pos < s1_len)) {
      {
      if (! (s2_pos < s2_len)) {
        {
        goto while_break;
        }
      }
      }
    }
    {
    first_diff = 0;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      if (s1_pos < s1_len) {
        {
        {
        __c = (int )*(s1 + s1_pos);
        }
        if (__c >= 48) {
          {
          if (__c <= 57) {
            {
            {
            tmp___3 = 1;
            }
            }
          } else {
            {
            {
            tmp___3 = 0;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___3 = 0;
          }
          }
        }
        if (tmp___3) {
          {
          goto _L;
          }
        }
        }
      } else {
        {
        _L:
        if (s2_pos < s2_len) {
          {
          {
          __c___0 = (int )*(s2 + s2_pos);
          }
          if (__c___0 >= 48) {
            {
            if (__c___0 <= 57) {
              {
              {
              tmp___4 = 1;
              }
              }
            } else {
              {
              {
              tmp___4 = 0;
              }
              }
            }
            }
          } else {
            {
            {
            tmp___4 = 0;
            }
            }
          }
          if (tmp___4) {
            {
            goto while_break___0;
            }
          }
          }
        } else {
          {
          goto while_break___0;
          }
        }
        }
      }
      if (s1_pos == s1_len) {
        {
        {
        tmp___0 = 0;
        }
        }
      } else {
        {
        {
        tmp = order((unsigned char )*(s1 + s1_pos));
        tmp___0 = tmp;
        }
        }
      }
      {
      s1_c = tmp___0;
      }
      if (s2_pos == s2_len) {
        {
        {
        tmp___2 = 0;
        }
        }
      } else {
        {
        {
        tmp___1 = order((unsigned char )*(s2 + s2_pos));
        tmp___2 = tmp___1;
        }
        }
      }
      {
      s2_c = tmp___2;
      }
      if (s1_c != s2_c) {
        {
        return (s1_c - s2_c);
        }
      }
      {
      s1_pos ++;
      s2_pos ++;
      }
    }
    while_break___0: ;
    }
    {
    while (1) {
      while_continue___1: ;
      if (! ((int const )*(s1 + s1_pos) == 48)) {
        {
        goto while_break___1;
        }
      }
      {
      s1_pos ++;
      }
    }
    while_break___1: ;
    }
    {
    while (1) {
      while_continue___2: ;
      if (! ((int const )*(s2 + s2_pos) == 48)) {
        {
        goto while_break___2;
        }
      }
      {
      s2_pos ++;
      }
    }
    while_break___2: ;
    }
    {
    while (1) {
      while_continue___3: ;
      if (! 1) {
        {
        goto while_break___3;
        }
      }
      {
      __c___1 = (int )*(s1 + s1_pos);
      }
      if (__c___1 >= 48) {
        {
        if (__c___1 <= 57) {
          {
          {
          tmp___5 = 1;
          }
          }
        } else {
          {
          {
          tmp___5 = 0;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___5 = 0;
        }
        }
      }
      if (tmp___5) {
        {
        {
        __c___2 = (int )*(s2 + s2_pos);
        }
        if (__c___2 >= 48) {
          {
          if (__c___2 <= 57) {
            {
            {
            tmp___6 = 1;
            }
            }
          } else {
            {
            {
            tmp___6 = 0;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___6 = 0;
          }
          }
        }
        if (! tmp___6) {
          {
          goto while_break___3;
          }
        }
        }
      } else {
        {
        goto while_break___3;
        }
      }
      if (! first_diff) {
        {
        {
        first_diff = (int )((int const )*(s1 + s1_pos) - (int const )*(s2 + s2_pos));
        }
        }
      }
      {
      s1_pos ++;
      s2_pos ++;
      }
    }
    while_break___3: ;
    }
    {
    __c___3 = (int )*(s1 + s1_pos);
    }
    if (__c___3 >= 48) {
      {
      if (__c___3 <= 57) {
        {
        {
        tmp___7 = 1;
        }
        }
      } else {
        {
        {
        tmp___7 = 0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___7 = 0;
      }
      }
    }
    if (tmp___7) {
      {
      return (1);
      }
    }
    {
    __c___4 = (int )*(s2 + s2_pos);
    }
    if (__c___4 >= 48) {
      {
      if (__c___4 <= 57) {
        {
        {
        tmp___8 = 1;
        }
        }
      } else {
        {
        {
        tmp___8 = 0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___8 = 0;
      }
      }
    }
    if (tmp___8) {
      {
      return (-1);
      }
    }
    if (first_diff) {
      {
      return (first_diff);
      }
    }
  }
  while_break: ;
  }
  return (0);
}
}
int filevercmp(char const *s1 , char const *s2 )
{
  char const *s1_pos ;
  char const *s2_pos ;
  char const *s1_suffix ;
  char const *s2_suffix ;
  size_t s1_len ;
  size_t s2_len ;
  int result ;
  int simple_cmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___28 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char const *tmp___34 ;
  char const *tmp___35 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___39 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___49 ;
  {
  if (0) {
    {
    {
    __s1_len = __builtin_strlen(s1);
    __s2_len = __builtin_strlen(s2);
    }
    if (! ((size_t )((void const *)(s1 + 1)) - (size_t )((void const *)s1) == 1UL)) {
      {
      goto _L___0;
      }
    } else {
      {
      if (__s1_len >= 4UL) {
        {
        _L___0:
        if (! ((size_t )((void const *)(s2 + 1)) - (size_t )((void const *)s2) == 1UL)) {
          {
          {
          tmp___5 = 1;
          }
          }
        } else {
          {
          if (__s2_len >= 4UL) {
            {
            {
            tmp___5 = 1;
            }
            }
          } else {
            {
            {
            tmp___5 = 0;
            }
            }
          }
          }
        }
        }
      } else {
        {
        {
        tmp___5 = 0;
        }
        }
      }
      }
    }
    if (tmp___5) {
      {
      {
      tmp___0 = __builtin_strcmp(s1, s2);
      tmp___4 = tmp___0;
      }
      }
    } else {
      {
      {
      tmp___3 = __builtin_strcmp(s1, s2);
      tmp___4 = tmp___3;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___3 = __builtin_strcmp(s1, s2);
    tmp___4 = tmp___3;
    }
    }
  }
  {
  simple_cmp = tmp___4;
  }
  if (simple_cmp == 0) {
    {
    return (0);
    }
  }
  if (! *s1) {
    {
    return (-1);
    }
  }
  if (! *s2) {
    {
    return (1);
    }
  }
  if (0) {
    {
    {
    __s1_len___0 = __builtin_strlen((char const *)".");
    __s2_len___0 = __builtin_strlen(s1);
    }
    if (! ((size_t )((void const *)("." + 1)) - (size_t )((void const *)".") == 1UL)) {
      {
      goto _L___2;
      }
    } else {
      {
      if (__s1_len___0 >= 4UL) {
        {
        _L___2:
        if (! ((size_t )((void const *)(s1 + 1)) - (size_t )((void const *)s1) == 1UL)) {
          {
          {
          tmp___12 = 1;
          }
          }
        } else {
          {
          if (__s2_len___0 >= 4UL) {
            {
            {
            tmp___12 = 1;
            }
            }
          } else {
            {
            {
            tmp___12 = 0;
            }
            }
          }
          }
        }
        }
      } else {
        {
        {
        tmp___12 = 0;
        }
        }
      }
      }
    }
    if (tmp___12) {
      {
      {
      tmp___7 = __builtin_strcmp((char const *)".", s1);
      tmp___11 = tmp___7;
      }
      }
    } else {
      {
      {
      tmp___10 = __builtin_strcmp((char const *)".", s1);
      tmp___11 = tmp___10;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___10 = __builtin_strcmp((char const *)".", s1);
    tmp___11 = tmp___10;
    }
    }
  }
  if (0 == tmp___11) {
    {
    return (-1);
    }
  }
  if (0) {
    {
    {
    __s1_len___1 = __builtin_strlen((char const *)".");
    __s2_len___1 = __builtin_strlen(s2);
    }
    if (! ((size_t )((void const *)("." + 1)) - (size_t )((void const *)".") == 1UL)) {
      {
      goto _L___4;
      }
    } else {
      {
      if (__s1_len___1 >= 4UL) {
        {
        _L___4:
        if (! ((size_t )((void const *)(s2 + 1)) - (size_t )((void const *)s2) == 1UL)) {
          {
          {
          tmp___19 = 1;
          }
          }
        } else {
          {
          if (__s2_len___1 >= 4UL) {
            {
            {
            tmp___19 = 1;
            }
            }
          } else {
            {
            {
            tmp___19 = 0;
            }
            }
          }
          }
        }
        }
      } else {
        {
        {
        tmp___19 = 0;
        }
        }
      }
      }
    }
    if (tmp___19) {
      {
      {
      tmp___14 = __builtin_strcmp((char const *)".", s2);
      tmp___18 = tmp___14;
      }
      }
    } else {
      {
      {
      tmp___17 = __builtin_strcmp((char const *)".", s2);
      tmp___18 = tmp___17;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___17 = __builtin_strcmp((char const *)".", s2);
    tmp___18 = tmp___17;
    }
    }
  }
  if (0 == tmp___18) {
    {
    return (1);
    }
  }
  if (0) {
    {
    {
    __s1_len___2 = __builtin_strlen((char const *)"..");
    __s2_len___2 = __builtin_strlen(s1);
    }
    if (! ((size_t )((void const *)(".." + 1)) - (size_t )((void const *)"..") == 1UL)) {
      {
      goto _L___6;
      }
    } else {
      {
      if (__s1_len___2 >= 4UL) {
        {
        _L___6:
        if (! ((size_t )((void const *)(s1 + 1)) - (size_t )((void const *)s1) == 1UL)) {
          {
          {
          tmp___26 = 1;
          }
          }
        } else {
          {
          if (__s2_len___2 >= 4UL) {
            {
            {
            tmp___26 = 1;
            }
            }
          } else {
            {
            {
            tmp___26 = 0;
            }
            }
          }
          }
        }
        }
      } else {
        {
        {
        tmp___26 = 0;
        }
        }
      }
      }
    }
    if (tmp___26) {
      {
      {
      tmp___21 = __builtin_strcmp((char const *)"..", s1);
      tmp___25 = tmp___21;
      }
      }
    } else {
      {
      {
      tmp___24 = __builtin_strcmp((char const *)"..", s1);
      tmp___25 = tmp___24;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___24 = __builtin_strcmp((char const *)"..", s1);
    tmp___25 = tmp___24;
    }
    }
  }
  if (0 == tmp___25) {
    {
    return (-1);
    }
  }
  if (0) {
    {
    {
    __s1_len___3 = __builtin_strlen((char const *)"..");
    __s2_len___3 = __builtin_strlen(s2);
    }
    if (! ((size_t )((void const *)(".." + 1)) - (size_t )((void const *)"..") == 1UL)) {
      {
      goto _L___8;
      }
    } else {
      {
      if (__s1_len___3 >= 4UL) {
        {
        _L___8:
        if (! ((size_t )((void const *)(s2 + 1)) - (size_t )((void const *)s2) == 1UL)) {
          {
          {
          tmp___33 = 1;
          }
          }
        } else {
          {
          if (__s2_len___3 >= 4UL) {
            {
            {
            tmp___33 = 1;
            }
            }
          } else {
            {
            {
            tmp___33 = 0;
            }
            }
          }
          }
        }
        }
      } else {
        {
        {
        tmp___33 = 0;
        }
        }
      }
      }
    }
    if (tmp___33) {
      {
      {
      tmp___28 = __builtin_strcmp((char const *)"..", s2);
      tmp___32 = tmp___28;
      }
      }
    } else {
      {
      {
      tmp___31 = __builtin_strcmp((char const *)"..", s2);
      tmp___32 = tmp___31;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___31 = __builtin_strcmp((char const *)"..", s2);
    tmp___32 = tmp___31;
    }
    }
  }
  if (0 == tmp___32) {
    {
    return (1);
    }
  }
  if ((int const )*s1 == 46) {
    {
    if ((int const )*s2 != 46) {
      {
      return (-1);
      }
    }
    }
  }
  if ((int const )*s1 != 46) {
    {
    if ((int const )*s2 == 46) {
      {
      return (1);
      }
    }
    }
  }
  if ((int const )*s1 == 46) {
    {
    if ((int const )*s2 == 46) {
      {
      {
      s1 ++;
      s2 ++;
      }
      }
    }
    }
  }
  {
  s1_pos = s1;
  s2_pos = s2;
  s1_suffix = match_suffix(& s1_pos);
  s2_suffix = match_suffix(& s2_pos);
  }
  if (s1_suffix) {
    {
    {
    tmp___34 = s1_suffix;
    }
    }
  } else {
    {
    {
    tmp___34 = s1_pos;
    }
    }
  }
  {
  s1_len = (size_t )(tmp___34 - s1);
  }
  if (s2_suffix) {
    {
    {
    tmp___35 = s2_suffix;
    }
    }
  } else {
    {
    {
    tmp___35 = s2_pos;
    }
    }
  }
  {
  s2_len = (size_t )(tmp___35 - s2);
  }
  if (s1_suffix) {
    {
    goto _L___11;
    }
  } else {
    {
    if (s2_suffix) {
      {
      _L___11:
      if (s1_len == s2_len) {
        {
        if (0) {
          {
          if (0) {
            {
            {
            __s1_len___4 = __builtin_strlen(s1);
            __s2_len___4 = __builtin_strlen(s2);
            }
            if (! ((size_t )((void const *)(s1 + 1)) - (size_t )((void const *)s1) == 1UL)) {
              {
              goto _L___10;
              }
            } else {
              {
              if (__s1_len___4 >= 4UL) {
                {
                _L___10:
                if (! ((size_t )((void const *)(s2 + 1)) - (size_t )((void const *)s2) == 1UL)) {
                  {
                  {
                  tmp___44 = 1;
                  }
                  }
                } else {
                  {
                  if (__s2_len___4 >= 4UL) {
                    {
                    {
                    tmp___44 = 1;
                    }
                    }
                  } else {
                    {
                    {
                    tmp___44 = 0;
                    }
                    }
                  }
                  }
                }
                }
              } else {
                {
                {
                tmp___44 = 0;
                }
                }
              }
              }
            }
            if (tmp___44) {
              {
              {
              tmp___39 = __builtin_strcmp(s1, s2);
              tmp___43 = tmp___39;
              }
              }
            } else {
              {
              {
              tmp___42 = __builtin_strcmp(s1, s2);
              tmp___43 = tmp___42;
              }
              }
            }
            }
          } else {
            {
            {
            tmp___42 = __builtin_strcmp(s1, s2);
            tmp___43 = tmp___42;
            }
            }
          }
          {
          tmp___46 = tmp___43;
          }
          }
        } else {
          {
          {
          tmp___45 = strncmp(s1, s2, s1_len);
          tmp___46 = tmp___45;
          }
          }
        }
        if (0 == tmp___46) {
          {
          {
          s1_len = (size_t )(s1_pos - s1);
          s2_len = (size_t )(s2_pos - s2);
          }
          }
        }
        }
      }
      }
    }
    }
  }
  {
  result = verrevcmp(s1, s1_len, s2, s2_len);
  }
  if (result == 0) {
    {
    {
    tmp___49 = simple_cmp;
    }
    }
  } else {
    {
    {
    tmp___49 = result;
    }
    }
  }
  return (tmp___49);
}
}
FILE *fopen_safer(char const *file , char const *mode )
{
  FILE *fp ;
  FILE *tmp ;
  int fd ;
  int tmp___0 ;
  int f ;
  int tmp___1 ;
  int e ;
  int *tmp___2 ;
  int *tmp___3 ;
  int e___0 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  {
  {
  tmp = fopen((char const * __restrict )file, (char const * __restrict )mode);
  fp = tmp;
  }
  if (fp) {
    {
    {
    tmp___0 = fileno(fp);
    fd = tmp___0;
    }
    if (0 <= fd) {
      {
      if (fd <= 2) {
        {
        {
        tmp___1 = dup_safer(fd);
        f = tmp___1;
        }
        if (f < 0) {
          {
          {
          tmp___2 = __errno_location();
          e = *tmp___2;
          rpl_fclose(fp);
          tmp___3 = __errno_location();
          *tmp___3 = e;
          }
          return ((FILE *)((void *)0));
          }
        }
        {
        tmp___6 = rpl_fclose(fp);
        }
        if (tmp___6 != 0) {
          {
          goto _L;
          }
        } else {
          {
          {
          fp = fdopen(f, mode);
          }
          if (! fp) {
            {
            _L:
            {
            tmp___4 = __errno_location();
            e___0 = *tmp___4;
            close(f);
            tmp___5 = __errno_location();
            *tmp___5 = e___0;
            }
            return ((FILE *)((void *)0));
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  return (fp);
}
}
__inline static size_t ( __attribute__((__nonnull__(1,4))) rpl_fwrite)(void const *ptr ,
                                                                       size_t s ,
                                                                       size_t n ,
                                                                       FILE *stream )
{
  size_t r ;
  size_t tmp ;
  {
  {
  tmp = fwrite((void const * __restrict )ptr, s, n, (FILE * __restrict )stream);
  r = tmp;
  }
  return (r);
}
}
static void fwrite_lowcase(FILE *fp , char const *src , size_t len )
{
  int __res ;
  __int32_t const **tmp___0 ;
  size_t tmp___1 ;
  {
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___1 = len;
    len --;
    }
    if (! (tmp___1 > 0UL)) {
      {
      goto while_break;
      }
    }
    if (sizeof((unsigned char )*src) > 1UL) {
      {
      {
      __res = tolower((int )((unsigned char )*src));
      }
      }
    } else {
      {
      {
      tmp___0 = __ctype_tolower_loc();
      __res = (int )*(*tmp___0 + (int )((unsigned char )*src));
      }
      }
    }
    {
    fputc(__res, fp);
    src ++;
    }
  }
  while_break: ;
  }
  return;
}
}
static void fwrite_uppcase(FILE *fp , char const *src , size_t len )
{
  int __res ;
  __int32_t const **tmp___0 ;
  size_t tmp___1 ;
  {
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___1 = len;
    len --;
    }
    if (! (tmp___1 > 0UL)) {
      {
      goto while_break;
      }
    }
    if (sizeof((unsigned char )*src) > 1UL) {
      {
      {
      __res = toupper((int )((unsigned char )*src));
      }
      }
    } else {
      {
      {
      tmp___0 = __ctype_toupper_loc();
      __res = (int )*(*tmp___0 + (int )((unsigned char )*src));
      }
      }
    }
    {
    fputc(__res, fp);
    src ++;
    }
  }
  while_break: ;
  }
  return;
}
}
__inline static int iso_week_days(int yday , int wday )
{
  int big_enough_multiple_of_7 ;
  {
  {
  big_enough_multiple_of_7 = 378;
  }
  return (((yday - (((yday - wday) + 4) + big_enough_multiple_of_7) % 7) + 4) - 1);
}
}
static size_t strftime_case_(_Bool upcase , FILE *s , char const *format , struct tm const *tp ,
                             int ut , int ns )
{
  size_t maxsize ;
  int hour12 ;
  char const *zone ;
  size_t i ;
  FILE *p ;
  char const *f ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___1[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  size_t _n ;
  size_t _w ;
  int tmp ;
  size_t _incr ;
  size_t tmp___0 ;
  size_t _delta ;
  size_t _i ;
  size_t _i___0 ;
  char const *tmp___1 ;
  size_t _n___0 ;
  size_t _w___0 ;
  int tmp___2 ;
  size_t _incr___0 ;
  size_t tmp___3 ;
  size_t _delta___0 ;
  size_t _i___1 ;
  size_t _i___2 ;
  size_t len ;
  size_t tmp___4 ;
  size_t _n___1 ;
  size_t _w___1 ;
  int tmp___5 ;
  size_t _incr___1 ;
  size_t tmp___6 ;
  size_t _delta___1 ;
  size_t _i___3 ;
  size_t _i___4 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t _n___2 ;
  size_t _w___2 ;
  int tmp___11 ;
  size_t _incr___2 ;
  size_t tmp___12 ;
  size_t _delta___2 ;
  size_t _i___5 ;
  size_t _i___6 ;
  size_t __x ;
  size_t tmp___13 ;
  int century ;
  int tmp___14 ;
  int tmp___15 ;
  size_t _n___3 ;
  size_t _w___3 ;
  int tmp___16 ;
  size_t _incr___3 ;
  size_t tmp___17 ;
  size_t _delta___3 ;
  size_t _i___7 ;
  size_t _i___8 ;
  int padding ;
  size_t _i___9 ;
  size_t _n___4 ;
  size_t _w___4 ;
  int tmp___18 ;
  size_t _incr___4 ;
  size_t tmp___19 ;
  size_t _delta___4 ;
  size_t _i___10 ;
  size_t _i___11 ;
  size_t _n___5 ;
  size_t _w___5 ;
  int tmp___20 ;
  size_t _incr___5 ;
  size_t tmp___21 ;
  size_t _delta___5 ;
  size_t _i___12 ;
  size_t _i___13 ;
  size_t _i___14 ;
  size_t _n___6 ;
  size_t _w___6 ;
  int tmp___22 ;
  size_t _incr___6 ;
  size_t tmp___23 ;
  size_t _delta___6 ;
  size_t _i___15 ;
  size_t _i___16 ;
  size_t _n___7 ;
  size_t _w___7 ;
  int tmp___24 ;
  size_t _incr___7 ;
  size_t tmp___25 ;
  size_t _delta___7 ;
  size_t _i___17 ;
  size_t _i___18 ;
  size_t __x___0 ;
  size_t tmp___26 ;
  int j ;
  size_t _n___8 ;
  size_t _w___8 ;
  int tmp___27 ;
  size_t _incr___8 ;
  size_t tmp___28 ;
  size_t _delta___8 ;
  size_t _i___19 ;
  size_t _i___20 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___29 ;
  size_t _n___9 ;
  size_t _w___9 ;
  int tmp___30 ;
  size_t _incr___9 ;
  size_t tmp___31 ;
  size_t _delta___9 ;
  size_t _i___21 ;
  size_t _i___22 ;
  int year___0 ;
  int tmp___32 ;
  int year_adjust ;
  int days ;
  int tmp___33 ;
  int tmp___34 ;
  int d___0 ;
  int tmp___35 ;
  int tmp___36 ;
  int yy ;
  int tmp___37 ;
  int yy___0 ;
  size_t _n___10 ;
  size_t tmp___38 ;
  size_t _w___10 ;
  int tmp___39 ;
  size_t _incr___10 ;
  size_t tmp___40 ;
  size_t _delta___10 ;
  size_t _i___23 ;
  size_t _i___24 ;
  size_t __x___1 ;
  size_t tmp___41 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  size_t _n___11 ;
  size_t _w___11 ;
  int tmp___42 ;
  size_t _incr___11 ;
  size_t tmp___43 ;
  size_t _delta___11 ;
  size_t _i___25 ;
  size_t _i___26 ;
  size_t __x___2 ;
  size_t tmp___44 ;
  {
  {
  maxsize = (size_t )-1;
  hour12 = (int )tp->tm_hour;
  i = (size_t )0;
  p = s;
  zone = (char const *)((void *)0);
  zone = (char const *)tp->tm_zone;
  }
  if (hour12 > 12) {
    {
    {
    hour12 -= 12;
    }
    }
  } else {
    {
    if (hour12 == 0) {
      {
      {
      hour12 = 12;
      }
      }
    }
    }
  }
  {
  f = format;
  }
  {
  while (1) {
    while_continue: ;
    if (! ((int const )*f != 0)) {
      {
      goto while_break;
      }
    }
    {
    pad = 0;
    digits = 0;
    width = -1;
    to_lowcase = (_Bool)0;
    to_uppcase = upcase;
    change_case = (_Bool)0;
    }
    if ((int const )*f != 37) {
      {
      {
      while (1) {
        while_continue___0: ;
        if (! 1) {
          {
          goto while_break___0;
          }
        }
        {
        _n = (size_t )1;
        }
        if (width < 0) {
          {
          {
          tmp = 0;
          }
          }
        } else {
          {
          {
          tmp = width;
          }
          }
        }
        {
        _w = (size_t )tmp;
        }
        if (_n < _w) {
          {
          {
          tmp___0 = _w;
          }
          }
        } else {
          {
          {
          tmp___0 = _n;
          }
          }
        }
        {
        _incr = tmp___0;
        }
        if (_incr >= maxsize - i) {
          {
          return ((size_t )0);
          }
        }
        if (p) {
          {
          if (digits == 0) {
            {
            if (_n < _w) {
              {
              {
              _delta = (size_t )width - _n;
              }
              if (pad == 48) {
                {
                {
                while (1) {
                  while_continue___1: ;
                  if (! 1) {
                    {
                    goto while_break___1;
                    }
                  }
                  {
                  _i = (size_t )0;
                  }
                  {
                  while (1) {
                    while_continue___2: ;
                    if (! (_i < _delta)) {
                      {
                      goto while_break___2;
                      }
                    }
                    {
                    fputc('0', p);
                    _i ++;
                    }
                  }
                  while_break___2: ;
                  }
                  goto while_break___1;
                }
                while_break___1: ;
                }
                }
              } else {
                {
                {
                while (1) {
                  while_continue___3: ;
                  if (! 1) {
                    {
                    goto while_break___3;
                    }
                  }
                  {
                  _i___0 = (size_t )0;
                  }
                  {
                  while (1) {
                    while_continue___4: ;
                    if (! (_i___0 < _delta)) {
                      {
                      goto while_break___4;
                      }
                    }
                    {
                    fputc(' ', p);
                    _i___0 ++;
                    }
                  }
                  while_break___4: ;
                  }
                  goto while_break___3;
                }
                while_break___3: ;
                }
                }
              }
              }
            }
            }
          }
          {
          fputc((int )*f, p);
          }
          }
        }
        {
        i += _incr;
        }
        goto while_break___0;
      }
      while_break___0: ;
      }
      goto __Cont;
      }
    }
    {
    while (1) {
      while_continue___5: ;
      if (! 1) {
        {
        goto while_break___5;
        }
      }
      {
      f ++;
      }
      {
      if ((int )*f == 48) {
        {
        goto case_48;
        }
      }
      if ((int )*f == 45) {
        {
        goto case_48;
        }
      }
      if ((int )*f == 95) {
        {
        goto case_48;
        }
      }
      if ((int )*f == 94) {
        {
        goto case_94;
        }
      }
      if ((int )*f == 35) {
        {
        goto case_35;
        }
      }
      goto switch_default;
      case_48:
      case_45:
      case_95:
      {
      pad = (int )*f;
      }
      goto while_continue___5;
      case_94:
      {
      to_uppcase = (_Bool)1;
      }
      goto while_continue___5;
      case_35:
      {
      change_case = (_Bool)1;
      }
      goto while_continue___5;
      switch_default:
      goto switch_break;
      switch_break: ;
      }
      goto while_break___5;
    }
    while_break___5: ;
    }
    if ((unsigned int )*f - 48U <= 9U) {
      {
      {
      width = 0;
      }
      {
      while (1) {
        while_continue___6: ;
        if (! 1) {
          {
          goto while_break___6;
          }
        }
        if (width > 214748364) {
          {
          {
          width = 2147483647;
          }
          }
        } else {
          {
          if (width == 214748364) {
            {
            if ((int const )*f - 48 > 7) {
              {
              {
              width = 2147483647;
              }
              }
            } else {
              {
              {
              width *= 10;
              width += (int )((int const )*f - 48);
              }
              }
            }
            }
          } else {
            {
            {
            width *= 10;
            width += (int )((int const )*f - 48);
            }
            }
          }
          }
        }
        {
        f ++;
        }
        if (! ((unsigned int )*f - 48U <= 9U)) {
          {
          goto while_break___6;
          }
        }
      }
      while_break___6: ;
      }
      }
    }
    {
    if ((int )*f == 79) {
      {
      goto case_79;
      }
    }
    if ((int )*f == 69) {
      {
      goto case_79;
      }
    }
    goto switch_default___0;
    case_79:
    case_69:
    {
    tmp___1 = f;
    f ++;
    modifier = (int )*tmp___1;
    }
    goto switch_break___0;
    switch_default___0:
    {
    modifier = 0;
    }
    goto switch_break___0;
    switch_break___0: ;
    }
    {
    format_char = (int )*f;
    }
    {
    if (format_char == 37) {
      {
      goto case_37;
      }
    }
    if (format_char == 97) {
      {
      goto case_97;
      }
    }
    if (format_char == 65) {
      {
      goto case_65;
      }
    }
    if (format_char == 104) {
      {
      goto case_104;
      }
    }
    if (format_char == 98) {
      {
      goto case_104;
      }
    }
    if (format_char == 66) {
      {
      goto case_66;
      }
    }
    if (format_char == 99) {
      {
      goto case_99;
      }
    }
    if (format_char == 67) {
      {
      goto case_67;
      }
    }
    if (format_char == 120) {
      {
      goto case_120;
      }
    }
    if (format_char == 68) {
      {
      goto case_68;
      }
    }
    if (format_char == 100) {
      {
      goto case_100;
      }
    }
    if (format_char == 101) {
      {
      goto case_101;
      }
    }
    if (format_char == 70) {
      {
      goto case_70;
      }
    }
    if (format_char == 72) {
      {
      goto case_72;
      }
    }
    if (format_char == 73) {
      {
      goto case_73;
      }
    }
    if (format_char == 107) {
      {
      goto case_107;
      }
    }
    if (format_char == 108) {
      {
      goto case_108;
      }
    }
    if (format_char == 106) {
      {
      goto case_106;
      }
    }
    if (format_char == 77) {
      {
      goto case_77;
      }
    }
    if (format_char == 109) {
      {
      goto case_109;
      }
    }
    if (format_char == 78) {
      {
      goto case_78;
      }
    }
    if (format_char == 110) {
      {
      goto case_110;
      }
    }
    if (format_char == 80) {
      {
      goto case_80;
      }
    }
    if (format_char == 112) {
      {
      goto case_112;
      }
    }
    if (format_char == 82) {
      {
      goto case_82;
      }
    }
    if (format_char == 114) {
      {
      goto case_114;
      }
    }
    if (format_char == 83) {
      {
      goto case_83;
      }
    }
    if (format_char == 115) {
      {
      goto case_115;
      }
    }
    if (format_char == 88) {
      {
      goto case_88;
      }
    }
    if (format_char == 84) {
      {
      goto case_84;
      }
    }
    if (format_char == 116) {
      {
      goto case_116;
      }
    }
    if (format_char == 117) {
      {
      goto case_117;
      }
    }
    if (format_char == 85) {
      {
      goto case_85;
      }
    }
    if (format_char == 71) {
      {
      goto case_71;
      }
    }
    if (format_char == 103) {
      {
      goto case_71;
      }
    }
    if (format_char == 86) {
      {
      goto case_71;
      }
    }
    if (format_char == 87) {
      {
      goto case_87;
      }
    }
    if (format_char == 119) {
      {
      goto case_119;
      }
    }
    if (format_char == 89) {
      {
      goto case_89;
      }
    }
    if (format_char == 121) {
      {
      goto case_121;
      }
    }
    if (format_char == 90) {
      {
      goto case_90;
      }
    }
    if (format_char == 58) {
      {
      goto case_58;
      }
    }
    if (format_char == 122) {
      {
      goto case_122;
      }
    }
    if (format_char == 0) {
      {
      goto case_0___0;
      }
    }
    goto switch_default___3;
    case_37:
    if (modifier != 0) {
      {
      goto switch_default___3;
      }
    }
    {
    while (1) {
      while_continue___7: ;
      if (! 1) {
        {
        goto while_break___7;
        }
      }
      {
      _n___0 = (size_t )1;
      }
      if (width < 0) {
        {
        {
        tmp___2 = 0;
        }
        }
      } else {
        {
        {
        tmp___2 = width;
        }
        }
      }
      {
      _w___0 = (size_t )tmp___2;
      }
      if (_n___0 < _w___0) {
        {
        {
        tmp___3 = _w___0;
        }
        }
      } else {
        {
        {
        tmp___3 = _n___0;
        }
        }
      }
      {
      _incr___0 = tmp___3;
      }
      if (_incr___0 >= maxsize - i) {
        {
        return ((size_t )0);
        }
      }
      if (p) {
        {
        if (digits == 0) {
          {
          if (_n___0 < _w___0) {
            {
            {
            _delta___0 = (size_t )width - _n___0;
            }
            if (pad == 48) {
              {
              {
              while (1) {
                while_continue___8: ;
                if (! 1) {
                  {
                  goto while_break___8;
                  }
                }
                {
                _i___1 = (size_t )0;
                }
                {
                while (1) {
                  while_continue___9: ;
                  if (! (_i___1 < _delta___0)) {
                    {
                    goto while_break___9;
                    }
                  }
                  {
                  fputc('0', p);
                  _i___1 ++;
                  }
                }
                while_break___9: ;
                }
                goto while_break___8;
              }
              while_break___8: ;
              }
              }
            } else {
              {
              {
              while (1) {
                while_continue___10: ;
                if (! 1) {
                  {
                  goto while_break___10;
                  }
                }
                {
                _i___2 = (size_t )0;
                }
                {
                while (1) {
                  while_continue___11: ;
                  if (! (_i___2 < _delta___0)) {
                    {
                    goto while_break___11;
                    }
                  }
                  {
                  fputc(' ', p);
                  _i___2 ++;
                  }
                }
                while_break___11: ;
                }
                goto while_break___10;
              }
              while_break___10: ;
              }
              }
            }
            }
          }
          }
        }
        {
        fputc((int )*f, p);
        }
        }
      }
      {
      i += _incr___0;
      }
      goto while_break___7;
    }
    while_break___7: ;
    }
    goto switch_break___1;
    case_97:
    if (modifier != 0) {
      {
      goto switch_default___3;
      }
    }
    if (change_case) {
      {
      {
      to_uppcase = (_Bool)1;
      to_lowcase = (_Bool)0;
      }
      }
    }
    goto underlying_strftime;
    case_65:
    if (modifier != 0) {
      {
      goto switch_default___3;
      }
    }
    if (change_case) {
      {
      {
      to_uppcase = (_Bool)1;
      to_lowcase = (_Bool)0;
      }
      }
    }
    goto underlying_strftime;
    case_104:
    case_98:
    if (change_case) {
      {
      {
      to_uppcase = (_Bool)1;
      to_lowcase = (_Bool)0;
      }
      }
    }
    if (modifier != 0) {
      {
      goto switch_default___3;
      }
    }
    goto underlying_strftime;
    case_66:
    if (modifier != 0) {
      {
      goto switch_default___3;
      }
    }
    if (change_case) {
      {
      {
      to_uppcase = (_Bool)1;
      to_lowcase = (_Bool)0;
      }
      }
    }
    goto underlying_strftime;
    case_99:
    if (modifier == 79) {
      {
      goto switch_default___3;
      }
    }
    goto underlying_strftime;
    subformat:
    {
    tmp___4 = strftime_case_(to_uppcase, (FILE *)((void *)0), subfmt, tp, ut, ns);
    len = tmp___4;
    }
    {
    while (1) {
      while_continue___12: ;
      if (! 1) {
        {
        goto while_break___12;
        }
      }
      {
      _n___1 = len;
      }
      if (width < 0) {
        {
        {
        tmp___5 = 0;
        }
        }
      } else {
        {
        {
        tmp___5 = width;
        }
        }
      }
      {
      _w___1 = (size_t )tmp___5;
      }
      if (_n___1 < _w___1) {
        {
        {
        tmp___6 = _w___1;
        }
        }
      } else {
        {
        {
        tmp___6 = _n___1;
        }
        }
      }
      {
      _incr___1 = tmp___6;
      }
      if (_incr___1 >= maxsize - i) {
        {
        return ((size_t )0);
        }
      }
      if (p) {
        {
        if (digits == 0) {
          {
          if (_n___1 < _w___1) {
            {
            {
            _delta___1 = (size_t )width - _n___1;
            }
            if (pad == 48) {
              {
              {
              while (1) {
                while_continue___13: ;
                if (! 1) {
                  {
                  goto while_break___13;
                  }
                }
                {
                _i___3 = (size_t )0;
                }
                {
                while (1) {
                  while_continue___14: ;
                  if (! (_i___3 < _delta___1)) {
                    {
                    goto while_break___14;
                    }
                  }
                  {
                  fputc('0', p);
                  _i___3 ++;
                  }
                }
                while_break___14: ;
                }
                goto while_break___13;
              }
              while_break___13: ;
              }
              }
            } else {
              {
              {
              while (1) {
                while_continue___15: ;
                if (! 1) {
                  {
                  goto while_break___15;
                  }
                }
                {
                _i___4 = (size_t )0;
                }
                {
                while (1) {
                  while_continue___16: ;
                  if (! (_i___4 < _delta___1)) {
                    {
                    goto while_break___16;
                    }
                  }
                  {
                  fputc(' ', p);
                  _i___4 ++;
                  }
                }
                while_break___16: ;
                }
                goto while_break___15;
              }
              while_break___15: ;
              }
              }
            }
            }
          }
          }
        }
        {
        strftime_case_(to_uppcase, p, subfmt, tp, ut, ns);
        }
        }
      }
      {
      i += _incr___1;
      }
      goto while_break___12;
    }
    while_break___12: ;
    }
    goto switch_break___1;
    underlying_strftime:
    {
    u = ufmt;
    tmp___7 = u;
    u ++;
    *tmp___7 = (char )' ';
    tmp___8 = u;
    u ++;
    *tmp___8 = (char )'%';
    }
    if (modifier != 0) {
      {
      {
      tmp___9 = u;
      u ++;
      *tmp___9 = (char )modifier;
      }
      }
    }
    {
    tmp___10 = u;
    u ++;
    *tmp___10 = (char )format_char;
    *u = (char )'\000';
    len___0 = strftime((char * __restrict )(ubuf), sizeof(ubuf), (char const * __restrict )(ufmt),
                       (struct tm const * __restrict )tp);
    }
    if (len___0 != 0UL) {
      {
      {
      while (1) {
        while_continue___17: ;
        if (! 1) {
          {
          goto while_break___17;
          }
        }
        {
        _n___2 = len___0 - 1UL;
        }
        if (width < 0) {
          {
          {
          tmp___11 = 0;
          }
          }
        } else {
          {
          {
          tmp___11 = width;
          }
          }
        }
        {
        _w___2 = (size_t )tmp___11;
        }
        if (_n___2 < _w___2) {
          {
          {
          tmp___12 = _w___2;
          }
          }
        } else {
          {
          {
          tmp___12 = _n___2;
          }
          }
        }
        {
        _incr___2 = tmp___12;
        }
        if (_incr___2 >= maxsize - i) {
          {
          return ((size_t )0);
          }
        }
        if (p) {
          {
          if (digits == 0) {
            {
            if (_n___2 < _w___2) {
              {
              {
              _delta___2 = (size_t )width - _n___2;
              }
              if (pad == 48) {
                {
                {
                while (1) {
                  while_continue___18: ;
                  if (! 1) {
                    {
                    goto while_break___18;
                    }
                  }
                  {
                  _i___5 = (size_t )0;
                  }
                  {
                  while (1) {
                    while_continue___19: ;
                    if (! (_i___5 < _delta___2)) {
                      {
                      goto while_break___19;
                      }
                    }
                    {
                    fputc('0', p);
                    _i___5 ++;
                    }
                  }
                  while_break___19: ;
                  }
                  goto while_break___18;
                }
                while_break___18: ;
                }
                }
              } else {
                {
                {
                while (1) {
                  while_continue___20: ;
                  if (! 1) {
                    {
                    goto while_break___20;
                    }
                  }
                  {
                  _i___6 = (size_t )0;
                  }
                  {
                  while (1) {
                    while_continue___21: ;
                    if (! (_i___6 < _delta___2)) {
                      {
                      goto while_break___21;
                      }
                    }
                    {
                    fputc(' ', p);
                    _i___6 ++;
                    }
                  }
                  while_break___21: ;
                  }
                  goto while_break___20;
                }
                while_break___20: ;
                }
                }
              }
              }
            }
            }
          }
          {
          while (1) {
            while_continue___22: ;
            if (! 1) {
              {
              goto while_break___22;
              }
            }
            if (to_lowcase) {
              {
              {
              fwrite_lowcase(p, (char const *)(ubuf + 1), _n___2);
              }
              }
            } else {
              {
              if (to_uppcase) {
                {
                {
                fwrite_uppcase(p, (char const *)(ubuf + 1), _n___2);
                }
                }
              } else {
                {
                {
                tmp___13 = rpl_fwrite((void const *)(ubuf + 1), _n___2, (size_t )1,
                                      p);
                __x = tmp___13;
                }
                }
              }
              }
            }
            goto while_break___22;
          }
          while_break___22: ;
          }
          }
        }
        {
        i += _incr___2;
        }
        goto while_break___17;
      }
      while_break___17: ;
      }
      }
    }
    goto switch_break___1;
    case_67:
    if (modifier == 79) {
      {
      goto switch_default___3;
      }
    }
    if (modifier == 69) {
      {
      goto underlying_strftime;
      }
    }
    {
    century = (int )(tp->tm_year / 100 + 19);
    }
    if (tp->tm_year % 100 < 0) {
      {
      if (0 < century) {
        {
        {
        tmp___14 = 1;
        }
        }
      } else {
        {
        {
        tmp___14 = 0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___14 = 0;
      }
      }
    }
    {
    century -= tmp___14;
    digits = 2;
    negative_number = (_Bool )(tp->tm_year < -1900);
    u_number_value = (unsigned int )century;
    }
    goto do_signed_number;
    case_120:
    if (modifier == 79) {
      {
      goto switch_default___3;
      }
    }
    goto underlying_strftime;
    case_68:
    if (modifier != 0) {
      {
      goto switch_default___3;
      }
    }
    {
    subfmt = (char const *)"%m/%d/%y";
    }
    goto subformat;
    case_100:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = (int )tp->tm_mday;
    }
    goto do_number;
    case_101:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = (int )tp->tm_mday;
    }
    goto do_number_spacepad;
    do_tz_offset:
    {
    always_output_a_sign = (_Bool)1;
    }
    goto do_number_body;
    do_number_spacepad:
    if (pad != 48) {
      {
      if (pad != 45) {
        {
        {
        pad = '_';
        }
        }
      }
      }
    }
    do_number:
    {
    negative_number = (_Bool )(number_value < 0);
    u_number_value = (unsigned int )number_value;
    }
    do_signed_number:
    {
    always_output_a_sign = (_Bool)0;
    tz_colon_mask = 0;
    }
    do_number_body:
    if (modifier == 79) {
      {
      if (! negative_number) {
        {
        goto underlying_strftime;
        }
      }
      }
    }
    {
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
    }
    if (negative_number) {
      {
      {
      u_number_value = - u_number_value;
      }
      }
    }
    {
    while (1) {
      while_continue___23: ;
      if (! 1) {
        {
        goto while_break___23;
        }
      }
      if (tz_colon_mask & 1) {
        {
        {
        bufp --;
        *bufp = (char )':';
        }
        }
      }
      {
      tz_colon_mask >>= 1;
      bufp --;
      *bufp = (char )(u_number_value % 10U + 48U);
      u_number_value /= 10U;
      }
      if (! (u_number_value != 0U)) {
        {
        if (! (tz_colon_mask != 0)) {
          {
          goto while_break___23;
          }
        }
        }
      }
    }
    while_break___23: ;
    }
    do_number_sign_and_padding:
    if (digits < width) {
      {
      {
      digits = width;
      }
      }
    }
    if (negative_number) {
      {
      {
      sign_char = (char )'-';
      }
      }
    } else {
      {
      if (always_output_a_sign) {
        {
        {
        tmp___15 = '+';
        }
        }
      } else {
        {
        {
        tmp___15 = 0;
        }
        }
      }
      {
      sign_char = (char )tmp___15;
      }
      }
    }
    if (pad == 45) {
      {
      if (sign_char) {
        {
        {
        while (1) {
          while_continue___24: ;
          if (! 1) {
            {
            goto while_break___24;
            }
          }
          {
          _n___3 = (size_t )1;
          }
          if (width < 0) {
            {
            {
            tmp___16 = 0;
            }
            }
          } else {
            {
            {
            tmp___16 = width;
            }
            }
          }
          {
          _w___3 = (size_t )tmp___16;
          }
          if (_n___3 < _w___3) {
            {
            {
            tmp___17 = _w___3;
            }
            }
          } else {
            {
            {
            tmp___17 = _n___3;
            }
            }
          }
          {
          _incr___3 = tmp___17;
          }
          if (_incr___3 >= maxsize - i) {
            {
            return ((size_t )0);
            }
          }
          if (p) {
            {
            if (digits == 0) {
              {
              if (_n___3 < _w___3) {
                {
                {
                _delta___3 = (size_t )width - _n___3;
                }
                if (pad == 48) {
                  {
                  {
                  while (1) {
                    while_continue___25: ;
                    if (! 1) {
                      {
                      goto while_break___25;
                      }
                    }
                    {
                    _i___7 = (size_t )0;
                    }
                    {
                    while (1) {
                      while_continue___26: ;
                      if (! (_i___7 < _delta___3)) {
                        {
                        goto while_break___26;
                        }
                      }
                      {
                      fputc('0', p);
                      _i___7 ++;
                      }
                    }
                    while_break___26: ;
                    }
                    goto while_break___25;
                  }
                  while_break___25: ;
                  }
                  }
                } else {
                  {
                  {
                  while (1) {
                    while_continue___27: ;
                    if (! 1) {
                      {
                      goto while_break___27;
                      }
                    }
                    {
                    _i___8 = (size_t )0;
                    }
                    {
                    while (1) {
                      while_continue___28: ;
                      if (! (_i___8 < _delta___3)) {
                        {
                        goto while_break___28;
                        }
                      }
                      {
                      fputc(' ', p);
                      _i___8 ++;
                      }
                    }
                    while_break___28: ;
                    }
                    goto while_break___27;
                  }
                  while_break___27: ;
                  }
                  }
                }
                }
              }
              }
            }
            {
            fputc((int )sign_char, p);
            }
            }
          }
          {
          i += _incr___3;
          }
          goto while_break___24;
        }
        while_break___24: ;
        }
        }
      }
      }
    } else {
      {
      {
      padding = (int )(((long )digits - ((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp)) - (long )(! (! sign_char)));
      }
      if (padding > 0) {
        {
        if (pad == 95) {
          {
          if ((size_t )padding >= maxsize - i) {
            {
            return ((size_t )0);
            }
          }
          if (p) {
            {
            {
            while (1) {
              while_continue___29: ;
              if (! 1) {
                {
                goto while_break___29;
                }
              }
              {
              _i___9 = (size_t )0;
              }
              {
              while (1) {
                while_continue___30: ;
                if (! (_i___9 < (size_t )padding)) {
                  {
                  goto while_break___30;
                  }
                }
                {
                fputc(' ', p);
                _i___9 ++;
                }
              }
              while_break___30: ;
              }
              goto while_break___29;
            }
            while_break___29: ;
            }
            }
          }
          {
          i += (size_t )padding;
          }
          if (width > padding) {
            {
            {
            width -= padding;
            }
            }
          } else {
            {
            {
            width = 0;
            }
            }
          }
          if (sign_char) {
            {
            {
            while (1) {
              while_continue___31: ;
              if (! 1) {
                {
                goto while_break___31;
                }
              }
              {
              _n___4 = (size_t )1;
              }
              if (width < 0) {
                {
                {
                tmp___18 = 0;
                }
                }
              } else {
                {
                {
                tmp___18 = width;
                }
                }
              }
              {
              _w___4 = (size_t )tmp___18;
              }
              if (_n___4 < _w___4) {
                {
                {
                tmp___19 = _w___4;
                }
                }
              } else {
                {
                {
                tmp___19 = _n___4;
                }
                }
              }
              {
              _incr___4 = tmp___19;
              }
              if (_incr___4 >= maxsize - i) {
                {
                return ((size_t )0);
                }
              }
              if (p) {
                {
                if (digits == 0) {
                  {
                  if (_n___4 < _w___4) {
                    {
                    {
                    _delta___4 = (size_t )width - _n___4;
                    }
                    if (pad == 48) {
                      {
                      {
                      while (1) {
                        while_continue___32: ;
                        if (! 1) {
                          {
                          goto while_break___32;
                          }
                        }
                        {
                        _i___10 = (size_t )0;
                        }
                        {
                        while (1) {
                          while_continue___33: ;
                          if (! (_i___10 < _delta___4)) {
                            {
                            goto while_break___33;
                            }
                          }
                          {
                          fputc('0', p);
                          _i___10 ++;
                          }
                        }
                        while_break___33: ;
                        }
                        goto while_break___32;
                      }
                      while_break___32: ;
                      }
                      }
                    } else {
                      {
                      {
                      while (1) {
                        while_continue___34: ;
                        if (! 1) {
                          {
                          goto while_break___34;
                          }
                        }
                        {
                        _i___11 = (size_t )0;
                        }
                        {
                        while (1) {
                          while_continue___35: ;
                          if (! (_i___11 < _delta___4)) {
                            {
                            goto while_break___35;
                            }
                          }
                          {
                          fputc(' ', p);
                          _i___11 ++;
                          }
                        }
                        while_break___35: ;
                        }
                        goto while_break___34;
                      }
                      while_break___34: ;
                      }
                      }
                    }
                    }
                  }
                  }
                }
                {
                fputc((int )sign_char, p);
                }
                }
              }
              {
              i += _incr___4;
              }
              goto while_break___31;
            }
            while_break___31: ;
            }
            }
          }
          }
        } else {
          {
          if ((size_t )digits >= maxsize - i) {
            {
            return ((size_t )0);
            }
          }
          if (sign_char) {
            {
            {
            while (1) {
              while_continue___36: ;
              if (! 1) {
                {
                goto while_break___36;
                }
              }
              {
              _n___5 = (size_t )1;
              }
              if (width < 0) {
                {
                {
                tmp___20 = 0;
                }
                }
              } else {
                {
                {
                tmp___20 = width;
                }
                }
              }
              {
              _w___5 = (size_t )tmp___20;
              }
              if (_n___5 < _w___5) {
                {
                {
                tmp___21 = _w___5;
                }
                }
              } else {
                {
                {
                tmp___21 = _n___5;
                }
                }
              }
              {
              _incr___5 = tmp___21;
              }
              if (_incr___5 >= maxsize - i) {
                {
                return ((size_t )0);
                }
              }
              if (p) {
                {
                if (digits == 0) {
                  {
                  if (_n___5 < _w___5) {
                    {
                    {
                    _delta___5 = (size_t )width - _n___5;
                    }
                    if (pad == 48) {
                      {
                      {
                      while (1) {
                        while_continue___37: ;
                        if (! 1) {
                          {
                          goto while_break___37;
                          }
                        }
                        {
                        _i___12 = (size_t )0;
                        }
                        {
                        while (1) {
                          while_continue___38: ;
                          if (! (_i___12 < _delta___5)) {
                            {
                            goto while_break___38;
                            }
                          }
                          {
                          fputc('0', p);
                          _i___12 ++;
                          }
                        }
                        while_break___38: ;
                        }
                        goto while_break___37;
                      }
                      while_break___37: ;
                      }
                      }
                    } else {
                      {
                      {
                      while (1) {
                        while_continue___39: ;
                        if (! 1) {
                          {
                          goto while_break___39;
                          }
                        }
                        {
                        _i___13 = (size_t )0;
                        }
                        {
                        while (1) {
                          while_continue___40: ;
                          if (! (_i___13 < _delta___5)) {
                            {
                            goto while_break___40;
                            }
                          }
                          {
                          fputc(' ', p);
                          _i___13 ++;
                          }
                        }
                        while_break___40: ;
                        }
                        goto while_break___39;
                      }
                      while_break___39: ;
                      }
                      }
                    }
                    }
                  }
                  }
                }
                {
                fputc((int )sign_char, p);
                }
                }
              }
              {
              i += _incr___5;
              }
              goto while_break___36;
            }
            while_break___36: ;
            }
            }
          }
          if (p) {
            {
            {
            while (1) {
              while_continue___41: ;
              if (! 1) {
                {
                goto while_break___41;
                }
              }
              {
              _i___14 = (size_t )0;
              }
              {
              while (1) {
                while_continue___42: ;
                if (! (_i___14 < (size_t )padding)) {
                  {
                  goto while_break___42;
                  }
                }
                {
                fputc('0', p);
                _i___14 ++;
                }
              }
              while_break___42: ;
              }
              goto while_break___41;
            }
            while_break___41: ;
            }
            }
          }
          {
          i += (size_t )padding;
          width = 0;
          }
          }
        }
        }
      } else {
        {
        if (sign_char) {
          {
          {
          while (1) {
            while_continue___43: ;
            if (! 1) {
              {
              goto while_break___43;
              }
            }
            {
            _n___6 = (size_t )1;
            }
            if (width < 0) {
              {
              {
              tmp___22 = 0;
              }
              }
            } else {
              {
              {
              tmp___22 = width;
              }
              }
            }
            {
            _w___6 = (size_t )tmp___22;
            }
            if (_n___6 < _w___6) {
              {
              {
              tmp___23 = _w___6;
              }
              }
            } else {
              {
              {
              tmp___23 = _n___6;
              }
              }
            }
            {
            _incr___6 = tmp___23;
            }
            if (_incr___6 >= maxsize - i) {
              {
              return ((size_t )0);
              }
            }
            if (p) {
              {
              if (digits == 0) {
                {
                if (_n___6 < _w___6) {
                  {
                  {
                  _delta___6 = (size_t )width - _n___6;
                  }
                  if (pad == 48) {
                    {
                    {
                    while (1) {
                      while_continue___44: ;
                      if (! 1) {
                        {
                        goto while_break___44;
                        }
                      }
                      {
                      _i___15 = (size_t )0;
                      }
                      {
                      while (1) {
                        while_continue___45: ;
                        if (! (_i___15 < _delta___6)) {
                          {
                          goto while_break___45;
                          }
                        }
                        {
                        fputc('0', p);
                        _i___15 ++;
                        }
                      }
                      while_break___45: ;
                      }
                      goto while_break___44;
                    }
                    while_break___44: ;
                    }
                    }
                  } else {
                    {
                    {
                    while (1) {
                      while_continue___46: ;
                      if (! 1) {
                        {
                        goto while_break___46;
                        }
                      }
                      {
                      _i___16 = (size_t )0;
                      }
                      {
                      while (1) {
                        while_continue___47: ;
                        if (! (_i___16 < _delta___6)) {
                          {
                          goto while_break___47;
                          }
                        }
                        {
                        fputc(' ', p);
                        _i___16 ++;
                        }
                      }
                      while_break___47: ;
                      }
                      goto while_break___46;
                    }
                    while_break___46: ;
                    }
                    }
                  }
                  }
                }
                }
              }
              {
              fputc((int )sign_char, p);
              }
              }
            }
            {
            i += _incr___6;
            }
            goto while_break___43;
          }
          while_break___43: ;
          }
          }
        }
        }
      }
      }
    }
    {
    while (1) {
      while_continue___48: ;
      if (! 1) {
        {
        goto while_break___48;
        }
      }
      {
      _n___7 = (size_t )((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp);
      }
      if (width < 0) {
        {
        {
        tmp___24 = 0;
        }
        }
      } else {
        {
        {
        tmp___24 = width;
        }
        }
      }
      {
      _w___7 = (size_t )tmp___24;
      }
      if (_n___7 < _w___7) {
        {
        {
        tmp___25 = _w___7;
        }
        }
      } else {
        {
        {
        tmp___25 = _n___7;
        }
        }
      }
      {
      _incr___7 = tmp___25;
      }
      if (_incr___7 >= maxsize - i) {
        {
        return ((size_t )0);
        }
      }
      if (p) {
        {
        if (digits == 0) {
          {
          if (_n___7 < _w___7) {
            {
            {
            _delta___7 = (size_t )width - _n___7;
            }
            if (pad == 48) {
              {
              {
              while (1) {
                while_continue___49: ;
                if (! 1) {
                  {
                  goto while_break___49;
                  }
                }
                {
                _i___17 = (size_t )0;
                }
                {
                while (1) {
                  while_continue___50: ;
                  if (! (_i___17 < _delta___7)) {
                    {
                    goto while_break___50;
                    }
                  }
                  {
                  fputc('0', p);
                  _i___17 ++;
                  }
                }
                while_break___50: ;
                }
                goto while_break___49;
              }
              while_break___49: ;
              }
              }
            } else {
              {
              {
              while (1) {
                while_continue___51: ;
                if (! 1) {
                  {
                  goto while_break___51;
                  }
                }
                {
                _i___18 = (size_t )0;
                }
                {
                while (1) {
                  while_continue___52: ;
                  if (! (_i___18 < _delta___7)) {
                    {
                    goto while_break___52;
                    }
                  }
                  {
                  fputc(' ', p);
                  _i___18 ++;
                  }
                }
                while_break___52: ;
                }
                goto while_break___51;
              }
              while_break___51: ;
              }
              }
            }
            }
          }
          }
        }
        {
        while (1) {
          while_continue___53: ;
          if (! 1) {
            {
            goto while_break___53;
            }
          }
          if (to_lowcase) {
            {
            {
            fwrite_lowcase(p, (char const *)bufp, _n___7);
            }
            }
          } else {
            {
            if (to_uppcase) {
              {
              {
              fwrite_uppcase(p, (char const *)bufp, _n___7);
              }
              }
            } else {
              {
              {
              tmp___26 = rpl_fwrite((void const *)bufp, _n___7, (size_t )1, p);
              __x___0 = tmp___26;
              }
              }
            }
            }
          }
          goto while_break___53;
        }
        while_break___53: ;
        }
        }
      }
      {
      i += _incr___7;
      }
      goto while_break___48;
    }
    while_break___48: ;
    }
    goto switch_break___1;
    case_70:
    if (modifier != 0) {
      {
      goto switch_default___3;
      }
    }
    {
    subfmt = (char const *)"%Y-%m-%d";
    }
    goto subformat;
    case_72:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = (int )tp->tm_hour;
    }
    goto do_number;
    case_73:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = hour12;
    }
    goto do_number;
    case_107:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = (int )tp->tm_hour;
    }
    goto do_number_spacepad;
    case_108:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = hour12;
    }
    goto do_number_spacepad;
    case_106:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 3;
    negative_number = (_Bool )(tp->tm_yday < -1);
    u_number_value = (unsigned int )tp->tm_yday + 1U;
    }
    goto do_signed_number;
    case_77:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = (int )tp->tm_min;
    }
    goto do_number;
    case_109:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    negative_number = (_Bool )(tp->tm_mon < -1);
    u_number_value = (unsigned int )tp->tm_mon + 1U;
    }
    goto do_signed_number;
    case_78:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    number_value = ns;
    }
    if (width == -1) {
      {
      {
      width = 9;
      }
      }
    } else {
      {
      {
      j = width;
      }
      {
      while (1) {
        while_continue___54: ;
        if (! (j < 9)) {
          {
          goto while_break___54;
          }
        }
        {
        number_value /= 10;
        j ++;
        }
      }
      while_break___54: ;
      }
      }
    }
    {
    digits = width;
    number_value = number_value;
    }
    goto do_number;
    case_110:
    {
    while (1) {
      while_continue___55: ;
      if (! 1) {
        {
        goto while_break___55;
        }
      }
      {
      _n___8 = (size_t )1;
      }
      if (width < 0) {
        {
        {
        tmp___27 = 0;
        }
        }
      } else {
        {
        {
        tmp___27 = width;
        }
        }
      }
      {
      _w___8 = (size_t )tmp___27;
      }
      if (_n___8 < _w___8) {
        {
        {
        tmp___28 = _w___8;
        }
        }
      } else {
        {
        {
        tmp___28 = _n___8;
        }
        }
      }
      {
      _incr___8 = tmp___28;
      }
      if (_incr___8 >= maxsize - i) {
        {
        return ((size_t )0);
        }
      }
      if (p) {
        {
        if (digits == 0) {
          {
          if (_n___8 < _w___8) {
            {
            {
            _delta___8 = (size_t )width - _n___8;
            }
            if (pad == 48) {
              {
              {
              while (1) {
                while_continue___56: ;
                if (! 1) {
                  {
                  goto while_break___56;
                  }
                }
                {
                _i___19 = (size_t )0;
                }
                {
                while (1) {
                  while_continue___57: ;
                  if (! (_i___19 < _delta___8)) {
                    {
                    goto while_break___57;
                    }
                  }
                  {
                  fputc('0', p);
                  _i___19 ++;
                  }
                }
                while_break___57: ;
                }
                goto while_break___56;
              }
              while_break___56: ;
              }
              }
            } else {
              {
              {
              while (1) {
                while_continue___58: ;
                if (! 1) {
                  {
                  goto while_break___58;
                  }
                }
                {
                _i___20 = (size_t )0;
                }
                {
                while (1) {
                  while_continue___59: ;
                  if (! (_i___20 < _delta___8)) {
                    {
                    goto while_break___59;
                    }
                  }
                  {
                  fputc(' ', p);
                  _i___20 ++;
                  }
                }
                while_break___59: ;
                }
                goto while_break___58;
              }
              while_break___58: ;
              }
              }
            }
            }
          }
          }
        }
        {
        fputc('\n', p);
        }
        }
      }
      {
      i += _incr___8;
      }
      goto while_break___55;
    }
    while_break___55: ;
    }
    goto switch_break___1;
    case_80:
    {
    to_lowcase = (_Bool)1;
    format_char = 'p';
    }
    case_112:
    if (change_case) {
      {
      {
      to_uppcase = (_Bool)0;
      to_lowcase = (_Bool)1;
      }
      }
    }
    goto underlying_strftime;
    case_82:
    {
    subfmt = (char const *)"%H:%M";
    }
    goto subformat;
    case_114:
    goto underlying_strftime;
    case_83:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = (int )tp->tm_sec;
    }
    goto do_number;
    case_115:
    {
    ltm = (struct tm )*tp;
    t = mktime(& ltm);
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
    negative_number = (_Bool )(t < 0L);
    }
    {
    while (1) {
      while_continue___60: ;
      if (! 1) {
        {
        goto while_break___60;
        }
      }
      {
      d = (int )(t % 10L);
      t /= 10L;
      bufp --;
      }
      if (negative_number) {
        {
        {
        tmp___29 = - d;
        }
        }
      } else {
        {
        {
        tmp___29 = d;
        }
        }
      }
      {
      *bufp = (char )(tmp___29 + 48);
      }
      if (! (t != 0L)) {
        {
        goto while_break___60;
        }
      }
    }
    while_break___60: ;
    }
    {
    digits = 1;
    always_output_a_sign = (_Bool)0;
    }
    goto do_number_sign_and_padding;
    case_88:
    if (modifier == 79) {
      {
      goto switch_default___3;
      }
    }
    goto underlying_strftime;
    case_84:
    {
    subfmt = (char const *)"%H:%M:%S";
    }
    goto subformat;
    case_116:
    {
    while (1) {
      while_continue___61: ;
      if (! 1) {
        {
        goto while_break___61;
        }
      }
      {
      _n___9 = (size_t )1;
      }
      if (width < 0) {
        {
        {
        tmp___30 = 0;
        }
        }
      } else {
        {
        {
        tmp___30 = width;
        }
        }
      }
      {
      _w___9 = (size_t )tmp___30;
      }
      if (_n___9 < _w___9) {
        {
        {
        tmp___31 = _w___9;
        }
        }
      } else {
        {
        {
        tmp___31 = _n___9;
        }
        }
      }
      {
      _incr___9 = tmp___31;
      }
      if (_incr___9 >= maxsize - i) {
        {
        return ((size_t )0);
        }
      }
      if (p) {
        {
        if (digits == 0) {
          {
          if (_n___9 < _w___9) {
            {
            {
            _delta___9 = (size_t )width - _n___9;
            }
            if (pad == 48) {
              {
              {
              while (1) {
                while_continue___62: ;
                if (! 1) {
                  {
                  goto while_break___62;
                  }
                }
                {
                _i___21 = (size_t )0;
                }
                {
                while (1) {
                  while_continue___63: ;
                  if (! (_i___21 < _delta___9)) {
                    {
                    goto while_break___63;
                    }
                  }
                  {
                  fputc('0', p);
                  _i___21 ++;
                  }
                }
                while_break___63: ;
                }
                goto while_break___62;
              }
              while_break___62: ;
              }
              }
            } else {
              {
              {
              while (1) {
                while_continue___64: ;
                if (! 1) {
                  {
                  goto while_break___64;
                  }
                }
                {
                _i___22 = (size_t )0;
                }
                {
                while (1) {
                  while_continue___65: ;
                  if (! (_i___22 < _delta___9)) {
                    {
                    goto while_break___65;
                    }
                  }
                  {
                  fputc(' ', p);
                  _i___22 ++;
                  }
                }
                while_break___65: ;
                }
                goto while_break___64;
              }
              while_break___64: ;
              }
              }
            }
            }
          }
          }
        }
        {
        fputc('\t', p);
        }
        }
      }
      {
      i += _incr___9;
      }
      goto while_break___61;
    }
    while_break___61: ;
    }
    goto switch_break___1;
    case_117:
    {
    digits = 1;
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
    }
    goto do_number;
    case_85:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
    }
    goto do_number;
    case_71:
    case_103:
    case_86:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    if (tp->tm_year < 0) {
      {
      {
      tmp___32 = 300;
      }
      }
    } else {
      {
      {
      tmp___32 = -100;
      }
      }
    }
    {
    year___0 = (int )(tp->tm_year + (int )((int const )tmp___32));
    year_adjust = 0;
    tmp___33 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
    days = tmp___33;
    }
    if (days < 0) {
      {
      {
      year_adjust = -1;
      }
      if ((year___0 - 1) % 4 == 0) {
        {
        if ((year___0 - 1) % 100 != 0) {
          {
          {
          tmp___34 = 1;
          }
          }
        } else {
          {
          if ((year___0 - 1) % 400 == 0) {
            {
            {
            tmp___34 = 1;
            }
            }
          } else {
            {
            {
            tmp___34 = 0;
            }
            }
          }
          }
        }
        }
      } else {
        {
        {
        tmp___34 = 0;
        }
        }
      }
      {
      days = iso_week_days((int )(tp->tm_yday + (int )((int const )(365 + tmp___34))),
                           (int )tp->tm_wday);
      }
      }
    } else {
      {
      if (year___0 % 4 == 0) {
        {
        if (year___0 % 100 != 0) {
          {
          {
          tmp___35 = 1;
          }
          }
        } else {
          {
          if (year___0 % 400 == 0) {
            {
            {
            tmp___35 = 1;
            }
            }
          } else {
            {
            {
            tmp___35 = 0;
            }
            }
          }
          }
        }
        }
      } else {
        {
        {
        tmp___35 = 0;
        }
        }
      }
      {
      tmp___36 = iso_week_days((int )(tp->tm_yday - (int )((int const )(365 + tmp___35))),
                               (int )tp->tm_wday);
      d___0 = tmp___36;
      }
      if (0 <= d___0) {
        {
        {
        year_adjust = 1;
        days = d___0;
        }
        }
      }
      }
    }
    {
    if ((int )*f == 103) {
      {
      goto case_103___0;
      }
    }
    if ((int )*f == 71) {
      {
      goto case_71___0;
      }
    }
    goto switch_default___1;
    case_103___0:
    {
    yy = (int )((tp->tm_year % 100 + (int )((int const )year_adjust)) % 100);
    digits = 2;
    }
    if (0 <= yy) {
      {
      {
      number_value = yy;
      }
      }
    } else {
      {
      if (tp->tm_year < (int )((int const )(-1900 - year_adjust))) {
        {
        {
        tmp___37 = - yy;
        }
        }
      } else {
        {
        {
        tmp___37 = yy + 100;
        }
        }
      }
      {
      number_value = tmp___37;
      }
      }
    }
    goto do_number;
    case_71___0:
    {
    digits = 4;
    negative_number = (_Bool )(tp->tm_year < (int )((int const )(-1900 - year_adjust)));
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
    }
    goto do_signed_number;
    switch_default___1:
    {
    digits = 2;
    number_value = days / 7 + 1;
    }
    goto do_number;
    switch_break___2: ;
    }
    case_87:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
    }
    goto do_number;
    case_119:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 1;
    number_value = (int )tp->tm_wday;
    }
    goto do_number;
    case_89:
    if (modifier == 69) {
      {
      goto underlying_strftime;
      }
    }
    if (modifier == 79) {
      {
      goto switch_default___3;
      }
    } else {
      {
      {
      digits = 4;
      }
      }
    }
    {
    negative_number = (_Bool )(tp->tm_year < -1900);
    u_number_value = (unsigned int )tp->tm_year + 1900U;
    }
    goto do_signed_number;
    case_121:
    if (modifier == 69) {
      {
      goto underlying_strftime;
      }
    }
    {
    yy___0 = (int )(tp->tm_year % 100);
    }
    if (yy___0 < 0) {
      {
      if (tp->tm_year < -1900) {
        {
        {
        yy___0 = - yy___0;
        }
        }
      } else {
        {
        {
        yy___0 += 100;
        }
        }
      }
      }
    }
    {
    digits = 2;
    number_value = yy___0;
    }
    goto do_number;
    case_90:
    if (change_case) {
      {
      {
      to_uppcase = (_Bool)0;
      to_lowcase = (_Bool)1;
      }
      }
    }
    if (! zone) {
      {
      {
      zone = (char const *)"";
      }
      }
    }
    {
    while (1) {
      while_continue___66: ;
      if (! 1) {
        {
        goto while_break___66;
        }
      }
      {
      tmp___38 = strlen(zone);
      _n___10 = tmp___38;
      }
      if (width < 0) {
        {
        {
        tmp___39 = 0;
        }
        }
      } else {
        {
        {
        tmp___39 = width;
        }
        }
      }
      {
      _w___10 = (size_t )tmp___39;
      }
      if (_n___10 < _w___10) {
        {
        {
        tmp___40 = _w___10;
        }
        }
      } else {
        {
        {
        tmp___40 = _n___10;
        }
        }
      }
      {
      _incr___10 = tmp___40;
      }
      if (_incr___10 >= maxsize - i) {
        {
        return ((size_t )0);
        }
      }
      if (p) {
        {
        if (digits == 0) {
          {
          if (_n___10 < _w___10) {
            {
            {
            _delta___10 = (size_t )width - _n___10;
            }
            if (pad == 48) {
              {
              {
              while (1) {
                while_continue___67: ;
                if (! 1) {
                  {
                  goto while_break___67;
                  }
                }
                {
                _i___23 = (size_t )0;
                }
                {
                while (1) {
                  while_continue___68: ;
                  if (! (_i___23 < _delta___10)) {
                    {
                    goto while_break___68;
                    }
                  }
                  {
                  fputc('0', p);
                  _i___23 ++;
                  }
                }
                while_break___68: ;
                }
                goto while_break___67;
              }
              while_break___67: ;
              }
              }
            } else {
              {
              {
              while (1) {
                while_continue___69: ;
                if (! 1) {
                  {
                  goto while_break___69;
                  }
                }
                {
                _i___24 = (size_t )0;
                }
                {
                while (1) {
                  while_continue___70: ;
                  if (! (_i___24 < _delta___10)) {
                    {
                    goto while_break___70;
                    }
                  }
                  {
                  fputc(' ', p);
                  _i___24 ++;
                  }
                }
                while_break___70: ;
                }
                goto while_break___69;
              }
              while_break___69: ;
              }
              }
            }
            }
          }
          }
        }
        {
        while (1) {
          while_continue___71: ;
          if (! 1) {
            {
            goto while_break___71;
            }
          }
          if (to_lowcase) {
            {
            {
            fwrite_lowcase(p, zone, _n___10);
            }
            }
          } else {
            {
            if (to_uppcase) {
              {
              {
              fwrite_uppcase(p, zone, _n___10);
              }
              }
            } else {
              {
              {
              tmp___41 = rpl_fwrite((void const *)zone, _n___10, (size_t )1, p);
              __x___1 = tmp___41;
              }
              }
            }
            }
          }
          goto while_break___71;
        }
        while_break___71: ;
        }
        }
      }
      {
      i += _incr___10;
      }
      goto while_break___66;
    }
    while_break___66: ;
    }
    goto switch_break___1;
    case_58:
    {
    colons = (size_t )1;
    }
    {
    while (1) {
      while_continue___72: ;
      if (! ((int const )*(f + colons) == 58)) {
        {
        goto while_break___72;
        }
      }
      goto __Cont___0;
      __Cont___0:
      {
      colons ++;
      }
    }
    while_break___72: ;
    }
    if ((int const )*(f + colons) != 122) {
      {
      goto switch_default___3;
      }
    }
    {
    f += colons;
    }
    goto do_z_conversion;
    case_122:
    {
    colons = (size_t )0;
    }
    do_z_conversion:
    if (tp->tm_isdst < 0) {
      {
      goto switch_break___1;
      }
    }
    {
    diff = (int )tp->tm_gmtoff;
    hour_diff = (diff / 60) / 60;
    min_diff = (diff / 60) % 60;
    sec_diff = diff % 60;
    }
    {
    if ((int )colons == 0) {
      {
      goto case_0;
      }
    }
    if ((int )colons == 1) {
      {
      goto case_1;
      }
    }
    if ((int )colons == 2) {
      {
      goto case_2;
      }
    }
    if ((int )colons == 3) {
      {
      goto case_3;
      }
    }
    goto switch_default___2;
    case_0:
    {
    digits = 5;
    negative_number = (_Bool )(diff < 0);
    tz_colon_mask = 0;
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
    }
    goto do_tz_offset;
    case_1:
    tz_hh_mm:
    {
    digits = 6;
    negative_number = (_Bool )(diff < 0);
    tz_colon_mask = 4;
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
    }
    goto do_tz_offset;
    case_2:
    tz_hh_mm_ss:
    {
    digits = 9;
    negative_number = (_Bool )(diff < 0);
    tz_colon_mask = 20;
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
    }
    goto do_tz_offset;
    case_3:
    if (sec_diff != 0) {
      {
      goto case_2;
      }
    }
    if (min_diff != 0) {
      {
      goto case_1;
      }
    }
    {
    digits = 3;
    negative_number = (_Bool )(diff < 0);
    tz_colon_mask = 0;
    u_number_value = (unsigned int )hour_diff;
    }
    goto do_tz_offset;
    switch_default___2:
    goto switch_default___3;
    switch_break___3: ;
    }
    case_0___0:
    {
    f --;
    }
    switch_default___3:
    bad_format:
    {
    flen = 1;
    }
    {
    while (1) {
      while_continue___73: ;
      if (! ((int const )*(f + (1 - flen)) != 37)) {
        {
        goto while_break___73;
        }
      }
      goto __Cont___1;
      __Cont___1:
      {
      flen ++;
      }
    }
    while_break___73: ;
    }
    {
    while (1) {
      while_continue___74: ;
      if (! 1) {
        {
        goto while_break___74;
        }
      }
      {
      _n___11 = (size_t )flen;
      }
      if (width < 0) {
        {
        {
        tmp___42 = 0;
        }
        }
      } else {
        {
        {
        tmp___42 = width;
        }
        }
      }
      {
      _w___11 = (size_t )tmp___42;
      }
      if (_n___11 < _w___11) {
        {
        {
        tmp___43 = _w___11;
        }
        }
      } else {
        {
        {
        tmp___43 = _n___11;
        }
        }
      }
      {
      _incr___11 = tmp___43;
      }
      if (_incr___11 >= maxsize - i) {
        {
        return ((size_t )0);
        }
      }
      if (p) {
        {
        if (digits == 0) {
          {
          if (_n___11 < _w___11) {
            {
            {
            _delta___11 = (size_t )width - _n___11;
            }
            if (pad == 48) {
              {
              {
              while (1) {
                while_continue___75: ;
                if (! 1) {
                  {
                  goto while_break___75;
                  }
                }
                {
                _i___25 = (size_t )0;
                }
                {
                while (1) {
                  while_continue___76: ;
                  if (! (_i___25 < _delta___11)) {
                    {
                    goto while_break___76;
                    }
                  }
                  {
                  fputc('0', p);
                  _i___25 ++;
                  }
                }
                while_break___76: ;
                }
                goto while_break___75;
              }
              while_break___75: ;
              }
              }
            } else {
              {
              {
              while (1) {
                while_continue___77: ;
                if (! 1) {
                  {
                  goto while_break___77;
                  }
                }
                {
                _i___26 = (size_t )0;
                }
                {
                while (1) {
                  while_continue___78: ;
                  if (! (_i___26 < _delta___11)) {
                    {
                    goto while_break___78;
                    }
                  }
                  {
                  fputc(' ', p);
                  _i___26 ++;
                  }
                }
                while_break___78: ;
                }
                goto while_break___77;
              }
              while_break___77: ;
              }
              }
            }
            }
          }
          }
        }
        {
        while (1) {
          while_continue___79: ;
          if (! 1) {
            {
            goto while_break___79;
            }
          }
          if (to_lowcase) {
            {
            {
            fwrite_lowcase(p, f + (1 - flen), _n___11);
            }
            }
          } else {
            {
            if (to_uppcase) {
              {
              {
              fwrite_uppcase(p, f + (1 - flen), _n___11);
              }
              }
            } else {
              {
              {
              tmp___44 = rpl_fwrite((void const *)(f + (1 - flen)), _n___11, (size_t )1,
                                    p);
              __x___2 = tmp___44;
              }
              }
            }
            }
          }
          goto while_break___79;
        }
        while_break___79: ;
        }
        }
      }
      {
      i += _incr___11;
      }
      goto while_break___74;
    }
    while_break___74: ;
    }
    goto switch_break___1;
    switch_break___1: ;
    }
    __Cont:
    {
    f ++;
    }
  }
  while_break: ;
  }
  return (i);
}
}
size_t fprintftime(FILE *s , char const *format , struct tm const *tp , int ut ,
                   int ns )
{
  size_t tmp ;
  {
  {
  tmp = strftime_case_((_Bool)0, s, format, tp, ut, ns);
  }
  return (tmp);
}
}
size_t freadahead(FILE *fp )
{
  int tmp ;
  {
  if ((unsigned long )fp->_IO_write_ptr > (unsigned long )fp->_IO_write_base) {
    {
    return ((size_t )0);
    }
  }
  if (fp->_flags & 256) {
    {
    {
    tmp = (int )(fp->_IO_save_end - fp->_IO_save_base);
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  return ((size_t )((fp->_IO_read_end - fp->_IO_read_ptr) + (long )tmp));
}
}
char const *freadptr(FILE *fp , size_t *sizep )
{
  size_t size ;
  {
  if ((unsigned long )fp->_IO_write_ptr > (unsigned long )fp->_IO_write_base) {
    {
    return ((char const *)((void *)0));
    }
  }
  {
  size = (size_t )(fp->_IO_read_end - fp->_IO_read_ptr);
  }
  if (size == 0UL) {
    {
    return ((char const *)((void *)0));
    }
  }
  {
  *sizep = size;
  }
  return ((char const *)fp->_IO_read_ptr);
}
}
__inline static void freadptrinc(FILE *fp , size_t increment )
{
  {
  {
  fp->_IO_read_ptr += increment;
  }
  return;
}
}
int freadseek(FILE *fp , size_t offset )
{
  size_t total_buffered ;
  int fd ;
  size_t buffered ;
  size_t increment ;
  size_t tmp ;
  char const *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char buf___1[4096] ;
  size_t count ;
  unsigned long tmp___3 ;
  size_t tmp___4 ;
  __off_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  {
  if (offset == 0UL) {
    {
    return (0);
    }
  }
  {
  total_buffered = freadahead(fp);
  }
  {
  while (1) {
    while_continue: ;
    if (! (total_buffered > 0UL)) {
      {
      goto while_break;
      }
    }
    {
    tmp___0 = freadptr(fp, & buffered);
    }
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      {
      if (buffered > 0UL) {
        {
        if (buffered < offset) {
          {
          {
          tmp = buffered;
          }
          }
        } else {
          {
          {
          tmp = offset;
          }
          }
        }
        {
        increment = tmp;
        freadptrinc(fp, increment);
        offset -= increment;
        }
        if (offset == 0UL) {
          {
          return (0);
          }
        }
        {
        total_buffered -= increment;
        }
        if (total_buffered == 0UL) {
          {
          goto while_break;
          }
        }
        }
      }
      }
    }
    {
    tmp___1 = fgetc(fp);
    }
    if (tmp___1 == -1) {
      {
      goto eof;
      }
    }
    {
    offset --;
    }
    if (offset == 0UL) {
      {
      return (0);
      }
    }
    {
    total_buffered --;
    }
  }
  while_break: ;
  }
  {
  fd = fileno(fp);
  }
  if (fd >= 0) {
    {
    {
    tmp___5 = lseek(fd, (__off_t )0, 1);
    }
    if (tmp___5 >= 0L) {
      {
      {
      tmp___2 = rpl_fseeko(fp, (off_t )offset, 1);
      }
      return (tmp___2);
      }
    } else {
      {
      goto _L;
      }
    }
    }
  } else {
    {
    _L:
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      if (sizeof(buf___1) < offset) {
        {
        {
        tmp___3 = sizeof(buf___1);
        }
        }
      } else {
        {
        {
        tmp___3 = offset;
        }
        }
      }
      {
      count = tmp___3;
      tmp___8 = fread((void *)((void * __restrict )(buf___1)), (size_t )1, count,
                      (FILE *)((FILE * __restrict )fp));
      tmp___7 = tmp___8;
      tmp___4 = tmp___7;
      }
      if (tmp___4 < count) {
        {
        goto eof;
        }
      }
      {
      offset -= count;
      }
      if (! (offset > 0UL)) {
        {
        goto while_break___0;
        }
      }
    }
    while_break___0: ;
    }
    return (0);
    }
  }
  eof:
  {
  tmp___6 = ferror(fp);
  }
  if (tmp___6) {
    {
    return (-1);
    }
  } else {
    {
    return (0);
    }
  }
}
}
static _Bool protect_fd(int fd )
{
  int value ;
  int tmp ;
  int *tmp___0 ;
  {
  {
  tmp = open((char const *)"/dev/null", 0);
  value = tmp;
  }
  if (value != fd) {
    {
    if (0 <= value) {
      {
      {
      close(value);
      tmp___0 = __errno_location();
      *tmp___0 = 9;
      }
      }
    }
    return ((_Bool)0);
    }
  }
  return ((_Bool)1);
}
}
FILE *freopen_safer(char const *name , char const *mode , FILE *f )
{
  _Bool protect_in ;
  _Bool protect_out ;
  _Bool protect_err ;
  int saved_errno ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  {
  {
  protect_in = (_Bool)0;
  protect_out = (_Bool)0;
  protect_err = (_Bool)0;
  tmp = fileno(f);
  }
  {
  if (tmp == 2) {
    {
    goto case_2;
    }
  }
  if (tmp == 1) {
    {
    goto case_1;
    }
  }
  if (tmp == 0) {
    {
    goto case_0;
    }
  }
  goto switch_default;
  switch_default:
  {
  tmp___0 = dup2(2, 2);
  }
  if (tmp___0 != 2) {
    {
    {
    protect_err = (_Bool)1;
    }
    }
  }
  case_2:
  {
  tmp___1 = dup2(1, 1);
  }
  if (tmp___1 != 1) {
    {
    {
    protect_out = (_Bool)1;
    }
    }
  }
  case_1:
  {
  tmp___2 = dup2(0, 0);
  }
  if (tmp___2 != 0) {
    {
    {
    protect_in = (_Bool)1;
    }
    }
  }
  case_0:
  goto switch_break;
  switch_break: ;
  }
  if (protect_in) {
    {
    {
    tmp___5 = protect_fd(0);
    }
    if (tmp___5) {
      {
      goto _L___0;
      }
    } else {
      {
      {
      f = (FILE *)((void *)0);
      }
      }
    }
    }
  } else {
    {
    _L___0:
    if (protect_out) {
      {
      {
      tmp___4 = protect_fd(1);
      }
      if (tmp___4) {
        {
        goto _L;
        }
      } else {
        {
        {
        f = (FILE *)((void *)0);
        }
        }
      }
      }
    } else {
      {
      _L:
      if (protect_err) {
        {
        {
        tmp___3 = protect_fd(2);
        }
        if (tmp___3) {
          {
          {
          f = freopen((char const * __restrict )name, (char const * __restrict )mode,
                      (FILE * __restrict )f);
          }
          }
        } else {
          {
          {
          f = (FILE *)((void *)0);
          }
          }
        }
        }
      } else {
        {
        {
        f = freopen((char const * __restrict )name, (char const * __restrict )mode,
                    (FILE * __restrict )f);
        }
        }
      }
      }
    }
    }
  }
  {
  tmp___6 = __errno_location();
  saved_errno = *tmp___6;
  }
  if (protect_err) {
    {
    {
    close(2);
    }
    }
  }
  if (protect_out) {
    {
    {
    close(1);
    }
    }
  }
  if (protect_in) {
    {
    {
    close(0);
    }
    }
  }
  if (! f) {
    {
    {
    tmp___7 = __errno_location();
    *tmp___7 = saved_errno;
    }
    }
  }
  return (f);
}
}
void fseterr(FILE *fp )
{
  {
  {
  fp->_flags |= 32;
  }
  return;
}
}
int ftoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , float x )
{
  char format[sizeof("%-+ 0*.*Lg")] ;
  float abs_x ;
  float tmp ;
  int prec ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int n ;
  int tmp___5 ;
  float tmp___6 ;
  {
  if (x < (float )0) {
    {
    {
    tmp = - x;
    }
    }
  } else {
    {
    {
    tmp = x;
    }
    }
  }
  {
  abs_x = tmp;
  p = format;
  tmp___0 = p;
  p ++;
  *tmp___0 = (char )'%';
  *p = (char )'-';
  p += (flags & 1) != 0;
  *p = (char )'+';
  p += (flags & 2) != 0;
  *p = (char )' ';
  p += (flags & 4) != 0;
  *p = (char )'0';
  p += (flags & 8) != 0;
  tmp___1 = p;
  p ++;
  *tmp___1 = (char )'*';
  tmp___2 = p;
  p ++;
  *tmp___2 = (char )'.';
  tmp___3 = p;
  p ++;
  *tmp___3 = (char )'*';
  *p = (char )'L';
  p += 0;
  tmp___4 = p;
  p ++;
  }
  if (flags & 16) {
    {
    {
    *tmp___4 = (char )'G';
    }
    }
  } else {
    {
    {
    *tmp___4 = (char )'g';
    }
    }
  }
  {
  *p = (char )'\000';
  }
  if (abs_x < 1.17549435082228750797e-38F) {
    {
    {
    prec = 1;
    }
    }
  } else {
    {
    {
    prec = 6;
    }
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___5 = snprintf((char *)((char * __restrict )buf___1), bufsize___0, (char const *)((char const * __restrict )(format)),
                       width, prec, (double )x);
    n = tmp___5;
    }
    if (n < 0) {
      {
      return (n);
      }
    } else {
      {
      if (9 <= prec) {
        {
        return (n);
        }
      } else {
        {
        if ((size_t )n < bufsize___0) {
          {
          {
          tmp___6 = strtof((char const * __restrict )buf___1, (char ** __restrict )((void *)0));
          }
          if (tmp___6 == x) {
            {
            return (n);
            }
          }
          }
        }
        }
      }
      }
    }
    {
    prec ++;
    }
  }
  while_break: ;
  }
  return (0);
}
}
size_t full_read(int fd , void *buf___1 , size_t count )
{
  size_t total ;
  char *ptr ;
  size_t n_rw ;
  size_t tmp ;
  int *tmp___0 ;
  {
  {
  total = (size_t )0;
  ptr = (char *)buf___1;
  }
  {
  while (1) {
    while_continue: ;
    if (! (count > 0UL)) {
      {
      goto while_break;
      }
    }
    {
    tmp = safe_read(fd, (void *)ptr, count);
    n_rw = tmp;
    }
    if (n_rw == 0xffffffffffffffffUL) {
      {
      goto while_break;
      }
    }
    if (n_rw == 0UL) {
      {
      {
      tmp___0 = __errno_location();
      *tmp___0 = 0;
      }
      goto while_break;
      }
    }
    {
    total += n_rw;
    ptr += n_rw;
    count -= n_rw;
    }
  }
  while_break: ;
  }
  return (total);
}
}
size_t full_write(int fd , void const *buf___1 , size_t count )
{
  size_t total ;
  char const *ptr ;
  size_t n_rw ;
  size_t tmp ;
  int *tmp___0 ;
  {
  {
  total = (size_t )0;
  ptr = (char const *)buf___1;
  }
  {
  while (1) {
    while_continue: ;
    if (! (count > 0UL)) {
      {
      goto while_break;
      }
    }
    {
    tmp = safe_write(fd, (void const *)ptr, count);
    n_rw = tmp;
    }
    if (n_rw == 0xffffffffffffffffUL) {
      {
      goto while_break;
      }
    }
    if (n_rw == 0UL) {
      {
      {
      tmp___0 = __errno_location();
      *tmp___0 = 28;
      }
      goto while_break;
      }
    }
    {
    total += n_rw;
    ptr += n_rw;
    count -= n_rw;
    }
  }
  while_break: ;
  }
  return (total);
}
}
ssize_t getndelim2(char **lineptr , size_t *linesize , size_t offset , size_t nmax ,
                   int delim1 , int delim2 , FILE *stream )
{
  size_t nbytes_avail ;
  char *read_pos ;
  ssize_t bytes_stored ;
  char *ptr ;
  size_t size ;
  _Bool found_delimiter ;
  void *tmp ;
  int c ;
  char const *buffer ;
  size_t buffer_len ;
  char const *end ;
  void *tmp___0 ;
  size_t newsize ;
  size_t tmp___1 ;
  char *newptr ;
  size_t newsizemax ;
  void *tmp___2 ;
  size_t copy_len ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  {
  {
  bytes_stored = (ssize_t )-1;
  ptr = *lineptr;
  size = *linesize;
  }
  if (! ptr) {
    {
    if (nmax < 64UL) {
      {
      {
      size = nmax;
      }
      }
    } else {
      {
      {
      size = (size_t )64;
      }
      }
    }
    {
    tmp = malloc(size);
    ptr = (char *)tmp;
    }
    if (! ptr) {
      {
      return ((ssize_t )-1);
      }
    }
    }
  }
  if (size < offset) {
    {
    goto done;
    }
  }
  {
  nbytes_avail = size - offset;
  read_pos = ptr + offset;
  }
  if (nbytes_avail == 0UL) {
    {
    if (nmax <= size) {
      {
      goto done;
      }
    }
    }
  }
  if (delim1 == -1) {
    {
    {
    delim1 = delim2;
    }
    }
  } else {
    {
    if (delim2 == -1) {
      {
      {
      delim2 = delim1;
      }
      }
    }
    }
  }
  {
  found_delimiter = (_Bool)0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    buffer = freadptr(stream, & buffer_len);
    }
    if (buffer) {
      {
      if (delim1 != -1) {
        {
        {
        tmp___0 = memchr2((void const *)buffer, delim1, delim2, buffer_len);
        end = (char const *)tmp___0;
        }
        if (end) {
          {
          {
          buffer_len = (size_t )((end - buffer) + 1L);
          found_delimiter = (_Bool)1;
          }
          }
        }
        }
      }
      }
    } else {
      {
      {
      c = getc_unlocked(stream);
      }
      if (c == -1) {
        {
        if ((unsigned long )read_pos == (unsigned long )ptr) {
          {
          goto unlock_done;
          }
        } else {
          {
          goto while_break;
          }
        }
        }
      }
      if (c == delim1) {
        {
        {
        found_delimiter = (_Bool)1;
        }
        }
      } else {
        {
        if (c == delim2) {
          {
          {
          found_delimiter = (_Bool)1;
          }
          }
        }
        }
      }
      {
      buffer_len = (size_t )1;
      }
      }
    }
    if (nbytes_avail < buffer_len + 1UL) {
      {
      if (size < nmax) {
        {
        if (size < 64UL) {
          {
          {
          tmp___1 = size + 64UL;
          }
          }
        } else {
          {
          {
          tmp___1 = 2UL * size;
          }
          }
        }
        {
        newsize = tmp___1;
        }
        if (newsize - (size_t )(read_pos - ptr) < buffer_len + 1UL) {
          {
          {
          newsize = ((size_t )(read_pos - ptr) + buffer_len) + 1UL;
          }
          }
        }
        if (size < newsize) {
          {
          if (! (newsize <= nmax)) {
            {
            {
            newsize = nmax;
            }
            }
          }
          }
        } else {
          {
          {
          newsize = nmax;
          }
          }
        }
        if (9223372036854775807UL < newsize - offset) {
          {
          {
          newsizemax = (offset + 9223372036854775807UL) + 1UL;
          }
          if (size == newsizemax) {
            {
            goto unlock_done;
            }
          }
          {
          newsize = newsizemax;
          }
          }
        }
        {
        nbytes_avail = newsize - (size_t )(read_pos - ptr);
        tmp___2 = realloc((void *)ptr, newsize);
        newptr = (char *)tmp___2;
        }
        if (! newptr) {
          {
          goto unlock_done;
          }
        }
        {
        ptr = newptr;
        size = newsize;
        read_pos = ptr + (size - nbytes_avail);
        }
        }
      }
      }
    }
    if (1UL < nbytes_avail) {
      {
      {
      copy_len = nbytes_avail - 1UL;
      }
      if (buffer_len < copy_len) {
        {
        {
        copy_len = buffer_len;
        }
        }
      }
      if (buffer) {
        {
        {
        memcpy((void *)((void * __restrict )read_pos), (void const *)((void const * __restrict )buffer),
               copy_len);
        }
        }
      } else {
        {
        {
        *read_pos = (char )c;
        }
        }
      }
      {
      read_pos += copy_len;
      nbytes_avail -= copy_len;
      }
      }
    }
    if (buffer) {
      {
      {
      tmp___3 = freadseek(stream, buffer_len);
      }
      if (tmp___3) {
        {
        goto unlock_done;
        }
      }
      }
    }
    if (! (! found_delimiter)) {
      {
      goto while_break;
      }
    }
  }
  while_break: ;
  }
  {
  *read_pos = (char )'\000';
  bytes_stored = read_pos - (ptr + offset);
  }
  unlock_done:
  {
  }
  done:
  {
  *lineptr = ptr;
  *linesize = size;
  }
  if (bytes_stored) {
    {
    {
    tmp___4 = bytes_stored;
    }
    }
  } else {
    {
    {
    tmp___4 = (ssize_t )-1;
    }
    }
  }
  return (tmp___4);
}
}
void gettime(struct timespec *ts )
{
  int tmp ;
  struct timeval tv ;
  {
  {
  tmp = clock_gettime(0, ts);
  }
  if (tmp == 0) {
    {
    return;
    }
  }
  {
  gettimeofday((struct timeval * __restrict )(& tv), (__timezone_ptr_t )((void *)0));
  ts->tv_sec = tv.tv_sec;
  ts->tv_nsec = tv.tv_usec * 1000L;
  }
  return;
}
}
int getugroups(int maxcount , gid_t *grouplist , char const *username , gid_t gid )
{
  int count ;
  char **cp ;
  struct group *grp ;
  int *tmp ;
  int n ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int saved_errno ;
  int *tmp___9 ;
  int *tmp___10 ;
  {
  {
  count = 0;
  }
  if (gid != 4294967295U) {
    {
    if (maxcount != 0) {
      {
      {
      *(grouplist + count) = gid;
      }
      }
    }
    {
    count ++;
    }
    }
  }
  {
  setgrent();
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp = __errno_location();
    *tmp = 0;
    grp = getgrent();
    }
    if ((unsigned long )grp == (unsigned long )((void *)0)) {
      {
      goto while_break;
      }
    }
    {
    cp = grp->gr_mem;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! *cp) {
        {
        goto while_break___0;
        }
      }
      if (0) {
        {
        {
        __s1_len = __builtin_strlen(username);
        __s2_len = __builtin_strlen((char const *)*cp);
        }
        if (! ((size_t )((void const *)(username + 1)) - (size_t )((void const *)username) == 1UL)) {
          {
          goto _L___0;
          }
        } else {
          {
          if (__s1_len >= 4UL) {
            {
            _L___0:
            if (! ((size_t )((void const *)(*cp + 1)) - (size_t )((void const *)*cp) == 1UL)) {
              {
              {
              tmp___6 = 1;
              }
              }
            } else {
              {
              if (__s2_len >= 4UL) {
                {
                {
                tmp___6 = 1;
                }
                }
              } else {
                {
                {
                tmp___6 = 0;
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            tmp___6 = 0;
            }
            }
          }
          }
        }
        if (tmp___6) {
          {
          {
          tmp___1 = __builtin_strcmp(username, (char const *)*cp);
          tmp___5 = tmp___1;
          }
          }
        } else {
          {
          {
          tmp___4 = __builtin_strcmp(username, (char const *)*cp);
          tmp___5 = tmp___4;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___4 = __builtin_strcmp(username, (char const *)*cp);
        tmp___5 = tmp___4;
        }
        }
      }
      if (! (tmp___5 == 0)) {
        {
        goto __Cont;
        }
      }
      {
      n = 0;
      }
      {
      while (1) {
        while_continue___1: ;
        if (! (n < count)) {
          {
          goto while_break___1;
          }
        }
        if (grouplist) {
          {
          if (*(grouplist + n) == grp->gr_gid) {
            {
            goto while_break___1;
            }
          }
          }
        }
        {
        n ++;
        }
      }
      while_break___1: ;
      }
      if (n == count) {
        {
        if (maxcount != 0) {
          {
          if (count >= maxcount) {
            {
            goto done;
            }
          }
          {
          *(grouplist + count) = grp->gr_gid;
          }
          }
        }
        if (count == 2147483647) {
          {
          {
          tmp___7 = __errno_location();
          *tmp___7 = 75;
          }
          goto done;
          }
        }
        {
        count ++;
        }
        }
      }
      __Cont:
      {
      cp ++;
      }
    }
    while_break___0: ;
    }
  }
  while_break: ;
  }
  {
  tmp___8 = __errno_location();
  }
  if (*tmp___8 != 0) {
    {
    {
    count = -1;
    }
    }
  }
  done:
  {
  tmp___9 = __errno_location();
  saved_errno = *tmp___9;
  endgrent();
  tmp___10 = __errno_location();
  *tmp___10 = saved_errno;
  }
  return (count);
}
}
_Bool hard_locale(int category )
{
  _Bool hard ;
  char const *p ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *locale ;
  char *tmp___19 ;
  char *tmp___20 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  {
  {
  hard = (_Bool)1;
  tmp = setlocale(category, (char const *)((void *)0));
  p = (char const *)tmp;
  }
  if (p) {
    {
    if (1) {
      {
      if (0) {
        {
        {
        __s1_len = __builtin_strlen(p);
        __s2_len = __builtin_strlen((char const *)"C");
        }
        if (! ((size_t )((void const *)(p + 1)) - (size_t )((void const *)p) == 1UL)) {
          {
          goto _L___0;
          }
        } else {
          {
          if (__s1_len >= 4UL) {
            {
            _L___0:
            if (! ((size_t )((void const *)("C" + 1)) - (size_t )((void const *)"C") == 1UL)) {
              {
              {
              tmp___6 = 1;
              }
              }
            } else {
              {
              if (__s2_len >= 4UL) {
                {
                {
                tmp___6 = 1;
                }
                }
              } else {
                {
                {
                tmp___6 = 0;
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            tmp___6 = 0;
            }
            }
          }
          }
        }
        if (tmp___6) {
          {
          {
          tmp___1 = __builtin_strcmp(p, (char const *)"C");
          tmp___5 = tmp___1;
          }
          }
        } else {
          {
          {
          tmp___4 = __builtin_strcmp(p, (char const *)"C");
          tmp___5 = tmp___4;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___4 = __builtin_strcmp(p, (char const *)"C");
        tmp___5 = tmp___4;
        }
        }
      }
      if (tmp___5 == 0) {
        {
        {
        hard = (_Bool)0;
        }
        }
      } else {
        {
        if (0) {
          {
          {
          __s1_len___0 = __builtin_strlen(p);
          __s2_len___0 = __builtin_strlen((char const *)"POSIX");
          }
          if (! ((size_t )((void const *)(p + 1)) - (size_t )((void const *)p) == 1UL)) {
            {
            goto _L___2;
            }
          } else {
            {
            if (__s1_len___0 >= 4UL) {
              {
              _L___2:
              if (! ((size_t )((void const *)("POSIX" + 1)) - (size_t )((void const *)"POSIX") == 1UL)) {
                {
                {
                tmp___13 = 1;
                }
                }
              } else {
                {
                if (__s2_len___0 >= 4UL) {
                  {
                  {
                  tmp___13 = 1;
                  }
                  }
                } else {
                  {
                  {
                  tmp___13 = 0;
                  }
                  }
                }
                }
              }
              }
            } else {
              {
              {
              tmp___13 = 0;
              }
              }
            }
            }
          }
          if (tmp___13) {
            {
            {
            tmp___8 = __builtin_strcmp(p, (char const *)"POSIX");
            tmp___12 = tmp___8;
            }
            }
          } else {
            {
            {
            tmp___11 = __builtin_strcmp(p, (char const *)"POSIX");
            tmp___12 = tmp___11;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___11 = __builtin_strcmp(p, (char const *)"POSIX");
          tmp___12 = tmp___11;
          }
          }
        }
        if (tmp___12 == 0) {
          {
          {
          hard = (_Bool)0;
          }
          }
        }
        }
      }
      }
    } else {
      {
      {
      tmp___19 = __strdup(p);
      locale = tmp___19;
      }
      if (locale) {
        {
        {
        tmp___20 = setlocale(category, (char const *)"C");
        p = (char const *)tmp___20;
        }
        if (p) {
          {
          if (0) {
            {
            {
            __s1_len___1 = __builtin_strlen(p);
            __s2_len___1 = __builtin_strlen((char const *)locale);
            }
            if (! ((size_t )((void const *)(p + 1)) - (size_t )((void const *)p) == 1UL)) {
              {
              goto _L___4;
              }
            } else {
              {
              if (__s1_len___1 >= 4UL) {
                {
                _L___4:
                if (! ((size_t )((void const *)(locale + 1)) - (size_t )((void const *)locale) == 1UL)) {
                  {
                  {
                  tmp___27 = 1;
                  }
                  }
                } else {
                  {
                  if (__s2_len___1 >= 4UL) {
                    {
                    {
                    tmp___27 = 1;
                    }
                    }
                  } else {
                    {
                    {
                    tmp___27 = 0;
                    }
                    }
                  }
                  }
                }
                }
              } else {
                {
                {
                tmp___27 = 0;
                }
                }
              }
              }
            }
            if (tmp___27) {
              {
              {
              tmp___22 = __builtin_strcmp(p, (char const *)locale);
              tmp___26 = tmp___22;
              }
              }
            } else {
              {
              {
              tmp___25 = __builtin_strcmp(p, (char const *)locale);
              tmp___26 = tmp___25;
              }
              }
            }
            }
          } else {
            {
            {
            tmp___25 = __builtin_strcmp(p, (char const *)locale);
            tmp___26 = tmp___25;
            }
            }
          }
          if (tmp___26 == 0) {
            {
            {
            hard = (_Bool)0;
            }
            }
          } else {
            {
            goto _L___7;
            }
          }
          }
        } else {
          {
          _L___7:
          {
          tmp___28 = setlocale(category, (char const *)"POSIX");
          p = (char const *)tmp___28;
          }
          if (p) {
            {
            if (0) {
              {
              {
              __s1_len___2 = __builtin_strlen(p);
              __s2_len___2 = __builtin_strlen((char const *)locale);
              }
              if (! ((size_t )((void const *)(p + 1)) - (size_t )((void const *)p) == 1UL)) {
                {
                goto _L___6;
                }
              } else {
                {
                if (__s1_len___2 >= 4UL) {
                  {
                  _L___6:
                  if (! ((size_t )((void const *)(locale + 1)) - (size_t )((void const *)locale) == 1UL)) {
                    {
                    {
                    tmp___35 = 1;
                    }
                    }
                  } else {
                    {
                    if (__s2_len___2 >= 4UL) {
                      {
                      {
                      tmp___35 = 1;
                      }
                      }
                    } else {
                      {
                      {
                      tmp___35 = 0;
                      }
                      }
                    }
                    }
                  }
                  }
                } else {
                  {
                  {
                  tmp___35 = 0;
                  }
                  }
                }
                }
              }
              if (tmp___35) {
                {
                {
                tmp___30 = __builtin_strcmp(p, (char const *)locale);
                tmp___34 = tmp___30;
                }
                }
              } else {
                {
                {
                tmp___33 = __builtin_strcmp(p, (char const *)locale);
                tmp___34 = tmp___33;
                }
                }
              }
              }
            } else {
              {
              {
              tmp___33 = __builtin_strcmp(p, (char const *)locale);
              tmp___34 = tmp___33;
              }
              }
            }
            if (tmp___34 == 0) {
              {
              {
              hard = (_Bool)0;
              }
              }
            }
            }
          }
          }
        }
        {
        setlocale(category, (char const *)locale);
        free((void *)locale);
        }
        }
      }
      }
    }
    }
  }
  return (hard);
}
}
__inline static size_t rotr_sz(size_t x , int n )
{
  {
  return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
size_t hash_get_n_buckets(Hash_table const *table___0 )
{
  {
  return ((size_t )table___0->n_buckets);
}
}
size_t hash_get_n_buckets_used(Hash_table const *table___0 )
{
  {
  return ((size_t )table___0->n_buckets_used);
}
}
size_t hash_get_n_entries(Hash_table const *table___0 )
{
  {
  return ((size_t )table___0->n_entries);
}
}
size_t hash_get_max_bucket_length(Hash_table const *table___0 )
{
  struct hash_entry const *bucket ;
  size_t max_bucket_length ;
  struct hash_entry const *cursor ;
  size_t bucket_length ;
  {
  {
  max_bucket_length = (size_t )0;
  bucket = (struct hash_entry const *)table___0->bucket;
  }
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
      {
      goto while_break;
      }
    }
    if (bucket->data) {
      {
      {
      cursor = bucket;
      bucket_length = (size_t )1;
      }
      {
      while (1) {
        while_continue___0: ;
        if (! 1) {
          {
          goto while_break___0;
          }
        }
        {
        cursor = (struct hash_entry const *)cursor->next;
        }
        if (! cursor) {
          {
          goto while_break___0;
          }
        }
        {
        bucket_length ++;
        }
      }
      while_break___0: ;
      }
      if (bucket_length > max_bucket_length) {
        {
        {
        max_bucket_length = bucket_length;
        }
        }
      }
      }
    }
    {
    bucket ++;
    }
  }
  while_break: ;
  }
  return (max_bucket_length);
}
}
_Bool hash_table_ok(Hash_table const *table___0 )
{
  struct hash_entry const *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry const *cursor ;
  {
  {
  n_buckets_used = (size_t )0;
  n_entries = (size_t )0;
  bucket = (struct hash_entry const *)table___0->bucket;
  }
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
      {
      goto while_break;
      }
    }
    if (bucket->data) {
      {
      {
      cursor = bucket;
      n_buckets_used ++;
      n_entries ++;
      }
      {
      while (1) {
        while_continue___0: ;
        if (! 1) {
          {
          goto while_break___0;
          }
        }
        {
        cursor = (struct hash_entry const *)cursor->next;
        }
        if (! cursor) {
          {
          goto while_break___0;
          }
        }
        {
        n_entries ++;
        }
      }
      while_break___0: ;
      }
      }
    }
    {
    bucket ++;
    }
  }
  while_break: ;
  }
  if (n_buckets_used == (size_t )table___0->n_buckets_used) {
    {
    if (n_entries == (size_t )table___0->n_entries) {
      {
      return ((_Bool)1);
      }
    }
    }
  }
  return ((_Bool)0);
}
}
void hash_print_statistics(Hash_table const *table___0 , FILE *stream )
{
  size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;
  {
  {
  tmp = hash_get_n_entries(table___0);
  n_entries = tmp;
  tmp___0 = hash_get_n_buckets(table___0);
  n_buckets = tmp___0;
  tmp___1 = hash_get_n_buckets_used(table___0);
  n_buckets_used = tmp___1;
  tmp___2 = hash_get_max_bucket_length(table___0);
  max_bucket_length = tmp___2;
  fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )"# entries:         %lu\n"),
          n_entries);
  fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )"# buckets:         %lu\n"),
          n_buckets);
  fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )"# buckets used:    %lu (%.2f%%)\n"),
          n_buckets_used, (100.0 * (double )n_buckets_used) / (double )n_buckets);
  fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )"max bucket length: %lu\n"),
          max_bucket_length);
  }
  return;
}
}
static struct hash_entry *safe_hasher(Hash_table const *table___0 , void const *key )
{
  size_t n ;
  size_t tmp ;
  {
  {
  tmp = (*(table___0->hasher))(key, (size_t )table___0->n_buckets);
  n = tmp;
  }
  if (! (n < (size_t )table___0->n_buckets)) {
    {
    {
    abort();
    }
    }
  }
  return ((struct hash_entry *)(table___0->bucket + n));
}
}
void *hash_lookup(Hash_table const *table___0 , void const *entry )
{
  struct hash_entry const *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry const *cursor ;
  _Bool tmp___0 ;
  {
  {
  tmp = safe_hasher(table___0, entry);
  bucket = (struct hash_entry const *)tmp;
  }
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
    {
    return ((void *)0);
    }
  }
  {
  cursor = bucket;
  }
  {
  while (1) {
    while_continue: ;
    if (! cursor) {
      {
      goto while_break;
      }
    }
    if ((unsigned long )entry == (unsigned long )cursor->data) {
      {
      return ((void *)cursor->data);
      }
    } else {
      {
      {
      tmp___0 = (*(table___0->comparator))(entry, (void const *)cursor->data);
      }
      if (tmp___0) {
        {
        return ((void *)cursor->data);
        }
      }
      }
    }
    {
    cursor = (struct hash_entry const *)cursor->next;
    }
  }
  while_break: ;
  }
  return ((void *)0);
}
}
void *hash_get_first(Hash_table const *table___0 )
{
  struct hash_entry const *bucket ;
  {
  if (table___0->n_entries == 0UL) {
    {
    return ((void *)0);
    }
  }
  {
  bucket = (struct hash_entry const *)table___0->bucket;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
      {
      {
      abort();
      }
      }
    } else {
      {
      if (bucket->data) {
        {
        return ((void *)bucket->data);
        }
      }
      }
    }
    {
    bucket ++;
    }
  }
  while_break: ;
  }
  return ((void *)0);
}
}
void *hash_get_next(Hash_table const *table___0 , void const *entry )
{
  struct hash_entry const *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry const *cursor ;
  {
  {
  tmp = safe_hasher(table___0, entry);
  bucket = (struct hash_entry const *)tmp;
  cursor = bucket;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if ((unsigned long )cursor->data == (unsigned long )entry) {
      {
      if (cursor->next) {
        {
        return ((cursor->next)->data);
        }
      }
      }
    }
    {
    cursor = (struct hash_entry const *)cursor->next;
    }
    if (! ((unsigned long )cursor != (unsigned long )((void *)0))) {
      {
      goto while_break;
      }
    }
  }
  while_break: ;
  }
  {
  while (1) {
    while_continue___0: ;
    if (! 1) {
      {
      goto while_break___0;
      }
    }
    {
    bucket ++;
    }
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
      {
      goto while_break___0;
      }
    }
    if (bucket->data) {
      {
      return ((void *)bucket->data);
      }
    }
  }
  while_break___0: ;
  }
  return ((void *)0);
}
}
size_t hash_get_entries(Hash_table const *table___0 , void **buffer , size_t buffer_size )
{
  size_t counter ;
  struct hash_entry const *bucket ;
  struct hash_entry const *cursor ;
  size_t tmp ;
  {
  {
  counter = (size_t )0;
  bucket = (struct hash_entry const *)table___0->bucket;
  }
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
      {
      goto while_break;
      }
    }
    if (bucket->data) {
      {
      {
      cursor = bucket;
      }
      {
      while (1) {
        while_continue___0: ;
        if (! cursor) {
          {
          goto while_break___0;
          }
        }
        if (counter >= buffer_size) {
          {
          return (counter);
          }
        }
        {
        tmp = counter;
        counter ++;
        *(buffer + tmp) = (void *)cursor->data;
        cursor = (struct hash_entry const *)cursor->next;
        }
      }
      while_break___0: ;
      }
      }
    }
    {
    bucket ++;
    }
  }
  while_break: ;
  }
  return (counter);
}
}
size_t hash_do_for_each(Hash_table const *table___0 , _Bool (*processor)(void * ,
                                                                           void * ) ,
                        void *processor_data )
{
  size_t counter ;
  struct hash_entry const *bucket ;
  struct hash_entry const *cursor ;
  _Bool tmp ;
  {
  {
  counter = (size_t )0;
  bucket = (struct hash_entry const *)table___0->bucket;
  }
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
      {
      goto while_break;
      }
    }
    if (bucket->data) {
      {
      {
      cursor = bucket;
      }
      {
      while (1) {
        while_continue___0: ;
        if (! cursor) {
          {
          goto while_break___0;
          }
        }
        {
        tmp = (*processor)((void *)cursor->data, processor_data);
        }
        if (! tmp) {
          {
          return (counter);
          }
        }
        {
        counter ++;
        cursor = (struct hash_entry const *)cursor->next;
        }
      }
      while_break___0: ;
      }
      }
    }
    {
    bucket ++;
    }
  }
  while_break: ;
  }
  return (counter);
}
}
size_t hash_string(char const *string , size_t n_buckets )
{
  size_t value ;
  unsigned char ch ;
  {
  {
  value = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    ch = (unsigned char )*string;
    }
    if (! ch) {
      {
      goto while_break;
      }
    }
    {
    value = (value * 31UL + (size_t )ch) % n_buckets;
    string ++;
    }
  }
  while_break: ;
  }
  return (value);
}
}
static _Bool is_prime(size_t candidate )
{
  size_t divisor ;
  size_t square ;
  int tmp ;
  {
  {
  divisor = (size_t )3;
  square = divisor * divisor;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (square < candidate) {
      {
      if (! (candidate % divisor)) {
        {
        goto while_break;
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
    {
    divisor ++;
    square += 4UL * divisor;
    divisor ++;
    }
  }
  while_break: ;
  }
  if (candidate % divisor) {
    {
    {
    tmp = 1;
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  return ((_Bool )tmp);
}
}
static size_t next_prime(size_t candidate )
{
  _Bool tmp ;
  {
  if (candidate < 10UL) {
    {
    {
    candidate = (size_t )10;
    }
    }
  }
  {
  candidate |= 1UL;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (0xffffffffffffffffUL != candidate) {
      {
      {
      tmp = is_prime(candidate);
      }
      if (tmp) {
        {
        goto while_break;
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
    {
    candidate += 2UL;
    }
  }
  while_break: ;
  }
  return (candidate);
}
}
void hash_reset_tuning(Hash_tuning *tuning )
{
  {
  {
  *tuning = (Hash_tuning )default_tuning;
  }
  return;
}
}
static size_t raw_hasher(void const *data , size_t n )
{
  size_t val ;
  size_t tmp ;
  {
  {
  tmp = rotr_sz((size_t )data, 3);
  val = tmp;
  }
  return (val % n);
}
}
static _Bool raw_comparator(void const *a , void const *b )
{
  {
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
static _Bool check_tuning(Hash_table *table___0 )
{
  Hash_tuning const *tuning ;
  float epsilon ;
  {
  {
  tuning = table___0->tuning;
  }
  if ((unsigned long )tuning == (unsigned long )(& default_tuning)) {
    {
    return ((_Bool)1);
    }
  }
  {
  epsilon = 0.1f;
  }
  if (epsilon < (float )tuning->growth_threshold) {
    {
    if (tuning->growth_threshold < (float )((float const )((float )1 - epsilon))) {
      {
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
        {
        if ((float const )0 <= (float const )tuning->shrink_threshold) {
          {
          if (tuning->shrink_threshold + (float )((float const )epsilon) < tuning->shrink_factor) {
            {
            if (tuning->shrink_factor <= (float )((float const )1)) {
              {
              if (tuning->shrink_threshold + (float )((float const )epsilon) < tuning->growth_threshold) {
                {
                return ((_Bool)1);
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  {
  table___0->tuning = & default_tuning;
  }
  return ((_Bool)0);
}
}
static size_t compute_bucket_size(size_t candidate , Hash_tuning const *tuning )
{
  float new_candidate ;
  int tmp ;
  {
  if (! tuning->is_n_buckets) {
    {
    {
    new_candidate = (float )((float const )candidate / (float const )tuning->growth_threshold);
    }
    if ((float )0xffffffffffffffffUL <= new_candidate) {
      {
      return ((size_t )0);
      }
    }
    {
    candidate = (size_t )new_candidate;
    }
    }
  }
  {
  candidate = next_prime(candidate);
  }
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
    {
    {
    tmp = -1;
    }
    }
  } else {
    {
    {
    tmp = -2;
    }
    }
  }
  if ((size_t )tmp / sizeof(struct hash_entry *) < candidate) {
    {
    return ((size_t )0);
    }
  }
  return (candidate);
}
}
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const *tuning ,
                                                                       size_t (*hasher)(void const * ,
                                                                                        size_t ) ,
                                                                       _Bool (*comparator)(void const * ,
                                                                                           void const * ) ,
                                                                       void (*data_freer)(void * ) )
{
  Hash_table *table___0 ;
  void *tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;
  {
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
    {
    {
    hasher = & raw_hasher;
    }
    }
  }
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
    {
    {
    comparator = & raw_comparator;
    }
    }
  }
  {
  tmp = malloc(sizeof(*table___0));
  table___0 = (Hash_table *)tmp;
  }
  if ((unsigned long )table___0 == (unsigned long )((void *)0)) {
    {
    return ((Hash_table *)((void *)0));
    }
  }
  if (! tuning) {
    {
    {
    tuning = & default_tuning;
    }
    }
  }
  {
  table___0->tuning = tuning;
  tmp___0 = check_tuning(table___0);
  }
  if (! tmp___0) {
    {
    goto fail;
    }
  }
  {
  table___0->n_buckets = compute_bucket_size(candidate, tuning);
  }
  if (! table___0->n_buckets) {
    {
    goto fail;
    }
  }
  {
  tmp___1 = calloc(table___0->n_buckets, sizeof(*(table___0->bucket)));
  table___0->bucket = (struct hash_entry *)tmp___1;
  }
  if ((unsigned long )table___0->bucket == (unsigned long )((void *)0)) {
    {
    goto fail;
    }
  }
  {
  table___0->bucket_limit = (struct hash_entry const *)(table___0->bucket + table___0->n_buckets);
  table___0->n_buckets_used = (size_t )0;
  table___0->n_entries = (size_t )0;
  table___0->hasher = hasher;
  table___0->comparator = comparator;
  table___0->data_freer = data_freer;
  table___0->free_entry_list = (struct hash_entry *)((void *)0);
  }
  return (table___0);
  fail:
  {
  free((void *)table___0);
  }
  return ((Hash_table *)((void *)0));
}
}
void hash_clear(Hash_table *table___0 )
{
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  {
  {
  bucket = table___0->bucket;
  }
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
      {
      goto while_break;
      }
    }
    if (bucket->data) {
      {
      {
      cursor = bucket->next;
      }
      {
      while (1) {
        while_continue___0: ;
        if (! cursor) {
          {
          goto while_break___0;
          }
        }
        if (table___0->data_freer) {
          {
          {
          (*(table___0->data_freer))(cursor->data);
          }
          }
        }
        {
        cursor->data = (void *)0;
        next = cursor->next;
        cursor->next = table___0->free_entry_list;
        table___0->free_entry_list = cursor;
        cursor = next;
        }
      }
      while_break___0: ;
      }
      if (table___0->data_freer) {
        {
        {
        (*(table___0->data_freer))(bucket->data);
        }
        }
      }
      {
      bucket->data = (void *)0;
      bucket->next = (struct hash_entry *)((void *)0);
      }
      }
    }
    {
    bucket ++;
    }
  }
  while_break: ;
  }
  {
  table___0->n_buckets_used = (size_t )0;
  table___0->n_entries = (size_t )0;
  }
  return;
}
}
void hash_free(Hash_table *table___0 )
{
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  {
  if (table___0->data_freer) {
    {
    if (table___0->n_entries) {
      {
      {
      bucket = table___0->bucket;
      }
      {
      while (1) {
        while_continue: ;
        if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
          {
          goto while_break;
          }
        }
        if (bucket->data) {
          {
          {
          cursor = bucket;
          }
          {
          while (1) {
            while_continue___0: ;
            if (! cursor) {
              {
              goto while_break___0;
              }
            }
            {
            (*(table___0->data_freer))(cursor->data);
            cursor = cursor->next;
            }
          }
          while_break___0: ;
          }
          }
        }
        {
        bucket ++;
        }
      }
      while_break: ;
      }
      }
    }
    }
  }
  {
  bucket = table___0->bucket;
  }
  {
  while (1) {
    while_continue___1: ;
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
      {
      goto while_break___1;
      }
    }
    {
    cursor = bucket->next;
    }
    {
    while (1) {
      while_continue___2: ;
      if (! cursor) {
        {
        goto while_break___2;
        }
      }
      {
      next = cursor->next;
      free((void *)cursor);
      cursor = next;
      }
    }
    while_break___2: ;
    }
    {
    bucket ++;
    }
  }
  while_break___1: ;
  }
  {
  cursor = table___0->free_entry_list;
  }
  {
  while (1) {
    while_continue___3: ;
    if (! cursor) {
      {
      goto while_break___3;
      }
    }
    {
    next = cursor->next;
    free((void *)cursor);
    cursor = next;
    }
  }
  while_break___3: ;
  }
  {
  free((void *)table___0->bucket);
  free((void *)table___0);
  }
  return;
}
}
static struct hash_entry *allocate_entry(Hash_table *table___0 )
{
  struct hash_entry *new ;
  void *tmp ;
  {
  if (table___0->free_entry_list) {
    {
    {
    new = table___0->free_entry_list;
    table___0->free_entry_list = new->next;
    }
    }
  } else {
    {
    {
    tmp = malloc(sizeof(*new));
    new = (struct hash_entry *)tmp;
    }
    }
  }
  return (new);
}
}
static void free_entry(Hash_table *table___0 , struct hash_entry *entry )
{
  {
  {
  entry->data = (void *)0;
  entry->next = table___0->free_entry_list;
  table___0->free_entry_list = entry;
  }
  return;
}
}
static void *hash_find_entry(Hash_table *table___0 , void const *entry , struct hash_entry **bucket_head ,
                             _Bool delete )
{
  struct hash_entry *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;
  {
  {
  tmp = safe_hasher((Hash_table const *)table___0, entry);
  bucket = tmp;
  *bucket_head = bucket;
  }
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
    {
    return ((void *)0);
    }
  }
  if ((unsigned long )entry == (unsigned long )bucket->data) {
    {
    goto _L;
    }
  } else {
    {
    {
    tmp___0 = (*(table___0->comparator))(entry, (void const *)bucket->data);
    }
    if (tmp___0) {
      {
      _L:
      {
      data = bucket->data;
      }
      if (delete) {
        {
        if (bucket->next) {
          {
          {
          next = bucket->next;
          *bucket = *next;
          free_entry(table___0, next);
          }
          }
        } else {
          {
          {
          bucket->data = (void *)0;
          }
          }
        }
        }
      }
      return (data);
      }
    }
    }
  }
  {
  cursor = bucket;
  }
  {
  while (1) {
    while_continue: ;
    if (! cursor->next) {
      {
      goto while_break;
      }
    }
    if ((unsigned long )entry == (unsigned long )(cursor->next)->data) {
      {
      goto _L___0;
      }
    } else {
      {
      {
      tmp___1 = (*(table___0->comparator))(entry, (void const *)(cursor->next)->data);
      }
      if (tmp___1) {
        {
        _L___0:
        {
        data___0 = (cursor->next)->data;
        }
        if (delete) {
          {
          {
          next___0 = cursor->next;
          cursor->next = next___0->next;
          free_entry(table___0, next___0);
          }
          }
        }
        return (data___0);
        }
      }
      }
    }
    {
    cursor = cursor->next;
    }
  }
  while_break: ;
  }
  return ((void *)0);
}
}
static _Bool transfer_entries(Hash_table *dst , Hash_table *src , _Bool safe )
{
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;
  {
  {
  bucket = src->bucket;
  }
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )bucket < (unsigned long )src->bucket_limit)) {
      {
      goto while_break;
      }
    }
    if (bucket->data) {
      {
      {
      cursor = bucket->next;
      }
      {
      while (1) {
        while_continue___0: ;
        if (! cursor) {
          {
          goto while_break___0;
          }
        }
        {
        data = cursor->data;
        new_bucket = safe_hasher((Hash_table const *)dst, (void const *)data);
        next = cursor->next;
        }
        if (new_bucket->data) {
          {
          {
          cursor->next = new_bucket->next;
          new_bucket->next = cursor;
          }
          }
        } else {
          {
          {
          new_bucket->data = data;
          (dst->n_buckets_used) ++;
          free_entry(dst, cursor);
          }
          }
        }
        {
        cursor = next;
        }
      }
      while_break___0: ;
      }
      {
      data = bucket->data;
      bucket->next = (struct hash_entry *)((void *)0);
      }
      if (safe) {
        {
        goto __Cont;
        }
      }
      {
      new_bucket = safe_hasher((Hash_table const *)dst, (void const *)data);
      }
      if (new_bucket->data) {
        {
        {
        tmp = allocate_entry(dst);
        new_entry = tmp;
        }
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
          {
          return ((_Bool)0);
          }
        }
        {
        new_entry->data = data;
        new_entry->next = new_bucket->next;
        new_bucket->next = new_entry;
        }
        }
      } else {
        {
        {
        new_bucket->data = data;
        (dst->n_buckets_used) ++;
        }
        }
      }
      {
      bucket->data = (void *)0;
      (src->n_buckets_used) --;
      }
      }
    }
    __Cont:
    {
    bucket ++;
    }
  }
  while_break: ;
  }
  return ((_Bool)1);
}
}
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table___0 ,
                                                             size_t candidate )
{
  Hash_table storage ;
  Hash_table *new_table ;
  size_t new_size ;
  size_t tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  {
  {
  tmp = compute_bucket_size(candidate, table___0->tuning);
  new_size = tmp;
  }
  if (! new_size) {
    {
    return ((_Bool)0);
    }
  }
  if (new_size == table___0->n_buckets) {
    {
    return ((_Bool)1);
    }
  }
  {
  new_table = & storage;
  tmp___0 = calloc(new_size, sizeof(*(new_table->bucket)));
  new_table->bucket = (struct hash_entry *)tmp___0;
  }
  if ((unsigned long )new_table->bucket == (unsigned long )((void *)0)) {
    {
    return ((_Bool)0);
    }
  }
  {
  new_table->n_buckets = new_size;
  new_table->bucket_limit = (struct hash_entry const *)(new_table->bucket + new_size);
  new_table->n_buckets_used = (size_t )0;
  new_table->n_entries = (size_t )0;
  new_table->tuning = table___0->tuning;
  new_table->hasher = table___0->hasher;
  new_table->comparator = table___0->comparator;
  new_table->data_freer = table___0->data_freer;
  new_table->free_entry_list = table___0->free_entry_list;
  tmp___1 = transfer_entries(new_table, table___0, (_Bool)0);
  }
  if (tmp___1) {
    {
    {
    free((void *)table___0->bucket);
    table___0->bucket = new_table->bucket;
    table___0->bucket_limit = new_table->bucket_limit;
    table___0->n_buckets = new_table->n_buckets;
    table___0->n_buckets_used = new_table->n_buckets_used;
    table___0->free_entry_list = new_table->free_entry_list;
    }
    return ((_Bool)1);
    }
  }
  {
  table___0->free_entry_list = new_table->free_entry_list;
  tmp___2 = transfer_entries(table___0, new_table, (_Bool)1);
  }
  if (tmp___2) {
    {
    {
    tmp___3 = transfer_entries(table___0, new_table, (_Bool)0);
    }
    if (! tmp___3) {
      {
      {
      abort();
      }
      }
    }
    }
  } else {
    {
    {
    abort();
    }
    }
  }
  {
  free((void *)new_table->bucket);
  }
  return ((_Bool)0);
}
}
int hash_insert0(Hash_table *table___0 , void const *entry , void const **matched_ent )
{
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const *tuning ;
  float candidate ;
  float tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___2 ;
  {
  if (! entry) {
    {
    {
    abort();
    }
    }
  }
  {
  data = hash_find_entry(table___0, entry, & bucket, (_Bool)0);
  }
  if ((unsigned long )data != (unsigned long )((void *)0)) {
    {
    if (matched_ent) {
      {
      {
      *matched_ent = (void const *)data;
      }
      }
    }
    return (0);
    }
  }
  if ((float const )table___0->n_buckets_used > (float const )((table___0->tuning)->growth_threshold * (float )((float const )table___0->n_buckets))) {
    {
    {
    check_tuning(table___0);
    }
    if ((float const )table___0->n_buckets_used > (float const )((table___0->tuning)->growth_threshold * (float )((float const )table___0->n_buckets))) {
      {
      {
      tuning = table___0->tuning;
      }
      if (tuning->is_n_buckets) {
        {
        {
        tmp = (float )((float const )table___0->n_buckets * (float const )tuning->growth_factor);
        }
        }
      } else {
        {
        {
        tmp = (float )(((float const )table___0->n_buckets * (float const )tuning->growth_factor) * (float const )tuning->growth_threshold);
        }
        }
      }
      {
      candidate = tmp;
      }
      if ((float )0xffffffffffffffffUL <= candidate) {
        {
        return (-1);
        }
      }
      {
      tmp___0 = hash_rehash(table___0, (size_t )candidate);
      }
      if (! tmp___0) {
        {
        return (-1);
        }
      }
      {
      tmp___1 = hash_find_entry(table___0, entry, & bucket, (_Bool)0);
      }
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        {
        {
        abort();
        }
        }
      }
      }
    }
    }
  }
  if (bucket->data) {
    {
    {
    tmp___2 = allocate_entry(table___0);
    new_entry = tmp___2;
    }
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
      {
      return (-1);
      }
    }
    {
    new_entry->data = (void *)entry;
    new_entry->next = bucket->next;
    bucket->next = new_entry;
    (table___0->n_entries) ++;
    }
    return (1);
    }
  }
  {
  bucket->data = (void *)entry;
  (table___0->n_entries) ++;
  (table___0->n_buckets_used) ++;
  }
  return (1);
}
}
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table___0 ,
                                                             void const *entry )
{
  void const *matched_ent ;
  int err ;
  int tmp ;
  void const *tmp___0 ;
  void *tmp___1 ;
  {
  {
  tmp = hash_insert0(table___0, entry, & matched_ent);
  err = tmp;
  }
  if (err == -1) {
    {
    {
    tmp___1 = (void *)0;
    }
    }
  } else {
    {
    if (err == 0) {
      {
      {
      tmp___0 = matched_ent;
      }
      }
    } else {
      {
      {
      tmp___0 = entry;
      }
      }
    }
    {
    tmp___1 = (void *)tmp___0;
    }
    }
  }
  return (tmp___1);
}
}
void *hash_delete(Hash_table *table___0 , void const *entry )
{
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const *tuning ;
  size_t candidate ;
  float tmp ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  {
  {
  data = hash_find_entry(table___0, entry, & bucket, (_Bool)1);
  }
  if (! data) {
    {
    return ((void *)0);
    }
  }
  {
  (table___0->n_entries) --;
  }
  if (! bucket->data) {
    {
    {
    (table___0->n_buckets_used) --;
    }
    if ((float const )table___0->n_buckets_used < (float const )((table___0->tuning)->shrink_threshold * (float )((float const )table___0->n_buckets))) {
      {
      {
      check_tuning(table___0);
      }
      if ((float const )table___0->n_buckets_used < (float const )((table___0->tuning)->shrink_threshold * (float )((float const )table___0->n_buckets))) {
        {
        {
        tuning = table___0->tuning;
        }
        if (tuning->is_n_buckets) {
          {
          {
          tmp = (float )((float const )table___0->n_buckets * (float const )tuning->shrink_factor);
          }
          }
        } else {
          {
          {
          tmp = (float )(((float const )table___0->n_buckets * (float const )tuning->shrink_factor) * (float const )tuning->growth_threshold);
          }
          }
        }
        {
        candidate = (size_t )tmp;
        tmp___0 = hash_rehash(table___0, candidate);
        }
        if (! tmp___0) {
          {
          {
          cursor = table___0->free_entry_list;
          }
          {
          while (1) {
            while_continue: ;
            if (! cursor) {
              {
              goto while_break;
              }
            }
            {
            next = cursor->next;
            free((void *)cursor);
            cursor = next;
            }
          }
          while_break: ;
          }
          {
          table___0->free_entry_list = (struct hash_entry *)((void *)0);
          }
          }
        }
        }
      }
      }
    }
    }
  }
  return (data);
}
}
size_t hash_pjw(void const *x , size_t tablesize )
{
  char const *s ;
  size_t h ;
  {
  {
  h = (size_t )0;
  s = (char const *)x;
  }
  {
  while (1) {
    while_continue: ;
    if (! *s) {
      {
      goto while_break;
      }
    }
    {
    h = (unsigned long )*s + ((h << 9) | (h >> (sizeof(size_t ) * 8UL - 9UL)));
    s ++;
    }
  }
  while_break: ;
  }
  return (h % tablesize);
}
}
size_t triple_hash(void const *x , size_t table_size )
{
  struct F_triple const *p ;
  size_t tmp ;
  size_t tmp___0 ;
  {
  {
  p = (struct F_triple const *)x;
  tmp___0 = hash_pjw((void const *)p->name, table_size);
  tmp = tmp___0;
  }
  return ((tmp ^ (unsigned long )p->st_ino) % table_size);
}
}
size_t triple_hash_no_name(void const *x , size_t table_size )
{
  struct F_triple const *p ;
  {
  {
  p = (struct F_triple const *)x;
  }
  return ((size_t )(p->st_ino % (unsigned long )((unsigned long const )table_size)));
}
}
_Bool triple_compare(void const *x , void const *y )
{
  struct F_triple const *a ;
  struct F_triple const *b ;
  int tmp___0 ;
  _Bool tmp___1 ;
  {
  {
  a = (struct F_triple const *)x;
  b = (struct F_triple const *)y;
  }
  if (a->st_ino == b->st_ino) {
    {
    if (a->st_dev == b->st_dev) {
      {
      {
      tmp___1 = same_name((char const *)a->name, (char const *)b->name);
      }
      if (tmp___1) {
        {
        {
        tmp___0 = 1;
        }
        }
      } else {
        {
        {
        tmp___0 = 0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___0 = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___0 = 0;
    }
    }
  }
  return ((_Bool )tmp___0);
}
}
_Bool triple_compare_ino_str(void const *x , void const *y )
{
  struct F_triple const *a ;
  struct F_triple const *b ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  {
  {
  a = (struct F_triple const *)x;
  b = (struct F_triple const *)y;
  }
  if (a->st_ino == b->st_ino) {
    {
    if (a->st_dev == b->st_dev) {
      {
      if (0) {
        {
        {
        __s1_len___0 = __builtin_strlen((char const *)a->name);
        __s2_len___0 = __builtin_strlen((char const *)b->name);
        }
        if (! ((size_t )((void const *)(a->name + 1)) - (size_t )((void const *)a->name) == 1UL)) {
          {
          goto _L___2;
          }
        } else {
          {
          if (__s1_len___0 >= 4UL) {
            {
            _L___2:
            if (! ((size_t )((void const *)(b->name + 1)) - (size_t )((void const *)b->name) == 1UL)) {
              {
              {
              tmp___13 = 1;
              }
              }
            } else {
              {
              if (__s2_len___0 >= 4UL) {
                {
                {
                tmp___13 = 1;
                }
                }
              } else {
                {
                {
                tmp___13 = 0;
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            tmp___13 = 0;
            }
            }
          }
          }
        }
        if (tmp___13) {
          {
          {
          tmp___8 = __builtin_strcmp((char const *)a->name, (char const *)b->name);
          tmp___12 = tmp___8;
          }
          }
        } else {
          {
          {
          tmp___11 = __builtin_strcmp((char const *)a->name, (char const *)b->name);
          tmp___12 = tmp___11;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___11 = __builtin_strcmp((char const *)a->name, (char const *)b->name);
        tmp___12 = tmp___11;
        }
        }
      }
      if (tmp___12 == 0) {
        {
        {
        tmp___6 = 1;
        }
        }
      } else {
        {
        {
        tmp___6 = 0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___6 = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___6 = 0;
    }
    }
  }
  return ((_Bool )tmp___6);
}
}
void triple_free(void *x )
{
  struct F_triple *a ;
  {
  {
  a = (struct F_triple *)x;
  free((void *)a->name);
  free((void *)a);
  }
  return;
}
}
__inline static void *xnmalloc(size_t n , size_t s ) __attribute__((__malloc__, __alloc_size__(1,2))) ;
__inline static void *xnmalloc(size_t n , size_t s )
{
  int tmp ;
  void *tmp___0 ;
  {
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
    {
    {
    tmp = -1;
    }
    }
  } else {
    {
    {
    tmp = -2;
    }
    }
  }
  if ((size_t )tmp / s < n) {
    {
    {
    xalloc_die();
    }
    }
  }
  {
  tmp___0 = xmalloc(n * s);
  }
  return (tmp___0);
}
}
struct heap *heap_alloc(int (*compare)(void const * , void const * ) , size_t n_reserve )
{
  struct heap *heap ;
  void *tmp ;
  void *tmp___0 ;
  {
  {
  tmp = xmalloc(sizeof(*heap));
  heap = (struct heap *)tmp;
  }
  if (n_reserve == 0UL) {
    {
    {
    n_reserve = (size_t )1;
    }
    }
  }
  {
  tmp___0 = xnmalloc(n_reserve, sizeof(*(heap->array)));
  heap->array = (void **)tmp___0;
  *(heap->array + 0) = (void *)0;
  heap->capacity = n_reserve;
  heap->count = (size_t )0;
  }
  if (compare) {
    {
    {
    heap->compare = compare;
    }
    }
  } else {
    {
    {
    heap->compare = & heap_default_compare;
    }
    }
  }
  return (heap);
}
}
static int heap_default_compare(void const *a , void const *b )
{
  {
  return (0);
}
}
void heap_free(struct heap *heap )
{
  {
  {
  free((void *)heap->array);
  free((void *)heap);
  }
  return;
}
}
int heap_insert(struct heap *heap , void *item )
{
  void *tmp ;
  {
  if (heap->capacity - 1UL <= heap->count) {
    {
    {
    tmp = x2nrealloc((void *)heap->array, & heap->capacity, sizeof(*(heap->array)));
    heap->array = (void **)tmp;
    }
    }
  }
  {
  (heap->count) ++;
  *(heap->array + heap->count) = item;
  heapify_up(heap->array, heap->count, heap->compare);
  }
  return (0);
}
}
void *heap_remove_top(struct heap *heap )
{
  void *top ;
  size_t tmp ;
  {
  if (heap->count == 0UL) {
    {
    return ((void *)0);
    }
  }
  {
  top = *(heap->array + 1);
  tmp = heap->count;
  (heap->count) --;
  *(heap->array + 1) = *(heap->array + tmp);
  heapify_down(heap->array, heap->count, (size_t )1, heap->compare);
  }
  return (top);
}
}
static size_t heapify_down(void **array , size_t count , size_t initial , int (*compare)(void const * ,
                                                                                         void const * ) )
{
  void *element ;
  size_t parent ;
  size_t child ;
  int tmp ;
  int tmp___0 ;
  {
  {
  element = *(array + initial);
  parent = initial;
  }
  {
  while (1) {
    while_continue: ;
    if (! (parent <= count / 2UL)) {
      {
      goto while_break;
      }
    }
    {
    child = 2UL * parent;
    }
    if (child < count) {
      {
      {
      tmp = (*compare)((void const *)*(array + child), (void const *)*(array + (child + 1UL)));
      }
      if (tmp < 0) {
        {
        {
        child ++;
        }
        }
      }
      }
    }
    {
    tmp___0 = (*compare)((void const *)*(array + child), (void const *)element);
    }
    if (tmp___0 <= 0) {
      {
      goto while_break;
      }
    }
    {
    *(array + parent) = *(array + child);
    parent = child;
    }
  }
  while_break: ;
  }
  {
  *(array + parent) = element;
  }
  return (parent);
}
}
static void heapify_up(void **array , size_t count , int (*compare)(void const * ,
                                                                    void const * ) )
{
  size_t k ;
  void *new_element ;
  int tmp ;
  {
  {
  k = count;
  new_element = *(array + k);
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (k != 1UL) {
      {
      {
      tmp = (*compare)((void const *)*(array + k / 2UL), (void const *)new_element);
      }
      if (! (tmp <= 0)) {
        {
        goto while_break;
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
    {
    *(array + k) = *(array + k / 2UL);
    k /= 2UL;
    }
  }
  while_break: ;
  }
  {
  *(array + k) = new_element;
  }
  return;
}
}
__inline extern intmax_t strtoimax(char const *nptr , char **endptr , int base ) __attribute__((__nothrow__)) ;
__inline extern intmax_t strtoimax(char const *nptr , char **endptr , int base )
{
  long tmp ;
  {
  {
  tmp = __strtol_internal((char const * __restrict )nptr, (char ** __restrict )endptr,
                          base, 0);
  }
  return (tmp);
}
}
__inline extern uintmax_t strtoumax(char const *nptr , char **endptr , int base ) __attribute__((__nothrow__)) ;
__inline extern uintmax_t strtoumax(char const *nptr , char **endptr , int base )
{
  unsigned long tmp ;
  {
  {
  tmp = __strtoul_internal((char const * __restrict )nptr, (char ** __restrict )endptr,
                           base, 0);
  }
  return (tmp);
}
}
__inline extern intmax_t wcstoimax(__gwchar_t const *nptr , __gwchar_t **endptr ,
                                   int base ) __attribute__((__nothrow__)) ;
__inline extern intmax_t wcstoimax(__gwchar_t const *nptr , __gwchar_t **endptr ,
                                   int base )
{
  long tmp ;
  {
  {
  tmp = __wcstol_internal((__gwchar_t const * __restrict )nptr, (__gwchar_t ** __restrict )endptr,
                          base, 0);
  }
  return (tmp);
}
}
__inline extern uintmax_t wcstoumax(__gwchar_t const *nptr , __gwchar_t **endptr ,
                                    int base ) __attribute__((__nothrow__)) ;
__inline extern uintmax_t wcstoumax(__gwchar_t const *nptr , __gwchar_t **endptr ,
                                    int base )
{
  unsigned long tmp ;
  {
  {
  tmp = __wcstoul_internal((__gwchar_t const * __restrict )nptr, (__gwchar_t ** __restrict )endptr,
                           base, 0);
  }
  return (tmp);
}
}
static long double adjust_value(int inexact_style , long double value )
{
  uintmax_t u ;
  int tmp ;
  {
  if (inexact_style != 1) {
    {
    if (value < (long double )0xffffffffffffffffUL) {
      {
      {
      u = (uintmax_t )value;
      }
      if (inexact_style == 0) {
        {
        if ((long double )u != value) {
          {
          {
          tmp = 1;
          }
          }
        } else {
          {
          {
          tmp = 0;
          }
          }
        }
        }
      } else {
        {
        {
        tmp = 0;
        }
        }
      }
      {
      value = (long double )(u + (uintmax_t )tmp);
      }
      }
    }
    }
  }
  return (value);
}
}
static char *group_number(char *number , size_t numberlen , char const *grouping ,
                          char const *thousands_sep )
{
  register char *d ;
  size_t grouplen ;
  size_t thousands_seplen ;
  size_t tmp ;
  size_t i ;
  char buf___1[2UL * (((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL) + 1UL] ;
  unsigned char g ;
  {
  {
  grouplen = 0xffffffffffffffffUL;
  tmp = strlen(thousands_sep);
  thousands_seplen = tmp;
  i = numberlen;
  memcpy((void *)((void * __restrict )(buf___1)), (void const *)((void const * __restrict )number),
         numberlen);
  d = number + numberlen;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    g = (unsigned char )*grouping;
    }
    if (g) {
      {
      if ((int )g < 127) {
        {
        {
        grouplen = (size_t )g;
        }
        }
      } else {
        {
        {
        grouplen = i;
        }
        }
      }
      {
      grouping ++;
      }
      }
    }
    if (i < grouplen) {
      {
      {
      grouplen = i;
      }
      }
    }
    {
    d -= grouplen;
    i -= grouplen;
    memcpy((void *)((void * __restrict )d), (void const *)((void const * __restrict )(buf___1 + i)),
           grouplen);
    }
    if (i == 0UL) {
      {
      return (d);
      }
    }
    {
    d -= thousands_seplen;
    memcpy((void *)((void * __restrict )d), (void const *)((void const * __restrict )thousands_sep),
           thousands_seplen);
    }
  }
  while_break: ;
  }
  return ((char *)0);
}
}
char *human_readable(uintmax_t n , char *buf___1 , int opts , uintmax_t from_block_size ,
                     uintmax_t to_block_size )
{
  int inexact_style ;
  unsigned int base ;
  int tmp ;
  uintmax_t amt ;
  int tenths ;
  int exponent ;
  int exponent_max ;
  char *p ;
  char *psuffix ;
  char const *integerlim ;
  int rounding ;
  char const *decimal_point ;
  size_t decimal_pointlen ;
  char const *grouping ;
  char const *thousands_sep ;
  struct lconv const *l ;
  struct lconv *tmp___0 ;
  size_t pointlen ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  uintmax_t multiplier ;
  uintmax_t divisor ;
  uintmax_t r10 ;
  uintmax_t r2 ;
  long double dto_block_size ;
  long double damt ;
  size_t buflen ;
  size_t nonintegerlen ;
  long double tmp___3 ;
  long double e ;
  long double tmp___4 ;
  long double tmp___5 ;
  unsigned int r10___0 ;
  unsigned int r2___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int digit ;
  uintmax_t power ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  {
  {
  inexact_style = opts & 3;
  }
  if (opts & 32) {
    {
    {
    tmp = 1024;
    }
    }
  } else {
    {
    {
    tmp = 1000;
    }
    }
  }
  {
  base = (unsigned int )tmp;
  exponent = -1;
  exponent_max = (int )(sizeof(power_letter) - 1UL);
  decimal_point = (char const *)".";
  decimal_pointlen = (size_t )1;
  grouping = (char const *)"";
  thousands_sep = (char const *)"";
  tmp___0 = localeconv();
  l = (struct lconv const *)tmp___0;
  tmp___1 = strlen((char const *)l->decimal_point);
  pointlen = tmp___1;
  }
  if (0UL < pointlen) {
    {
    if (pointlen <= 16UL) {
      {
      {
      decimal_point = (char const *)l->decimal_point;
      decimal_pointlen = pointlen;
      }
      }
    }
    }
  }
  {
  grouping = (char const *)l->grouping;
  tmp___2 = strlen((char const *)l->thousands_sep);
  }
  if (tmp___2 <= 16UL) {
    {
    {
    thousands_sep = (char const *)l->thousands_sep;
    }
    }
  }
  {
  psuffix = (buf___1 + (((((((2UL * sizeof(uintmax_t )) * 8UL) * 146UL) / 485UL + 1UL) * 17UL - 16UL) + 1UL) + 3UL)) - 3;
  p = psuffix;
  }
  if (to_block_size <= from_block_size) {
    {
    if (from_block_size % to_block_size == 0UL) {
      {
      {
      multiplier = from_block_size / to_block_size;
      amt = n * multiplier;
      }
      if (amt / multiplier == n) {
        {
        {
        tenths = 0;
        rounding = 0;
        }
        goto use_integer_arithmetic;
        }
      }
      }
    }
    }
  } else {
    {
    if (from_block_size != 0UL) {
      {
      if (to_block_size % from_block_size == 0UL) {
        {
        {
        divisor = to_block_size / from_block_size;
        r10 = (n % divisor) * 10UL;
        r2 = (r10 % divisor) * 2UL;
        amt = n / divisor;
        tenths = (int )(r10 / divisor);
        }
        if (r2 < divisor) {
          {
          {
          rounding = 0UL < r2;
          }
          }
        } else {
          {
          {
          rounding = 2 + (divisor < r2);
          }
          }
        }
        goto use_integer_arithmetic;
        }
      }
      }
    }
    }
  }
  {
  dto_block_size = (long double )to_block_size;
  damt = (long double )n * ((long double )from_block_size / dto_block_size);
  }
  if (! (opts & 16)) {
    {
    {
    tmp___3 = adjust_value(inexact_style, damt);
    sprintf((char *)((char * __restrict )buf___1), (char const *)((char const * __restrict )"%.0Lf"),
            tmp___3);
    buflen = strlen((char const *)buf___1);
    nonintegerlen = (size_t )0;
    }
    }
  } else {
    {
    {
    e = (long double )1;
    exponent = 0;
    }
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      {
      e *= (long double )base;
      exponent ++;
      }
      if (e * (long double )base <= damt) {
        {
        if (! (exponent < exponent_max)) {
          {
          goto while_break;
          }
        }
        }
      } else {
        {
        goto while_break;
        }
      }
    }
    while_break: ;
    }
    {
    damt /= e;
    tmp___4 = adjust_value(inexact_style, damt);
    sprintf((char *)((char * __restrict )buf___1), (char const *)((char const * __restrict )"%.1Lf"),
            tmp___4);
    buflen = strlen((char const *)buf___1);
    nonintegerlen = decimal_pointlen + 1UL;
    }
    if ((1UL + nonintegerlen) + (size_t )(! (opts & 32)) < buflen) {
      {
      {
      tmp___5 = adjust_value(inexact_style, damt * (long double )10);
      sprintf((char *)((char * __restrict )buf___1), (char const *)((char const * __restrict )"%.0Lf"),
              tmp___5 / (long double )10);
      buflen = strlen((char const *)buf___1);
      nonintegerlen = (size_t )0;
      }
      }
    } else {
      {
      if (opts & 8) {
        {
        if ((int )*(buf___1 + (buflen - 1UL)) == 48) {
          {
          {
          tmp___5 = adjust_value(inexact_style, damt * (long double )10);
          sprintf((char *)((char * __restrict )buf___1), (char const *)((char const * __restrict )"%.0Lf"),
                  tmp___5 / (long double )10);
          buflen = strlen((char const *)buf___1);
          nonintegerlen = (size_t )0;
          }
          }
        }
        }
      }
      }
    }
    }
  }
  {
  p = psuffix - buflen;
  memmove((void *)p, (void const *)buf___1, buflen);
  integerlim = (char const *)((p + buflen) - nonintegerlen);
  }
  goto do_grouping;
  use_integer_arithmetic:
  if (opts & 16) {
    {
    {
    exponent = 0;
    }
    if ((uintmax_t )base <= amt) {
      {
      {
      while (1) {
        while_continue___0: ;
        if (! 1) {
          {
          goto while_break___0;
          }
        }
        {
        r10___0 = (unsigned int )((amt % (unsigned long )base) * 10UL + (unsigned long )tenths);
        r2___0 = (r10___0 % base) * 2U + (unsigned int )(rounding >> 1);
        amt /= (uintmax_t )base;
        tenths = (int )(r10___0 / base);
        }
        if (r2___0 < base) {
          {
          {
          rounding = r2___0 + (unsigned int )rounding != 0U;
          }
          }
        } else {
          {
          {
          rounding = 2 + (base < r2___0 + (unsigned int )rounding);
          }
          }
        }
        {
        exponent ++;
        }
        if ((uintmax_t )base <= amt) {
          {
          if (! (exponent < exponent_max)) {
            {
            goto while_break___0;
            }
          }
          }
        } else {
          {
          goto while_break___0;
          }
        }
      }
      while_break___0: ;
      }
      if (amt < 10UL) {
        {
        if (inexact_style == 1) {
          {
          {
          tmp___7 = 2 < rounding + (tenths & 1);
          }
          }
        } else {
          {
          if (inexact_style == 0) {
            {
            if (0 < rounding) {
              {
              {
              tmp___6 = 1;
              }
              }
            } else {
              {
              {
              tmp___6 = 0;
              }
              }
            }
            }
          } else {
            {
            {
            tmp___6 = 0;
            }
            }
          }
          {
          tmp___7 = tmp___6;
          }
          }
        }
        if (tmp___7) {
          {
          {
          tenths ++;
          rounding = 0;
          }
          if (tenths == 10) {
            {
            {
            amt ++;
            tenths = 0;
            }
            }
          }
          }
        }
        if (amt < 10UL) {
          {
          if (tenths) {
            {
            goto _L;
            }
          } else {
            {
            if (! (opts & 8)) {
              {
              _L:
              {
              p --;
              *p = (char )(48 + tenths);
              p -= decimal_pointlen;
              memcpy((void *)((void * __restrict )p), (void const *)((void const * __restrict )decimal_point),
                     decimal_pointlen);
              rounding = 0;
              tenths = rounding;
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  if (inexact_style == 1) {
    {
    {
    tmp___9 = 5 < tenths + (0UL < (unsigned long )rounding + (amt & 1UL));
    }
    }
  } else {
    {
    if (inexact_style == 0) {
      {
      if (0 < tenths + rounding) {
        {
        {
        tmp___8 = 1;
        }
        }
      } else {
        {
        {
        tmp___8 = 0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___8 = 0;
      }
      }
    }
    {
    tmp___9 = tmp___8;
    }
    }
  }
  if (tmp___9) {
    {
    {
    amt ++;
    }
    if (opts & 16) {
      {
      if (amt == (uintmax_t )base) {
        {
        if (exponent < exponent_max) {
          {
          {
          exponent ++;
          }
          if (! (opts & 8)) {
            {
            {
            p --;
            *p = (char )'0';
            p -= decimal_pointlen;
            memcpy((void *)((void * __restrict )p), (void const *)((void const * __restrict )decimal_point),
                   decimal_pointlen);
            }
            }
          }
          {
          amt = (uintmax_t )1;
          }
          }
        }
        }
      }
      }
    }
    }
  }
  {
  integerlim = (char const *)p;
  }
  {
  while (1) {
    while_continue___1: ;
    if (! 1) {
      {
      goto while_break___1;
      }
    }
    {
    digit = (int )(amt % 10UL);
    p --;
    *p = (char )(digit + 48);
    amt /= 10UL;
    }
    if (! (amt != 0UL)) {
      {
      goto while_break___1;
      }
    }
  }
  while_break___1: ;
  }
  do_grouping:
  if (opts & 4) {
    {
    {
    p = group_number(p, (size_t )(integerlim - (char const *)p), grouping, thousands_sep);
    }
    }
  }
  if (opts & 128) {
    {
    if (exponent < 0) {
      {
      {
      exponent = 0;
      power = (uintmax_t )1;
      }
      {
      while (1) {
        while_continue___2: ;
        if (! (power < to_block_size)) {
          {
          goto while_break___2;
          }
        }
        {
        exponent ++;
        }
        if (exponent == exponent_max) {
          {
          goto while_break___2;
          }
        }
        {
        power *= (uintmax_t )base;
        }
      }
      while_break___2: ;
      }
      }
    }
    if (exponent | (opts & 256)) {
      {
      if (opts & 64) {
        {
        {
        tmp___10 = psuffix;
        psuffix ++;
        *tmp___10 = (char )' ';
        }
        }
      }
      }
    }
    if (exponent) {
      {
      {
      tmp___11 = psuffix;
      psuffix ++;
      }
      if (! (opts & 32)) {
        {
        if (exponent == 1) {
          {
          {
          *tmp___11 = (char )'k';
          }
          }
        } else {
          {
          {
          *tmp___11 = (char )power_letter[exponent];
          }
          }
        }
        }
      } else {
        {
        {
        *tmp___11 = (char )power_letter[exponent];
        }
        }
      }
      }
    }
    if (opts & 256) {
      {
      if (opts & 32) {
        {
        if (exponent) {
          {
          {
          tmp___12 = psuffix;
          psuffix ++;
          *tmp___12 = (char )'i';
          }
          }
        }
        }
      }
      {
      tmp___13 = psuffix;
      psuffix ++;
      *tmp___13 = (char )'B';
      }
      }
    }
    }
  }
  {
  *psuffix = (char )'\000';
  }
  return (p);
}
}
static uintmax_t default_block_size(void)
{
  int tmp___0 ;
  char *tmp___1 ;
  {
  {
  tmp___1 = getenv((char const *)"POSIXLY_CORRECT");
  }
  if (tmp___1) {
    {
    {
    tmp___0 = 512;
    }
    }
  } else {
    {
    {
    tmp___0 = 1024;
    }
    }
  }
  return ((uintmax_t )tmp___0);
}
}
static strtol_error humblock(char const *spec , uintmax_t *block_size , int *options )
{
  int i ;
  int opts ;
  char *ptr ;
  strtol_error e ;
  strtol_error tmp ;
  ptrdiff_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  {
  {
  opts = 0;
  }
  if (! spec) {
    {
    {
    tmp___1 = getenv((char const *)"BLOCK_SIZE");
    spec = (char const *)tmp___1;
    }
    if (spec) {
      {
      goto _L___0;
      }
    } else {
      {
      {
      tmp___2 = getenv((char const *)"BLOCKSIZE");
      spec = (char const *)tmp___2;
      }
      if (spec) {
        {
        goto _L___0;
        }
      } else {
        {
        {
        *block_size = default_block_size();
        }
        }
      }
      }
    }
    }
  } else {
    {
    _L___0:
    if ((int const )*spec == 39) {
      {
      {
      opts |= 4;
      spec ++;
      }
      }
    }
    {
    tmp___0 = argmatch(spec, block_size_args, (char const *)(block_size_opts), sizeof(block_size_opts[0]));
    i = (int )tmp___0;
    }
    if (0 <= i) {
      {
      {
      opts |= (int )block_size_opts[i];
      *block_size = (uintmax_t )1;
      }
      }
    } else {
      {
      {
      tmp = xstrtoumax(spec, & ptr, 0, block_size, (char const *)"eEgGkKmMpPtTyYzZ0");
      e = tmp;
      }
      if ((unsigned int )e != 0U) {
        {
        {
        *options = 0;
        }
        return (e);
        }
      }
      {
      while (1) {
        while_continue: ;
        if (! 1) {
          {
          goto while_break;
          }
        }
        if (48 <= (int )*spec) {
          {
          if ((int const )*spec <= 57) {
            {
            goto while_break;
            }
          }
          }
        }
        if ((unsigned long )spec == (unsigned long )ptr) {
          {
          {
          opts |= 128;
          }
          if ((int )*(ptr + -1) == 66) {
            {
            {
            opts |= 256;
            }
            }
          }
          if ((int )*(ptr + -1) != 66) {
            {
            {
            opts |= 32;
            }
            }
          } else {
            {
            if ((int )*(ptr + -2) == 105) {
              {
              {
              opts |= 32;
              }
              }
            }
            }
          }
          goto while_break;
          }
        }
        {
        spec ++;
        }
      }
      while_break: ;
      }
      }
    }
    }
  }
  {
  *options = opts;
  }
  return ((strtol_error )0);
}
}
enum strtol_error human_options(char const *spec , int *opts , uintmax_t *block_size )
{
  strtol_error e ;
  strtol_error tmp ;
  {
  {
  tmp = humblock(spec, block_size, opts);
  e = tmp;
  }
  if (*block_size == 0UL) {
    {
    {
    *block_size = default_block_size();
    e = (strtol_error )4;
    }
    }
  }
  return (e);
}
}
void i_ring_init(I_ring *ir , int default_val )
{
  int i ;
  {
  {
  ir->ir_empty = (_Bool)1;
  ir->ir_front = 0U;
  ir->ir_back = 0U;
  i = 0;
  }
  {
  while (1) {
    while_continue: ;
    if (! (i < 4)) {
      {
      goto while_break;
      }
    }
    {
    ir->ir_data[i] = default_val;
    i ++;
    }
  }
  while_break: ;
  }
  {
  ir->ir_default_val = default_val;
  }
  return;
}
}
_Bool i_ring_empty(I_ring const *ir )
{
  {
  return ((_Bool )ir->ir_empty);
}
}
int i_ring_push(I_ring *ir , int val )
{
  unsigned int dest_idx ;
  int old_val ;
  {
  {
  dest_idx = (ir->ir_front + (unsigned int )(! ir->ir_empty)) % 4U;
  old_val = ir->ir_data[dest_idx];
  ir->ir_data[dest_idx] = val;
  ir->ir_front = dest_idx;
  }
  if (dest_idx == ir->ir_back) {
    {
    {
    ir->ir_back = (ir->ir_back + (unsigned int )(! ir->ir_empty)) % 4U;
    }
    }
  }
  {
  ir->ir_empty = (_Bool)0;
  }
  return (old_val);
}
}
int i_ring_pop(I_ring *ir )
{
  int top_val ;
  _Bool tmp ;
  {
  {
  tmp = i_ring_empty((I_ring const *)ir);
  }
  if (tmp) {
    {
    {
    abort();
    }
    }
  }
  {
  top_val = ir->ir_data[ir->ir_front];
  ir->ir_data[ir->ir_front] = ir->ir_default_val;
  }
  if (ir->ir_front == ir->ir_back) {
    {
    {
    ir->ir_empty = (_Bool)1;
    }
    }
  } else {
    {
    {
    ir->ir_front = ((ir->ir_front + 4U) - 1U) % 4U;
    }
    }
  }
  return (top_val);
}
}
char *getuser(uid_t uid )
{
  struct userid *tail ;
  struct userid *match ;
  struct passwd *pwent ;
  struct passwd *tmp ;
  char const *name ;
  char const *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  {
  {
  match = (struct userid *)((void *)0);
  tail = user_alist;
  }
  {
  while (1) {
    while_continue: ;
    if (! tail) {
      {
      goto while_break;
      }
    }
    if (tail->id.u == uid) {
      {
      {
      match = tail;
      }
      goto while_break;
      }
    }
    {
    tail = tail->next;
    }
  }
  while_break: ;
  }
  if ((unsigned long )match == (unsigned long )((void *)0)) {
    {
    {
    tmp = getpwuid(uid);
    pwent = tmp;
    }
    if (pwent) {
      {
      {
      tmp___0 = (char const *)pwent->pw_name;
      }
      }
    } else {
      {
      {
      tmp___0 = (char const *)"";
      }
      }
    }
    {
    name = tmp___0;
    tmp___1 = strlen(name);
    tmp___2 = xmalloc(((size_t )((unsigned int )(& ((struct userid *)0)->name)) + tmp___1) + 1UL);
    match = (struct userid *)tmp___2;
    match->id.u = uid;
    strcpy((char *)((char * __restrict )(match->name)), (char const *)((char const * __restrict )name));
    match->next = user_alist;
    user_alist = match;
    }
    }
  }
  if (match->name[0]) {
    {
    {
    tmp___3 = match->name;
    }
    }
  } else {
    {
    {
    tmp___3 = (char *)((void *)0);
    }
    }
  }
  return (tmp___3);
}
}
uid_t *getuidbyname(char const *user )
{
  struct userid *tail ;
  struct passwd *pwent ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  {
  {
  tail = user_alist;
  }
  {
  while (1) {
    while_continue: ;
    if (! tail) {
      {
      goto while_break;
      }
    }
    if ((int )tail->name[0] == (int )*user) {
      {
      if (0) {
        {
        {
        __s1_len = __builtin_strlen((char const *)(tail->name));
        __s2_len = __builtin_strlen(user);
        }
        if (! ((size_t )((void const *)(tail->name + 1)) - (size_t )((void const *)(tail->name)) == 1UL)) {
          {
          goto _L___0;
          }
        } else {
          {
          if (__s1_len >= 4UL) {
            {
            _L___0:
            if (! ((size_t )((void const *)(user + 1)) - (size_t )((void const *)user) == 1UL)) {
              {
              {
              tmp___5 = 1;
              }
              }
            } else {
              {
              if (__s2_len >= 4UL) {
                {
                {
                tmp___5 = 1;
                }
                }
              } else {
                {
                {
                tmp___5 = 0;
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            tmp___5 = 0;
            }
            }
          }
          }
        }
        if (tmp___5) {
          {
          {
          tmp___0 = __builtin_strcmp((char const *)(tail->name), user);
          tmp___4 = tmp___0;
          }
          }
        } else {
          {
          {
          tmp___3 = __builtin_strcmp((char const *)(tail->name), user);
          tmp___4 = tmp___3;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___3 = __builtin_strcmp((char const *)(tail->name), user);
        tmp___4 = tmp___3;
        }
        }
      }
      if (! tmp___4) {
        {
        return (& tail->id.u);
        }
      }
      }
    }
    {
    tail = tail->next;
    }
  }
  while_break: ;
  }
  {
  tail = nouser_alist;
  }
  {
  while (1) {
    while_continue___0: ;
    if (! tail) {
      {
      goto while_break___0;
      }
    }
    if ((int )tail->name[0] == (int )*user) {
      {
      if (0) {
        {
        {
        __s1_len___0 = __builtin_strlen((char const *)(tail->name));
        __s2_len___0 = __builtin_strlen(user);
        }
        if (! ((size_t )((void const *)(tail->name + 1)) - (size_t )((void const *)(tail->name)) == 1UL)) {
          {
          goto _L___2;
          }
        } else {
          {
          if (__s1_len___0 >= 4UL) {
            {
            _L___2:
            if (! ((size_t )((void const *)(user + 1)) - (size_t )((void const *)user) == 1UL)) {
              {
              {
              tmp___12 = 1;
              }
              }
            } else {
              {
              if (__s2_len___0 >= 4UL) {
                {
                {
                tmp___12 = 1;
                }
                }
              } else {
                {
                {
                tmp___12 = 0;
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            tmp___12 = 0;
            }
            }
          }
          }
        }
        if (tmp___12) {
          {
          {
          tmp___7 = __builtin_strcmp((char const *)(tail->name), user);
          tmp___11 = tmp___7;
          }
          }
        } else {
          {
          {
          tmp___10 = __builtin_strcmp((char const *)(tail->name), user);
          tmp___11 = tmp___10;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___10 = __builtin_strcmp((char const *)(tail->name), user);
        tmp___11 = tmp___10;
        }
        }
      }
      if (! tmp___11) {
        {
        return ((uid_t *)((void *)0));
        }
      }
      }
    }
    {
    tail = tail->next;
    }
  }
  while_break___0: ;
  }
  {
  pwent = getpwnam(user);
  tmp___13 = strlen(user);
  tmp___14 = xmalloc(((size_t )((unsigned int )(& ((struct userid *)0)->name)) + tmp___13) + 1UL);
  tail = (struct userid *)tmp___14;
  strcpy((char *)((char * __restrict )(tail->name)), (char const *)((char const * __restrict )user));
  }
  if (pwent) {
    {
    {
    tail->id.u = pwent->pw_uid;
    tail->next = user_alist;
    user_alist = tail;
    }
    return (& tail->id.u);
    }
  }
  {
  tail->next = nouser_alist;
  nouser_alist = tail;
  }
  return ((uid_t *)((void *)0));
}
}
char *getgroup(gid_t gid )
{
  struct userid *tail ;
  struct userid *match ;
  struct group *grent ;
  struct group *tmp ;
  char const *name ;
  char const *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  {
  {
  match = (struct userid *)((void *)0);
  tail = group_alist;
  }
  {
  while (1) {
    while_continue: ;
    if (! tail) {
      {
      goto while_break;
      }
    }
    if (tail->id.g == gid) {
      {
      {
      match = tail;
      }
      goto while_break;
      }
    }
    {
    tail = tail->next;
    }
  }
  while_break: ;
  }
  if ((unsigned long )match == (unsigned long )((void *)0)) {
    {
    {
    tmp = getgrgid(gid);
    grent = tmp;
    }
    if (grent) {
      {
      {
      tmp___0 = (char const *)grent->gr_name;
      }
      }
    } else {
      {
      {
      tmp___0 = (char const *)"";
      }
      }
    }
    {
    name = tmp___0;
    tmp___1 = strlen(name);
    tmp___2 = xmalloc(((size_t )((unsigned int )(& ((struct userid *)0)->name)) + tmp___1) + 1UL);
    match = (struct userid *)tmp___2;
    match->id.g = gid;
    strcpy((char *)((char * __restrict )(match->name)), (char const *)((char const * __restrict )name));
    match->next = group_alist;
    group_alist = match;
    }
    }
  }
  if (match->name[0]) {
    {
    {
    tmp___3 = match->name;
    }
    }
  } else {
    {
    {
    tmp___3 = (char *)((void *)0);
    }
    }
  }
  return (tmp___3);
}
}
gid_t *getgidbyname(char const *group )
{
  struct userid *tail ;
  struct group *grent ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  {
  {
  tail = group_alist;
  }
  {
  while (1) {
    while_continue: ;
    if (! tail) {
      {
      goto while_break;
      }
    }
    if ((int )tail->name[0] == (int )*group) {
      {
      if (0) {
        {
        {
        __s1_len = __builtin_strlen((char const *)(tail->name));
        __s2_len = __builtin_strlen(group);
        }
        if (! ((size_t )((void const *)(tail->name + 1)) - (size_t )((void const *)(tail->name)) == 1UL)) {
          {
          goto _L___0;
          }
        } else {
          {
          if (__s1_len >= 4UL) {
            {
            _L___0:
            if (! ((size_t )((void const *)(group + 1)) - (size_t )((void const *)group) == 1UL)) {
              {
              {
              tmp___5 = 1;
              }
              }
            } else {
              {
              if (__s2_len >= 4UL) {
                {
                {
                tmp___5 = 1;
                }
                }
              } else {
                {
                {
                tmp___5 = 0;
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            tmp___5 = 0;
            }
            }
          }
          }
        }
        if (tmp___5) {
          {
          {
          tmp___0 = __builtin_strcmp((char const *)(tail->name), group);
          tmp___4 = tmp___0;
          }
          }
        } else {
          {
          {
          tmp___3 = __builtin_strcmp((char const *)(tail->name), group);
          tmp___4 = tmp___3;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___3 = __builtin_strcmp((char const *)(tail->name), group);
        tmp___4 = tmp___3;
        }
        }
      }
      if (! tmp___4) {
        {
        return (& tail->id.g);
        }
      }
      }
    }
    {
    tail = tail->next;
    }
  }
  while_break: ;
  }
  {
  tail = nogroup_alist;
  }
  {
  while (1) {
    while_continue___0: ;
    if (! tail) {
      {
      goto while_break___0;
      }
    }
    if ((int )tail->name[0] == (int )*group) {
      {
      if (0) {
        {
        {
        __s1_len___0 = __builtin_strlen((char const *)(tail->name));
        __s2_len___0 = __builtin_strlen(group);
        }
        if (! ((size_t )((void const *)(tail->name + 1)) - (size_t )((void const *)(tail->name)) == 1UL)) {
          {
          goto _L___2;
          }
        } else {
          {
          if (__s1_len___0 >= 4UL) {
            {
            _L___2:
            if (! ((size_t )((void const *)(group + 1)) - (size_t )((void const *)group) == 1UL)) {
              {
              {
              tmp___12 = 1;
              }
              }
            } else {
              {
              if (__s2_len___0 >= 4UL) {
                {
                {
                tmp___12 = 1;
                }
                }
              } else {
                {
                {
                tmp___12 = 0;
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            tmp___12 = 0;
            }
            }
          }
          }
        }
        if (tmp___12) {
          {
          {
          tmp___7 = __builtin_strcmp((char const *)(tail->name), group);
          tmp___11 = tmp___7;
          }
          }
        } else {
          {
          {
          tmp___10 = __builtin_strcmp((char const *)(tail->name), group);
          tmp___11 = tmp___10;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___10 = __builtin_strcmp((char const *)(tail->name), group);
        tmp___11 = tmp___10;
        }
        }
      }
      if (! tmp___11) {
        {
        return ((gid_t *)((void *)0));
        }
      }
      }
    }
    {
    tail = tail->next;
    }
  }
  while_break___0: ;
  }
  {
  grent = getgrnam(group);
  tmp___13 = strlen(group);
  tmp___14 = xmalloc(((size_t )((unsigned int )(& ((struct userid *)0)->name)) + tmp___13) + 1UL);
  tail = (struct userid *)tmp___14;
  strcpy((char *)((char * __restrict )(tail->name)), (char const *)((char const * __restrict )group));
  }
  if (grent) {
    {
    {
    tail->id.g = grent->gr_gid;
    tail->next = group_alist;
    group_alist = tail;
    }
    return (& tail->id.g);
    }
  }
  {
  tail->next = nogroup_alist;
  nogroup_alist = tail;
  }
  return ((gid_t *)((void *)0));
}
}
static size_t ino_hash(void const *x , size_t table_size )
{
  struct ino_map_ent const *p ;
  ino_t ino ;
  size_t h ;
  unsigned int i ;
  unsigned int n_words ;
  {
  {
  p = (struct ino_map_ent const *)x;
  ino = (ino_t )p->ino;
  h = ino;
  n_words = (unsigned int )(sizeof(ino) / sizeof(h) + (unsigned long )(sizeof(ino) % sizeof(h) != 0UL));
  i = 1U;
  }
  {
  while (1) {
    while_continue: ;
    if (! (i < n_words)) {
      {
      goto while_break;
      }
    }
    {
    h ^= ino >> (8UL * sizeof(h)) * (unsigned long )i;
    i ++;
    }
  }
  while_break: ;
  }
  return (h % table_size);
}
}
static _Bool ino_compare(void const *x , void const *y )
{
  struct ino_map_ent const *a ;
  struct ino_map_ent const *b ;
  {
  {
  a = (struct ino_map_ent const *)x;
  b = (struct ino_map_ent const *)y;
  }
  return ((_Bool )(a->ino == b->ino));
}
}
struct ino_map *ino_map_alloc(size_t next_mapped_ino )
{
  struct ino_map *im ;
  void *tmp ;
  {
  {
  tmp = malloc(sizeof(*im));
  im = (struct ino_map *)tmp;
  }
  if (im) {
    {
    {
    im->map = hash_initialize((size_t )1021, (Hash_tuning const *)((void *)0), & ino_hash,
                              & ino_compare, & free);
    }
    if (! im->map) {
      {
      {
      free((void *)im);
      }
      return ((struct ino_map *)((void *)0));
      }
    }
    {
    im->next_mapped_ino = next_mapped_ino;
    im->probe = (struct ino_map_ent *)((void *)0);
    }
    }
  }
  return (im);
}
}
void ( __attribute__((__nonnull__(1))) ino_map_free)(struct ino_map *map )
{
  {
  {
  hash_free(map->map);
  free((void *)map->probe);
  free((void *)map);
  }
  return;
}
}
size_t ( __attribute__((__nonnull__(1))) ino_map_insert)(struct ino_map *im , ino_t ino )
{
  struct ino_map_ent *ent ;
  struct ino_map_ent *probe ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  {
  {
  probe = im->probe;
  }
  if (probe) {
    {
    if (probe->ino == ino) {
      {
      return (probe->mapped_ino);
      }
    }
    }
  } else {
    {
    {
    tmp = malloc(sizeof(*probe));
    probe = (struct ino_map_ent *)tmp;
    im->probe = probe;
    }
    if (! probe) {
      {
      return ((size_t )-1);
      }
    }
    }
  }
  {
  probe->ino = ino;
  tmp___0 = hash_insert(im->map, (void const *)probe);
  ent = (struct ino_map_ent *)tmp___0;
  }
  if (! ent) {
    {
    return ((size_t )-1);
    }
  }
  if ((unsigned long )ent != (unsigned long )probe) {
    {
    {
    probe->mapped_ino = ent->mapped_ino;
    }
    }
  } else {
    {
    {
    im->probe = (struct ino_map_ent *)((void *)0);
    tmp___1 = im->next_mapped_ino;
    (im->next_mapped_ino) ++;
    probe->mapped_ino = tmp___1;
    }
    }
  }
  return (probe->mapped_ino);
}
}
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i , char *buf___1 )
{
  char *p ;
  {
  {
  p = buf___1 + (((sizeof(intmax_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL);
  *p = (char)0;
  }
  if (i < 0L) {
    {
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      {
      p --;
      *p = (char )(48L - i % 10L);
      i /= 10L;
      }
      if (! (i != 0L)) {
        {
        goto while_break;
        }
      }
    }
    while_break: ;
    }
    {
    p --;
    *p = (char )'-';
    }
    }
  } else {
    {
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      {
      p --;
      *p = (char )(48L + i % 10L);
      i /= 10L;
      }
      if (! (i != 0L)) {
        {
        goto while_break___0;
        }
      }
    }
    while_break___0: ;
    }
    }
  }
  return (p);
}
}
char *( __attribute__((__warn_unused_result__)) inttostr)(int i , char *buf___1 )
{
  char *p ;
  {
  {
  p = buf___1 + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL);
  *p = (char)0;
  }
  if (i < 0) {
    {
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      {
      p --;
      *p = (char )(48 - i % 10);
      i /= 10;
      }
      if (! (i != 0)) {
        {
        goto while_break;
        }
      }
    }
    while_break: ;
    }
    {
    p --;
    *p = (char )'-';
    }
    }
  } else {
    {
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      {
      p --;
      *p = (char )(48 + i % 10);
      i /= 10;
      }
      if (! (i != 0)) {
        {
        goto while_break___0;
        }
      }
    }
    while_break___0: ;
    }
    }
  }
  return (p);
}
}
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i , char *buf___1 )
{
  char *p ;
  {
  {
  p = buf___1 + (((sizeof(off_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL);
  *p = (char)0;
  }
  if (i < 0L) {
    {
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      {
      p --;
      *p = (char )(48L - i % 10L);
      i /= 10L;
      }
      if (! (i != 0L)) {
        {
        goto while_break;
        }
      }
    }
    while_break: ;
    }
    {
    p --;
    *p = (char )'-';
    }
    }
  } else {
    {
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      {
      p --;
      *p = (char )(48L + i % 10L);
      i /= 10L;
      }
      if (! (i != 0L)) {
        {
        goto while_break___0;
        }
      }
    }
    while_break___0: ;
    }
    }
  }
  return (p);
}
}
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i , char *buf___1 )
{
  char *p ;
  {
  {
  p = buf___1 + ((sizeof(unsigned int ) * 8UL) * 146UL + 484UL) / 485UL;
  *p = (char)0;
  }
  if (i < 0U) {
    {
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      {
      p --;
      *p = (char )(48U - i % 10U);
      i /= 10U;
      }
      if (! (i != 0U)) {
        {
        goto while_break;
        }
      }
    }
    while_break: ;
    }
    {
    p --;
    *p = (char )'-';
    }
    }
  } else {
    {
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      {
      p --;
      *p = (char )(48U + i % 10U);
      i /= 10U;
      }
      if (! (i != 0U)) {
        {
        goto while_break___0;
        }
      }
    }
    while_break___0: ;
    }
    }
  }
  return (p);
}
}
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i , char *buf___1 )
{
  char *p ;
  {
  {
  p = buf___1 + ((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL;
  *p = (char)0;
  }
  if (i < 0UL) {
    {
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      {
      p --;
      *p = (char )(48UL - i % 10UL);
      i /= 10UL;
      }
      if (! (i != 0UL)) {
        {
        goto while_break;
        }
      }
    }
    while_break: ;
    }
    {
    p --;
    *p = (char )'-';
    }
    }
  } else {
    {
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      {
      p --;
      *p = (char )(48UL + i % 10UL);
      i /= 10UL;
      }
      if (! (i != 0UL)) {
        {
        goto while_break___0;
        }
      }
    }
    while_break___0: ;
    }
    }
  }
  return (p);
}
}
int ldtoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , long double x )
{
  char format[sizeof("%-+ 0*.*Lg")] ;
  long double abs_x ;
  long double tmp ;
  int prec ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int n ;
  int tmp___5 ;
  long double tmp___6 ;
  {
  if (x < (long double )0) {
    {
    {
    tmp = - x;
    }
    }
  } else {
    {
    {
    tmp = x;
    }
    }
  }
  {
  abs_x = tmp;
  p = format;
  tmp___0 = p;
  p ++;
  *tmp___0 = (char )'%';
  *p = (char )'-';
  p += (flags & 1) != 0;
  *p = (char )'+';
  p += (flags & 2) != 0;
  *p = (char )' ';
  p += (flags & 4) != 0;
  *p = (char )'0';
  p += (flags & 8) != 0;
  tmp___1 = p;
  p ++;
  *tmp___1 = (char )'*';
  tmp___2 = p;
  p ++;
  *tmp___2 = (char )'.';
  tmp___3 = p;
  p ++;
  *tmp___3 = (char )'*';
  *p = (char )'L';
  p ++;
  tmp___4 = p;
  p ++;
  }
  if (flags & 16) {
    {
    {
    *tmp___4 = (char )'G';
    }
    }
  } else {
    {
    {
    *tmp___4 = (char )'g';
    }
    }
  }
  {
  *p = (char )'\000';
  }
  if (abs_x < 3.36210314311209350626e-4932L) {
    {
    {
    prec = 1;
    }
    }
  } else {
    {
    {
    prec = 18;
    }
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___5 = snprintf((char *)((char * __restrict )buf___1), bufsize___0, (char const *)((char const * __restrict )(format)),
                       width, prec, x);
    n = tmp___5;
    }
    if (n < 0) {
      {
      return (n);
      }
    } else {
      {
      if (21 <= prec) {
        {
        return (n);
        }
      } else {
        {
        if ((size_t )n < bufsize___0) {
          {
          {
          tmp___6 = strtold((char const * __restrict )buf___1, (char ** __restrict )((void *)0));
          }
          if (tmp___6 == x) {
            {
            return (n);
            }
          }
          }
        }
        }
      }
      }
    }
    {
    prec ++;
    }
  }
  while_break: ;
  }
  return (0);
}
}
void initbuffer(struct linebuffer *linebuffer )
{
  {
  {
  memset((void *)linebuffer, 0, sizeof(*linebuffer));
  }
  return;
}
}
struct linebuffer *readlinebuffer(struct linebuffer *linebuffer , FILE *stream )
{
  struct linebuffer *tmp ;
  {
  {
  tmp = readlinebuffer_delim(linebuffer, stream, (char )'\n');
  }
  return (tmp);
}
}
struct linebuffer *readlinebuffer_delim(struct linebuffer *linebuffer , FILE *stream ,
                                        char delimiter )
{
  int c ;
  char *buffer ;
  char *p ;
  char *end ;
  int tmp ;
  int tmp___0 ;
  size_t oldsize ;
  void *tmp___1 ;
  char *tmp___2 ;
  {
  {
  buffer = linebuffer->buffer;
  p = linebuffer->buffer;
  end = buffer + linebuffer->size;
  tmp = feof_unlocked(stream);
  }
  if (tmp) {
    {
    return ((struct linebuffer *)((void *)0));
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    c = getc_unlocked(stream);
    }
    if (c == -1) {
      {
      if ((unsigned long )p == (unsigned long )buffer) {
        {
        return ((struct linebuffer *)((void *)0));
        }
      } else {
        {
        {
        tmp___0 = ferror_unlocked(stream);
        }
        if (tmp___0) {
          {
          return ((struct linebuffer *)((void *)0));
          }
        }
        }
      }
      if ((int )*(p + -1) == (int )delimiter) {
        {
        goto while_break;
        }
      }
      {
      c = (int )delimiter;
      }
      }
    }
    if ((unsigned long )p == (unsigned long )end) {
      {
      {
      oldsize = linebuffer->size;
      tmp___1 = x2realloc((void *)buffer, & linebuffer->size);
      buffer = (char *)tmp___1;
      p = buffer + oldsize;
      linebuffer->buffer = buffer;
      end = buffer + linebuffer->size;
      }
      }
    }
    {
    tmp___2 = p;
    p ++;
    *tmp___2 = (char )c;
    }
    if (! (c != (int )delimiter)) {
      {
      goto while_break;
      }
    }
  }
  while_break: ;
  }
  {
  linebuffer->length = (size_t )(p - buffer);
  }
  return (linebuffer);
}
}
void freebuffer(struct linebuffer *linebuffer )
{
  {
  {
  free((void *)linebuffer->buffer);
  }
  return;
}
}
static char const *get_charset_aliases(void)
{
  char const *cp ;
  char const *dir ;
  char const *base ;
  char *file_name___1 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  int tmp___4 ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  {
  {
  cp = (char const *)charset_aliases;
  }
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
    {
    base = (char const *)"charset.alias";
    tmp = getenv((char const *)"CHARSETALIASDIR");
    dir = (char const *)tmp;
    }
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
      {
      {
      dir = (char const *)"/usr/local/lib";
      }
      }
    } else {
      {
      if ((int const )*(dir + 0) == 0) {
        {
        {
        dir = (char const *)"/usr/local/lib";
        }
        }
      }
      }
    }
    {
    tmp___0 = strlen(dir);
    dir_len___0 = tmp___0;
    tmp___1 = strlen(base);
    base_len___0 = tmp___1;
    }
    if (dir_len___0 > 0UL) {
      {
      if (! ((int const )*(dir + (dir_len___0 - 1UL)) == 47)) {
        {
        {
        tmp___2 = 1;
        }
        }
      } else {
        {
        {
        tmp___2 = 0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___2 = 0;
      }
      }
    }
    {
    add_slash = tmp___2;
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
    file_name___1 = (char *)tmp___3;
    }
    if ((unsigned long )file_name___1 != (unsigned long )((void *)0)) {
      {
      {
      memcpy((void *)((void * __restrict )file_name___1), (void const *)((void const * __restrict )dir),
             dir_len___0);
      }
      if (add_slash) {
        {
        {
        *(file_name___1 + dir_len___0) = (char )'/';
        }
        }
      }
      {
      memcpy((void *)((void * __restrict )((file_name___1 + dir_len___0) + add_slash)),
             (void const *)((void const * __restrict )base), base_len___0 + 1UL);
      }
      }
    }
    if ((unsigned long )file_name___1 == (unsigned long )((void *)0)) {
      {
      {
      cp = (char const *)"";
      }
      }
    } else {
      {
      {
      tmp___4 = open((char const *)file_name___1, 131072);
      fd = tmp___4;
      }
      if (fd < 0) {
        {
        {
        cp = (char const *)"";
        }
        }
      } else {
        {
        {
        fp = fdopen(fd, (char const *)"r");
        }
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
          {
          close(fd);
          cp = (char const *)"";
          }
          }
        } else {
          {
          {
          res_ptr = (char *)((void *)0);
          res_size = (size_t )0;
          }
          {
          while (1) {
            while_continue: ;
            if (! 1) {
              {
              goto while_break;
              }
            }
            {
            c = getc_unlocked(fp);
            }
            if (c == -1) {
              {
              goto while_break;
              }
            }
            if (c == 10) {
              {
              goto __Cont;
              }
            } else {
              {
              if (c == 32) {
                {
                goto __Cont;
                }
              } else {
                {
                if (c == 9) {
                  {
                  goto __Cont;
                  }
                }
                }
              }
              }
            }
            if (c == 35) {
              {
              {
              while (1) {
                while_continue___0: ;
                if (! 1) {
                  {
                  goto while_break___0;
                  }
                }
                {
                c = getc_unlocked(fp);
                }
                if (c == -1) {
                  {
                  goto while_break___0;
                  }
                } else {
                  {
                  if (c == 10) {
                    {
                    goto while_break___0;
                    }
                  }
                  }
                }
              }
              while_break___0: ;
              }
              if (c == -1) {
                {
                goto while_break;
                }
              }
              goto __Cont;
              }
            }
            {
            ungetc(c, fp);
            tmp___5 = fscanf((FILE * __restrict )fp, (char const * __restrict )"%50s %50s",
                             buf1, buf2);
            }
            if (tmp___5 < 2) {
              {
              goto while_break;
              }
            }
            {
            l1 = strlen((char const *)(buf1));
            l2 = strlen((char const *)(buf2));
            old_res_ptr = res_ptr;
            }
            if (res_size == 0UL) {
              {
              {
              res_size = ((l1 + 1UL) + l2) + 1UL;
              tmp___6 = malloc(res_size + 1UL);
              res_ptr = (char *)tmp___6;
              }
              }
            } else {
              {
              {
              res_size += ((l1 + 1UL) + l2) + 1UL;
              tmp___7 = realloc((void *)res_ptr, res_size + 1UL);
              res_ptr = (char *)tmp___7;
              }
              }
            }
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
              {
              {
              res_size = (size_t )0;
              free((void *)old_res_ptr);
              }
              goto while_break;
              }
            }
            {
            strcpy((char *)((char * __restrict )(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL))),
                   (char const *)((char const * __restrict )(buf1)));
            strcpy((char *)((char * __restrict )((res_ptr + res_size) - (l2 + 1UL))),
                   (char const *)((char const * __restrict )(buf2)));
            }
            __Cont:
            {
            }
          }
          while_break: ;
          }
          {
          rpl_fclose(fp);
          }
          if (res_size == 0UL) {
            {
            {
            cp = (char const *)"";
            }
            }
          } else {
            {
            {
            *(res_ptr + res_size) = (char )'\000';
            cp = (char const *)res_ptr;
            }
            }
          }
          }
        }
        }
      }
      {
      free((void *)file_name___1);
      }
      }
    }
    {
    charset_aliases = (char const * volatile )cp;
    }
    }
  }
  return (cp);
}
}
char const *locale_charset(void)
{
  char const *codeset ;
  char const *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  {
  {
  tmp = nl_langinfo(14);
  codeset = (char const *)tmp;
  }
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
    {
    {
    codeset = (char const *)"";
    }
    }
  }
  {
  aliases = get_charset_aliases();
  }
  {
  while (1) {
    while_continue: ;
    if (! ((int const )*aliases != 0)) {
      {
      goto while_break;
      }
    }
    if (0) {
      {
      {
      __s1_len = __builtin_strlen(codeset);
      __s2_len = __builtin_strlen(aliases);
      }
      if (! ((size_t )((void const *)(codeset + 1)) - (size_t )((void const *)codeset) == 1UL)) {
        {
        goto _L___0;
        }
      } else {
        {
        if (__s1_len >= 4UL) {
          {
          _L___0:
          if (! ((size_t )((void const *)(aliases + 1)) - (size_t )((void const *)aliases) == 1UL)) {
            {
            {
            tmp___9 = 1;
            }
            }
          } else {
            {
            if (__s2_len >= 4UL) {
              {
              {
              tmp___9 = 1;
              }
              }
            } else {
              {
              {
              tmp___9 = 0;
              }
              }
            }
            }
          }
          }
        } else {
          {
          {
          tmp___9 = 0;
          }
          }
        }
        }
      }
      if (tmp___9) {
        {
        {
        tmp___4 = __builtin_strcmp(codeset, aliases);
        tmp___8 = tmp___4;
        }
        }
      } else {
        {
        {
        tmp___7 = __builtin_strcmp(codeset, aliases);
        tmp___8 = tmp___7;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___7 = __builtin_strcmp(codeset, aliases);
      tmp___8 = tmp___7;
      }
      }
    }
    if (tmp___8 == 0) {
      {
      {
      tmp___2 = strlen(aliases);
      codeset = (aliases + tmp___2) + 1;
      }
      goto while_break;
      }
    } else {
      {
      if ((int const )*(aliases + 0) == 42) {
        {
        if ((int const )*(aliases + 1) == 0) {
          {
          {
          tmp___2 = strlen(aliases);
          codeset = (aliases + tmp___2) + 1;
          }
          goto while_break;
          }
        }
        }
      }
      }
    }
    {
    tmp___0 = strlen(aliases);
    aliases += tmp___0 + 1UL;
    tmp___1 = strlen(aliases);
    aliases += tmp___1 + 1UL;
    }
  }
  while_break: ;
  }
  if ((int const )*(codeset + 0) == 0) {
    {
    {
    codeset = (char const *)"ASCII";
    }
    }
  }
  return (codeset);
}
}
extern int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 , pthread_t __thread2 ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 , pthread_t __thread2 )
{
  {
  return (__thread1 == __thread2);
}
}
int glthread_recursive_lock_init_multithreaded(gl_recursive_lock_t *lock )
{
  pthread_mutexattr_t attributes ;
  int err ;
  {
  {
  err = pthread_mutexattr_init(& attributes);
  }
  if (err != 0) {
    {
    return (err);
    }
  }
  {
  err = pthread_mutexattr_settype(& attributes, 1);
  }
  if (err != 0) {
    {
    {
    pthread_mutexattr_destroy(& attributes);
    }
    return (err);
    }
  }
  {
  err = pthread_mutex_init(lock, (pthread_mutexattr_t const *)(& attributes));
  }
  if (err != 0) {
    {
    {
    pthread_mutexattr_destroy(& attributes);
    }
    return (err);
    }
  }
  {
  err = pthread_mutexattr_destroy(& attributes);
  }
  if (err != 0) {
    {
    return (err);
    }
  }
  return (0);
}
}
int glthread_once_singlethreaded(pthread_once_t *once_control )
{
  char *firstbyte ;
  {
  {
  firstbyte = (char *)once_control;
  }
  if ((int )*firstbyte == (int )*((char const *)(& fresh_once))) {
    {
    {
    *firstbyte = (char )(~ ((int const )*((char const *)(& fresh_once))));
    }
    return (1);
    }
  } else {
    {
    return (0);
    }
  }
}
}
void parse_long_options(int argc , char **argv , char const *command_name , char const *package ,
                        char const *version , void (*usage_func)(int ) , ...)
{
  int c ;
  int saved_opterr ;
  va_list authors ;
  {
  {
  saved_opterr = rpl_opterr;
  rpl_opterr = 0;
  }
  if (argc == 2) {
    {
    { if(!(argc == 2)) { reach_error(); abort(); } };
    {
    c = rpl_getopt_long(argc, argv, (char const *)"+", long_options, (int *)((void *)0));
    }
    if (c != -1) {
      {
      { if(!(c != -1)) { reach_error(); abort(); } };
      {
      if (c == 104) {
        {
        goto case_104;
        }
      }
      if (c == 118) {
        {
        goto case_118;
        }
      }
      goto switch_default;
      case_104:
      {
      (*usage_func)(0);
      { if(!(argc == 2)) { reach_error(); abort(); } };
      { if(!(usage_func == & usage)) { reach_error(); abort(); } };
      { if(!(c == 118)) { reach_error(); abort(); } };
      }
      case_118:
      {
      { if(!(argc == 2)) { reach_error(); abort(); } };
      { if(!(usage_func == & usage)) { reach_error(); abort(); } };
      { if(!(c == 118)) { reach_error(); abort(); } };
      {
      __builtin_va_start(authors, usage_func);
      { if(!(argc == 2)) { reach_error(); abort(); } };
      { if(!(usage_func == & usage)) { reach_error(); abort(); } };
      { if(!(c == 118)) { reach_error(); abort(); } };
      version_etc_va(stdout, command_name, package, version, authors);
      { if(!(argc == 2)) { reach_error(); abort(); } };
      { if(!(usage_func == & usage)) { reach_error(); abort(); } };
      { if(!(c == 118)) { reach_error(); abort(); } };
      exit(0);
      }
      }
      switch_default:
      goto switch_break;
      switch_break: ;
      }
      }
    }
    }
  }
  {
  rpl_opterr = saved_opterr;
  rpl_optind = 0;
  }
  return;
}
}
void *mmalloca(size_t n )
{
  size_t nplus ;
  char *p ;
  void *tmp ;
  size_t slot ;
  {
  {
  nplus = n + (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
  }
  if (nplus >= n) {
    {
    {
    tmp = malloc(nplus);
    p = (char *)tmp;
    }
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
      {
      p += (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
      *((int *)p + -1) = 336984906;
      slot = (unsigned long )p % 257UL;
      ((struct header *)(p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next = mmalloca_results[slot];
      mmalloca_results[slot] = (void *)p;
      }
      return ((void *)p);
      }
    }
    }
  }
  return ((void *)0);
}
}
void freea(void *p )
{
  size_t slot ;
  void **chain ;
  char *p_begin ;
  {
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
    if (*((int *)p + -1) == 336984906) {
      {
      {
      slot = (unsigned long )p % 257UL;
      chain = & mmalloca_results[slot];
      }
      {
      while (1) {
        while_continue: ;
        if (! ((unsigned long )*chain != (unsigned long )((void *)0))) {
          {
          goto while_break;
          }
        }
        if ((unsigned long )*chain == (unsigned long )p) {
          {
          {
          p_begin = (char *)p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
          *chain = ((struct header *)p_begin)->next;
          free((void *)p_begin);
          }
          return;
          }
        }
        {
        chain = & ((struct header *)((char *)*chain - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next;
        }
      }
      while_break: ;
      }
      }
    }
    }
  }
  return;
}
}
static _Bool wc_ensure_printable(wchar_t *wchars )
{
  _Bool replaced ;
  wchar_t *wc ;
  int tmp ;
  {
  {
  replaced = (_Bool)0;
  wc = wchars;
  }
  {
  while (1) {
    while_continue: ;
    if (! *wc) {
      {
      goto while_break;
      }
    }
    {
    tmp = iswprint((wint_t )*wc);
    }
    if (! tmp) {
      {
      {
      *wc = 65533;
      replaced = (_Bool)1;
      }
      }
    }
    {
    wc ++;
    }
  }
  while_break: ;
  }
  return (replaced);
}
}
static size_t wc_truncate(wchar_t *wc , size_t width )
{
  size_t cells ;
  int next_cells ;
  {
  {
  cells = (size_t )0;
  next_cells = 0;
  }
  {
  while (1) {
    while_continue: ;
    if (! *wc) {
      {
      goto while_break;
      }
    }
    {
    next_cells = wcwidth(*wc);
    }
    if (next_cells == -1) {
      {
      {
      *wc = 65533;
      next_cells = 1;
      }
      }
    }
    if (cells + (size_t )next_cells > width) {
      {
      goto while_break;
      }
    }
    {
    cells += (size_t )next_cells;
    wc ++;
    }
  }
  while_break: ;
  }
  {
  *wc = 0;
  }
  return (cells);
}
}
static char *mbs_align_pad(char *dest , char const *dest_end , size_t n_spaces )
{
  char *tmp ;
  size_t tmp___0 ;
  {
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___0 = n_spaces;
    n_spaces --;
    }
    if (tmp___0) {
      {
      if (! ((unsigned long )dest < (unsigned long )dest_end)) {
        {
        goto while_break;
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
    {
    tmp = dest;
    dest ++;
    *tmp = (char )' ';
    }
  }
  while_break: ;
  }
  {
  *dest = (char )'\000';
  }
  return (dest);
}
}
size_t mbsalign(char const *src , char *dest , size_t dest_size , size_t *width ,
                mbs_align_t align , int flags )
{
  size_t ret ;
  size_t src_size ;
  size_t tmp ;
  char *newstr ;
  wchar_t *str_wc ;
  char const *str_to_print ;
  size_t n_cols ;
  size_t n_used_bytes ;
  size_t n_spaces ;
  _Bool conversion ;
  _Bool wc_enabled ;
  size_t src_chars ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  size_t start_spaces ;
  size_t end_spaces ;
  size_t space_left ;
  char *dest_end ;
  size_t tmp___8 ;
  void *tmp___9 ;
  {
  {
  ret = 0xffffffffffffffffUL;
  tmp = strlen(src);
  src_size = tmp + 1UL;
  newstr = (char *)((void *)0);
  str_wc = (wchar_t *)((void *)0);
  str_to_print = src;
  n_cols = src_size - 1UL;
  n_used_bytes = n_cols;
  n_spaces = (size_t )0;
  conversion = (_Bool)0;
  wc_enabled = (_Bool)0;
  tmp___4 = __ctype_get_mb_cur_max();
  }
  if (tmp___4 > 1UL) {
    {
    {
    tmp___0 = mbstowcs((wchar_t *)((wchar_t * __restrict )((void *)0)), (char const *)((char const * __restrict )src),
                       (size_t )0);
    src_chars = tmp___0;
    }
    if (src_chars == 0xffffffffffffffffUL) {
      {
      if (flags & 1) {
        {
        goto mbsalign_unibyte;
        }
      } else {
        {
        goto mbsalign_cleanup;
        }
      }
      }
    }
    {
    src_chars ++;
    tmp___1 = malloc(src_chars * sizeof(wchar_t ));
    str_wc = (wchar_t *)tmp___1;
    }
    if ((unsigned long )str_wc == (unsigned long )((void *)0)) {
      {
      if (flags & 1) {
        {
        goto mbsalign_unibyte;
        }
      } else {
        {
        goto mbsalign_cleanup;
        }
      }
      }
    }
    {
    tmp___3 = mbstowcs((wchar_t *)((wchar_t * __restrict )str_wc), (char const *)((char const * __restrict )src),
                       src_chars);
    }
    if (tmp___3 != 0UL) {
      {
      {
      *(str_wc + (src_chars - 1UL)) = 0;
      wc_enabled = (_Bool)1;
      conversion = wc_ensure_printable(str_wc);
      tmp___2 = wcswidth((wchar_t const *)str_wc, src_chars);
      n_cols = (size_t )tmp___2;
      }
      }
    }
    }
  }
  if (wc_enabled) {
    {
    if (conversion) {
      {
      goto _L;
      }
    } else {
      {
      if (n_cols > *width) {
        {
        _L:
        if (conversion) {
          {
          {
          tmp___5 = wcstombs((char *)((char * __restrict )((void *)0)), (wchar_t const *)((wchar_t const * __restrict )str_wc),
                             (size_t )0);
          src_size = tmp___5 + 1UL;
          }
          }
        }
        {
        tmp___6 = malloc(src_size);
        newstr = (char *)tmp___6;
        }
        if ((unsigned long )newstr == (unsigned long )((void *)0)) {
          {
          if (flags & 1) {
            {
            goto mbsalign_unibyte;
            }
          } else {
            {
            goto mbsalign_cleanup;
            }
          }
          }
        }
        {
        str_to_print = (char const *)newstr;
        n_cols = wc_truncate(str_wc, *width);
        tmp___7 = wcstombs((char *)((char * __restrict )newstr), (wchar_t const *)((wchar_t const * __restrict )str_wc),
                           src_size);
        n_used_bytes = tmp___7;
        }
        }
      }
      }
    }
    }
  }
  mbsalign_unibyte:
  if (n_cols > *width) {
    {
    {
    n_cols = *width;
    n_used_bytes = n_cols;
    }
    }
  }
  if (*width > n_cols) {
    {
    {
    n_spaces = *width - n_cols;
    }
    }
  }
  {
  *width = n_cols;
  ret = n_used_bytes + n_spaces;
  }
  if (dest_size != 0UL) {
    {
    {
    dest_end = (dest + dest_size) - 1;
    }
    {
    if ((int )align == 0) {
      {
      goto case_0;
      }
    }
    if ((int )align == 1) {
      {
      goto case_1;
      }
    }
    goto switch_default;
    case_0:
    {
    start_spaces = (size_t )0;
    end_spaces = n_spaces;
    }
    goto switch_break;
    case_1:
    {
    start_spaces = n_spaces;
    end_spaces = (size_t )0;
    }
    goto switch_break;
    switch_default:
    {
    start_spaces = n_spaces / 2UL + n_spaces % 2UL;
    end_spaces = n_spaces / 2UL;
    }
    goto switch_break;
    switch_break: ;
    }
    {
    dest = mbs_align_pad(dest, (char const *)dest_end, start_spaces);
    space_left = (size_t )(dest_end - dest);
    }
    if (n_used_bytes < space_left) {
      {
      {
      tmp___8 = n_used_bytes;
      }
      }
    } else {
      {
      {
      tmp___8 = space_left;
      }
      }
    }
    {
    tmp___9 = mempcpy((void *)((void * __restrict )dest), (void const *)((void const * __restrict )str_to_print),
                      tmp___8);
    dest = (char *)tmp___9;
    mbs_align_pad(dest, (char const *)dest_end, end_spaces);
    }
    }
  }
  mbsalign_cleanup:
  {
  free((void *)str_wc);
  free((void *)newstr);
  }
  return (ret);
}
}
char *ambsalign(char const *src , size_t *width , mbs_align_t align , int flags )
{
  size_t orig_width ;
  size_t size ;
  size_t req ;
  char *buf___1 ;
  char *nbuf ;
  void *tmp ;
  {
  {
  orig_width = *width;
  size = *width;
  req = size;
  buf___1 = (char *)((void *)0);
  }
  {
  while (1) {
    while_continue: ;
    if (! (req >= size)) {
      {
      goto while_break;
      }
    }
    {
    size = req + 1UL;
    tmp = realloc((void *)buf___1, size);
    nbuf = (char *)tmp;
    }
    if ((unsigned long )nbuf == (unsigned long )((void *)0)) {
      {
      {
      free((void *)buf___1);
      buf___1 = (char *)((void *)0);
      }
      goto while_break;
      }
    }
    {
    buf___1 = nbuf;
    *width = orig_width;
    req = mbsalign(src, buf___1, size, width, align, flags);
    }
    if (req == 0xffffffffffffffffUL) {
      {
      {
      free((void *)buf___1);
      buf___1 = (char *)((void *)0);
      }
      goto while_break;
      }
    }
  }
  while_break: ;
  }
  return (buf___1);
}
}
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const *s1 , char const *s2 )
{
  mbui_iterator_t iter1 ;
  mbui_iterator_t iter2 ;
  int cmp ;
  wint_t tmp ;
  wint_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned char const *p1 ;
  unsigned char const *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int __res ;
  __int32_t const **tmp___19 ;
  unsigned short const **tmp___20 ;
  int __res___0 ;
  __int32_t const **tmp___23 ;
  unsigned short const **tmp___24 ;
  size_t tmp___27 ;
  {
  if ((unsigned long )s1 == (unsigned long )s2) {
    {
    return (0);
    }
  }
  {
  tmp___27 = __ctype_get_mb_cur_max();
  }
  if (tmp___27 > 1UL) {
    {
    {
    iter1.cur.ptr = s1;
    iter1.in_shift = (_Bool)0;
    memset((void *)(& iter1.state), '\000', sizeof(mbstate_t ));
    iter1.next_done = (_Bool)0;
    iter2.cur.ptr = s2;
    iter2.in_shift = (_Bool)0;
    memset((void *)(& iter2.state), '\000', sizeof(mbstate_t ));
    iter2.next_done = (_Bool)0;
    }
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      {
      mbuiter_multi_next(& iter1);
      }
      if (iter1.cur.wc_valid) {
        {
        if (iter1.cur.wc == 0) {
          {
          {
          tmp___13 = 0;
          }
          }
        } else {
          {
          {
          tmp___13 = 1;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___13 = 1;
        }
        }
      }
      if (tmp___13) {
        {
        {
        mbuiter_multi_next(& iter2);
        }
        if (iter2.cur.wc_valid) {
          {
          if (iter2.cur.wc == 0) {
            {
            {
            tmp___14 = 0;
            }
            }
          } else {
            {
            {
            tmp___14 = 1;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___14 = 1;
          }
          }
        }
        if (! tmp___14) {
          {
          goto while_break;
          }
        }
        }
      } else {
        {
        goto while_break;
        }
      }
      if (iter1.cur.wc_valid) {
        {
        if (iter2.cur.wc_valid) {
          {
          {
          tmp = towlower((wint_t )iter1.cur.wc);
          tmp___0 = towlower((wint_t )iter2.cur.wc);
          tmp___1 = (int )tmp - (int )tmp___0;
          }
          }
        } else {
          {
          {
          tmp___1 = -1;
          }
          }
        }
        {
        tmp___12 = tmp___1;
        }
        }
      } else {
        {
        if (iter2.cur.wc_valid) {
          {
          {
          tmp___11 = 1;
          }
          }
        } else {
          {
          if (iter1.cur.bytes == iter2.cur.bytes) {
            {
            {
            tmp___2 = memcmp((void const *)iter1.cur.ptr, (void const *)iter2.cur.ptr,
                             iter1.cur.bytes);
            tmp___10 = tmp___2;
            }
            }
          } else {
            {
            if (iter1.cur.bytes < iter2.cur.bytes) {
              {
              {
              tmp___5 = memcmp((void const *)iter1.cur.ptr, (void const *)iter2.cur.ptr,
                               iter1.cur.bytes);
              }
              if (tmp___5 > 0) {
                {
                {
                tmp___4 = 1;
                }
                }
              } else {
                {
                {
                tmp___4 = -1;
                }
                }
              }
              {
              tmp___9 = tmp___4;
              }
              }
            } else {
              {
              {
              tmp___8 = memcmp((void const *)iter1.cur.ptr, (void const *)iter2.cur.ptr,
                               iter2.cur.bytes);
              }
              if (tmp___8 >= 0) {
                {
                {
                tmp___7 = 1;
                }
                }
              } else {
                {
                {
                tmp___7 = -1;
                }
                }
              }
              {
              tmp___9 = tmp___7;
              }
              }
            }
            {
            tmp___10 = tmp___9;
            }
            }
          }
          {
          tmp___11 = tmp___10;
          }
          }
        }
        {
        tmp___12 = tmp___11;
        }
        }
      }
      {
      cmp = tmp___12;
      }
      if (cmp != 0) {
        {
        return (cmp);
        }
      }
      {
      iter1.cur.ptr += iter1.cur.bytes;
      iter1.next_done = (_Bool)0;
      iter2.cur.ptr += iter2.cur.bytes;
      iter2.next_done = (_Bool)0;
      }
    }
    while_break: ;
    }
    {
    mbuiter_multi_next(& iter1);
    }
    if (iter1.cur.wc_valid) {
      {
      if (iter1.cur.wc == 0) {
        {
        {
        tmp___15 = 0;
        }
        }
      } else {
        {
        {
        tmp___15 = 1;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___15 = 1;
      }
      }
    }
    if (tmp___15) {
      {
      return (1);
      }
    }
    {
    mbuiter_multi_next(& iter2);
    }
    if (iter2.cur.wc_valid) {
      {
      if (iter2.cur.wc == 0) {
        {
        {
        tmp___16 = 0;
        }
        }
      } else {
        {
        {
        tmp___16 = 1;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___16 = 1;
      }
      }
    }
    if (tmp___16) {
      {
      return (-1);
      }
    }
    return (0);
    }
  } else {
    {
    {
    p1 = (unsigned char const *)s1;
    p2 = (unsigned char const *)s2;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      {
      tmp___20 = __ctype_b_loc();
      }
      if ((int const )*(*tmp___20 + (int )*p1) & 256) {
        {
        if (sizeof(*p1) > 1UL) {
          {
          {
          __res = tolower((int )*p1);
          }
          }
        } else {
          {
          {
          tmp___19 = __ctype_tolower_loc();
          __res = (int )*(*tmp___19 + (int )*p1);
          }
          }
        }
        {
        c1 = (unsigned char )__res;
        }
        }
      } else {
        {
        {
        c1 = (unsigned char )*p1;
        }
        }
      }
      {
      tmp___24 = __ctype_b_loc();
      }
      if ((int const )*(*tmp___24 + (int )*p2) & 256) {
        {
        if (sizeof(*p2) > 1UL) {
          {
          {
          __res___0 = tolower((int )*p2);
          }
          }
        } else {
          {
          {
          tmp___23 = __ctype_tolower_loc();
          __res___0 = (int )*(*tmp___23 + (int )*p2);
          }
          }
        }
        {
        c2 = (unsigned char )__res___0;
        }
        }
      } else {
        {
        {
        c2 = (unsigned char )*p2;
        }
        }
      }
      if ((int )c1 == 0) {
        {
        goto while_break___0;
        }
      }
      {
      p1 ++;
      p2 ++;
      }
      if (! ((int )c1 == (int )c2)) {
        {
        goto while_break___0;
        }
      }
    }
    while_break___0: ;
    }
    return ((int )c1 - (int )c2);
    }
  }
}
}
size_t ( __attribute__((__nonnull__(1))) mbslen)(char const *string )
{
  size_t count ;
  mbui_iterator_t iter ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  {
  {
  tmp___1 = __ctype_get_mb_cur_max();
  }
  if (tmp___1 > 1UL) {
    {
    {
    count = (size_t )0;
    iter.cur.ptr = string;
    iter.in_shift = (_Bool)0;
    memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
    iter.next_done = (_Bool)0;
    }
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      {
      mbuiter_multi_next(& iter);
      }
      if (iter.cur.wc_valid) {
        {
        if (iter.cur.wc == 0) {
          {
          {
          tmp = 0;
          }
          }
        } else {
          {
          {
          tmp = 1;
          }
          }
        }
        }
      } else {
        {
        {
        tmp = 1;
        }
        }
      }
      if (! tmp) {
        {
        goto while_break;
        }
      }
      {
      count ++;
      iter.cur.ptr += iter.cur.bytes;
      iter.next_done = (_Bool)0;
      }
    }
    while_break: ;
    }
    return (count);
    }
  } else {
    {
    {
    tmp___0 = strlen(string);
    }
    return (tmp___0);
    }
  }
}
}
__inline static void mb_copy(mbchar_t *new_mbc , mbchar_t const *old_mbc )
{
  _Bool tmp ;
  {
  if ((unsigned long )old_mbc->ptr == (unsigned long )(& old_mbc->buf[0])) {
    {
    {
    memcpy((void *)((void * __restrict )(& new_mbc->buf[0])), (void const *)((void const * __restrict )(& old_mbc->buf[0])),
           (size_t )old_mbc->bytes);
    new_mbc->ptr = (char const *)(& new_mbc->buf[0]);
    }
    }
  } else {
    {
    {
    new_mbc->ptr = (char const *)old_mbc->ptr;
    }
    }
  }
  {
  new_mbc->bytes = (size_t )old_mbc->bytes;
  tmp = (_Bool )old_mbc->wc_valid;
  new_mbc->wc_valid = tmp;
  }
  if (tmp) {
    {
    {
    new_mbc->wc = (wchar_t )old_mbc->wc;
    }
    }
  }
  return;
}
}
static _Bool knuth_morris_pratt(unsigned char const *haystack , unsigned char const *needle ,
                                size_t needle_len , unsigned char const **resultp )
{
  size_t m ;
  size_t *table___0 ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t i ;
  size_t j ;
  unsigned char b ;
  size_t j___0 ;
  unsigned char const *rhaystack ;
  unsigned char const *phaystack ;
  {
  {
  m = needle_len;
  }
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
    {
    {
    tmp___4 = -1;
    }
    }
  } else {
    {
    {
    tmp___4 = -2;
    }
    }
  }
  if (m > (size_t )tmp___4 / sizeof(size_t )) {
    {
    {
    tmp___3 = (void *)0;
    }
    }
  } else {
    {
    if (m * sizeof(size_t ) < 4016UL) {
      {
      {
      tmp___0 = __builtin_alloca(m * sizeof(size_t ) + 16UL);
      tmp___2 = (void *)((char *)tmp___0 + 16);
      }
      }
    } else {
      {
      {
      tmp___1 = mmalloca(m * sizeof(size_t ));
      tmp___2 = tmp___1;
      }
      }
    }
    {
    tmp___3 = tmp___2;
    }
    }
  }
  {
  table___0 = (size_t *)tmp___3;
  }
  if ((unsigned long )table___0 == (unsigned long )((void *)0)) {
    {
    return ((_Bool)0);
    }
  }
  {
  *(table___0 + 1) = (size_t )1;
  j = (size_t )0;
  i = (size_t )2;
  }
  {
  while (1) {
    while_continue: ;
    if (! (i < m)) {
      {
      goto while_break;
      }
    }
    {
    b = (unsigned char )*(needle + (i - 1UL));
    }
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      if ((int )b == (int )*(needle + j)) {
        {
        {
        j ++;
        *(table___0 + i) = i - j;
        }
        goto while_break___0;
        }
      }
      if (j == 0UL) {
        {
        {
        *(table___0 + i) = i;
        }
        goto while_break___0;
        }
      }
      {
      j -= *(table___0 + j);
      }
    }
    while_break___0: ;
    }
    {
    i ++;
    }
  }
  while_break: ;
  }
  {
  *resultp = (unsigned char const *)((void *)0);
  j___0 = (size_t )0;
  rhaystack = haystack;
  phaystack = haystack;
  }
  {
  while (1) {
    while_continue___1: ;
    if (! ((int const )*phaystack != 0)) {
      {
      goto while_break___1;
      }
    }
    if ((int const )*(needle + j___0) == (int const )*phaystack) {
      {
      {
      j___0 ++;
      phaystack ++;
      }
      if (j___0 == m) {
        {
        {
        *resultp = rhaystack;
        }
        goto while_break___1;
        }
      }
      }
    } else {
      {
      if (j___0 > 0UL) {
        {
        {
        rhaystack += *(table___0 + j___0);
        j___0 -= *(table___0 + j___0);
        }
        }
      } else {
        {
        {
        rhaystack ++;
        phaystack ++;
        }
        }
      }
      }
    }
  }
  while_break___1: ;
  }
  {
  freea((void *)table___0);
  }
  return ((_Bool)1);
}
}
static _Bool knuth_morris_pratt_multibyte(char const *haystack , char const *needle ,
                                          char const **resultp )
{
  size_t m ;
  size_t tmp ;
  mbchar_t *needle_mbchars ;
  size_t *table___0 ;
  char *memory ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  mbui_iterator_t iter ;
  size_t j ;
  int tmp___6 ;
  size_t i ;
  size_t j___0 ;
  mbchar_t *b ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t j___1 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t phaystack ;
  size_t count ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  {
  {
  tmp = mbslen(needle);
  m = tmp;
  }
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
    {
    {
    tmp___5 = -1;
    }
    }
  } else {
    {
    {
    tmp___5 = -2;
    }
    }
  }
  if (m > (size_t )tmp___5 / (sizeof(mbchar_t ) + sizeof(size_t ))) {
    {
    {
    tmp___4 = (void *)0;
    }
    }
  } else {
    {
    if (m * (sizeof(mbchar_t ) + sizeof(size_t )) < 4016UL) {
      {
      {
      tmp___1 = __builtin_alloca(m * (sizeof(mbchar_t ) + sizeof(size_t )) + 16UL);
      tmp___3 = (void *)((char *)tmp___1 + 16);
      }
      }
    } else {
      {
      {
      tmp___2 = mmalloca(m * (sizeof(mbchar_t ) + sizeof(size_t )));
      tmp___3 = tmp___2;
      }
      }
    }
    {
    tmp___4 = tmp___3;
    }
    }
  }
  {
  memory = (char *)tmp___4;
  }
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
    {
    return ((_Bool)0);
    }
  }
  {
  needle_mbchars = (mbchar_t *)memory;
  table___0 = (size_t *)(memory + m * sizeof(mbchar_t ));
  j = (size_t )0;
  iter.cur.ptr = needle;
  iter.in_shift = (_Bool)0;
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
  iter.next_done = (_Bool)0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    mbuiter_multi_next(& iter);
    }
    if (iter.cur.wc_valid) {
      {
      if (iter.cur.wc == 0) {
        {
        {
        tmp___6 = 0;
        }
        }
      } else {
        {
        {
        tmp___6 = 1;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___6 = 1;
      }
      }
    }
    if (! tmp___6) {
      {
      goto while_break;
      }
    }
    {
    mb_copy(needle_mbchars + j, (mbchar_t const *)(& iter.cur));
    iter.cur.ptr += iter.cur.bytes;
    iter.next_done = (_Bool)0;
    j ++;
    }
  }
  while_break: ;
  }
  {
  *(table___0 + 1) = (size_t )1;
  j___0 = (size_t )0;
  i = (size_t )2;
  }
  {
  while (1) {
    while_continue___0: ;
    if (! (i < m)) {
      {
      goto while_break___0;
      }
    }
    {
    b = needle_mbchars + (i - 1UL);
    }
    {
    while (1) {
      while_continue___1: ;
      if (! 1) {
        {
        goto while_break___1;
        }
      }
      if (b->wc_valid) {
        {
        if ((needle_mbchars + j___0)->wc_valid) {
          {
          {
          tmp___9 = b->wc == (needle_mbchars + j___0)->wc;
          }
          }
        } else {
          {
          goto _L;
          }
        }
        }
      } else {
        {
        _L:
        if (b->bytes == (needle_mbchars + j___0)->bytes) {
          {
          {
          tmp___7 = memcmp((void const *)b->ptr, (void const *)(needle_mbchars + j___0)->ptr,
                           b->bytes);
          }
          if (tmp___7 == 0) {
            {
            {
            tmp___8 = 1;
            }
            }
          } else {
            {
            {
            tmp___8 = 0;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___8 = 0;
          }
          }
        }
        {
        tmp___9 = tmp___8;
        }
        }
      }
      if (tmp___9) {
        {
        {
        j___0 ++;
        *(table___0 + i) = i - j___0;
        }
        goto while_break___1;
        }
      }
      if (j___0 == 0UL) {
        {
        {
        *(table___0 + i) = i;
        }
        goto while_break___1;
        }
      }
      {
      j___0 -= *(table___0 + j___0);
      }
    }
    while_break___1: ;
    }
    {
    i ++;
    }
  }
  while_break___0: ;
  }
  {
  *resultp = (char const *)((void *)0);
  j___1 = (size_t )0;
  rhaystack.cur.ptr = haystack;
  rhaystack.in_shift = (_Bool)0;
  memset((void *)(& rhaystack.state), '\000', sizeof(mbstate_t ));
  rhaystack.next_done = (_Bool)0;
  phaystack.cur.ptr = haystack;
  phaystack.in_shift = (_Bool)0;
  memset((void *)(& phaystack.state), '\000', sizeof(mbstate_t ));
  phaystack.next_done = (_Bool)0;
  }
  {
  while (1) {
    while_continue___2: ;
    if (! 1) {
      {
      goto while_break___2;
      }
    }
    {
    mbuiter_multi_next(& phaystack);
    }
    if (phaystack.cur.wc_valid) {
      {
      if (phaystack.cur.wc == 0) {
        {
        {
        tmp___15 = 0;
        }
        }
      } else {
        {
        {
        tmp___15 = 1;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___15 = 1;
      }
      }
    }
    if (! tmp___15) {
      {
      goto while_break___2;
      }
    }
    if ((needle_mbchars + j___1)->wc_valid) {
      {
      if (phaystack.cur.wc_valid) {
        {
        {
        tmp___14 = (needle_mbchars + j___1)->wc == phaystack.cur.wc;
        }
        }
      } else {
        {
        goto _L___0;
        }
      }
      }
    } else {
      {
      _L___0:
      if ((needle_mbchars + j___1)->bytes == phaystack.cur.bytes) {
        {
        {
        tmp___12 = memcmp((void const *)(needle_mbchars + j___1)->ptr, (void const *)phaystack.cur.ptr,
                          (needle_mbchars + j___1)->bytes);
        }
        if (tmp___12 == 0) {
          {
          {
          tmp___13 = 1;
          }
          }
        } else {
          {
          {
          tmp___13 = 0;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___13 = 0;
        }
        }
      }
      {
      tmp___14 = tmp___13;
      }
      }
    }
    if (tmp___14) {
      {
      {
      j___1 ++;
      phaystack.cur.ptr += phaystack.cur.bytes;
      phaystack.next_done = (_Bool)0;
      }
      if (j___1 == m) {
        {
        {
        *resultp = rhaystack.cur.ptr;
        }
        goto while_break___2;
        }
      }
      }
    } else {
      {
      if (j___1 > 0UL) {
        {
        {
        count = *(table___0 + j___1);
        j___1 -= count;
        }
        {
        while (1) {
          while_continue___3: ;
          if (! (count > 0UL)) {
            {
            goto while_break___3;
            }
          }
          {
          mbuiter_multi_next(& rhaystack);
          }
          if (rhaystack.cur.wc_valid) {
            {
            if (rhaystack.cur.wc == 0) {
              {
              {
              tmp___10 = 0;
              }
              }
            } else {
              {
              {
              tmp___10 = 1;
              }
              }
            }
            }
          } else {
            {
            {
            tmp___10 = 1;
            }
            }
          }
          if (! tmp___10) {
            {
            {
            abort();
            }
            }
          }
          {
          rhaystack.cur.ptr += rhaystack.cur.bytes;
          rhaystack.next_done = (_Bool)0;
          count --;
          }
        }
        while_break___3: ;
        }
        }
      } else {
        {
        {
        mbuiter_multi_next(& rhaystack);
        }
        if (rhaystack.cur.wc_valid) {
          {
          if (rhaystack.cur.wc == 0) {
            {
            {
            tmp___11 = 0;
            }
            }
          } else {
            {
            {
            tmp___11 = 1;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___11 = 1;
          }
          }
        }
        if (! tmp___11) {
          {
          {
          abort();
          }
          }
        }
        {
        rhaystack.cur.ptr += rhaystack.cur.bytes;
        rhaystack.next_done = (_Bool)0;
        phaystack.cur.ptr += phaystack.cur.bytes;
        phaystack.next_done = (_Bool)0;
        }
        }
      }
      }
    }
  }
  while_break___2: ;
  }
  {
  freea((void *)memory);
  }
  return ((_Bool)1);
}
}
char *( __attribute__((__nonnull__(1,2))) mbsstr)(char const *haystack , char const *needle )
{
  mbui_iterator_t iter_needle ;
  _Bool try_kmp ;
  size_t outer_loop_count ;
  size_t comparison_count ;
  size_t last_ccount ;
  mbui_iterator_t iter_needle_last_ccount ;
  mbui_iterator_t iter_haystack ;
  int tmp ;
  size_t count ;
  int tmp___0 ;
  char const *result ;
  _Bool success ;
  _Bool tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t rneedle ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool try_kmp___0 ;
  size_t outer_loop_count___0 ;
  size_t comparison_count___0 ;
  size_t last_ccount___0 ;
  char const *needle_last_ccount ;
  char b ;
  char const *tmp___13 ;
  size_t tmp___14 ;
  unsigned char const *result___0 ;
  _Bool success___0 ;
  size_t tmp___15 ;
  _Bool tmp___16 ;
  char const *rhaystack___0 ;
  char const *rneedle___0 ;
  size_t tmp___17 ;
  {
  {
  tmp___17 = __ctype_get_mb_cur_max();
  }
  if (tmp___17 > 1UL) {
    {
    {
    iter_needle.cur.ptr = needle;
    iter_needle.in_shift = (_Bool)0;
    memset((void *)(& iter_needle.state), '\000', sizeof(mbstate_t ));
    iter_needle.next_done = (_Bool)0;
    mbuiter_multi_next(& iter_needle);
    }
    if (iter_needle.cur.wc_valid) {
      {
      if (iter_needle.cur.wc == 0) {
        {
        {
        tmp___12 = 0;
        }
        }
      } else {
        {
        {
        tmp___12 = 1;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___12 = 1;
      }
      }
    }
    if (tmp___12) {
      {
      {
      try_kmp = (_Bool)1;
      outer_loop_count = (size_t )0;
      comparison_count = (size_t )0;
      last_ccount = (size_t )0;
      iter_needle_last_ccount.cur.ptr = needle;
      iter_needle_last_ccount.in_shift = (_Bool)0;
      memset((void *)(& iter_needle_last_ccount.state), '\000', sizeof(mbstate_t ));
      iter_needle_last_ccount.next_done = (_Bool)0;
      iter_haystack.cur.ptr = haystack;
      iter_haystack.in_shift = (_Bool)0;
      memset((void *)(& iter_haystack.state), '\000', sizeof(mbstate_t ));
      iter_haystack.next_done = (_Bool)0;
      }
      {
      while (1) {
        while_continue: ;
        if (! 1) {
          {
          goto while_break;
          }
        }
        {
        mbuiter_multi_next(& iter_haystack);
        }
        if (iter_haystack.cur.wc_valid) {
          {
          if (iter_haystack.cur.wc == 0) {
            {
            {
            tmp = 0;
            }
            }
          } else {
            {
            {
            tmp = 1;
            }
            }
          }
          }
        } else {
          {
          {
          tmp = 1;
          }
          }
        }
        if (! tmp) {
          {
          return ((char *)((void *)0));
          }
        }
        if (try_kmp) {
          {
          if (outer_loop_count >= 10UL) {
            {
            if (comparison_count >= 5UL * outer_loop_count) {
              {
              {
              count = comparison_count - last_ccount;
              }
              {
              while (1) {
                while_continue___0: ;
                if (! 1) {
                  {
                  goto while_break___0;
                  }
                }
                if (count > 0UL) {
                  {
                  {
                  mbuiter_multi_next(& iter_needle_last_ccount);
                  }
                  if (iter_needle_last_ccount.cur.wc_valid) {
                    {
                    if (iter_needle_last_ccount.cur.wc == 0) {
                      {
                      {
                      tmp___0 = 0;
                      }
                      }
                    } else {
                      {
                      {
                      tmp___0 = 1;
                      }
                      }
                    }
                    }
                  } else {
                    {
                    {
                    tmp___0 = 1;
                    }
                    }
                  }
                  if (! tmp___0) {
                    {
                    goto while_break___0;
                    }
                  }
                  }
                } else {
                  {
                  goto while_break___0;
                  }
                }
                {
                iter_needle_last_ccount.cur.ptr += iter_needle_last_ccount.cur.bytes;
                iter_needle_last_ccount.next_done = (_Bool)0;
                count --;
                }
              }
              while_break___0: ;
              }
              {
              last_ccount = comparison_count;
              mbuiter_multi_next(& iter_needle_last_ccount);
              }
              if (iter_needle_last_ccount.cur.wc_valid) {
                {
                if (iter_needle_last_ccount.cur.wc == 0) {
                  {
                  {
                  tmp___2 = 0;
                  }
                  }
                } else {
                  {
                  {
                  tmp___2 = 1;
                  }
                  }
                }
                }
              } else {
                {
                {
                tmp___2 = 1;
                }
                }
              }
              if (! tmp___2) {
                {
                {
                tmp___1 = knuth_morris_pratt_multibyte(haystack, needle, & result);
                success = tmp___1;
                }
                if (success) {
                  {
                  return ((char *)result);
                  }
                }
                {
                try_kmp = (_Bool)0;
                }
                }
              }
              }
            }
            }
          }
          }
        }
        {
        outer_loop_count ++;
        comparison_count ++;
        }
        if (iter_haystack.cur.wc_valid) {
          {
          if (iter_needle.cur.wc_valid) {
            {
            {
            tmp___11 = iter_haystack.cur.wc == iter_needle.cur.wc;
            }
            }
          } else {
            {
            goto _L___0;
            }
          }
          }
        } else {
          {
          _L___0:
          if (iter_haystack.cur.bytes == iter_needle.cur.bytes) {
            {
            {
            tmp___9 = memcmp((void const *)iter_haystack.cur.ptr, (void const *)iter_needle.cur.ptr,
                             iter_haystack.cur.bytes);
            }
            if (tmp___9 == 0) {
              {
              {
              tmp___10 = 1;
              }
              }
            } else {
              {
              {
              tmp___10 = 0;
              }
              }
            }
            }
          } else {
            {
            {
            tmp___10 = 0;
            }
            }
          }
          {
          tmp___11 = tmp___10;
          }
          }
        }
        if (tmp___11) {
          {
          {
          memcpy((void *)((void * __restrict )(& rhaystack)), (void const *)((void const * __restrict )(& iter_haystack)),
                 sizeof(mbui_iterator_t ));
          rhaystack.cur.ptr += rhaystack.cur.bytes;
          rhaystack.next_done = (_Bool)0;
          rneedle.cur.ptr = needle;
          rneedle.in_shift = (_Bool)0;
          memset((void *)(& rneedle.state), '\000', sizeof(mbstate_t ));
          rneedle.next_done = (_Bool)0;
          mbuiter_multi_next(& rneedle);
          }
          if (rneedle.cur.wc_valid) {
            {
            if (rneedle.cur.wc == 0) {
              {
              {
              tmp___3 = 0;
              }
              }
            } else {
              {
              {
              tmp___3 = 1;
              }
              }
            }
            }
          } else {
            {
            {
            tmp___3 = 1;
            }
            }
          }
          if (! tmp___3) {
            {
            {
            abort();
            }
            }
          }
          {
          rneedle.cur.ptr += rneedle.cur.bytes;
          rneedle.next_done = (_Bool)0;
          }
          {
          while (1) {
            while_continue___1: ;
            if (! 1) {
              {
              goto while_break___1;
              }
            }
            {
            mbuiter_multi_next(& rneedle);
            }
            if (rneedle.cur.wc_valid) {
              {
              if (rneedle.cur.wc == 0) {
                {
                {
                tmp___4 = 0;
                }
                }
              } else {
                {
                {
                tmp___4 = 1;
                }
                }
              }
              }
            } else {
              {
              {
              tmp___4 = 1;
              }
              }
            }
            if (! tmp___4) {
              {
              return ((char *)iter_haystack.cur.ptr);
              }
            }
            {
            mbuiter_multi_next(& rhaystack);
            }
            if (rhaystack.cur.wc_valid) {
              {
              if (rhaystack.cur.wc == 0) {
                {
                {
                tmp___5 = 0;
                }
                }
              } else {
                {
                {
                tmp___5 = 1;
                }
                }
              }
              }
            } else {
              {
              {
              tmp___5 = 1;
              }
              }
            }
            if (! tmp___5) {
              {
              return ((char *)((void *)0));
              }
            }
            {
            comparison_count ++;
            }
            if (rhaystack.cur.wc_valid) {
              {
              if (rneedle.cur.wc_valid) {
                {
                {
                tmp___8 = rhaystack.cur.wc == rneedle.cur.wc;
                }
                }
              } else {
                {
                goto _L;
                }
              }
              }
            } else {
              {
              _L:
              if (rhaystack.cur.bytes == rneedle.cur.bytes) {
                {
                {
                tmp___6 = memcmp((void const *)rhaystack.cur.ptr, (void const *)rneedle.cur.ptr,
                                 rhaystack.cur.bytes);
                }
                if (tmp___6 == 0) {
                  {
                  {
                  tmp___7 = 1;
                  }
                  }
                } else {
                  {
                  {
                  tmp___7 = 0;
                  }
                  }
                }
                }
              } else {
                {
                {
                tmp___7 = 0;
                }
                }
              }
              {
              tmp___8 = tmp___7;
              }
              }
            }
            if (! tmp___8) {
              {
              goto while_break___1;
              }
            }
            {
            rhaystack.cur.ptr += rhaystack.cur.bytes;
            rhaystack.next_done = (_Bool)0;
            rneedle.cur.ptr += rneedle.cur.bytes;
            rneedle.next_done = (_Bool)0;
            }
          }
          while_break___1: ;
          }
          }
        }
        {
        iter_haystack.cur.ptr += iter_haystack.cur.bytes;
        iter_haystack.next_done = (_Bool)0;
        }
      }
      while_break: ;
      }
      }
    } else {
      {
      return ((char *)haystack);
      }
    }
    }
  } else {
    {
    if ((int const )*needle != 0) {
      {
      {
      try_kmp___0 = (_Bool)1;
      outer_loop_count___0 = (size_t )0;
      comparison_count___0 = (size_t )0;
      last_ccount___0 = (size_t )0;
      needle_last_ccount = needle;
      tmp___13 = needle;
      needle ++;
      b = (char )*tmp___13;
      }
      {
      while (1) {
        while_continue___2: ;
        if (! 1) {
          {
          goto while_break___2;
          }
        }
        if ((int const )*haystack == 0) {
          {
          return ((char *)((void *)0));
          }
        }
        if (try_kmp___0) {
          {
          if (outer_loop_count___0 >= 10UL) {
            {
            if (comparison_count___0 >= 5UL * outer_loop_count___0) {
              {
              if ((unsigned long )needle_last_ccount != (unsigned long )((void *)0)) {
                {
                {
                tmp___14 = strnlen(needle_last_ccount, comparison_count___0 - last_ccount___0);
                needle_last_ccount += tmp___14;
                }
                if ((int const )*needle_last_ccount == 0) {
                  {
                  {
                  needle_last_ccount = (char const *)((void *)0);
                  }
                  }
                }
                {
                last_ccount___0 = comparison_count___0;
                }
                }
              }
              if ((unsigned long )needle_last_ccount == (unsigned long )((void *)0)) {
                {
                {
                tmp___15 = strlen(needle - 1);
                tmp___16 = knuth_morris_pratt((unsigned char const *)haystack, (unsigned char const *)(needle - 1),
                                              tmp___15, & result___0);
                success___0 = tmp___16;
                }
                if (success___0) {
                  {
                  return ((char *)result___0);
                  }
                }
                {
                try_kmp___0 = (_Bool)0;
                }
                }
              }
              }
            }
            }
          }
          }
        }
        {
        outer_loop_count___0 ++;
        comparison_count___0 ++;
        }
        if ((int const )*haystack == (int const )b) {
          {
          {
          rhaystack___0 = haystack + 1;
          rneedle___0 = needle;
          }
          {
          while (1) {
            while_continue___3: ;
            if (! 1) {
              {
              goto while_break___3;
              }
            }
            if ((int const )*rneedle___0 == 0) {
              {
              return ((char *)haystack);
              }
            }
            if ((int const )*rhaystack___0 == 0) {
              {
              return ((char *)((void *)0));
              }
            }
            {
            comparison_count___0 ++;
            }
            if ((int const )*rhaystack___0 != (int const )*rneedle___0) {
              {
              goto while_break___3;
              }
            }
            {
            rhaystack___0 ++;
            rneedle___0 ++;
            }
          }
          while_break___3: ;
          }
          }
        }
        {
        haystack ++;
        }
      }
      while_break___2: ;
      }
      }
    } else {
      {
      return ((char *)haystack);
      }
    }
    }
  }
  return ((char *)0);
}
}
int gnu_mbswidth(char const *string , int flags )
{
  size_t tmp ;
  int tmp___0 ;
  {
  {
  tmp = strlen(string);
  tmp___0 = mbsnwidth(string, tmp, flags);
  }
  return (tmp___0);
}
}
int mbsnwidth(char const *string , size_t nbytes , int flags )
{
  char const *p ;
  char const *plimit ;
  int width ;
  mbstate_t mbstate ;
  wchar_t wc ;
  size_t bytes ;
  int w ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned char c ;
  char const *tmp___2 ;
  unsigned short const **tmp___3 ;
  unsigned short const **tmp___4 ;
  {
  {
  p = string;
  plimit = p + nbytes;
  width = 0;
  tmp___1 = __ctype_get_mb_cur_max();
  }
  if (tmp___1 > 1UL) {
    {
    {
    while (1) {
      while_continue: ;
      if (! ((unsigned long )p < (unsigned long )plimit)) {
        {
        goto while_break;
        }
      }
      {
      if ((int )*p == 126) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 125) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 124) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 123) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 122) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 121) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 120) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 119) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 118) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 117) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 116) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 115) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 114) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 113) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 112) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 111) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 110) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 109) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 108) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 107) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 106) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 105) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 104) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 103) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 102) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 101) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 100) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 99) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 98) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 97) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 95) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 94) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 93) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 92) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 91) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 90) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 89) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 88) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 87) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 86) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 85) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 84) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 83) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 82) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 81) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 80) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 79) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 78) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 77) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 76) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 75) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 74) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 73) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 72) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 71) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 70) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 69) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 68) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 67) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 66) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 65) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 63) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 62) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 61) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 60) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 59) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 58) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 57) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 56) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 55) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 54) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 53) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 52) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 51) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 50) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 49) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 48) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 47) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 46) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 45) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 44) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 43) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 42) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 41) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 40) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 39) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 38) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 37) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 35) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 34) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 33) {
        {
        goto case_126;
        }
      }
      if ((int )*p == 32) {
        {
        goto case_126;
        }
      }
      goto switch_default;
      case_126:
      case_125:
      case_124:
      case_123:
      case_122:
      case_121:
      case_120:
      case_119:
      case_118:
      case_117:
      case_116:
      case_115:
      case_114:
      case_113:
      case_112:
      case_111:
      case_110:
      case_109:
      case_108:
      case_107:
      case_106:
      case_105:
      case_104:
      case_103:
      case_102:
      case_101:
      case_100:
      case_99:
      case_98:
      case_97:
      case_95:
      case_94:
      case_93:
      case_92:
      case_91:
      case_90:
      case_89:
      case_88:
      case_87:
      case_86:
      case_85:
      case_84:
      case_83:
      case_82:
      case_81:
      case_80:
      case_79:
      case_78:
      case_77:
      case_76:
      case_75:
      case_74:
      case_73:
      case_72:
      case_71:
      case_70:
      case_69:
      case_68:
      case_67:
      case_66:
      case_65:
      case_63:
      case_62:
      case_61:
      case_60:
      case_59:
      case_58:
      case_57:
      case_56:
      case_55:
      case_54:
      case_53:
      case_52:
      case_51:
      case_50:
      case_49:
      case_48:
      case_47:
      case_46:
      case_45:
      case_44:
      case_43:
      case_42:
      case_41:
      case_40:
      case_39:
      case_38:
      case_37:
      case_35:
      case_34:
      case_33:
      case_32:
      {
      p ++;
      width ++;
      }
      goto switch_break;
      switch_default:
      {
      memset((void *)(& mbstate), 0, sizeof(mbstate));
      }
      {
      while (1) {
        while_continue___0: ;
        if (! 1) {
          {
          goto while_break___0;
          }
        }
        {
        bytes = mbrtowc((wchar_t * __restrict )(& wc), (char const * __restrict )p,
                        (size_t )(plimit - p), & mbstate);
        }
        if (bytes == 0xffffffffffffffffUL) {
          {
          if (! (flags & 1)) {
            {
            {
            p ++;
            width ++;
            }
            goto while_break___0;
            }
          } else {
            {
            return (-1);
            }
          }
          }
        }
        if (bytes == 0xfffffffffffffffeUL) {
          {
          if (! (flags & 1)) {
            {
            {
            p = plimit;
            width ++;
            }
            goto while_break___0;
            }
          } else {
            {
            return (-1);
            }
          }
          }
        }
        if (bytes == 0UL) {
          {
          {
          bytes = (size_t )1;
          }
          }
        }
        {
        w = wcwidth(wc);
        }
        if (w >= 0) {
          {
          if (w > 2147483647 - width) {
            {
            goto overflow;
            }
          }
          {
          width += w;
          }
          }
        } else {
          {
          if (! (flags & 2)) {
            {
            {
            tmp = iswcntrl((wint_t )wc);
            }
            if (! tmp) {
              {
              if (width == 2147483647) {
                {
                goto overflow;
                }
              }
              {
              width ++;
              }
              }
            }
            }
          } else {
            {
            return (-1);
            }
          }
          }
        }
        {
        p += bytes;
        tmp___0 = mbsinit((mbstate_t const *)(& mbstate));
        }
        if (tmp___0) {
          {
          goto while_break___0;
          }
        }
      }
      while_break___0: ;
      }
      goto switch_break;
      switch_break: ;
      }
    }
    while_break: ;
    }
    return (width);
    }
  }
  {
  while (1) {
    while_continue___1: ;
    if (! ((unsigned long )p < (unsigned long )plimit)) {
      {
      goto while_break___1;
      }
    }
    {
    tmp___2 = p;
    p ++;
    c = (unsigned char )*tmp___2;
    tmp___4 = __ctype_b_loc();
    }
    if ((int const )*(*tmp___4 + (int )c) & 16384) {
      {
      if (width == 2147483647) {
        {
        goto overflow;
        }
      }
      {
      width ++;
      }
      }
    } else {
      {
      if (! (flags & 2)) {
        {
        {
        tmp___3 = __ctype_b_loc();
        }
        if (! ((int const )*(*tmp___3 + (int )c) & 2)) {
          {
          if (width == 2147483647) {
            {
            goto overflow;
            }
          }
          {
          width ++;
          }
          }
        }
        }
      } else {
        {
        return (-1);
        }
      }
      }
    }
  }
  while_break___1: ;
  }
  return (width);
  overflow:
  return (2147483647);
}
}
int memcasecmp(void const *vs1 , void const *vs2 , size_t n )
{
  size_t i ;
  char const *s1 ;
  char const *s2 ;
  unsigned char u1 ;
  unsigned char u2 ;
  int U1 ;
  int __res ;
  __int32_t const **tmp___0 ;
  int U2 ;
  int __res___0 ;
  __int32_t const **tmp___2 ;
  int diff ;
  {
  {
  s1 = (char const *)vs1;
  s2 = (char const *)vs2;
  i = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! (i < n)) {
      {
      goto while_break;
      }
    }
    {
    u1 = (unsigned char )*(s1 + i);
    u2 = (unsigned char )*(s2 + i);
    }
    if (sizeof(u1) > 1UL) {
      {
      {
      __res = toupper((int )u1);
      }
      }
    } else {
      {
      {
      tmp___0 = __ctype_toupper_loc();
      __res = (int )*(*tmp___0 + (int )u1);
      }
      }
    }
    {
    U1 = __res;
    }
    if (sizeof(u2) > 1UL) {
      {
      {
      __res___0 = toupper((int )u2);
      }
      }
    } else {
      {
      {
      tmp___2 = __ctype_toupper_loc();
      __res___0 = (int )*(*tmp___2 + (int )u2);
      }
      }
    }
    {
    U2 = __res___0;
    diff = U1 - U2;
    }
    if (diff) {
      {
      return (diff);
      }
    }
    {
    i ++;
    }
  }
  while_break: ;
  }
  return (0);
}
}
void *memchr2(void const *s , int c1_in , int c2_in , size_t n )
{
  unsigned char const *char_ptr ;
  longword const *longword_ptr ;
  longword repeated_one ;
  longword repeated_c1 ;
  longword repeated_c2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  void *tmp ;
  size_t i ;
  longword longword1 ;
  longword longword2 ;
  {
  {
  c1 = (unsigned char )c1_in;
  c2 = (unsigned char )c2_in;
  }
  if ((int )c1 == (int )c2) {
    {
    {
    tmp = memchr(s, (int )c1, n);
    }
    return (tmp);
    }
  }
  {
  char_ptr = (unsigned char const *)s;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (n > 0UL) {
      {
      if (! ((size_t )char_ptr % sizeof(longword ) != 0UL)) {
        {
        goto while_break;
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
    if ((int const )*char_ptr == (int const )c1) {
      {
      return ((void *)char_ptr);
      }
    } else {
      {
      if ((int const )*char_ptr == (int const )c2) {
        {
        return ((void *)char_ptr);
        }
      }
      }
    }
    {
    n --;
    char_ptr ++;
    }
  }
  while_break: ;
  }
  {
  longword_ptr = (longword const *)char_ptr;
  repeated_one = (longword )16843009;
  repeated_c1 = (longword )((int )c1 | ((int )c1 << 8));
  repeated_c2 = (longword )((int )c2 | ((int )c2 << 8));
  repeated_c1 |= repeated_c1 << 16;
  repeated_c2 |= repeated_c2 << 16;
  repeated_one |= (repeated_one << 31) << 1;
  repeated_c1 |= (repeated_c1 << 31) << 1;
  repeated_c2 |= (repeated_c2 << 31) << 1;
  }
  if (8UL < sizeof(longword )) {
    {
    {
    i = (size_t )64;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! (i < sizeof(longword ) * 8UL)) {
        {
        goto while_break___0;
        }
      }
      {
      repeated_one |= repeated_one << i;
      repeated_c1 |= repeated_c1 << i;
      repeated_c2 |= repeated_c2 << i;
      i *= 2UL;
      }
    }
    while_break___0: ;
    }
    }
  }
  {
  while (1) {
    while_continue___1: ;
    if (! (n >= sizeof(longword ))) {
      {
      goto while_break___1;
      }
    }
    {
    longword1 = (longword )(*longword_ptr ^ (unsigned long const )repeated_c1);
    longword2 = (longword )(*longword_ptr ^ (unsigned long const )repeated_c2);
    }
    if (((((longword1 - repeated_one) & ~ longword1) | ((longword2 - repeated_one) & ~ longword2)) & (repeated_one << 7)) != 0UL) {
      {
      goto while_break___1;
      }
    }
    {
    longword_ptr ++;
    n -= sizeof(longword );
    }
  }
  while_break___1: ;
  }
  {
  char_ptr = (unsigned char const *)longword_ptr;
  }
  {
  while (1) {
    while_continue___2: ;
    if (! (n > 0UL)) {
      {
      goto while_break___2;
      }
    }
    if ((int const )*char_ptr == (int const )c1) {
      {
      return ((void *)char_ptr);
      }
    } else {
      {
      if ((int const )*char_ptr == (int const )c2) {
        {
        return ((void *)char_ptr);
        }
      }
      }
    }
    {
    n --;
    char_ptr ++;
    }
  }
  while_break___2: ;
  }
  return ((void *)0);
}
}
int memcmp2(char const *s1 , size_t n1 , char const *s2 , size_t n2 )
{
  int cmp ;
  size_t tmp ;
  int tmp___0 ;
  {
  if (n1 <= n2) {
    {
    {
    tmp = n1;
    }
    }
  } else {
    {
    {
    tmp = n2;
    }
    }
  }
  {
  tmp___0 = memcmp((void const *)s1, (void const *)s2, tmp);
  cmp = tmp___0;
  }
  if (cmp == 0) {
    {
    if (n1 < n2) {
      {
      {
      cmp = -1;
      }
      }
    } else {
      {
      if (n1 > n2) {
        {
        {
        cmp = 1;
        }
        }
      }
      }
    }
    }
  }
  return (cmp);
}
}
__inline static int strcoll_loop(char const *s1 , size_t s1size , char const *s2 ,
                                 size_t s2size )
{
  int diff ;
  size_t size1 ;
  size_t tmp ;
  size_t size2 ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  {
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___1 = __errno_location();
    *tmp___1 = 0;
    diff = strcoll(s1, s2);
    }
    if (diff) {
      {
      {
      tmp___3 = 1;
      }
      }
    } else {
      {
      {
      tmp___2 = __errno_location();
      }
      if (*tmp___2) {
        {
        {
        tmp___3 = 1;
        }
        }
      } else {
        {
        {
        tmp___3 = 0;
        }
        }
      }
      }
    }
    if (tmp___3) {
      {
      goto while_break;
      }
    }
    {
    tmp = strlen(s1);
    size1 = tmp + 1UL;
    tmp___0 = strlen(s2);
    size2 = tmp___0 + 1UL;
    s1 += size1;
    s2 += size2;
    s1size -= size1;
    s2size -= size2;
    }
    if (s1size == 0UL) {
      {
      return (- (s2size != 0UL));
      }
    }
    if (s2size == 0UL) {
      {
      return (1);
      }
    }
  }
  while_break: ;
  }
  return (diff);
}
}
int memcoll(char *s1 , size_t s1len , char *s2 , size_t s2len )
{
  int diff ;
  int *tmp ;
  char n1 ;
  char n2 ;
  int tmp___0 ;
  {
  if (s1len == s2len) {
    {
    {
    tmp___0 = memcmp((void const *)s1, (void const *)s2, s1len);
    }
    if (tmp___0 == 0) {
      {
      {
      tmp = __errno_location();
      *tmp = 0;
      diff = 0;
      }
      }
    } else {
      {
      goto _L;
      }
    }
    }
  } else {
    {
    _L:
    {
    n1 = *(s1 + s1len);
    n2 = *(s2 + s2len);
    *(s1 + s1len) = (char )'\000';
    *(s2 + s2len) = (char )'\000';
    diff = strcoll_loop((char const *)s1, s1len + 1UL, (char const *)s2, s2len + 1UL);
    *(s1 + s1len) = n1;
    *(s2 + s2len) = n2;
    }
    }
  }
  return (diff);
}
}
int memcoll0(char const *s1 , size_t s1size , char const *s2 , size_t s2size )
{
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  if (s1size == s2size) {
    {
    {
    tmp___1 = memcmp((void const *)s1, (void const *)s2, s1size);
    }
    if (tmp___1 == 0) {
      {
      {
      tmp = __errno_location();
      *tmp = 0;
      }
      return (0);
      }
    } else {
      {
      {
      tmp___0 = strcoll_loop(s1, s1size, s2, s2size);
      }
      return (tmp___0);
      }
    }
    }
  } else {
    {
    {
    tmp___0 = strcoll_loop(s1, s1size, s2, s2size);
    }
    return (tmp___0);
    }
  }
}
}
static gid_t *realloc_groupbuf(gid_t *g , size_t num )
{
  int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  {
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
    {
    {
    tmp___0 = -1;
    }
    }
  } else {
    {
    {
    tmp___0 = -2;
    }
    }
  }
  if ((size_t )tmp___0 / sizeof(*g) < num) {
    {
    {
    tmp = __errno_location();
    *tmp = 12;
    }
    return ((gid_t *)((void *)0));
    }
  }
  {
  tmp___1 = realloc((void *)g, num * sizeof(*g));
  }
  return ((gid_t *)tmp___1);
}
}
int mgetgroups(char const *username , gid_t gid , gid_t **groups )
{
  int max_n_groups ;
  int ng ;
  gid_t *g ;
  gid_t *h ;
  int last_n_groups ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int saved_errno___0 ;
  int *tmp___6 ;
  int *tmp___7 ;
  gid_t first ;
  gid_t *next ;
  gid_t *groups_end ;
  {
  if (username) {
    {
    {
    max_n_groups = 10;
    g = realloc_groupbuf((gid_t *)((void *)0), (size_t )max_n_groups);
    }
    if ((unsigned long )g == (unsigned long )((void *)0)) {
      {
      return (-1);
      }
    }
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      {
      last_n_groups = max_n_groups;
      ng = getgrouplist(username, gid, g, & max_n_groups);
      }
      if (ng < 0) {
        {
        if (last_n_groups == max_n_groups) {
          {
          {
          max_n_groups *= 2;
          }
          }
        }
        }
      }
      {
      h = realloc_groupbuf(g, (size_t )max_n_groups);
      }
      if ((unsigned long )h == (unsigned long )((void *)0)) {
        {
        {
        tmp = __errno_location();
        saved_errno = *tmp;
        free((void *)g);
        tmp___0 = __errno_location();
        *tmp___0 = saved_errno;
        }
        return (-1);
        }
      }
      {
      g = h;
      }
      if (0 <= ng) {
        {
        {
        *groups = g;
        }
        return (max_n_groups);
        }
      }
    }
    while_break: ;
    }
    }
  }
  if (username) {
    {
    {
    tmp___1 = getugroups(0, (gid_t *)((void *)0), username, gid);
    max_n_groups = tmp___1;
    }
    }
  } else {
    {
    {
    tmp___2 = getgroups(0, (__gid_t *)((void *)0));
    max_n_groups = tmp___2;
    }
    }
  }
  if (max_n_groups < 0) {
    {
    {
    tmp___3 = __errno_location();
    }
    if (*tmp___3 == 38) {
      {
      {
      g = realloc_groupbuf((gid_t *)((void *)0), (size_t )1);
      }
      if (g) {
        {
        {
        *groups = g;
        *g = gid;
        }
        return (gid != 4294967295U);
        }
      }
      }
    }
    return (-1);
    }
  }
  if (! username) {
    {
    if (gid != 4294967295U) {
      {
      {
      max_n_groups ++;
      }
      }
    }
    }
  }
  {
  g = realloc_groupbuf((gid_t *)((void *)0), (size_t )max_n_groups);
  }
  if ((unsigned long )g == (unsigned long )((void *)0)) {
    {
    return (-1);
    }
  }
  if (username) {
    {
    {
    tmp___4 = getugroups(max_n_groups, g, username, gid);
    ng = tmp___4;
    }
    }
  } else {
    {
    {
    tmp___5 = getgroups(max_n_groups - (gid != 4294967295U), g + (gid != 4294967295U));
    ng = tmp___5;
    }
    }
  }
  if (ng < 0) {
    {
    {
    tmp___6 = __errno_location();
    saved_errno___0 = *tmp___6;
    free((void *)g);
    tmp___7 = __errno_location();
    *tmp___7 = saved_errno___0;
    }
    return (-1);
    }
  }
  if (! username) {
    {
    if (gid != 4294967295U) {
      {
      {
      *g = gid;
      ng ++;
      }
      }
    }
    }
  }
  {
  *groups = g;
  }
  if (1 < ng) {
    {
    {
    first = *g;
    groups_end = g + ng;
    next = g + 1;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! ((unsigned long )next < (unsigned long )groups_end)) {
        {
        goto while_break___0;
        }
      }
      if (*next == first) {
        {
        {
        ng --;
        }
        }
      } else {
        {
        if (*next == *g) {
          {
          {
          ng --;
          }
          }
        } else {
          {
          {
          g ++;
          *g = *next;
          }
          }
        }
        }
      }
      {
      next ++;
      }
    }
    while_break___0: ;
    }
    }
  }
  return (ng);
}
}
ptrdiff_t mkancesdirs(char *file , struct savewd *wd , int (*make_dir)(char const * ,
                                                                       char const * ,
                                                                       void * ) ,
                      void *make_dir_arg )
{
  char *sep ;
  char *component ;
  char *p ;
  char c ;
  _Bool made_dir ;
  int make_dir_errno ;
  int savewd_chdir_options ;
  int chdir_result ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  {
  {
  sep = (char *)((void *)0);
  component = file;
  p = file + 0;
  made_dir = (_Bool)0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___3 = p;
    p ++;
    c = *tmp___3;
    }
    if (! c) {
      {
      goto while_break;
      }
    }
    if ((int )*p == 47) {
      {
      if (! ((int )c == 47)) {
        {
        {
        sep = p;
        }
        }
      }
      }
    } else {
      {
      if ((int )c == 47) {
        {
        if (*p) {
          {
          if (sep) {
            {
            if (sep - component == 1L) {
              {
              if (! ((int )*(component + 0) == 46)) {
                {
                goto _L___1;
                }
              }
              }
            } else {
              {
              _L___1:
              {
              make_dir_errno = 0;
              savewd_chdir_options = 0;
              *sep = (char )'\000';
              }
              if (sep - component == 2L) {
                {
                if ((int )*(component + 0) == 46) {
                  {
                  if ((int )*(component + 1) == 46) {
                    {
                    {
                    made_dir = (_Bool)0;
                    }
                    }
                  } else {
                    {
                    goto _L___0;
                    }
                  }
                  }
                } else {
                  {
                  goto _L___0;
                  }
                }
                }
              } else {
                {
                _L___0:
                {
                tmp = (*make_dir)((char const *)file, (char const *)component,
                                  make_dir_arg);
                }
                {
                if (tmp == -1) {
                  {
                  goto case_neg_1;
                  }
                }
                if (tmp == 0) {
                  {
                  goto case_0;
                  }
                }
                if (tmp == 1) {
                  {
                  goto case_1;
                  }
                }
                goto switch_break;
                case_neg_1:
                {
                tmp___0 = __errno_location();
                make_dir_errno = *tmp___0;
                }
                goto switch_break;
                case_0:
                {
                savewd_chdir_options |= 2;
                }
                case_1:
                {
                made_dir = (_Bool)1;
                }
                goto switch_break;
                switch_break: ;
                }
                }
              }
              if (made_dir) {
                {
                {
                savewd_chdir_options |= 1;
                }
                }
              }
              {
              chdir_result = savewd_chdir(wd, (char const *)component, savewd_chdir_options,
                                          (int *)((void *)0));
              }
              if (chdir_result != -1) {
                {
                {
                *sep = (char )'/';
                }
                }
              }
              if (chdir_result != 0) {
                {
                if (make_dir_errno != 0) {
                  {
                  {
                  tmp___2 = __errno_location();
                  }
                  if (*tmp___2 == 2) {
                    {
                    {
                    tmp___1 = __errno_location();
                    *tmp___1 = make_dir_errno;
                    }
                    }
                  }
                  }
                }
                return ((ptrdiff_t )chdir_result);
                }
              }
              }
            }
            {
            component = p;
            }
            }
          }
          }
        }
        }
      }
      }
    }
  }
  while_break: ;
  }
  return (component - file);
}
}
int dirchownmod(int fd , char const *dir , mode_t mkdir_mode , uid_t owner , gid_t group ,
                mode_t mode , mode_t mode_bits )
{
  struct stat st ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  mode_t dir_mode ;
  int *tmp___2 ;
  mode_t indeterminate ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  mode_t chmod_mode ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int e ;
  int *tmp___11 ;
  int *tmp___12 ;
  {
  if (fd < 0) {
    {
    {
    tmp = stat((char const *)((char const * __restrict )dir), (struct stat *)((struct stat * __restrict )(& st)));
    tmp___1 = tmp;
    }
    }
  } else {
    {
    {
    tmp___0 = fstat(fd, & st);
    tmp___1 = tmp___0;
    }
    }
  }
  {
  result = tmp___1;
  }
  if (result == 0) {
    {
    {
    dir_mode = st.st_mode;
    }
    if (! ((dir_mode & 61440U) == 16384U)) {
      {
      {
      tmp___2 = __errno_location();
      *tmp___2 = 20;
      result = -1;
      }
      }
    } else {
      {
      {
      indeterminate = (mode_t )0;
      }
      if (owner != 4294967295U) {
        {
        if (owner != st.st_uid) {
          {
          goto _L;
          }
        } else {
          {
          goto _L___0;
          }
        }
        }
      } else {
        {
        _L___0:
        if (group != 4294967295U) {
          {
          if (group != st.st_gid) {
            {
            _L:
            if (0 <= fd) {
              {
              {
              tmp___3 = fchown(fd, owner, group);
              result = tmp___3;
              }
              }
            } else {
              {
              if (mkdir_mode != 4294967295U) {
                {
                {
                tmp___4 = lchown(dir, owner, group);
                tmp___6 = tmp___4;
                }
                }
              } else {
                {
                {
                tmp___5 = chown(dir, owner, group);
                tmp___6 = tmp___5;
                }
                }
              }
              {
              result = tmp___6;
              }
              }
            }
            if (result == 0) {
              {
              if (dir_mode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
                {
                {
                indeterminate = dir_mode & 3072U;
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      if (result == 0) {
        {
        if (((dir_mode ^ mode) | indeterminate) & mode_bits) {
          {
          {
          chmod_mode = mode | ((dir_mode & (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3))) & ~ mode_bits);
          }
          if (0 <= fd) {
            {
            {
            tmp___7 = fchmod(fd, chmod_mode);
            result = tmp___7;
            }
            }
          } else {
            {
            if (mkdir_mode != 4294967295U) {
              {
              {
              tmp___8 = chmod(dir, chmod_mode);
              tmp___10 = tmp___8;
              }
              }
            } else {
              {
              {
              tmp___9 = chmod(dir, chmod_mode);
              tmp___10 = tmp___9;
              }
              }
            }
            {
            result = tmp___10;
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  if (0 <= fd) {
    {
    if (result == 0) {
      {
      {
      result = close(fd);
      }
      }
    } else {
      {
      {
      tmp___11 = __errno_location();
      e = *tmp___11;
      close(fd);
      tmp___12 = __errno_location();
      *tmp___12 = e;
      }
      }
    }
    }
  }
  return (result);
}
}
__inline static int savewd_errno(struct savewd const *wd )
{
  int tmp ;
  {
  if ((unsigned int const )wd->state == 4U) {
    {
    {
    tmp = (int )wd->val.errnum;
    }
    }
  } else {
    {
    {
    tmp = (int )((int const )0);
    }
    }
  }
  return (tmp);
}
}
_Bool make_dir_parents(char *dir , struct savewd *wd , int (*make_ancestor)(char const * ,
                                                                            char const * ,
                                                                            void * ) ,
                       void *options , mode_t mode , void (*announce)(char const * ,
                                                                      void * ) , mode_t mode_bits ,
                       uid_t owner , gid_t group , _Bool preserve_existing )
{
  int mkdir_errno ;
  int tmp ;
  int tmp___0 ;
  ptrdiff_t prefix_len ;
  int savewd_chdir_options ;
  int *tmp___1 ;
  _Bool keep_owner ;
  int tmp___2 ;
  _Bool keep_special_mode_bits ;
  mode_t mkdir_mode ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  struct stat st ;
  int tmp___6 ;
  int open_result[2] ;
  int chdir_result ;
  int tmp___7 ;
  _Bool chdir_ok ;
  int chdir_errno ;
  int *tmp___8 ;
  int fd ;
  _Bool chdir_failed_unexpectedly ;
  int tmp___9 ;
  char const *subdir ;
  char const *tmp___10 ;
  int tmp___11 ;
  char const *tmp___12 ;
  char const *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char const *tmp___19 ;
  char *tmp___20 ;
  {
  if ((int )*(dir + 0) == 47) {
    {
    {
    tmp___0 = 0;
    }
    }
  } else {
    {
    {
    tmp = savewd_errno((struct savewd const *)wd);
    tmp___0 = tmp;
    }
    }
  }
  {
  mkdir_errno = tmp___0;
  }
  if (mkdir_errno == 0) {
    {
    {
    prefix_len = (ptrdiff_t )0;
    savewd_chdir_options = 4;
    }
    if (make_ancestor) {
      {
      {
      prefix_len = mkancesdirs(dir, wd, make_ancestor, options);
      }
      if (prefix_len < 0L) {
        {
        if (prefix_len < -1L) {
          {
          return ((_Bool)1);
          }
        }
        {
        tmp___1 = __errno_location();
        mkdir_errno = *tmp___1;
        }
        }
      }
      }
    }
    if (0L <= prefix_len) {
      {
      if (owner == 4294967295U) {
        {
        if (group == 4294967295U) {
          {
          {
          tmp___2 = 1;
          }
          }
        } else {
          {
          {
          tmp___2 = 0;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___2 = 0;
        }
        }
      }
      {
      keep_owner = (_Bool )tmp___2;
      keep_special_mode_bits = (_Bool )(((mode_bits & 3072U) | (mode & 512U)) == 0U);
      mkdir_mode = mode;
      }
      if (! keep_owner) {
        {
        {
        mkdir_mode &= (unsigned int )(~ ((448 >> 3) | ((448 >> 3) >> 3)));
        }
        }
      } else {
        {
        if (! keep_special_mode_bits) {
          {
          {
          mkdir_mode &= (unsigned int )(~ ((128 >> 3) | ((128 >> 3) >> 3)));
          }
          }
        }
        }
      }
      {
      tmp___5 = mkdir((char const *)(dir + prefix_len), mkdir_mode);
      }
      if (tmp___5 == 0) {
        {
        {
        (*announce)((char const *)dir, options);
        preserve_existing = (_Bool )((int )keep_owner & (int )keep_special_mode_bits);
        }
        if (mode & 256U) {
          {
          {
          tmp___3 = 2;
          }
          }
        } else {
          {
          {
          tmp___3 = 0;
          }
          }
        }
        {
        savewd_chdir_options |= 1 | tmp___3;
        }
        }
      } else {
        {
        {
        tmp___4 = __errno_location();
        mkdir_errno = *tmp___4;
        mkdir_mode = (mode_t )-1;
        }
        }
      }
      if (preserve_existing) {
        {
        if (mkdir_errno == 0) {
          {
          return ((_Bool)1);
          }
        } else {
          {
          if (mkdir_errno != 2) {
            {
            if (make_ancestor) {
              {
              {
              tmp___6 = stat((char const *)((char const * __restrict )(dir + prefix_len)),
                             (struct stat *)((struct stat * __restrict )(& st)));
              }
              if (tmp___6 == 0) {
                {
                if ((st.st_mode & 61440U) == 16384U) {
                  {
                  return ((_Bool)1);
                  }
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      } else {
        {
        {
        tmp___7 = savewd_chdir(wd, (char const *)(dir + prefix_len), savewd_chdir_options,
                               open_result);
        chdir_result = tmp___7;
        }
        if (chdir_result < -1) {
          {
          return ((_Bool)1);
          }
        } else {
          {
          {
          chdir_ok = (_Bool )(chdir_result == 0);
          tmp___8 = __errno_location();
          chdir_errno = *tmp___8;
          fd = open_result[0];
          }
          if (mkdir_errno == 0) {
            {
            if (! chdir_ok) {
              {
              if (mode & 64U) {
                {
                {
                tmp___9 = 1;
                }
                }
              } else {
                {
                goto _L;
                }
              }
              }
            } else {
              {
              _L:
              if (fd < 0) {
                {
                if (mode & 256U) {
                  {
                  {
                  tmp___9 = 1;
                  }
                  }
                } else {
                  {
                  {
                  tmp___9 = 0;
                  }
                  }
                }
                }
              } else {
                {
                {
                tmp___9 = 0;
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            tmp___9 = 0;
            }
            }
          }
          {
          chdir_failed_unexpectedly = (_Bool )tmp___9;
          }
          if (chdir_failed_unexpectedly) {
            {
            if (0 <= fd) {
              {
              {
              close(fd);
              }
              }
            }
            }
          } else {
            {
            if (chdir_ok) {
              {
              {
              tmp___10 = (char const *)".";
              }
              }
            } else {
              {
              {
              tmp___10 = (char const *)(dir + prefix_len);
              }
              }
            }
            {
            subdir = tmp___10;
            tmp___11 = dirchownmod(fd, subdir, mkdir_mode, owner, group, mode, mode_bits);
            }
            if (tmp___11 == 0) {
              {
              return ((_Bool)1);
              }
            }
            }
          }
          if (mkdir_errno == 0) {
            {
            goto _L___0;
            }
          } else {
            {
            if (mkdir_errno != 2) {
              {
              if (make_ancestor) {
                {
                {
                tmp___18 = __errno_location();
                }
                if (*tmp___18 != 20) {
                  {
                  _L___0:
                  {
                  tmp___12 = quote((char const *)dir);
                  }
                  if (keep_owner) {
                    {
                    {
                    tmp___13 = (char const *)"cannot change permissions of %s";
                    }
                    }
                  } else {
                    {
                    {
                    tmp___13 = (char const *)"cannot change owner and permissions of %s";
                    }
                    }
                  }
                  {
                  tmp___14 = dcgettext((char const *)((void *)0), tmp___13, 5);
                  }
                  if (! chdir_failed_unexpectedly) {
                    {
                    {
                    tmp___15 = __errno_location();
                    tmp___17 = *tmp___15;
                    }
                    }
                  } else {
                    {
                    if (! chdir_ok) {
                      {
                      if (mode & 64U) {
                        {
                        {
                        tmp___16 = chdir_errno;
                        }
                        }
                      } else {
                        {
                        {
                        tmp___16 = open_result[1];
                        }
                        }
                      }
                      }
                    } else {
                      {
                      {
                      tmp___16 = open_result[1];
                      }
                      }
                    }
                    {
                    tmp___17 = tmp___16;
                    }
                    }
                  }
                  {
                  error(0, tmp___17, (char const *)tmp___14, tmp___12);
                  }
                  return ((_Bool)0);
                  }
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  {
  tmp___19 = quote((char const *)dir);
  tmp___20 = dcgettext((char const *)((void *)0), (char const *)"cannot create directory %s",
                       5);
  error(0, mkdir_errno, (char const *)tmp___20, tmp___19);
  }
  return ((_Bool)0);
}
}
static mode_t octal_to_mode(unsigned int octal )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  {
  if (256 >> 3 == 32) {
    {
    if (128 >> 3 == 16) {
      {
      if (64 >> 3 == 8) {
        {
        if ((256 >> 3) >> 3 == 4) {
          {
          if ((128 >> 3) >> 3 == 2) {
            {
            if ((64 >> 3) >> 3 == 1) {
              {
              {
              tmp___11 = octal;
              }
              }
            } else {
              {
              goto _L___3;
              }
            }
            }
          } else {
            {
            goto _L___3;
            }
          }
          }
        } else {
          {
          goto _L___3;
          }
        }
        }
      } else {
        {
        goto _L___3;
        }
      }
      }
    } else {
      {
      goto _L___3;
      }
    }
    }
  } else {
    {
    _L___3:
    if (octal & 2048U) {
      {
      {
      tmp = 2048;
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    if (octal & 1024U) {
      {
      {
      tmp___0 = 1024;
      }
      }
    } else {
      {
      {
      tmp___0 = 0;
      }
      }
    }
    if (octal & 512U) {
      {
      {
      tmp___1 = 512;
      }
      }
    } else {
      {
      {
      tmp___1 = 0;
      }
      }
    }
    if (octal & 256U) {
      {
      {
      tmp___2 = 256;
      }
      }
    } else {
      {
      {
      tmp___2 = 0;
      }
      }
    }
    if (octal & 128U) {
      {
      {
      tmp___3 = 128;
      }
      }
    } else {
      {
      {
      tmp___3 = 0;
      }
      }
    }
    if (octal & 64U) {
      {
      {
      tmp___4 = 64;
      }
      }
    } else {
      {
      {
      tmp___4 = 0;
      }
      }
    }
    if (octal & 32U) {
      {
      {
      tmp___5 = 256 >> 3;
      }
      }
    } else {
      {
      {
      tmp___5 = 0;
      }
      }
    }
    if (octal & 16U) {
      {
      {
      tmp___6 = 128 >> 3;
      }
      }
    } else {
      {
      {
      tmp___6 = 0;
      }
      }
    }
    if (octal & 8U) {
      {
      {
      tmp___7 = 64 >> 3;
      }
      }
    } else {
      {
      {
      tmp___7 = 0;
      }
      }
    }
    if (octal & 4U) {
      {
      {
      tmp___8 = (256 >> 3) >> 3;
      }
      }
    } else {
      {
      {
      tmp___8 = 0;
      }
      }
    }
    if (octal & 2U) {
      {
      {
      tmp___9 = (128 >> 3) >> 3;
      }
      }
    } else {
      {
      {
      tmp___9 = 0;
      }
      }
    }
    if (octal & 1U) {
      {
      {
      tmp___10 = (64 >> 3) >> 3;
      }
      }
    } else {
      {
      {
      tmp___10 = 0;
      }
      }
    }
    {
    tmp___11 = (mode_t )(((((((((((tmp | tmp___0) | tmp___1) | tmp___2) | tmp___3) | tmp___4) | tmp___5) | tmp___6) | tmp___7) | tmp___8) | tmp___9) | tmp___10);
    }
    }
  }
  return (tmp___11);
}
}
static struct mode_change *make_node_op_equals(mode_t new_mode , mode_t mentioned )
{
  struct mode_change *p ;
  void *tmp ;
  {
  {
  tmp = xmalloc(2UL * sizeof(*p));
  p = (struct mode_change *)tmp;
  p->op = (char )'=';
  p->flag = (char)1;
  p->affected = (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
  p->value = new_mode;
  p->mentioned = mentioned;
  (p + 1)->flag = (char)0;
  }
  return (p);
}
}
struct mode_change *mode_compile(char const *mode_string )
{
  struct mode_change *mc ;
  size_t used ;
  unsigned int octal_mode ;
  mode_t mode ;
  mode_t mentioned ;
  char const *tmp ;
  struct mode_change *tmp___0 ;
  size_t needed ;
  char const *p ;
  int tmp___1 ;
  void *tmp___2 ;
  mode_t affected ;
  char op ;
  char const *tmp___3 ;
  mode_t value ;
  char flag ;
  struct mode_change *change ;
  char const *tmp___4 ;
  size_t tmp___5 ;
  {
  {
  used = (size_t )0;
  }
  if (48 <= (int )*mode_string) {
    {
    if ((int const )*mode_string < 56) {
      {
      {
      octal_mode = 0U;
      }
      {
      while (1) {
        while_continue: ;
        if (! 1) {
          {
          goto while_break;
          }
        }
        {
        tmp = mode_string;
        mode_string ++;
        octal_mode = (8U * octal_mode + (unsigned int )*tmp) - 48U;
        }
        if (4095U < octal_mode) {
          {
          return ((struct mode_change *)((void *)0));
          }
        }
        if (48 <= (int )*mode_string) {
          {
          if (! ((int const )*mode_string < 56)) {
            {
            goto while_break;
            }
          }
          }
        } else {
          {
          goto while_break;
          }
        }
      }
      while_break: ;
      }
      if (*mode_string) {
        {
        return ((struct mode_change *)((void *)0));
        }
      }
      {
      mode = octal_to_mode(octal_mode);
      mentioned = ((mode & 3072U) | 512U) | (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3));
      tmp___0 = make_node_op_equals(mode, mentioned);
      }
      return (tmp___0);
      }
    }
    }
  }
  {
  needed = (size_t )1;
  p = mode_string;
  }
  {
  while (1) {
    while_continue___0: ;
    if (! *p) {
      {
      goto while_break___0;
      }
    }
    if ((int const )*p == 61) {
      {
      {
      tmp___1 = 1;
      }
      }
    } else {
      {
      if ((int const )*p == 43) {
        {
        {
        tmp___1 = 1;
        }
        }
      } else {
        {
        if ((int const )*p == 45) {
          {
          {
          tmp___1 = 1;
          }
          }
        } else {
          {
          {
          tmp___1 = 0;
          }
          }
        }
        }
      }
      }
    }
    {
    needed += (size_t )tmp___1;
    p ++;
    }
  }
  while_break___0: ;
  }
  {
  tmp___2 = xnmalloc(needed, sizeof(*mc));
  mc = (struct mode_change *)tmp___2;
  }
  {
  while (1) {
    while_continue___1: ;
    if (! 1) {
      {
      goto while_break___1;
      }
    }
    {
    affected = (mode_t )0;
    }
    {
    while (1) {
      while_continue___2: ;
      if (! 1) {
        {
        goto while_break___2;
        }
      }
      {
      if ((int )*mode_string == 117) {
        {
        goto case_117;
        }
      }
      if ((int )*mode_string == 103) {
        {
        goto case_103;
        }
      }
      if ((int )*mode_string == 111) {
        {
        goto case_111;
        }
      }
      if ((int )*mode_string == 97) {
        {
        goto case_97;
        }
      }
      if ((int )*mode_string == 45) {
        {
        goto case_45;
        }
      }
      if ((int )*mode_string == 43) {
        {
        goto case_45;
        }
      }
      if ((int )*mode_string == 61) {
        {
        goto case_45;
        }
      }
      goto switch_default;
      switch_default:
      goto invalid;
      case_117:
      {
      affected |= 2496U;
      }
      goto switch_break;
      case_103:
      {
      affected |= (unsigned int )(1024 | (448 >> 3));
      }
      goto switch_break;
      case_111:
      {
      affected |= (unsigned int )(512 | ((448 >> 3) >> 3));
      }
      goto switch_break;
      case_97:
      {
      affected |= (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
      }
      goto switch_break;
      case_45:
      case_43:
      case_61:
      goto no_more_affected;
      switch_break: ;
      }
      {
      mode_string ++;
      }
    }
    while_break___2: ;
    }
    no_more_affected:
    {
    }
    {
    while (1) {
      while_continue___3: ;
      if (! 1) {
        {
        goto while_break___3;
        }
      }
      {
      tmp___3 = mode_string;
      mode_string ++;
      op = (char )*tmp___3;
      flag = (char)3;
      tmp___4 = mode_string;
      mode_string ++;
      }
      {
      if ((int )*tmp___4 == 117) {
        {
        goto case_117___0;
        }
      }
      if ((int )*tmp___4 == 103) {
        {
        goto case_103___0;
        }
      }
      if ((int )*tmp___4 == 111) {
        {
        goto case_111___0;
        }
      }
      goto switch_default___0;
      case_117___0:
      {
      value = (mode_t )448;
      }
      goto switch_break___0;
      case_103___0:
      {
      value = (mode_t )(448 >> 3);
      }
      goto switch_break___0;
      case_111___0:
      {
      value = (mode_t )((448 >> 3) >> 3);
      }
      goto switch_break___0;
      switch_default___0:
      {
      value = (mode_t )0;
      flag = (char)1;
      mode_string --;
      }
      {
      while (1) {
        while_continue___4: ;
        if (! 1) {
          {
          goto while_break___4;
          }
        }
        {
        if ((int )*mode_string == 114) {
          {
          goto case_114;
          }
        }
        if ((int )*mode_string == 119) {
          {
          goto case_119;
          }
        }
        if ((int )*mode_string == 120) {
          {
          goto case_120;
          }
        }
        if ((int )*mode_string == 88) {
          {
          goto case_88;
          }
        }
        if ((int )*mode_string == 115) {
          {
          goto case_115;
          }
        }
        if ((int )*mode_string == 116) {
          {
          goto case_116;
          }
        }
        goto switch_default___1;
        case_114:
        {
        value |= (unsigned int )((256 | (256 >> 3)) | ((256 >> 3) >> 3));
        }
        goto switch_break___1;
        case_119:
        {
        value |= (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3));
        }
        goto switch_break___1;
        case_120:
        {
        value |= (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3));
        }
        goto switch_break___1;
        case_88:
        {
        flag = (char)2;
        }
        goto switch_break___1;
        case_115:
        {
        value |= 3072U;
        }
        goto switch_break___1;
        case_116:
        {
        value |= 512U;
        }
        goto switch_break___1;
        switch_default___1:
        goto no_more_values;
        switch_break___1: ;
        }
        {
        mode_string ++;
        }
      }
      while_break___4: ;
      }
      no_more_values:
      {
      }
      switch_break___0: ;
      }
      {
      tmp___5 = used;
      used ++;
      change = mc + tmp___5;
      change->op = op;
      change->flag = flag;
      change->affected = affected;
      change->value = value;
      }
      if (affected) {
        {
        {
        change->mentioned = affected & value;
        }
        }
      } else {
        {
        {
        change->mentioned = value;
        }
        }
      }
      if (! ((int const )*mode_string == 61)) {
        {
        if (! ((int const )*mode_string == 43)) {
          {
          if (! ((int const )*mode_string == 45)) {
            {
            goto while_break___3;
            }
          }
          }
        }
        }
      }
    }
    while_break___3: ;
    }
    if ((int const )*mode_string != 44) {
      {
      goto while_break___1;
      }
    }
    {
    mode_string ++;
    }
  }
  while_break___1: ;
  }
  if ((int const )*mode_string == 0) {
    {
    {
    (mc + used)->flag = (char)0;
    }
    return (mc);
    }
  }
  invalid:
  {
  free((void *)mc);
  }
  return ((struct mode_change *)((void *)0));
}
}
struct mode_change *mode_create_from_ref(char const *ref_file )
{
  struct stat ref_stats ;
  int tmp ;
  struct mode_change *tmp___0 ;
  {
  {
  tmp = stat((char const *)((char const * __restrict )ref_file), (struct stat *)((struct stat * __restrict )(& ref_stats)));
  }
  if (tmp != 0) {
    {
    return ((struct mode_change *)((void *)0));
    }
  }
  {
  tmp___0 = make_node_op_equals(ref_stats.st_mode, (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3)));
  }
  return (tmp___0);
}
}
mode_t mode_adjust(mode_t oldmode , _Bool dir , mode_t umask_value , struct mode_change const *changes ,
                   mode_t *pmode_bits )
{
  mode_t newmode ;
  mode_t mode_bits ;
  mode_t affected ;
  mode_t omit_change ;
  int tmp ;
  mode_t value ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  mode_t tmp___3 ;
  mode_t preserved ;
  mode_t tmp___4 ;
  {
  {
  newmode = oldmode & (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
  mode_bits = (mode_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! ((int const )changes->flag != 0)) {
      {
      goto while_break;
      }
    }
    {
    affected = (mode_t )changes->affected;
    }
    if (dir) {
      {
      {
      tmp = 3072;
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    {
    omit_change = (mode_t )((unsigned int const )tmp & (unsigned int const )(~ changes->mentioned));
    value = (mode_t )changes->value;
    }
    {
    if ((int )changes->flag == 1) {
      {
      goto case_1;
      }
    }
    if ((int )changes->flag == 3) {
      {
      goto case_3;
      }
    }
    if ((int )changes->flag == 2) {
      {
      goto case_2;
      }
    }
    goto switch_break;
    case_1:
    goto switch_break;
    case_3:
    {
    value &= newmode;
    }
    if (value & (unsigned int )((256 | (256 >> 3)) | ((256 >> 3) >> 3))) {
      {
      {
      tmp___0 = (256 | (256 >> 3)) | ((256 >> 3) >> 3);
      }
      }
    } else {
      {
      {
      tmp___0 = 0;
      }
      }
    }
    if (value & (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3))) {
      {
      {
      tmp___1 = (128 | (128 >> 3)) | ((128 >> 3) >> 3);
      }
      }
    } else {
      {
      {
      tmp___1 = 0;
      }
      }
    }
    if (value & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
      {
      {
      tmp___2 = (64 | (64 >> 3)) | ((64 >> 3) >> 3);
      }
      }
    } else {
      {
      {
      tmp___2 = 0;
      }
      }
    }
    {
    value |= (unsigned int )((tmp___0 | tmp___1) | tmp___2);
    }
    goto switch_break;
    case_2:
    if ((newmode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) | (unsigned int )dir) {
      {
      {
      value |= (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3));
      }
      }
    }
    goto switch_break;
    switch_break: ;
    }
    if (affected) {
      {
      {
      tmp___3 = affected;
      }
      }
    } else {
      {
      {
      tmp___3 = ~ umask_value;
      }
      }
    }
    {
    value &= tmp___3 & ~ omit_change;
    }
    {
    if ((int )changes->op == 61) {
      {
      goto case_61;
      }
    }
    if ((int )changes->op == 43) {
      {
      goto case_43;
      }
    }
    if ((int )changes->op == 45) {
      {
      goto case_45;
      }
    }
    goto switch_break___0;
    case_61:
    if (affected) {
      {
      {
      tmp___4 = ~ affected;
      }
      }
    } else {
      {
      {
      tmp___4 = (mode_t )0;
      }
      }
    }
    {
    preserved = tmp___4 | omit_change;
    mode_bits |= (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3)) & ~ preserved;
    newmode = (newmode & preserved) | value;
    }
    goto switch_break___0;
    case_43:
    {
    mode_bits |= value;
    newmode |= value;
    }
    goto switch_break___0;
    case_45:
    {
    mode_bits |= value;
    newmode &= ~ value;
    }
    goto switch_break___0;
    switch_break___0: ;
    }
    {
    changes ++;
    }
  }
  while_break: ;
  }
  if (pmode_bits) {
    {
    {
    *pmode_bits = mode_bits;
    }
    }
  }
  return (newmode);
}
}
static void mpsort_into_tmp(void const ** __restrict base , size_t n , void const ** __restrict tmp ,
                            int (*cmp)(void const * , void const * ) )
{
  size_t n1 ;
  size_t n2 ;
  size_t a ;
  size_t alim ;
  size_t b ;
  size_t blim ;
  void const *ba ;
  void const *bb ;
  void const ** __restrict tmp___0 ;
  void const ** __restrict tmp___1 ;
  int tmp___2 ;
  {
  {
  n1 = n / 2UL;
  n2 = n - n1;
  a = (size_t )0;
  alim = n1;
  b = n1;
  blim = n;
  mpsort_with_tmp(base + n1, n2, tmp, cmp);
  mpsort_with_tmp(base, n1, tmp, cmp);
  ba = *(base + a);
  bb = *(base + b);
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___2 = (*cmp)(ba, bb);
    }
    if (tmp___2 <= 0) {
      {
      {
      tmp___0 = tmp;
      tmp ++;
      *tmp___0 = ba;
      a ++;
      }
      if (a == alim) {
        {
        {
        a = b;
        alim = blim;
        }
        goto while_break;
        }
      }
      {
      ba = *(base + a);
      }
      }
    } else {
      {
      {
      tmp___1 = tmp;
      tmp ++;
      *tmp___1 = bb;
      b ++;
      }
      if (b == blim) {
        {
        goto while_break;
        }
      }
      {
      bb = *(base + b);
      }
      }
    }
  }
  while_break: ;
  }
  {
  memcpy((void *)((void * __restrict )tmp), (void const *)((void const * __restrict )(base + a)),
         (alim - a) * sizeof(*base));
  }
  return;
}
}
static void mpsort_with_tmp(void const **base , size_t n , void const **tmp ,
                            int (*cmp)(void const * , void const * ) )
{
  void const *p0 ;
  void const *p1 ;
  int tmp___0 ;
  size_t n1 ;
  size_t n2 ;
  size_t i ;
  size_t t ;
  size_t tlim ;
  size_t b ;
  size_t blim ;
  void const *bb ;
  void const *tt ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  {
  if (n <= 2UL) {
    {
    if (n == 2UL) {
      {
      {
      p0 = *(base + 0);
      p1 = *(base + 1);
      tmp___0 = (*cmp)(p0, p1);
      }
      if (! (tmp___0 <= 0)) {
        {
        {
        *(base + 0) = p1;
        *(base + 1) = p0;
        }
        }
      }
      }
    }
    }
  } else {
    {
    {
    n1 = n / 2UL;
    n2 = n - n1;
    t = (size_t )0;
    tlim = n1;
    b = n1;
    blim = n;
    mpsort_with_tmp(base + n1, n2, tmp, cmp);
    }
    if (n1 < 2UL) {
      {
      {
      *(tmp + 0) = *(base + 0);
      }
      }
    } else {
      {
      {
      mpsort_into_tmp((void const ** __restrict )base, n1, (void const ** __restrict )tmp,
                      cmp);
      }
      }
    }
    {
    tt = *(tmp + t);
    bb = *(base + b);
    i = (size_t )0;
    }
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      {
      tmp___3 = (*cmp)(tt, bb);
      }
      if (tmp___3 <= 0) {
        {
        {
        tmp___1 = i;
        i ++;
        *(base + tmp___1) = tt;
        t ++;
        }
        if (t == tlim) {
          {
          goto while_break;
          }
        }
        {
        tt = *(tmp + t);
        }
        }
      } else {
        {
        {
        tmp___2 = i;
        i ++;
        *(base + tmp___2) = bb;
        b ++;
        }
        if (b == blim) {
          {
          {
          memcpy((void *)((void * __restrict )(base + i)), (void const *)((void const * __restrict )(tmp + t)),
                 (tlim - t) * sizeof(*base));
          }
          goto while_break;
          }
        }
        {
        bb = *(base + b);
        }
        }
      }
    }
    while_break: ;
    }
    }
  }
  return;
}
}
void mpsort(void const **base , size_t n , int (*cmp)(void const * , void const * ) )
{
  {
  {
  mpsort_with_tmp((void const **)((void const ** __restrict )base), n, (void const **)((void const ** __restrict )(base + n)),
                  cmp);
  }
  return;
}
}
static unsigned long num_processors_via_affinity_mask(void)
{
  cpu_set_t set ;
  unsigned long count ;
  int tmp ;
  int tmp___0 ;
  {
  {
  tmp___0 = sched_getaffinity(0, sizeof(set), & set);
  }
  if (tmp___0 == 0) {
    {
    {
    tmp = __sched_cpucount(sizeof(cpu_set_t ), (cpu_set_t const *)(& set));
    count = (unsigned long )tmp;
    }
    if (count > 0UL) {
      {
      return (count);
      }
    }
    }
  }
  return (0UL);
}
}
unsigned long num_processors(enum nproc_query query )
{
  char const *envvalue ;
  char *tmp ;
  int __c ;
  int tmp___0 ;
  char *endptr ;
  unsigned long value ;
  unsigned long tmp___1 ;
  int __c___0 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  int __c___1 ;
  int tmp___4 ;
  unsigned long nprocs ;
  unsigned long tmp___5 ;
  long nprocs___0 ;
  long tmp___6 ;
  long nprocs___1 ;
  long tmp___7 ;
  unsigned long nprocs_current ;
  unsigned long tmp___8 ;
  {
  if ((unsigned int )query == 2U) {
    {
    {
    tmp = getenv((char const *)"OMP_NUM_THREADS");
    envvalue = (char const *)tmp;
    }
    if ((unsigned long )envvalue != (unsigned long )((void *)0)) {
      {
      {
      while (1) {
        while_continue: ;
        if (! 1) {
          {
          goto while_break;
          }
        }
        if ((int const )*envvalue != 0) {
          {
          {
          __c = (int )*envvalue;
          }
          if (__c == 32) {
            {
            {
            tmp___0 = 1;
            }
            }
          } else {
            {
            if (__c == 9) {
              {
              {
              tmp___0 = 1;
              }
              }
            } else {
              {
              if (__c == 10) {
                {
                {
                tmp___0 = 1;
                }
                }
              } else {
                {
                if (__c == 11) {
                  {
                  {
                  tmp___0 = 1;
                  }
                  }
                } else {
                  {
                  if (__c == 12) {
                    {
                    {
                    tmp___0 = 1;
                    }
                    }
                  } else {
                    {
                    if (__c == 13) {
                      {
                      {
                      tmp___0 = 1;
                      }
                      }
                    } else {
                      {
                      {
                      tmp___0 = 0;
                      }
                      }
                    }
                    }
                  }
                  }
                }
                }
              }
              }
            }
            }
          }
          if (! tmp___0) {
            {
            goto while_break;
            }
          }
          }
        } else {
          {
          goto while_break;
          }
        }
        {
        envvalue ++;
        }
      }
      while_break: ;
      }
      {
      __c___1 = (int )*envvalue;
      }
      if (__c___1 >= 48) {
        {
        if (__c___1 <= 57) {
          {
          {
          tmp___4 = 1;
          }
          }
        } else {
          {
          {
          tmp___4 = 0;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___4 = 0;
        }
        }
      }
      if (tmp___4) {
        {
        {
        endptr = (char *)((void *)0);
        tmp___1 = strtoul((char const * __restrict )envvalue, (char ** __restrict )(& endptr),
                          10);
        value = tmp___1;
        }
        if ((unsigned long )endptr != (unsigned long )((void *)0)) {
          {
          {
          while (1) {
            while_continue___0: ;
            if (! 1) {
              {
              goto while_break___0;
              }
            }
            if ((int )*endptr != 0) {
              {
              {
              __c___0 = (int )*endptr;
              }
              if (__c___0 == 32) {
                {
                {
                tmp___2 = 1;
                }
                }
              } else {
                {
                if (__c___0 == 9) {
                  {
                  {
                  tmp___2 = 1;
                  }
                  }
                } else {
                  {
                  if (__c___0 == 10) {
                    {
                    {
                    tmp___2 = 1;
                    }
                    }
                  } else {
                    {
                    if (__c___0 == 11) {
                      {
                      {
                      tmp___2 = 1;
                      }
                      }
                    } else {
                      {
                      if (__c___0 == 12) {
                        {
                        {
                        tmp___2 = 1;
                        }
                        }
                      } else {
                        {
                        if (__c___0 == 13) {
                          {
                          {
                          tmp___2 = 1;
                          }
                          }
                        } else {
                          {
                          {
                          tmp___2 = 0;
                          }
                          }
                        }
                        }
                      }
                      }
                    }
                    }
                  }
                  }
                }
                }
              }
              if (! tmp___2) {
                {
                goto while_break___0;
                }
              }
              }
            } else {
              {
              goto while_break___0;
              }
            }
            {
            endptr ++;
            }
          }
          while_break___0: ;
          }
          if ((int )*endptr == 0) {
            {
            if (value > 0UL) {
              {
              {
              tmp___3 = value;
              }
              }
            } else {
              {
              {
              tmp___3 = 1UL;
              }
              }
            }
            return (tmp___3);
            }
          }
          }
        }
        }
      }
      }
    }
    {
    query = (enum nproc_query )1;
    }
    }
  }
  if ((unsigned int )query == 1U) {
    {
    {
    tmp___5 = num_processors_via_affinity_mask();
    nprocs = tmp___5;
    }
    if (nprocs > 0UL) {
      {
      return (nprocs);
      }
    }
    {
    tmp___6 = sysconf(84);
    nprocs___0 = tmp___6;
    }
    if (nprocs___0 > 0L) {
      {
      return ((unsigned long )nprocs___0);
      }
    }
    }
  } else {
    {
    {
    tmp___7 = sysconf(83);
    nprocs___1 = tmp___7;
    }
    if (nprocs___1 == 1L) {
      {
      {
      tmp___8 = num_processors_via_affinity_mask();
      nprocs_current = tmp___8;
      }
      if (nprocs_current > 0UL) {
        {
        {
        nprocs___1 = (long )nprocs_current;
        }
        }
      }
      }
    }
    if (nprocs___1 > 0L) {
      {
      return ((unsigned long )nprocs___1);
      }
    }
    }
  }
  return (1UL);
}
}
void openat_save_fail(int errnum ) __attribute__((__noreturn__)) ;
void openat_save_fail(int errnum )
{
  char *tmp ;
  {
  {
  tmp = dcgettext((char const *)((void *)0), (char const *)"unable to record current working directory",
                  5);
  error((int )exit_failure, errnum, (char const *)tmp);
  abort();
  }
}
}
void openat_restore_fail(int errnum ) __attribute__((__noreturn__)) ;
void openat_restore_fail(int errnum )
{
  char *tmp ;
  {
  {
  tmp = dcgettext((char const *)((void *)0), (char const *)"failed to return to initial working directory",
                  5);
  error((int )exit_failure, errnum, (char const *)tmp);
  abort();
  }
}
}
int openat_safer(int fd , char const *file , int flags , ...)
{
  mode_t mode ;
  va_list ap ;
  int tmp ;
  int tmp___0 ;
  mode_t tmp___1 ;
  {
  {
  mode = (mode_t )0;
  }
  if (flags & 64) {
    {
    {
    __builtin_va_start(ap, flags);
    tmp___1 = __builtin_va_arg(ap, mode_t );
    mode = tmp___1;
    __builtin_va_end(ap);
    }
    }
  }
  {
  tmp = openat(fd, file, flags, mode);
  tmp___0 = fd_safer(tmp);
  }
  return (tmp___0);
}
}
static void digits_to_date_time(parser_control *pc , textint text_int )
{
  {
  if (pc->dates_seen) {
    {
    if (! pc->year.digits) {
      {
      if (! pc->rels_seen) {
        {
        if (pc->times_seen) {
          {
          {
          pc->year = text_int;
          }
          }
        } else {
          {
          if (2UL < text_int.digits) {
            {
            {
            pc->year = text_int;
            }
            }
          } else {
            {
            goto _L___1;
            }
          }
          }
        }
        }
      } else {
        {
        goto _L___1;
        }
      }
      }
    } else {
      {
      goto _L___1;
      }
    }
    }
  } else {
    {
    _L___1:
    if (4UL < text_int.digits) {
      {
      {
      (pc->dates_seen) ++;
      pc->day = text_int.value % 100L;
      pc->month = (text_int.value / 100L) % 100L;
      pc->year.value = text_int.value / 10000L;
      pc->year.digits = text_int.digits - 4UL;
      }
      }
    } else {
      {
      {
      (pc->times_seen) ++;
      }
      if (text_int.digits <= 2UL) {
        {
        {
        pc->hour = text_int.value;
        pc->minutes = 0L;
        }
        }
      } else {
        {
        {
        pc->hour = text_int.value / 100L;
        pc->minutes = text_int.value % 100L;
        }
        }
      }
      {
      pc->seconds.tv_sec = (time_t )0;
      pc->seconds.tv_nsec = 0L;
      pc->meridian = 2;
      }
      }
    }
    }
  }
  return;
}
}
static void apply_relative_time(parser_control *pc , relative_time rel , int factor )
{
  {
  {
  pc->rel.ns += (long )factor * rel.ns;
  pc->rel.seconds += (long_time_t )factor * rel.seconds;
  pc->rel.minutes += (long )factor * rel.minutes;
  pc->rel.hour += (long )factor * rel.hour;
  pc->rel.day += (long )factor * rel.day;
  pc->rel.month += (long )factor * rel.month;
  pc->rel.year += (long )factor * rel.year;
  pc->rels_seen = (_Bool)1;
  }
  return;
}
}
static void set_hhmmss(parser_control *pc , long hour , long minutes , time_t sec ,
                       long nsec )
{
  {
  {
  pc->hour = hour;
  pc->minutes = minutes;
  pc->seconds.tv_sec = sec;
  pc->seconds.tv_nsec = nsec;
  }
  return;
}
}
static void yydestruct(char const *yymsg , int yytype , YYSTYPE *yyvaluep , parser_control *pc )
{
  {
  if (! yymsg) {
    {
    {
    yymsg = (char const *)"Deleting";
    }
    }
  }
  {
  goto switch_default;
  switch_default:
  goto switch_break;
  switch_break: ;
  }
  return;
}
}
int yyparse(parser_control *pc )
{
  int yychar ;
  YYSTYPE yylval ;
  int yynerrs ;
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[20] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[20] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  long tmp___0 ;
  relative_time __constr_expr_0 ;
  relative_time __constr_expr_1 ;
  relative_time __constr_expr_2 ;
  relative_time __constr_expr_3 ;
  relative_time __constr_expr_4 ;
  relative_time __constr_expr_5 ;
  relative_time __constr_expr_6 ;
  relative_time __constr_expr_7 ;
  relative_time __constr_expr_8 ;
  relative_time __constr_expr_9 ;
  relative_time __constr_expr_10 ;
  relative_time __constr_expr_11 ;
  relative_time __constr_expr_12 ;
  relative_time __constr_expr_13 ;
  relative_time __constr_expr_14 ;
  relative_time __constr_expr_15 ;
  relative_time __constr_expr_16 ;
  relative_time __constr_expr_17 ;
  relative_time __constr_expr_18 ;
  relative_time __constr_expr_19 ;
  relative_time __constr_expr_20 ;
  relative_time __constr_expr_21 ;
  relative_time __constr_expr_22 ;
  relative_time __constr_expr_23 ;
  relative_time __constr_expr_24 ;
  relative_time __constr_expr_25 ;
  relative_time __constr_expr_26 ;
  {
  {
  yylen = 0;
  yytoken = 0;
  yyss = yyssa;
  yyvs = yyvsa;
  yystacksize = 20UL;
  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = -2;
  yyssp = yyss;
  yyvsp = yyvs;
  }
  goto yysetstate;
  yynewstate:
  {
  yyssp ++;
  }
  yysetstate:
  {
  *yyssp = (yytype_int16 )yystate;
  }
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
    {
    {
    yysize = (unsigned long )((yyssp - yyss) + 1L);
    }
    if (20UL <= yystacksize) {
      {
      goto yyexhaustedlab;
      }
    }
    {
    yystacksize *= 2UL;
    }
    if (20UL < yystacksize) {
      {
      {
      yystacksize = 20UL;
      }
      }
    }
    {
    yyss1 = yyss;
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
    yyptr = (union yyalloc *)tmp;
    }
    if (! yyptr) {
      {
      goto yyexhaustedlab;
      }
    }
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      {
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const *)yyss, yysize * sizeof(*yyss));
      yyss = & yyptr->yyss_alloc;
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
      yyptr += yynewbytes / sizeof(*yyptr);
      }
      goto while_break;
    }
    while_break: ;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      {
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const *)yyvs, yysize * sizeof(*yyvs));
      yyvs = & yyptr->yyvs_alloc;
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
      goto while_break___0;
    }
    while_break___0: ;
    }
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
      {
      free((void *)yyss1);
      }
      }
    }
    {
    yyssp = (yyss + yysize) - 1;
    yyvsp = (yyvs + yysize) - 1;
    }
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
      {
      goto yyabortlab;
      }
    }
    }
  }
  if (yystate == 12) {
    {
    goto yyacceptlab;
    }
  }
  goto yybackup;
  yybackup:
  {
  yyn = (int )yypact[yystate];
  }
  if (yyn == -93) {
    {
    goto yydefault;
    }
  }
  if (yychar == -2) {
    {
    {
    yychar = yylex(& yylval, pc);
    }
    }
  }
  if (yychar <= 0) {
    {
    {
    yytoken = 0;
    yychar = yytoken;
    }
    }
  } else {
    {
    if ((unsigned int )yychar <= 277U) {
      {
      {
      yytoken = (int )yytranslate[yychar];
      }
      }
    } else {
      {
      {
      yytoken = 2;
      }
      }
    }
    }
  }
  {
  yyn += yytoken;
  }
  if (yyn < 0) {
    {
    goto yydefault;
    }
  } else {
    {
    if (112 < yyn) {
      {
      goto yydefault;
      }
    } else {
      {
      if ((int const )yycheck[yyn] != (int const )yytoken) {
        {
        goto yydefault;
        }
      }
      }
    }
    }
  }
  {
  yyn = (int )yytable[yyn];
  }
  if (yyn <= 0) {
    {
    if (yyn == 0) {
      {
      goto yyerrlab;
      }
    } else {
      {
      if (yyn == -1) {
        {
        goto yyerrlab;
        }
      }
      }
    }
    {
    yyn = - yyn;
    }
    goto yyreduce;
    }
  }
  if (yyerrstatus) {
    {
    {
    yyerrstatus --;
    }
    }
  }
  {
  yychar = -2;
  yystate = yyn;
  yyvsp ++;
  *yyvsp = yylval;
  }
  goto yynewstate;
  yydefault:
  {
  yyn = (int )yydefact[yystate];
  }
  if (yyn == 0) {
    {
    goto yyerrlab;
    }
  }
  goto yyreduce;
  yyreduce:
  {
  yylen = (int )yyr2[yyn];
  yyval = *(yyvsp + (1 - yylen));
  }
  {
  if (yyn == 4) {
    {
    goto case_4;
    }
  }
  if (yyn == 7) {
    {
    goto case_7;
    }
  }
  if (yyn == 8) {
    {
    goto case_8;
    }
  }
  if (yyn == 9) {
    {
    goto case_9;
    }
  }
  if (yyn == 10) {
    {
    goto case_10;
    }
  }
  if (yyn == 11) {
    {
    goto case_11;
    }
  }
  if (yyn == 12) {
    {
    goto case_12;
    }
  }
  if (yyn == 18) {
    {
    goto case_18;
    }
  }
  if (yyn == 19) {
    {
    goto case_19;
    }
  }
  if (yyn == 20) {
    {
    goto case_20;
    }
  }
  if (yyn == 22) {
    {
    goto case_22;
    }
  }
  if (yyn == 23) {
    {
    goto case_23;
    }
  }
  if (yyn == 24) {
    {
    goto case_24;
    }
  }
  if (yyn == 27) {
    {
    goto case_27;
    }
  }
  if (yyn == 28) {
    {
    goto case_28;
    }
  }
  if (yyn == 29) {
    {
    goto case_29;
    }
  }
  if (yyn == 30) {
    {
    goto case_30;
    }
  }
  if (yyn == 31) {
    {
    goto case_31;
    }
  }
  if (yyn == 32) {
    {
    goto case_32;
    }
  }
  if (yyn == 33) {
    {
    goto case_33;
    }
  }
  if (yyn == 34) {
    {
    goto case_34;
    }
  }
  if (yyn == 35) {
    {
    goto case_35;
    }
  }
  if (yyn == 36) {
    {
    goto case_36;
    }
  }
  if (yyn == 37) {
    {
    goto case_37;
    }
  }
  if (yyn == 38) {
    {
    goto case_38;
    }
  }
  if (yyn == 39) {
    {
    goto case_39;
    }
  }
  if (yyn == 40) {
    {
    goto case_40;
    }
  }
  if (yyn == 41) {
    {
    goto case_41;
    }
  }
  if (yyn == 42) {
    {
    goto case_42;
    }
  }
  if (yyn == 43) {
    {
    goto case_43;
    }
  }
  if (yyn == 44) {
    {
    goto case_44;
    }
  }
  if (yyn == 45) {
    {
    goto case_45;
    }
  }
  if (yyn == 46) {
    {
    goto case_46;
    }
  }
  if (yyn == 47) {
    {
    goto case_47;
    }
  }
  if (yyn == 48) {
    {
    goto case_48;
    }
  }
  if (yyn == 50) {
    {
    goto case_50;
    }
  }
  if (yyn == 51) {
    {
    goto case_51;
    }
  }
  if (yyn == 52) {
    {
    goto case_52;
    }
  }
  if (yyn == 53) {
    {
    goto case_53;
    }
  }
  if (yyn == 54) {
    {
    goto case_54;
    }
  }
  if (yyn == 55) {
    {
    goto case_55;
    }
  }
  if (yyn == 56) {
    {
    goto case_56;
    }
  }
  if (yyn == 57) {
    {
    goto case_57;
    }
  }
  if (yyn == 58) {
    {
    goto case_58;
    }
  }
  if (yyn == 59) {
    {
    goto case_59;
    }
  }
  if (yyn == 60) {
    {
    goto case_60;
    }
  }
  if (yyn == 61) {
    {
    goto case_61;
    }
  }
  if (yyn == 62) {
    {
    goto case_62;
    }
  }
  if (yyn == 63) {
    {
    goto case_63;
    }
  }
  if (yyn == 64) {
    {
    goto case_64;
    }
  }
  if (yyn == 65) {
    {
    goto case_65;
    }
  }
  if (yyn == 66) {
    {
    goto case_66;
    }
  }
  if (yyn == 67) {
    {
    goto case_67;
    }
  }
  if (yyn == 68) {
    {
    goto case_68;
    }
  }
  if (yyn == 69) {
    {
    goto case_69;
    }
  }
  if (yyn == 70) {
    {
    goto case_70;
    }
  }
  if (yyn == 71) {
    {
    goto case_71;
    }
  }
  if (yyn == 72) {
    {
    goto case_72;
    }
  }
  if (yyn == 73) {
    {
    goto case_73;
    }
  }
  if (yyn == 75) {
    {
    goto case_75;
    }
  }
  if (yyn == 76) {
    {
    goto case_76;
    }
  }
  if (yyn == 77) {
    {
    goto case_77;
    }
  }
  if (yyn == 78) {
    {
    goto case_78;
    }
  }
  if (yyn == 79) {
    {
    goto case_79;
    }
  }
  if (yyn == 80) {
    {
    goto case_80;
    }
  }
  if (yyn == 81) {
    {
    goto case_81;
    }
  }
  if (yyn == 85) {
    {
    goto case_85;
    }
  }
  if (yyn == 87) {
    {
    goto case_87;
    }
  }
  if (yyn == 88) {
    {
    goto case_88;
    }
  }
  if (yyn == 89) {
    {
    goto case_89;
    }
  }
  if (yyn == 90) {
    {
    goto case_90;
    }
  }
  if (yyn == 91) {
    {
    goto case_91;
    }
  }
  goto switch_default;
  case_4:
  {
  pc->seconds = (yyvsp + 0)->timespec;
  pc->timespec_seen = (_Bool)1;
  }
  goto switch_break;
  case_7:
  {
  (pc->times_seen) ++;
  (pc->dates_seen) ++;
  }
  goto switch_break;
  case_8:
  {
  (pc->times_seen) ++;
  }
  goto switch_break;
  case_9:
  {
  (pc->local_zones_seen) ++;
  }
  goto switch_break;
  case_10:
  {
  (pc->zones_seen) ++;
  }
  goto switch_break;
  case_11:
  {
  (pc->dates_seen) ++;
  }
  goto switch_break;
  case_12:
  {
  (pc->days_seen) ++;
  }
  goto switch_break;
  case_18:
  {
  set_hhmmss(pc, (yyvsp + -1)->textintval.value, 0L, (time_t )0, 0L);
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
  goto switch_break;
  case_19:
  {
  set_hhmmss(pc, (yyvsp + -3)->textintval.value, (yyvsp + -1)->textintval.value, (time_t )0,
             0L);
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
  goto switch_break;
  case_20:
  {
  set_hhmmss(pc, (yyvsp + -5)->textintval.value, (yyvsp + -3)->textintval.value, (yyvsp + -1)->timespec.tv_sec,
             (yyvsp + -1)->timespec.tv_nsec);
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
  goto switch_break;
  case_22:
  {
  set_hhmmss(pc, (yyvsp + -1)->textintval.value, 0L, (time_t )0, 0L);
  pc->meridian = 2;
  }
  goto switch_break;
  case_23:
  {
  set_hhmmss(pc, (yyvsp + -3)->textintval.value, (yyvsp + -1)->textintval.value, (time_t )0,
             0L);
  pc->meridian = 2;
  }
  goto switch_break;
  case_24:
  {
  set_hhmmss(pc, (yyvsp + -5)->textintval.value, (yyvsp + -3)->textintval.value, (yyvsp + -1)->timespec.tv_sec,
             (yyvsp + -1)->timespec.tv_nsec);
  pc->meridian = 2;
  }
  goto switch_break;
  case_27:
  {
  (pc->zones_seen) ++;
  pc->time_zone = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
  }
  goto switch_break;
  case_28:
  {
  pc->local_isdst = (int )(yyvsp + 0)->intval;
  pc->dsts_seen += (size_t )(0L < (yyvsp + 0)->intval);
  }
  goto switch_break;
  case_29:
  {
  pc->local_isdst = 1;
  pc->dsts_seen += (size_t )((0L < (yyvsp + -1)->intval) + 1);
  }
  goto switch_break;
  case_30:
  {
  pc->time_zone = (yyvsp + 0)->intval;
  }
  goto switch_break;
  case_31:
  {
  pc->time_zone = 420L;
  }
  goto switch_break;
  case_32:
  {
  pc->time_zone = (yyvsp + -1)->intval;
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
  goto switch_break;
  case_33:
  {
  pc->time_zone = 420L;
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
  goto switch_break;
  case_34:
  {
  tmp___0 = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
  pc->time_zone = (yyvsp + -2)->intval + tmp___0;
  }
  goto switch_break;
  case_35:
  {
  pc->time_zone = (yyvsp + 0)->intval + 60L;
  }
  goto switch_break;
  case_36:
  {
  pc->time_zone = (yyvsp + -1)->intval + 60L;
  }
  goto switch_break;
  case_37:
  {
  pc->day_ordinal = 0L;
  pc->day_number = (int )(yyvsp + 0)->intval;
  }
  goto switch_break;
  case_38:
  {
  pc->day_ordinal = 0L;
  pc->day_number = (int )(yyvsp + -1)->intval;
  }
  goto switch_break;
  case_39:
  {
  pc->day_ordinal = (yyvsp + -1)->intval;
  pc->day_number = (int )(yyvsp + 0)->intval;
  }
  goto switch_break;
  case_40:
  {
  pc->day_ordinal = (yyvsp + -1)->textintval.value;
  pc->day_number = (int )(yyvsp + 0)->intval;
  }
  goto switch_break;
  case_41:
  {
  pc->month = (yyvsp + -2)->textintval.value;
  pc->day = (yyvsp + 0)->textintval.value;
  }
  goto switch_break;
  case_42:
  if (4UL <= (yyvsp + -4)->textintval.digits) {
    {
    {
    pc->year = (yyvsp + -4)->textintval;
    pc->month = (yyvsp + -2)->textintval.value;
    pc->day = (yyvsp + 0)->textintval.value;
    }
    }
  } else {
    {
    {
    pc->month = (yyvsp + -4)->textintval.value;
    pc->day = (yyvsp + -2)->textintval.value;
    pc->year = (yyvsp + 0)->textintval;
    }
    }
  }
  goto switch_break;
  case_43:
  {
  pc->day = (yyvsp + -2)->textintval.value;
  pc->month = (yyvsp + -1)->intval;
  pc->year.value = - (yyvsp + 0)->textintval.value;
  pc->year.digits = (yyvsp + 0)->textintval.digits;
  }
  goto switch_break;
  case_44:
  {
  pc->month = (yyvsp + -2)->intval;
  pc->day = - (yyvsp + -1)->textintval.value;
  pc->year.value = - (yyvsp + 0)->textintval.value;
  pc->year.digits = (yyvsp + 0)->textintval.digits;
  }
  goto switch_break;
  case_45:
  {
  pc->month = (yyvsp + -1)->intval;
  pc->day = (yyvsp + 0)->textintval.value;
  }
  goto switch_break;
  case_46:
  {
  pc->month = (yyvsp + -3)->intval;
  pc->day = (yyvsp + -2)->textintval.value;
  pc->year = (yyvsp + 0)->textintval;
  }
  goto switch_break;
  case_47:
  {
  pc->day = (yyvsp + -1)->textintval.value;
  pc->month = (yyvsp + 0)->intval;
  }
  goto switch_break;
  case_48:
  {
  pc->day = (yyvsp + -2)->textintval.value;
  pc->month = (yyvsp + -1)->intval;
  pc->year = (yyvsp + 0)->textintval;
  }
  goto switch_break;
  case_50:
  {
  pc->year = (yyvsp + -2)->textintval;
  pc->month = - (yyvsp + -1)->textintval.value;
  pc->day = - (yyvsp + 0)->textintval.value;
  }
  goto switch_break;
  case_51:
  {
  apply_relative_time(pc, (yyvsp + -1)->rel, -1);
  }
  goto switch_break;
  case_52:
  {
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
  goto switch_break;
  case_53:
  {
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
  goto switch_break;
  case_54:
  {
  __constr_expr_0.year = 0L;
  __constr_expr_0.month = 0L;
  __constr_expr_0.day = 0L;
  __constr_expr_0.hour = 0L;
  __constr_expr_0.minutes = 0L;
  __constr_expr_0.seconds = (long_time_t )0;
  __constr_expr_0.ns = 0L;
  yyval.rel = __constr_expr_0;
  yyval.rel.year = (yyvsp + -1)->intval;
  }
  goto switch_break;
  case_55:
  {
  __constr_expr_1.year = 0L;
  __constr_expr_1.month = 0L;
  __constr_expr_1.day = 0L;
  __constr_expr_1.hour = 0L;
  __constr_expr_1.minutes = 0L;
  __constr_expr_1.seconds = (long_time_t )0;
  __constr_expr_1.ns = 0L;
  yyval.rel = __constr_expr_1;
  yyval.rel.year = (yyvsp + -1)->textintval.value;
  }
  goto switch_break;
  case_56:
  {
  __constr_expr_2.year = 0L;
  __constr_expr_2.month = 0L;
  __constr_expr_2.day = 0L;
  __constr_expr_2.hour = 0L;
  __constr_expr_2.minutes = 0L;
  __constr_expr_2.seconds = (long_time_t )0;
  __constr_expr_2.ns = 0L;
  yyval.rel = __constr_expr_2;
  yyval.rel.year = 1L;
  }
  goto switch_break;
  case_57:
  {
  __constr_expr_3.year = 0L;
  __constr_expr_3.month = 0L;
  __constr_expr_3.day = 0L;
  __constr_expr_3.hour = 0L;
  __constr_expr_3.minutes = 0L;
  __constr_expr_3.seconds = (long_time_t )0;
  __constr_expr_3.ns = 0L;
  yyval.rel = __constr_expr_3;
  yyval.rel.month = (yyvsp + -1)->intval;
  }
  goto switch_break;
  case_58:
  {
  __constr_expr_4.year = 0L;
  __constr_expr_4.month = 0L;
  __constr_expr_4.day = 0L;
  __constr_expr_4.hour = 0L;
  __constr_expr_4.minutes = 0L;
  __constr_expr_4.seconds = (long_time_t )0;
  __constr_expr_4.ns = 0L;
  yyval.rel = __constr_expr_4;
  yyval.rel.month = (yyvsp + -1)->textintval.value;
  }
  goto switch_break;
  case_59:
  {
  __constr_expr_5.year = 0L;
  __constr_expr_5.month = 0L;
  __constr_expr_5.day = 0L;
  __constr_expr_5.hour = 0L;
  __constr_expr_5.minutes = 0L;
  __constr_expr_5.seconds = (long_time_t )0;
  __constr_expr_5.ns = 0L;
  yyval.rel = __constr_expr_5;
  yyval.rel.month = 1L;
  }
  goto switch_break;
  case_60:
  {
  __constr_expr_6.year = 0L;
  __constr_expr_6.month = 0L;
  __constr_expr_6.day = 0L;
  __constr_expr_6.hour = 0L;
  __constr_expr_6.minutes = 0L;
  __constr_expr_6.seconds = (long_time_t )0;
  __constr_expr_6.ns = 0L;
  yyval.rel = __constr_expr_6;
  yyval.rel.day = (yyvsp + -1)->intval * (yyvsp + 0)->intval;
  }
  goto switch_break;
  case_61:
  {
  __constr_expr_7.year = 0L;
  __constr_expr_7.month = 0L;
  __constr_expr_7.day = 0L;
  __constr_expr_7.hour = 0L;
  __constr_expr_7.minutes = 0L;
  __constr_expr_7.seconds = (long_time_t )0;
  __constr_expr_7.ns = 0L;
  yyval.rel = __constr_expr_7;
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
  }
  goto switch_break;
  case_62:
  {
  __constr_expr_8.year = 0L;
  __constr_expr_8.month = 0L;
  __constr_expr_8.day = 0L;
  __constr_expr_8.hour = 0L;
  __constr_expr_8.minutes = 0L;
  __constr_expr_8.seconds = (long_time_t )0;
  __constr_expr_8.ns = 0L;
  yyval.rel = __constr_expr_8;
  yyval.rel.day = (yyvsp + 0)->intval;
  }
  goto switch_break;
  case_63:
  {
  __constr_expr_9.year = 0L;
  __constr_expr_9.month = 0L;
  __constr_expr_9.day = 0L;
  __constr_expr_9.hour = 0L;
  __constr_expr_9.minutes = 0L;
  __constr_expr_9.seconds = (long_time_t )0;
  __constr_expr_9.ns = 0L;
  yyval.rel = __constr_expr_9;
  yyval.rel.hour = (yyvsp + -1)->intval;
  }
  goto switch_break;
  case_64:
  {
  __constr_expr_10.year = 0L;
  __constr_expr_10.month = 0L;
  __constr_expr_10.day = 0L;
  __constr_expr_10.hour = 0L;
  __constr_expr_10.minutes = 0L;
  __constr_expr_10.seconds = (long_time_t )0;
  __constr_expr_10.ns = 0L;
  yyval.rel = __constr_expr_10;
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
  }
  goto switch_break;
  case_65:
  {
  __constr_expr_11.year = 0L;
  __constr_expr_11.month = 0L;
  __constr_expr_11.day = 0L;
  __constr_expr_11.hour = 0L;
  __constr_expr_11.minutes = 0L;
  __constr_expr_11.seconds = (long_time_t )0;
  __constr_expr_11.ns = 0L;
  yyval.rel = __constr_expr_11;
  yyval.rel.hour = 1L;
  }
  goto switch_break;
  case_66:
  {
  __constr_expr_12.year = 0L;
  __constr_expr_12.month = 0L;
  __constr_expr_12.day = 0L;
  __constr_expr_12.hour = 0L;
  __constr_expr_12.minutes = 0L;
  __constr_expr_12.seconds = (long_time_t )0;
  __constr_expr_12.ns = 0L;
  yyval.rel = __constr_expr_12;
  yyval.rel.minutes = (yyvsp + -1)->intval;
  }
  goto switch_break;
  case_67:
  {
  __constr_expr_13.year = 0L;
  __constr_expr_13.month = 0L;
  __constr_expr_13.day = 0L;
  __constr_expr_13.hour = 0L;
  __constr_expr_13.minutes = 0L;
  __constr_expr_13.seconds = (long_time_t )0;
  __constr_expr_13.ns = 0L;
  yyval.rel = __constr_expr_13;
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
  }
  goto switch_break;
  case_68:
  {
  __constr_expr_14.year = 0L;
  __constr_expr_14.month = 0L;
  __constr_expr_14.day = 0L;
  __constr_expr_14.hour = 0L;
  __constr_expr_14.minutes = 0L;
  __constr_expr_14.seconds = (long_time_t )0;
  __constr_expr_14.ns = 0L;
  yyval.rel = __constr_expr_14;
  yyval.rel.minutes = 1L;
  }
  goto switch_break;
  case_69:
  {
  __constr_expr_15.year = 0L;
  __constr_expr_15.month = 0L;
  __constr_expr_15.day = 0L;
  __constr_expr_15.hour = 0L;
  __constr_expr_15.minutes = 0L;
  __constr_expr_15.seconds = (long_time_t )0;
  __constr_expr_15.ns = 0L;
  yyval.rel = __constr_expr_15;
  yyval.rel.seconds = (yyvsp + -1)->intval;
  }
  goto switch_break;
  case_70:
  {
  __constr_expr_16.year = 0L;
  __constr_expr_16.month = 0L;
  __constr_expr_16.day = 0L;
  __constr_expr_16.hour = 0L;
  __constr_expr_16.minutes = 0L;
  __constr_expr_16.seconds = (long_time_t )0;
  __constr_expr_16.ns = 0L;
  yyval.rel = __constr_expr_16;
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
  }
  goto switch_break;
  case_71:
  {
  __constr_expr_17.year = 0L;
  __constr_expr_17.month = 0L;
  __constr_expr_17.day = 0L;
  __constr_expr_17.hour = 0L;
  __constr_expr_17.minutes = 0L;
  __constr_expr_17.seconds = (long_time_t )0;
  __constr_expr_17.ns = 0L;
  yyval.rel = __constr_expr_17;
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
  }
  goto switch_break;
  case_72:
  {
  __constr_expr_18.year = 0L;
  __constr_expr_18.month = 0L;
  __constr_expr_18.day = 0L;
  __constr_expr_18.hour = 0L;
  __constr_expr_18.minutes = 0L;
  __constr_expr_18.seconds = (long_time_t )0;
  __constr_expr_18.ns = 0L;
  yyval.rel = __constr_expr_18;
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
  }
  goto switch_break;
  case_73:
  {
  __constr_expr_19.year = 0L;
  __constr_expr_19.month = 0L;
  __constr_expr_19.day = 0L;
  __constr_expr_19.hour = 0L;
  __constr_expr_19.minutes = 0L;
  __constr_expr_19.seconds = (long_time_t )0;
  __constr_expr_19.ns = 0L;
  yyval.rel = __constr_expr_19;
  yyval.rel.seconds = (long_time_t )1;
  }
  goto switch_break;
  case_75:
  {
  __constr_expr_20.year = 0L;
  __constr_expr_20.month = 0L;
  __constr_expr_20.day = 0L;
  __constr_expr_20.hour = 0L;
  __constr_expr_20.minutes = 0L;
  __constr_expr_20.seconds = (long_time_t )0;
  __constr_expr_20.ns = 0L;
  yyval.rel = __constr_expr_20;
  yyval.rel.year = (yyvsp + -1)->textintval.value;
  }
  goto switch_break;
  case_76:
  {
  __constr_expr_21.year = 0L;
  __constr_expr_21.month = 0L;
  __constr_expr_21.day = 0L;
  __constr_expr_21.hour = 0L;
  __constr_expr_21.minutes = 0L;
  __constr_expr_21.seconds = (long_time_t )0;
  __constr_expr_21.ns = 0L;
  yyval.rel = __constr_expr_21;
  yyval.rel.month = (yyvsp + -1)->textintval.value;
  }
  goto switch_break;
  case_77:
  {
  __constr_expr_22.year = 0L;
  __constr_expr_22.month = 0L;
  __constr_expr_22.day = 0L;
  __constr_expr_22.hour = 0L;
  __constr_expr_22.minutes = 0L;
  __constr_expr_22.seconds = (long_time_t )0;
  __constr_expr_22.ns = 0L;
  yyval.rel = __constr_expr_22;
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
  }
  goto switch_break;
  case_78:
  {
  __constr_expr_23.year = 0L;
  __constr_expr_23.month = 0L;
  __constr_expr_23.day = 0L;
  __constr_expr_23.hour = 0L;
  __constr_expr_23.minutes = 0L;
  __constr_expr_23.seconds = (long_time_t )0;
  __constr_expr_23.ns = 0L;
  yyval.rel = __constr_expr_23;
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
  }
  goto switch_break;
  case_79:
  {
  __constr_expr_24.year = 0L;
  __constr_expr_24.month = 0L;
  __constr_expr_24.day = 0L;
  __constr_expr_24.hour = 0L;
  __constr_expr_24.minutes = 0L;
  __constr_expr_24.seconds = (long_time_t )0;
  __constr_expr_24.ns = 0L;
  yyval.rel = __constr_expr_24;
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
  }
  goto switch_break;
  case_80:
  {
  __constr_expr_25.year = 0L;
  __constr_expr_25.month = 0L;
  __constr_expr_25.day = 0L;
  __constr_expr_25.hour = 0L;
  __constr_expr_25.minutes = 0L;
  __constr_expr_25.seconds = (long_time_t )0;
  __constr_expr_25.ns = 0L;
  yyval.rel = __constr_expr_25;
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
  }
  goto switch_break;
  case_81:
  {
  __constr_expr_26.year = 0L;
  __constr_expr_26.month = 0L;
  __constr_expr_26.day = 0L;
  __constr_expr_26.hour = 0L;
  __constr_expr_26.minutes = 0L;
  __constr_expr_26.seconds = (long_time_t )0;
  __constr_expr_26.ns = 0L;
  yyval.rel = __constr_expr_26;
  yyval.rel.day = (yyvsp + 0)->intval;
  }
  goto switch_break;
  case_85:
  {
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
  yyval.timespec.tv_nsec = 0L;
  }
  goto switch_break;
  case_87:
  {
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
  yyval.timespec.tv_nsec = 0L;
  }
  goto switch_break;
  case_88:
  {
  digits_to_date_time(pc, (yyvsp + 0)->textintval);
  }
  goto switch_break;
  case_89:
  {
  digits_to_date_time(pc, (yyvsp + -1)->textintval);
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
  goto switch_break;
  case_90:
  {
  yyval.intval = -1L;
  }
  goto switch_break;
  case_91:
  {
  yyval.intval = (yyvsp + 0)->textintval.value;
  }
  goto switch_break;
  switch_default:
  goto switch_break;
  switch_break: ;
  }
  {
  yyvsp -= yylen;
  yyssp -= yylen;
  yylen = 0;
  yyvsp ++;
  *yyvsp = yyval;
  yyn = (int )yyr1[yyn];
  yystate = (int )((int const )yypgoto[yyn - 28] + (int const )*yyssp);
  }
  if (0 <= yystate) {
    {
    if (yystate <= 112) {
      {
      if ((int const )yycheck[yystate] == (int const )*yyssp) {
        {
        {
        yystate = (int )yytable[yystate];
        }
        }
      } else {
        {
        {
        yystate = (int )yydefgoto[yyn - 28];
        }
        }
      }
      }
    } else {
      {
      {
      yystate = (int )yydefgoto[yyn - 28];
      }
      }
    }
    }
  } else {
    {
    {
    yystate = (int )yydefgoto[yyn - 28];
    }
    }
  }
  goto yynewstate;
  yyerrlab:
  if (! yyerrstatus) {
    {
    {
    yynerrs ++;
    yyerror((parser_control const *)pc, (char const *)"syntax error");
    }
    }
  }
  if (yyerrstatus == 3) {
    {
    if (yychar <= 0) {
      {
      if (yychar == 0) {
        {
        goto yyabortlab;
        }
      }
      }
    } else {
      {
      {
      yydestruct((char const *)"Error: discarding", yytoken, & yylval, pc);
      yychar = -2;
      }
      }
    }
    }
  }
  goto yyerrlab1;
  {
  yyvsp -= yylen;
  yyssp -= yylen;
  yylen = 0;
  yystate = (int )*yyssp;
  }
  goto yyerrlab1;
  yyerrlab1:
  {
  yyerrstatus = 3;
  }
  {
  while (1) {
    while_continue___1: ;
    if (! 1) {
      {
      goto while_break___1;
      }
    }
    {
    yyn = (int )yypact[yystate];
    }
    if (yyn != -93) {
      {
      {
      yyn ++;
      }
      if (0 <= yyn) {
        {
        if (yyn <= 112) {
          {
          if ((int const )yycheck[yyn] == 1) {
            {
            {
            yyn = (int )yytable[yyn];
            }
            if (0 < yyn) {
              {
              goto while_break___1;
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    if ((unsigned long )yyssp == (unsigned long )yyss) {
      {
      goto yyabortlab;
      }
    }
    {
    yydestruct((char const *)"Error: popping", (int )yystos[yystate], yyvsp, pc);
    yyvsp --;
    yyssp --;
    yystate = (int )*yyssp;
    }
  }
  while_break___1: ;
  }
  {
  yyvsp ++;
  *yyvsp = yylval;
  yystate = yyn;
  }
  goto yynewstate;
  yyacceptlab:
  {
  yyresult = 0;
  }
  goto yyreturn;
  yyabortlab:
  {
  yyresult = 1;
  }
  goto yyreturn;
  yyexhaustedlab:
  {
  yyerror((parser_control const *)pc, (char const *)"memory exhausted");
  yyresult = 2;
  }
  yyreturn:
  if (yychar != -2) {
    {
    {
    yydestruct((char const *)"Cleanup: discarding lookahead", yytoken, & yylval,
               pc);
    }
    }
  }
  {
  yyvsp -= yylen;
  yyssp -= yylen;
  }
  {
  while (1) {
    while_continue___2: ;
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
      {
      goto while_break___2;
      }
    }
    {
    yydestruct((char const *)"Cleanup: popping", (int )yystos[*yyssp], yyvsp, pc);
    yyvsp --;
    yyssp --;
    }
  }
  while_break___2: ;
  }
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
    {
    free((void *)yyss);
    }
    }
  }
  return (yyresult);
}
}
static long time_zone_hhmm(parser_control *pc , textint s , long mm )
{
  long n_minutes ;
  long tmp ;
  int tmp___0 ;
  {
  if (s.digits <= 2UL) {
    {
    if (mm < 0L) {
      {
      {
      s.value *= 100L;
      }
      }
    }
    }
  }
  if (mm < 0L) {
    {
    {
    n_minutes = (s.value / 100L) * 60L + s.value % 100L;
    }
    }
  } else {
    {
    if (s.negative) {
      {
      {
      tmp = - mm;
      }
      }
    } else {
      {
      {
      tmp = mm;
      }
      }
    }
    {
    n_minutes = s.value * 60L + tmp;
    }
    }
  }
  {
  tmp___0 = abs((int )n_minutes);
  }
  if (1440 < tmp___0) {
    {
    {
    (pc->zones_seen) ++;
    }
    }
  }
  return (n_minutes);
}
}
static int to_hour(long hours , int meridian )
{
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  {
  {
  if (meridian == 0) {
    {
    goto case_0;
    }
  }
  if (meridian == 1) {
    {
    goto case_1;
    }
  }
  goto switch_default;
  switch_default:
  if (0L <= hours) {
    {
    if (hours < 24L) {
      {
      {
      tmp = hours;
      }
      }
    } else {
      {
      {
      tmp = -1L;
      }
      }
    }
    }
  } else {
    {
    {
    tmp = -1L;
    }
    }
  }
  return ((int )tmp);
  case_0:
  if (0L < hours) {
    {
    if (hours < 12L) {
      {
      {
      tmp___1 = hours;
      }
      }
    } else {
      {
      goto _L;
      }
    }
    }
  } else {
    {
    _L:
    if (hours == 12L) {
      {
      {
      tmp___0 = 0;
      }
      }
    } else {
      {
      {
      tmp___0 = -1;
      }
      }
    }
    {
    tmp___1 = (long )tmp___0;
    }
    }
  }
  return ((int )tmp___1);
  case_1:
  if (0L < hours) {
    {
    if (hours < 12L) {
      {
      {
      tmp___3 = hours + 12L;
      }
      }
    } else {
      {
      goto _L___0;
      }
    }
    }
  } else {
    {
    _L___0:
    if (hours == 12L) {
      {
      {
      tmp___2 = 12;
      }
      }
    } else {
      {
      {
      tmp___2 = -1;
      }
      }
    }
    {
    tmp___3 = (long )tmp___2;
    }
    }
  }
  return ((int )tmp___3);
  switch_break: ;
  }
}
}
static long to_year(textint textyear )
{
  long year___0 ;
  int tmp ;
  {
  {
  year___0 = textyear.value;
  }
  if (year___0 < 0L) {
    {
    {
    year___0 = - year___0;
    }
    }
  } else {
    {
    if (textyear.digits == 2UL) {
      {
      if (year___0 < 69L) {
        {
        {
        tmp = 2000;
        }
        }
      } else {
        {
        {
        tmp = 1900;
        }
        }
      }
      {
      year___0 += (long )tmp;
      }
      }
    }
    }
  }
  return (year___0);
}
}
static table const *lookup_zone(parser_control const *pc , char const *name )
{
  table const *tp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  {
  {
  tp = universal_time_zone_table;
  }
  {
  while (1) {
    while_continue: ;
    if (! tp->name) {
      {
      goto while_break;
      }
    }
    if (0) {
      {
      {
      __s1_len = __builtin_strlen(name);
      __s2_len = __builtin_strlen((char const *)tp->name);
      }
      if (! ((size_t )((void const *)(name + 1)) - (size_t )((void const *)name) == 1UL)) {
        {
        goto _L___0;
        }
      } else {
        {
        if (__s1_len >= 4UL) {
          {
          _L___0:
          if (! ((size_t )((void const *)(tp->name + 1)) - (size_t )((void const *)tp->name) == 1UL)) {
            {
            {
            tmp___5 = 1;
            }
            }
          } else {
            {
            if (__s2_len >= 4UL) {
              {
              {
              tmp___5 = 1;
              }
              }
            } else {
              {
              {
              tmp___5 = 0;
              }
              }
            }
            }
          }
          }
        } else {
          {
          {
          tmp___5 = 0;
          }
          }
        }
        }
      }
      if (tmp___5) {
        {
        {
        tmp___0 = __builtin_strcmp(name, (char const *)tp->name);
        tmp___4 = tmp___0;
        }
        }
      } else {
        {
        {
        tmp___3 = __builtin_strcmp(name, (char const *)tp->name);
        tmp___4 = tmp___3;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___3 = __builtin_strcmp(name, (char const *)tp->name);
      tmp___4 = tmp___3;
      }
      }
    }
    if (tmp___4 == 0) {
      {
      return (tp);
      }
    }
    {
    tp ++;
    }
  }
  while_break: ;
  }
  {
  tp = (table const *)(pc->local_time_zone_table);
  }
  {
  while (1) {
    while_continue___0: ;
    if (! tp->name) {
      {
      goto while_break___0;
      }
    }
    if (0) {
      {
      {
      __s1_len___0 = __builtin_strlen(name);
      __s2_len___0 = __builtin_strlen((char const *)tp->name);
      }
      if (! ((size_t )((void const *)(name + 1)) - (size_t )((void const *)name) == 1UL)) {
        {
        goto _L___2;
        }
      } else {
        {
        if (__s1_len___0 >= 4UL) {
          {
          _L___2:
          if (! ((size_t )((void const *)(tp->name + 1)) - (size_t )((void const *)tp->name) == 1UL)) {
            {
            {
            tmp___12 = 1;
            }
            }
          } else {
            {
            if (__s2_len___0 >= 4UL) {
              {
              {
              tmp___12 = 1;
              }
              }
            } else {
              {
              {
              tmp___12 = 0;
              }
              }
            }
            }
          }
          }
        } else {
          {
          {
          tmp___12 = 0;
          }
          }
        }
        }
      }
      if (tmp___12) {
        {
        {
        tmp___7 = __builtin_strcmp(name, (char const *)tp->name);
        tmp___11 = tmp___7;
        }
        }
      } else {
        {
        {
        tmp___10 = __builtin_strcmp(name, (char const *)tp->name);
        tmp___11 = tmp___10;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___10 = __builtin_strcmp(name, (char const *)tp->name);
      tmp___11 = tmp___10;
      }
      }
    }
    if (tmp___11 == 0) {
      {
      return (tp);
      }
    }
    {
    tp ++;
    }
  }
  while_break___0: ;
  }
  {
  tp = time_zone_table;
  }
  {
  while (1) {
    while_continue___1: ;
    if (! tp->name) {
      {
      goto while_break___1;
      }
    }
    if (0) {
      {
      {
      __s1_len___1 = __builtin_strlen(name);
      __s2_len___1 = __builtin_strlen((char const *)tp->name);
      }
      if (! ((size_t )((void const *)(name + 1)) - (size_t )((void const *)name) == 1UL)) {
        {
        goto _L___4;
        }
      } else {
        {
        if (__s1_len___1 >= 4UL) {
          {
          _L___4:
          if (! ((size_t )((void const *)(tp->name + 1)) - (size_t )((void const *)tp->name) == 1UL)) {
            {
            {
            tmp___19 = 1;
            }
            }
          } else {
            {
            if (__s2_len___1 >= 4UL) {
              {
              {
              tmp___19 = 1;
              }
              }
            } else {
              {
              {
              tmp___19 = 0;
              }
              }
            }
            }
          }
          }
        } else {
          {
          {
          tmp___19 = 0;
          }
          }
        }
        }
      }
      if (tmp___19) {
        {
        {
        tmp___14 = __builtin_strcmp(name, (char const *)tp->name);
        tmp___18 = tmp___14;
        }
        }
      } else {
        {
        {
        tmp___17 = __builtin_strcmp(name, (char const *)tp->name);
        tmp___18 = tmp___17;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___17 = __builtin_strcmp(name, (char const *)tp->name);
      tmp___18 = tmp___17;
      }
      }
    }
    if (tmp___18 == 0) {
      {
      return (tp);
      }
    }
    {
    tp ++;
    }
  }
  while_break___1: ;
  }
  return ((table const *)((void *)0));
}
}
static table const *lookup_word(parser_control const *pc , char *word )
{
  char *p ;
  char *q ;
  size_t wordlen ;
  table const *tp ;
  _Bool period_found ;
  _Bool abbrev ;
  unsigned char ch ;
  int __c ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___37 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___51 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  char tmp___57 ;
  {
  {
  p = word;
  }
  {
  while (1) {
    while_continue: ;
    if (! *p) {
      {
      goto while_break;
      }
    }
    {
    ch = (unsigned char )*p;
    __c = (int )ch;
    }
    if (__c >= 97) {
      {
      if (__c <= 122) {
        {
        {
        tmp = (__c - 97) + 65;
        }
        }
      } else {
        {
        {
        tmp = __c;
        }
        }
      }
      }
    } else {
      {
      {
      tmp = __c;
      }
      }
    }
    {
    *p = (char )tmp;
    p ++;
    }
  }
  while_break: ;
  }
  {
  tp = meridian_table;
  }
  {
  while (1) {
    while_continue___0: ;
    if (! tp->name) {
      {
      goto while_break___0;
      }
    }
    if (0) {
      {
      {
      __s1_len = __builtin_strlen((char const *)word);
      __s2_len = __builtin_strlen((char const *)tp->name);
      }
      if (! ((size_t )((void const *)(word + 1)) - (size_t )((void const *)word) == 1UL)) {
        {
        goto _L___0;
        }
      } else {
        {
        if (__s1_len >= 4UL) {
          {
          _L___0:
          if (! ((size_t )((void const *)(tp->name + 1)) - (size_t )((void const *)tp->name) == 1UL)) {
            {
            {
            tmp___6 = 1;
            }
            }
          } else {
            {
            if (__s2_len >= 4UL) {
              {
              {
              tmp___6 = 1;
              }
              }
            } else {
              {
              {
              tmp___6 = 0;
              }
              }
            }
            }
          }
          }
        } else {
          {
          {
          tmp___6 = 0;
          }
          }
        }
        }
      }
      if (tmp___6) {
        {
        {
        tmp___1 = __builtin_strcmp((char const *)word, (char const *)tp->name);
        tmp___5 = tmp___1;
        }
        }
      } else {
        {
        {
        tmp___4 = __builtin_strcmp((char const *)word, (char const *)tp->name);
        tmp___5 = tmp___4;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___4 = __builtin_strcmp((char const *)word, (char const *)tp->name);
      tmp___5 = tmp___4;
      }
      }
    }
    if (tmp___5 == 0) {
      {
      return (tp);
      }
    }
    {
    tp ++;
    }
  }
  while_break___0: ;
  }
  {
  wordlen = strlen((char const *)word);
  }
  if (wordlen == 3UL) {
    {
    {
    tmp___7 = 1;
    }
    }
  } else {
    {
    if (wordlen == 4UL) {
      {
      if ((int )*(word + 3) == 46) {
        {
        {
        tmp___7 = 1;
        }
        }
      } else {
        {
        {
        tmp___7 = 0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___7 = 0;
      }
      }
    }
    }
  }
  {
  abbrev = (_Bool )tmp___7;
  tp = month_and_day_table;
  }
  {
  while (1) {
    while_continue___1: ;
    if (! tp->name) {
      {
      goto while_break___1;
      }
    }
    if (abbrev) {
      {
      if (0) {
        {
        if (0) {
          {
          {
          __s1_len___0 = __builtin_strlen((char const *)word);
          __s2_len___0 = __builtin_strlen((char const *)tp->name);
          }
          if (! ((size_t )((void const *)(word + 1)) - (size_t )((void const *)word) == 1UL)) {
            {
            goto _L___2;
            }
          } else {
            {
            if (__s1_len___0 >= 4UL) {
              {
              _L___2:
              if (! ((size_t )((void const *)(tp->name + 1)) - (size_t )((void const *)tp->name) == 1UL)) {
                {
                {
                tmp___16 = 1;
                }
                }
              } else {
                {
                if (__s2_len___0 >= 4UL) {
                  {
                  {
                  tmp___16 = 1;
                  }
                  }
                } else {
                  {
                  {
                  tmp___16 = 0;
                  }
                  }
                }
                }
              }
              }
            } else {
              {
              {
              tmp___16 = 0;
              }
              }
            }
            }
          }
          if (tmp___16) {
            {
            {
            tmp___11 = __builtin_strcmp((char const *)word, (char const *)tp->name);
            tmp___15 = tmp___11;
            }
            }
          } else {
            {
            {
            tmp___14 = __builtin_strcmp((char const *)word, (char const *)tp->name);
            tmp___15 = tmp___14;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___14 = __builtin_strcmp((char const *)word, (char const *)tp->name);
          tmp___15 = tmp___14;
          }
          }
        }
        {
        tmp___18 = tmp___15;
        }
        }
      } else {
        {
        {
        tmp___17 = strncmp((char const *)word, (char const *)tp->name, (size_t )3);
        tmp___18 = tmp___17;
        }
        }
      }
      {
      tmp___28 = tmp___18;
      }
      }
    } else {
      {
      if (0) {
        {
        {
        __s1_len___1 = __builtin_strlen((char const *)word);
        __s2_len___1 = __builtin_strlen((char const *)tp->name);
        }
        if (! ((size_t )((void const *)(word + 1)) - (size_t )((void const *)word) == 1UL)) {
          {
          goto _L___4;
          }
        } else {
          {
          if (__s1_len___1 >= 4UL) {
            {
            _L___4:
            if (! ((size_t )((void const *)(tp->name + 1)) - (size_t )((void const *)tp->name) == 1UL)) {
              {
              {
              tmp___27 = 1;
              }
              }
            } else {
              {
              if (__s2_len___1 >= 4UL) {
                {
                {
                tmp___27 = 1;
                }
                }
              } else {
                {
                {
                tmp___27 = 0;
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            tmp___27 = 0;
            }
            }
          }
          }
        }
        if (tmp___27) {
          {
          {
          tmp___22 = __builtin_strcmp((char const *)word, (char const *)tp->name);
          tmp___26 = tmp___22;
          }
          }
        } else {
          {
          {
          tmp___25 = __builtin_strcmp((char const *)word, (char const *)tp->name);
          tmp___26 = tmp___25;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___25 = __builtin_strcmp((char const *)word, (char const *)tp->name);
        tmp___26 = tmp___25;
        }
        }
      }
      {
      tmp___28 = tmp___26;
      }
      }
    }
    if (tmp___28 == 0) {
      {
      return (tp);
      }
    }
    {
    tp ++;
    }
  }
  while_break___1: ;
  }
  {
  tp = lookup_zone(pc, (char const *)word);
  }
  if (tp) {
    {
    return (tp);
    }
  }
  if (0) {
    {
    {
    __s1_len___2 = __builtin_strlen((char const *)word);
    __s2_len___2 = __builtin_strlen((char const *)dst_table[0].name);
    }
    if (! ((size_t )((void const *)(word + 1)) - (size_t )((void const *)word) == 1UL)) {
      {
      goto _L___6;
      }
    } else {
      {
      if (__s1_len___2 >= 4UL) {
        {
        _L___6:
        if (! ((size_t )((void const *)(dst_table[0].name + 1)) - (size_t )((void const *)dst_table[0].name) == 1UL)) {
          {
          {
          tmp___35 = 1;
          }
          }
        } else {
          {
          if (__s2_len___2 >= 4UL) {
            {
            {
            tmp___35 = 1;
            }
            }
          } else {
            {
            {
            tmp___35 = 0;
            }
            }
          }
          }
        }
        }
      } else {
        {
        {
        tmp___35 = 0;
        }
        }
      }
      }
    }
    if (tmp___35) {
      {
      {
      tmp___30 = __builtin_strcmp((char const *)word, (char const *)dst_table[0].name);
      tmp___34 = tmp___30;
      }
      }
    } else {
      {
      {
      tmp___33 = __builtin_strcmp((char const *)word, (char const *)dst_table[0].name);
      tmp___34 = tmp___33;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___33 = __builtin_strcmp((char const *)word, (char const *)dst_table[0].name);
    tmp___34 = tmp___33;
    }
    }
  }
  if (tmp___34 == 0) {
    {
    return (dst_table);
    }
  }
  {
  tp = time_units_table;
  }
  {
  while (1) {
    while_continue___2: ;
    if (! tp->name) {
      {
      goto while_break___2;
      }
    }
    if (0) {
      {
      {
      __s1_len___3 = __builtin_strlen((char const *)word);
      __s2_len___3 = __builtin_strlen((char const *)tp->name);
      }
      if (! ((size_t )((void const *)(word + 1)) - (size_t )((void const *)word) == 1UL)) {
        {
        goto _L___8;
        }
      } else {
        {
        if (__s1_len___3 >= 4UL) {
          {
          _L___8:
          if (! ((size_t )((void const *)(tp->name + 1)) - (size_t )((void const *)tp->name) == 1UL)) {
            {
            {
            tmp___42 = 1;
            }
            }
          } else {
            {
            if (__s2_len___3 >= 4UL) {
              {
              {
              tmp___42 = 1;
              }
              }
            } else {
              {
              {
              tmp___42 = 0;
              }
              }
            }
            }
          }
          }
        } else {
          {
          {
          tmp___42 = 0;
          }
          }
        }
        }
      }
      if (tmp___42) {
        {
        {
        tmp___37 = __builtin_strcmp((char const *)word, (char const *)tp->name);
        tmp___41 = tmp___37;
        }
        }
      } else {
        {
        {
        tmp___40 = __builtin_strcmp((char const *)word, (char const *)tp->name);
        tmp___41 = tmp___40;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___40 = __builtin_strcmp((char const *)word, (char const *)tp->name);
      tmp___41 = tmp___40;
      }
      }
    }
    if (tmp___41 == 0) {
      {
      return (tp);
      }
    }
    {
    tp ++;
    }
  }
  while_break___2: ;
  }
  if ((int )*(word + (wordlen - 1UL)) == 83) {
    {
    {
    *(word + (wordlen - 1UL)) = (char )'\000';
    tp = time_units_table;
    }
    {
    while (1) {
      while_continue___3: ;
      if (! tp->name) {
        {
        goto while_break___3;
        }
      }
      if (0) {
        {
        {
        __s1_len___4 = __builtin_strlen((char const *)word);
        __s2_len___4 = __builtin_strlen((char const *)tp->name);
        }
        if (! ((size_t )((void const *)(word + 1)) - (size_t )((void const *)word) == 1UL)) {
          {
          goto _L___10;
          }
        } else {
          {
          if (__s1_len___4 >= 4UL) {
            {
            _L___10:
            if (! ((size_t )((void const *)(tp->name + 1)) - (size_t )((void const *)tp->name) == 1UL)) {
              {
              {
              tmp___49 = 1;
              }
              }
            } else {
              {
              if (__s2_len___4 >= 4UL) {
                {
                {
                tmp___49 = 1;
                }
                }
              } else {
                {
                {
                tmp___49 = 0;
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            tmp___49 = 0;
            }
            }
          }
          }
        }
        if (tmp___49) {
          {
          {
          tmp___44 = __builtin_strcmp((char const *)word, (char const *)tp->name);
          tmp___48 = tmp___44;
          }
          }
        } else {
          {
          {
          tmp___47 = __builtin_strcmp((char const *)word, (char const *)tp->name);
          tmp___48 = tmp___47;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___47 = __builtin_strcmp((char const *)word, (char const *)tp->name);
        tmp___48 = tmp___47;
        }
        }
      }
      if (tmp___48 == 0) {
        {
        return (tp);
        }
      }
      {
      tp ++;
      }
    }
    while_break___3: ;
    }
    {
    *(word + (wordlen - 1UL)) = (char )'S';
    }
    }
  }
  {
  tp = relative_time_table;
  }
  {
  while (1) {
    while_continue___4: ;
    if (! tp->name) {
      {
      goto while_break___4;
      }
    }
    if (0) {
      {
      {
      __s1_len___5 = __builtin_strlen((char const *)word);
      __s2_len___5 = __builtin_strlen((char const *)tp->name);
      }
      if (! ((size_t )((void const *)(word + 1)) - (size_t )((void const *)word) == 1UL)) {
        {
        goto _L___12;
        }
      } else {
        {
        if (__s1_len___5 >= 4UL) {
          {
          _L___12:
          if (! ((size_t )((void const *)(tp->name + 1)) - (size_t )((void const *)tp->name) == 1UL)) {
            {
            {
            tmp___56 = 1;
            }
            }
          } else {
            {
            if (__s2_len___5 >= 4UL) {
              {
              {
              tmp___56 = 1;
              }
              }
            } else {
              {
              {
              tmp___56 = 0;
              }
              }
            }
            }
          }
          }
        } else {
          {
          {
          tmp___56 = 0;
          }
          }
        }
        }
      }
      if (tmp___56) {
        {
        {
        tmp___51 = __builtin_strcmp((char const *)word, (char const *)tp->name);
        tmp___55 = tmp___51;
        }
        }
      } else {
        {
        {
        tmp___54 = __builtin_strcmp((char const *)word, (char const *)tp->name);
        tmp___55 = tmp___54;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___54 = __builtin_strcmp((char const *)word, (char const *)tp->name);
      tmp___55 = tmp___54;
      }
      }
    }
    if (tmp___55 == 0) {
      {
      return (tp);
      }
    }
    {
    tp ++;
    }
  }
  while_break___4: ;
  }
  if (wordlen == 1UL) {
    {
    {
    tp = military_table;
    }
    {
    while (1) {
      while_continue___5: ;
      if (! tp->name) {
        {
        goto while_break___5;
        }
      }
      if ((int )*(word + 0) == (int )*(tp->name + 0)) {
        {
        return (tp);
        }
      }
      {
      tp ++;
      }
    }
    while_break___5: ;
    }
    }
  }
  {
  period_found = (_Bool)0;
  q = word;
  p = q;
  }
  {
  while (1) {
    while_continue___6: ;
    if (! 1) {
      {
      goto while_break___6;
      }
    }
    {
    tmp___57 = *q;
    *p = tmp___57;
    }
    if (! tmp___57) {
      {
      goto while_break___6;
      }
    }
    if ((int )*q == 46) {
      {
      {
      period_found = (_Bool)1;
      }
      }
    } else {
      {
      {
      p ++;
      }
      }
    }
    {
    q ++;
    }
  }
  while_break___6: ;
  }
  if (period_found) {
    {
    {
    tp = lookup_zone(pc, (char const *)word);
    }
    if (tp) {
      {
      return (tp);
      }
    }
    }
  }
  return ((table const *)((void *)0));
}
}
static int yylex(union YYSTYPE *lvalp , parser_control *pc )
{
  unsigned char c ;
  size_t count ;
  int __c ;
  int tmp ;
  char const *p ;
  int sign ;
  unsigned long value ;
  int __c___0 ;
  int tmp___0 ;
  unsigned long value1 ;
  time_t s ;
  int ns ;
  int digits ;
  unsigned long value1___0 ;
  char const *tmp___1 ;
  char const *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char buff[20] ;
  char *p___0 ;
  table const *tp ;
  char *tmp___5 ;
  int __c___1 ;
  int tmp___6 ;
  int __c___2 ;
  int tmp___7 ;
  char const *tmp___8 ;
  char const *tmp___9 ;
  {
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      {
      c = (unsigned char )*(pc->input);
      __c = (int )c;
      }
      if (__c == 32) {
        {
        {
        tmp = 1;
        }
        }
      } else {
        {
        if (__c == 9) {
          {
          {
          tmp = 1;
          }
          }
        } else {
          {
          if (__c == 10) {
            {
            {
            tmp = 1;
            }
            }
          } else {
            {
            if (__c == 11) {
              {
              {
              tmp = 1;
              }
              }
            } else {
              {
              if (__c == 12) {
                {
                {
                tmp = 1;
                }
                }
              } else {
                {
                if (__c == 13) {
                  {
                  {
                  tmp = 1;
                  }
                  }
                } else {
                  {
                  {
                  tmp = 0;
                  }
                  }
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      if (! tmp) {
        {
        goto while_break___0;
        }
      }
      {
      (pc->input) ++;
      }
    }
    while_break___0: ;
    }
    if ((unsigned int )c - 48U <= 9U) {
      {
      goto _L___2;
      }
    } else {
      {
      if ((int )c == 45) {
        {
        goto _L___2;
        }
      } else {
        {
        if ((int )c == 43) {
          {
          _L___2:
          if ((int )c == 45) {
            {
            goto _L;
            }
          } else {
            {
            if ((int )c == 43) {
              {
              _L:
              if ((int )c == 45) {
                {
                {
                sign = -1;
                }
                }
              } else {
                {
                {
                sign = 1;
                }
                }
              }
              {
              while (1) {
                while_continue___1: ;
                if (! 1) {
                  {
                  goto while_break___1;
                  }
                }
                {
                (pc->input) ++;
                c = (unsigned char )*(pc->input);
                __c___0 = (int )c;
                }
                if (__c___0 == 32) {
                  {
                  {
                  tmp___0 = 1;
                  }
                  }
                } else {
                  {
                  if (__c___0 == 9) {
                    {
                    {
                    tmp___0 = 1;
                    }
                    }
                  } else {
                    {
                    if (__c___0 == 10) {
                      {
                      {
                      tmp___0 = 1;
                      }
                      }
                    } else {
                      {
                      if (__c___0 == 11) {
                        {
                        {
                        tmp___0 = 1;
                        }
                        }
                      } else {
                        {
                        if (__c___0 == 12) {
                          {
                          {
                          tmp___0 = 1;
                          }
                          }
                        } else {
                          {
                          if (__c___0 == 13) {
                            {
                            {
                            tmp___0 = 1;
                            }
                            }
                          } else {
                            {
                            {
                            tmp___0 = 0;
                            }
                            }
                          }
                          }
                        }
                        }
                      }
                      }
                    }
                    }
                  }
                  }
                }
                if (! tmp___0) {
                  {
                  goto while_break___1;
                  }
                }
                goto while_continue___1;
              }
              while_break___1: ;
              }
              if (! ((unsigned int )c - 48U <= 9U)) {
                {
                goto __Cont;
                }
              }
              }
            } else {
              {
              {
              sign = 0;
              }
              }
            }
            }
          }
          {
          p = pc->input;
          value = 0UL;
          }
          {
          while (1) {
            while_continue___2: ;
            if (! 1) {
              {
              goto while_break___2;
              }
            }
            {
            value1 = value + (unsigned long )((int )c - 48);
            }
            if (value1 < value) {
              {
              return ('?');
              }
            }
            {
            value = value1;
            p ++;
            c = (unsigned char )*p;
            }
            if (! ((unsigned int )c - 48U <= 9U)) {
              {
              goto while_break___2;
              }
            }
            if (1844674407370955161UL < value) {
              {
              return ('?');
              }
            }
            {
            value *= 10UL;
            }
          }
          while_break___2: ;
          }
          if ((int )c == 46) {
            {
            goto _L___1;
            }
          } else {
            {
            if ((int )c == 44) {
              {
              _L___1:
              if ((unsigned int )*(p + 1) - 48U <= 9U) {
                {
                if (sign < 0) {
                  {
                  {
                  s = (time_t )(- value);
                  }
                  if (0L < s) {
                    {
                    return ('?');
                    }
                  }
                  {
                  value1___0 = (unsigned long )(- s);
                  }
                  }
                } else {
                  {
                  {
                  s = (time_t )value;
                  }
                  if (s < 0L) {
                    {
                    return ('?');
                    }
                  }
                  {
                  value1___0 = (unsigned long )s;
                  }
                  }
                }
                if (value != value1___0) {
                  {
                  return ('?');
                  }
                }
                {
                p ++;
                tmp___1 = p;
                p ++;
                ns = (int )((int const )*tmp___1 - 48);
                digits = 2;
                }
                {
                while (1) {
                  while_continue___3: ;
                  if (! (digits <= 9)) {
                    {
                    goto while_break___3;
                    }
                  }
                  {
                  ns *= 10;
                  }
                  if ((unsigned int )*p - 48U <= 9U) {
                    {
                    {
                    tmp___2 = p;
                    p ++;
                    ns += (int )((int const )*tmp___2 - 48);
                    }
                    }
                  }
                  {
                  digits ++;
                  }
                }
                while_break___3: ;
                }
                if (sign < 0) {
                  {
                  {
                  while (1) {
                    while_continue___4: ;
                    if (! ((unsigned int )*p - 48U <= 9U)) {
                      {
                      goto while_break___4;
                      }
                    }
                    if ((int const )*p != 48) {
                      {
                      {
                      ns ++;
                      }
                      goto while_break___4;
                      }
                    }
                    {
                    p ++;
                    }
                  }
                  while_break___4: ;
                  }
                  }
                }
                {
                while (1) {
                  while_continue___5: ;
                  if (! ((unsigned int )*p - 48U <= 9U)) {
                    {
                    goto while_break___5;
                    }
                  }
                  {
                  p ++;
                  }
                }
                while_break___5: ;
                }
                if (sign < 0) {
                  {
                  if (ns) {
                    {
                    {
                    s --;
                    }
                    if (! (s < 0L)) {
                      {
                      return ('?');
                      }
                    }
                    {
                    ns = 1000000000 - ns;
                    }
                    }
                  }
                  }
                }
                {
                lvalp->timespec.tv_sec = s;
                lvalp->timespec.tv_nsec = (long )ns;
                pc->input = p;
                }
                if (sign) {
                  {
                  {
                  tmp___3 = 276;
                  }
                  }
                } else {
                  {
                  {
                  tmp___3 = 277;
                  }
                  }
                }
                return (tmp___3);
                }
              } else {
                {
                goto _L___0;
                }
              }
              }
            } else {
              {
              _L___0:
              {
              lvalp->textintval.negative = (_Bool )(sign < 0);
              }
              if (sign < 0) {
                {
                {
                lvalp->textintval.value = (long )(- value);
                }
                if (0L < lvalp->textintval.value) {
                  {
                  return ('?');
                  }
                }
                }
              } else {
                {
                {
                lvalp->textintval.value = (long )value;
                }
                if (lvalp->textintval.value < 0L) {
                  {
                  return ('?');
                  }
                }
                }
              }
              {
              lvalp->textintval.digits = (size_t )(p - pc->input);
              pc->input = p;
              }
              if (sign) {
                {
                {
                tmp___4 = 274;
                }
                }
              } else {
                {
                {
                tmp___4 = 275;
                }
                }
              }
              return (tmp___4);
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    {
    __c___2 = (int )c;
    }
    if ((__c___2 & -33) >= 65) {
      {
      if ((__c___2 & -33) <= 90) {
        {
        {
        tmp___7 = 1;
        }
        }
      } else {
        {
        {
        tmp___7 = 0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___7 = 0;
      }
      }
    }
    if (tmp___7) {
      {
      {
      p___0 = buff;
      }
      {
      while (1) {
        while_continue___6: ;
        if (! 1) {
          {
          goto while_break___6;
          }
        }
        if ((unsigned long )(p___0 - buff) < sizeof(buff) - 1UL) {
          {
          {
          tmp___5 = p___0;
          p___0 ++;
          *tmp___5 = (char )c;
          }
          }
        }
        {
        (pc->input) ++;
        c = (unsigned char )*(pc->input);
        __c___1 = (int )c;
        }
        if ((__c___1 & -33) >= 65) {
          {
          if ((__c___1 & -33) <= 90) {
            {
            {
            tmp___6 = 1;
            }
            }
          } else {
            {
            {
            tmp___6 = 0;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___6 = 0;
          }
          }
        }
        if (! tmp___6) {
          {
          if (! ((int )c == 46)) {
            {
            goto while_break___6;
            }
          }
          }
        }
      }
      while_break___6: ;
      }
      {
      *p___0 = (char )'\000';
      tp = lookup_word((parser_control const *)pc, buff);
      }
      if (! tp) {
        {
        return ('?');
        }
      }
      {
      lvalp->intval = (long )tp->value;
      }
      return ((int )tp->type);
      }
    }
    if ((int )c != 40) {
      {
      {
      tmp___8 = pc->input;
      (pc->input) ++;
      }
      return ((int )*tmp___8);
      }
    }
    {
    count = (size_t )0;
    }
    {
    while (1) {
      while_continue___7: ;
      if (! 1) {
        {
        goto while_break___7;
        }
      }
      {
      tmp___9 = pc->input;
      (pc->input) ++;
      c = (unsigned char )*tmp___9;
      }
      if ((int )c == 0) {
        {
        return ((int )c);
        }
      }
      if ((int )c == 40) {
        {
        {
        count ++;
        }
        }
      } else {
        {
        if ((int )c == 41) {
          {
          {
          count --;
          }
          }
        }
        }
      }
      if (! (count != 0UL)) {
        {
        goto while_break___7;
        }
      }
    }
    while_break___7: ;
    }
    __Cont:
    {
    }
  }
  while_break: ;
  }
  return (0);
}
}
static int yyerror(parser_control const *pc __attribute__((__unused__)) , char const *s __attribute__((__unused__)) )
{
  {
  return (0);
}
}
static _Bool mktime_ok(struct tm const *tm0 , struct tm const *tm1 , time_t t )
{
  struct tm *tmp ;
  {
  if (t == -1L) {
    {
    {
    tmp = localtime((time_t const *)(& t));
    tm1 = (struct tm const *)tmp;
    }
    if (! tm1) {
      {
      return ((_Bool)0);
      }
    }
    }
  }
  return ((_Bool )(! ((((((tm0->tm_sec ^ tm1->tm_sec) | (tm0->tm_min ^ tm1->tm_min)) | (tm0->tm_hour ^ tm1->tm_hour)) | (tm0->tm_mday ^ tm1->tm_mday)) | (tm0->tm_mon ^ tm1->tm_mon)) | (tm0->tm_year ^ tm1->tm_year))));
}
}
static char *get_tz(char *tzbuf )
{
  char *tz ;
  char *tmp ;
  size_t tzsize ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  {
  {
  tmp = getenv((char const *)"TZ");
  tz = tmp;
  }
  if (tz) {
    {
    {
    tmp___0 = strlen((char const *)tz);
    tzsize = tmp___0 + 1UL;
    }
    if (tzsize <= 100UL) {
      {
      {
      tmp___1 = memcpy((void *)((void * __restrict )tzbuf), (void const *)((void const * __restrict )tz),
                       tzsize);
      tz = (char *)tmp___1;
      }
      }
    } else {
      {
      {
      tmp___2 = xmemdup((void const *)tz, tzsize);
      tz = (char *)tmp___2;
      }
      }
    }
    }
  }
  return (tz);
}
}
_Bool parse_datetime(struct timespec *result , char const *p , struct timespec const *now )
{
  time_t Start ;
  long Start_ns ;
  struct tm const *tmp ;
  struct tm tm ;
  struct tm tm0 ;
  parser_control pc ;
  struct timespec gettime_buffer ;
  unsigned char c ;
  _Bool tz_was_altered ;
  char *tz0 ;
  char tz0buf[100] ;
  _Bool ok ;
  struct tm *tmp___0 ;
  int __c ;
  int tmp___1 ;
  char const *tzbase ;
  size_t tzsize ;
  char const *s ;
  char *z ;
  char *tz1 ;
  char tz1buf[100] ;
  _Bool large_tz ;
  _Bool setenv_ok ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  relative_time __constr_expr_0 ;
  int quarter ;
  time_t probe ;
  struct tm const *probe_tm ;
  struct tm *tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  long tmp___27 ;
  long time_zone ;
  long abs_time_zone ;
  long tmp___28 ;
  long abs_time_zone_hour ;
  int abs_time_zone_min ;
  char tz1buf___0[sizeof("XXX+0:00") + (sizeof(pc.time_zone) * 8UL) / 3UL] ;
  int tmp___29 ;
  _Bool tmp___30 ;
  _Bool tmp___31 ;
  int tmp___32 ;
  int year___0 ;
  int month ;
  int day ;
  long delta ;
  time_t t1 ;
  long sum_ns ;
  long normalized_ns ;
  time_t t0 ;
  long d1 ;
  time_t t1___0 ;
  long d2 ;
  time_t t2 ;
  long_time_t d3 ;
  long_time_t t3 ;
  long d4 ;
  long_time_t t4 ;
  time_t t5 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  {
  {
  tz_was_altered = (_Bool)0;
  tz0 = (char *)((void *)0);
  ok = (_Bool)1;
  }
  if (! now) {
    {
    {
    gettime(& gettime_buffer);
    now = (struct timespec const *)(& gettime_buffer);
    }
    }
  }
  {
  Start = (time_t )now->tv_sec;
  Start_ns = (long )now->tv_nsec;
  tmp___0 = localtime((time_t const *)(& now->tv_sec));
  tmp = (struct tm const *)tmp___0;
  }
  if (! tmp) {
    {
    return ((_Bool)0);
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    c = (unsigned char )*p;
    __c = (int )c;
    }
    if (__c == 32) {
      {
      {
      tmp___1 = 1;
      }
      }
    } else {
      {
      if (__c == 9) {
        {
        {
        tmp___1 = 1;
        }
        }
      } else {
        {
        if (__c == 10) {
          {
          {
          tmp___1 = 1;
          }
          }
        } else {
          {
          if (__c == 11) {
            {
            {
            tmp___1 = 1;
            }
            }
          } else {
            {
            if (__c == 12) {
              {
              {
              tmp___1 = 1;
              }
              }
            } else {
              {
              if (__c == 13) {
                {
                {
                tmp___1 = 1;
                }
                }
              } else {
                {
                {
                tmp___1 = 0;
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    if (! tmp___1) {
      {
      goto while_break;
      }
    }
    {
    p ++;
    }
  }
  while_break: ;
  }
  if (0) {
    {
    if (0) {
      {
      {
      __s1_len = __builtin_strlen(p);
      __s2_len = __builtin_strlen((char const *)"TZ=\"");
      }
      if (! ((size_t )((void const *)(p + 1)) - (size_t )((void const *)p) == 1UL)) {
        {
        goto _L___0;
        }
      } else {
        {
        if (__s1_len >= 4UL) {
          {
          _L___0:
          if (! ((size_t )((void const *)("TZ=\"" + 1)) - (size_t )((void const *)"TZ=\"") == 1UL)) {
            {
            {
            tmp___13 = 1;
            }
            }
          } else {
            {
            if (__s2_len >= 4UL) {
              {
              {
              tmp___13 = 1;
              }
              }
            } else {
              {
              {
              tmp___13 = 0;
              }
              }
            }
            }
          }
          }
        } else {
          {
          {
          tmp___13 = 0;
          }
          }
        }
        }
      }
      if (tmp___13) {
        {
        {
        tmp___8 = __builtin_strcmp(p, (char const *)"TZ=\"");
        tmp___12 = tmp___8;
        }
        }
      } else {
        {
        {
        tmp___11 = __builtin_strcmp(p, (char const *)"TZ=\"");
        tmp___12 = tmp___11;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___11 = __builtin_strcmp(p, (char const *)"TZ=\"");
      tmp___12 = tmp___11;
      }
      }
    }
    {
    tmp___15 = tmp___12;
    }
    }
  } else {
    {
    {
    tmp___14 = strncmp(p, (char const *)"TZ=\"", (size_t )4);
    tmp___15 = tmp___14;
    }
    }
  }
  if (tmp___15 == 0) {
    {
    {
    tzbase = p + 4;
    tzsize = (size_t )1;
    s = tzbase;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! *s) {
        {
        goto while_break___0;
        }
      }
      if ((int const )*s == 92) {
        {
        {
        s ++;
        }
        if (! ((int const )*s == 92)) {
          {
          if (! ((int const )*s == 34)) {
            {
            goto while_break___0;
            }
          }
          }
        }
        }
      } else {
        {
        if ((int const )*s == 34) {
          {
          {
          large_tz = (_Bool )(100UL < tzsize);
          free((void *)tz0);
          tz0 = get_tz(tz0buf);
          }
          if (large_tz) {
            {
            {
            tmp___2 = xmalloc(tzsize);
            tz1 = (char *)tmp___2;
            }
            }
          } else {
            {
            {
            tz1 = tz1buf;
            }
            }
          }
          {
          z = tz1;
          s = tzbase;
          }
          {
          while (1) {
            while_continue___1: ;
            if (! ((int const )*s != 34)) {
              {
              goto while_break___1;
              }
            }
            {
            tmp___3 = z;
            z ++;
            s += (int const )*s == 92;
            *tmp___3 = (char )*s;
            s ++;
            }
          }
          while_break___1: ;
          }
          {
          *z = (char )'\000';
          tmp___4 = setenv((char const *)"TZ", (char const *)tz1, 1);
          setenv_ok = (_Bool )(tmp___4 == 0);
          }
          if (large_tz) {
            {
            {
            free((void *)tz1);
            }
            }
          }
          if (! setenv_ok) {
            {
            goto fail;
            }
          }
          {
          tz_was_altered = (_Bool)1;
          p = s + 1;
          }
          }
        }
        }
      }
      {
      s ++;
      tzsize ++;
      }
    }
    while_break___0: ;
    }
    }
  }
  if ((int const )*p == 0) {
    {
    {
    p = (char const *)"0";
    }
    }
  }
  {
  pc.input = p;
  pc.year.value = (long )tmp->tm_year;
  pc.year.value += 1900L;
  pc.year.digits = (size_t )0;
  pc.month = (long )(tmp->tm_mon + 1);
  pc.day = (long )tmp->tm_mday;
  pc.hour = (long )tmp->tm_hour;
  pc.minutes = (long )tmp->tm_min;
  pc.seconds.tv_sec = (time_t )tmp->tm_sec;
  pc.seconds.tv_nsec = Start_ns;
  tm.tm_isdst = (int )tmp->tm_isdst;
  pc.meridian = 2;
  __constr_expr_0.year = 0L;
  __constr_expr_0.month = 0L;
  __constr_expr_0.day = 0L;
  __constr_expr_0.hour = 0L;
  __constr_expr_0.minutes = 0L;
  __constr_expr_0.seconds = (long_time_t )0;
  __constr_expr_0.ns = 0L;
  pc.rel = __constr_expr_0;
  pc.timespec_seen = (_Bool)0;
  pc.rels_seen = (_Bool)0;
  pc.dates_seen = (size_t )0;
  pc.days_seen = (size_t )0;
  pc.times_seen = (size_t )0;
  pc.local_zones_seen = (size_t )0;
  pc.dsts_seen = (size_t )0;
  pc.zones_seen = (size_t )0;
  pc.local_time_zone_table[0].name = (char const *)tmp->tm_zone;
  pc.local_time_zone_table[0].type = 269;
  pc.local_time_zone_table[0].value = (int )tmp->tm_isdst;
  pc.local_time_zone_table[1].name = (char const *)((void *)0);
  quarter = 1;
  }
  {
  while (1) {
    while_continue___2: ;
    if (! (quarter <= 3)) {
      {
      goto while_break___2;
      }
    }
    {
    probe = Start + (time_t )(quarter * 7776000);
    tmp___18 = localtime((time_t const *)(& probe));
    probe_tm = (struct tm const *)tmp___18;
    }
    if (probe_tm) {
      {
      if (probe_tm->tm_zone) {
        {
        if (probe_tm->tm_isdst != (int )((int const )pc.local_time_zone_table[0].value)) {
          {
          {
          pc.local_time_zone_table[1].name = (char const *)probe_tm->tm_zone;
          pc.local_time_zone_table[1].type = 269;
          pc.local_time_zone_table[1].value = (int )probe_tm->tm_isdst;
          pc.local_time_zone_table[2].name = (char const *)((void *)0);
          }
          goto while_break___2;
          }
        }
        }
      }
      }
    }
    {
    quarter ++;
    }
  }
  while_break___2: ;
  }
  if (pc.local_time_zone_table[0].name) {
    {
    if (pc.local_time_zone_table[1].name) {
      {
      if (0) {
        {
        {
        __s1_len___0 = __builtin_strlen(pc.local_time_zone_table[0].name);
        __s2_len___0 = __builtin_strlen(pc.local_time_zone_table[1].name);
        }
        if (! ((size_t )((void const *)(pc.local_time_zone_table[0].name + 1)) - (size_t )((void const *)pc.local_time_zone_table[0].name) == 1UL)) {
          {
          goto _L___2;
          }
        } else {
          {
          if (__s1_len___0 >= 4UL) {
            {
            _L___2:
            if (! ((size_t )((void const *)(pc.local_time_zone_table[1].name + 1)) - (size_t )((void const *)pc.local_time_zone_table[1].name) == 1UL)) {
              {
              {
              tmp___25 = 1;
              }
              }
            } else {
              {
              if (__s2_len___0 >= 4UL) {
                {
                {
                tmp___25 = 1;
                }
                }
              } else {
                {
                {
                tmp___25 = 0;
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            tmp___25 = 0;
            }
            }
          }
          }
        }
        if (tmp___25) {
          {
          {
          tmp___20 = __builtin_strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);
          tmp___24 = tmp___20;
          }
          }
        } else {
          {
          {
          tmp___23 = __builtin_strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);
          tmp___24 = tmp___23;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___23 = __builtin_strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);
        tmp___24 = tmp___23;
        }
        }
      }
      if (! tmp___24) {
        {
        {
        pc.local_time_zone_table[0].value = -1;
        pc.local_time_zone_table[1].name = (char const *)((void *)0);
        }
        }
      }
      }
    }
    }
  }
  {
  tmp___26 = yyparse(& pc);
  }
  if (tmp___26 != 0) {
    {
    goto fail;
    }
  }
  if (pc.timespec_seen) {
    {
    {
    *result = pc.seconds;
    }
    }
  } else {
    {
    if (1UL < ((((pc.times_seen | pc.dates_seen) | pc.days_seen) | pc.dsts_seen) | (pc.local_zones_seen + pc.zones_seen))) {
      {
      goto fail;
      }
    }
    {
    tmp___27 = to_year(pc.year);
    tm.tm_year = (int )(tmp___27 - 1900L);
    tm.tm_mon = (int )(pc.month - 1L);
    tm.tm_mday = (int )pc.day;
    }
    if (pc.times_seen) {
      {
      goto _L___3;
      }
    } else {
      {
      if (pc.rels_seen) {
        {
        if (! pc.dates_seen) {
          {
          if (! pc.days_seen) {
            {
            _L___3:
            {
            tm.tm_hour = to_hour(pc.hour, pc.meridian);
            }
            if (tm.tm_hour < 0) {
              {
              goto fail;
              }
            }
            {
            tm.tm_min = (int )pc.minutes;
            tm.tm_sec = (int )pc.seconds.tv_sec;
            }
            }
          } else {
            {
            {
            tm.tm_sec = 0;
            tm.tm_min = tm.tm_sec;
            tm.tm_hour = tm.tm_min;
            pc.seconds.tv_nsec = 0L;
            }
            }
          }
          }
        } else {
          {
          {
          tm.tm_sec = 0;
          tm.tm_min = tm.tm_sec;
          tm.tm_hour = tm.tm_min;
          pc.seconds.tv_nsec = 0L;
          }
          }
        }
        }
      } else {
        {
        {
        tm.tm_sec = 0;
        tm.tm_min = tm.tm_sec;
        tm.tm_hour = tm.tm_min;
        pc.seconds.tv_nsec = 0L;
        }
        }
      }
      }
    }
    if ((pc.dates_seen | pc.days_seen) | pc.times_seen) {
      {
      {
      tm.tm_isdst = -1;
      }
      }
    }
    if (pc.local_zones_seen) {
      {
      {
      tm.tm_isdst = pc.local_isdst;
      }
      }
    }
    {
    tm0 = tm;
    Start = mktime(& tm);
    tmp___31 = mktime_ok((struct tm const *)(& tm0), (struct tm const *)(& tm),
                         Start);
    }
    if (! tmp___31) {
      {
      if (! pc.zones_seen) {
        {
        goto fail;
        }
      } else {
        {
        {
        time_zone = pc.time_zone;
        }
        if (time_zone < 0L) {
          {
          {
          tmp___28 = - time_zone;
          }
          }
        } else {
          {
          {
          tmp___28 = time_zone;
          }
          }
        }
        {
        abs_time_zone = tmp___28;
        abs_time_zone_hour = abs_time_zone / 60L;
        abs_time_zone_min = (int )(abs_time_zone % 60L);
        }
        if (! tz_was_altered) {
          {
          {
          tz0 = get_tz(tz0buf);
          }
          }
        }
        {
        sprintf((char *)((char * __restrict )(tz1buf___0)), (char const *)((char const * __restrict )"XXX%s%ld:%02d"),
                "-" + (time_zone < 0L), abs_time_zone_hour, abs_time_zone_min);
        tmp___29 = setenv((char const *)"TZ", (char const *)(tz1buf___0), 1);
        }
        if (tmp___29 != 0) {
          {
          goto fail;
          }
        }
        {
        tz_was_altered = (_Bool)1;
        tm = tm0;
        Start = mktime(& tm);
        tmp___30 = mktime_ok((struct tm const *)(& tm0), (struct tm const *)(& tm),
                             Start);
        }
        if (! tmp___30) {
          {
          goto fail;
          }
        }
        }
      }
      }
    }
    if (pc.days_seen) {
      {
      if (! pc.dates_seen) {
        {
        if (0L < pc.day_ordinal) {
          {
          if (tm.tm_wday != pc.day_number) {
            {
            {
            tmp___32 = 1;
            }
            }
          } else {
            {
            {
            tmp___32 = 0;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___32 = 0;
          }
          }
        }
        {
        tm.tm_mday = (int )((long )tm.tm_mday + ((long )(((pc.day_number - tm.tm_wday) + 7) % 7) + 7L * (pc.day_ordinal - (long )tmp___32)));
        tm.tm_isdst = -1;
        Start = mktime(& tm);
        }
        if (Start == -1L) {
          {
          goto fail;
          }
        }
        }
      }
      }
    }
    if ((pc.rel.year | pc.rel.month) | pc.rel.day) {
      {
      {
      year___0 = (int )((long )tm.tm_year + pc.rel.year);
      month = (int )((long )tm.tm_mon + pc.rel.month);
      day = (int )((long )tm.tm_mday + pc.rel.day);
      }
      if ((((year___0 < tm.tm_year) ^ (pc.rel.year < 0L)) | ((month < tm.tm_mon) ^ (pc.rel.month < 0L))) | ((day < tm.tm_mday) ^ (pc.rel.day < 0L))) {
        {
        goto fail;
        }
      }
      {
      tm.tm_year = year___0;
      tm.tm_mon = month;
      tm.tm_mday = day;
      tm.tm_hour = tm0.tm_hour;
      tm.tm_min = tm0.tm_min;
      tm.tm_sec = tm0.tm_sec;
      tm.tm_isdst = tm0.tm_isdst;
      Start = mktime(& tm);
      }
      if (Start == -1L) {
        {
        goto fail;
        }
      }
      }
    }
    if (pc.zones_seen) {
      {
      {
      delta = pc.time_zone * 60L;
      delta -= tm.tm_gmtoff;
      t1 = Start - delta;
      }
      if ((Start < t1) != (delta < 0L)) {
        {
        goto fail;
        }
      }
      {
      Start = t1;
      }
      }
    }
    {
    sum_ns = pc.seconds.tv_nsec + pc.rel.ns;
    normalized_ns = (sum_ns % 1000000000L + 1000000000L) % 1000000000L;
    t0 = Start;
    d1 = 3600L * pc.rel.hour;
    t1___0 = t0 + d1;
    d2 = 60L * pc.rel.minutes;
    t2 = t1___0 + d2;
    d3 = pc.rel.seconds;
    t3 = t2 + d3;
    d4 = (sum_ns - normalized_ns) / 1000000000L;
    t4 = t3 + d4;
    t5 = t4;
    }
    if (((((((d1 / 3600L ^ pc.rel.hour) | (d2 / 60L ^ pc.rel.minutes)) | (long )((t1___0 < t0) ^ (d1 < 0L))) | (long )((t2 < t1___0) ^ (d2 < 0L))) | (long )((t3 < t2) ^ (d3 < 0L))) | (long )((t4 < t3) ^ (d4 < 0L))) | (long )(t5 != t4)) {
      {
      goto fail;
      }
    }
    {
    result->tv_sec = t5;
    result->tv_nsec = normalized_ns;
    }
    }
  }
  goto done;
  fail:
  {
  ok = (_Bool)0;
  }
  done:
  if (tz_was_altered) {
    {
    if (tz0) {
      {
      {
      tmp___33 = setenv((char const *)"TZ", (char const *)tz0, 1);
      tmp___35 = tmp___33;
      }
      }
    } else {
      {
      {
      tmp___34 = unsetenv((char const *)"TZ");
      tmp___35 = tmp___34;
      }
      }
    }
    {
    ok = (_Bool )((int )ok & (tmp___35 == 0));
    }
    }
  }
  if ((unsigned long )tz0 != (unsigned long )(tz0buf)) {
    {
    {
    free((void *)tz0);
    }
    }
  }
  return (ok);
}
}
double physmem_total(void)
{
  double pages ;
  long tmp ;
  double pagesize ;
  long tmp___0 ;
  {
  {
  tmp = sysconf(85);
  pages = (double )tmp;
  tmp___0 = sysconf(30);
  pagesize = (double )tmp___0;
  }
  if ((double )0 <= pages) {
    {
    if ((double )0 <= pagesize) {
      {
      return (pages * pagesize);
      }
    }
    }
  }
  return ((double )67108864);
}
}
double physmem_available(void)
{
  double pages ;
  long tmp ;
  double pagesize ;
  long tmp___0 ;
  double tmp___1 ;
  {
  {
  tmp = sysconf(86);
  pages = (double )tmp;
  tmp___0 = sysconf(30);
  pagesize = (double )tmp___0;
  }
  if ((double )0 <= pages) {
    {
    if ((double )0 <= pagesize) {
      {
      return (pages * pagesize);
      }
    }
    }
  }
  {
  tmp___1 = physmem_total();
  }
  return (tmp___1 / (double )4);
}
}
static int year(struct tm *tm , int const *digit_pair , size_t n , unsigned int syntax_bits )
{
  time_t now ;
  struct tm *tmp ;
  {
  {
  if ((int )n == 1) {
    {
    goto case_1;
    }
  }
  if ((int )n == 2) {
    {
    goto case_2;
    }
  }
  if ((int )n == 0) {
    {
    goto case_0;
    }
  }
  goto switch_default;
  case_1:
  {
  tm->tm_year = (int )*digit_pair;
  }
  if (*(digit_pair + 0) <= 68) {
    {
    if (syntax_bits & 16U) {
      {
      return (1);
      }
    }
    {
    tm->tm_year += 100;
    }
    }
  }
  goto switch_break;
  case_2:
  if (! (syntax_bits & 4U)) {
    {
    return (1);
    }
  }
  {
  tm->tm_year = (int )((*(digit_pair + 0) * 100 + *(digit_pair + 1)) - 1900);
  }
  goto switch_break;
  case_0:
  {
  time(& now);
  tmp = localtime((time_t const *)(& now));
  }
  if (! tmp) {
    {
    return (1);
    }
  }
  {
  tm->tm_year = tmp->tm_year;
  }
  goto switch_break;
  switch_default:
  {
  abort();
  }
  switch_break: ;
  }
  return (0);
}
}
static int posix_time_parse(struct tm *tm , char const *s , unsigned int syntax_bits )
{
  char const *dot ;
  int pair[6] ;
  int *p ;
  size_t i ;
  size_t s_len ;
  size_t tmp ;
  size_t len ;
  size_t tmp___2 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int seconds ;
  {
  {
  dot = (char const *)((void *)0);
  tmp = strlen(s);
  s_len = tmp;
  }
  if (syntax_bits & 8U) {
    {
    {
    tmp___4 = __builtin_strchr((char *)s, '.');
    dot = (char const *)tmp___4;
    }
    if (dot) {
      {
      {
      tmp___2 = (size_t )(dot - s);
      }
      }
    } else {
      {
      {
      tmp___2 = s_len;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___2 = s_len;
    }
    }
  }
  {
  len = tmp___2;
  }
  if (len != 8UL) {
    {
    if (len != 10UL) {
      {
      if (len != 12UL) {
        {
        return (1);
        }
      }
      }
    }
    }
  }
  if (dot) {
    {
    if (! (syntax_bits & 8U)) {
      {
      return (1);
      }
    }
    if (s_len - len != 3UL) {
      {
      return (1);
      }
    }
    }
  }
  {
  i = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! (i < len)) {
      {
      goto while_break;
      }
    }
    if (! ((unsigned int )*(s + i) - 48U <= 9U)) {
      {
      return (1);
      }
    }
    {
    i ++;
    }
  }
  while_break: ;
  }
  {
  len /= 2UL;
  i = (size_t )0;
  }
  {
  while (1) {
    while_continue___0: ;
    if (! (i < len)) {
      {
      goto while_break___0;
      }
    }
    {
    pair[i] = (10 * (int )((int const )*(s + 2UL * i) - 48) + (int )*(s + (2UL * i + 1UL))) - 48;
    i ++;
    }
  }
  while_break___0: ;
  }
  {
  p = pair;
  }
  if (syntax_bits & 1U) {
    {
    {
    tmp___5 = year(tm, (int const *)p, len - 4UL, syntax_bits);
    }
    if (tmp___5) {
      {
      return (1);
      }
    }
    {
    p += len - 4UL;
    len = (size_t )4;
    }
    }
  }
  {
  tmp___6 = p;
  p ++;
  tm->tm_mon = *tmp___6 - 1;
  tmp___7 = p;
  p ++;
  tm->tm_mday = *tmp___7;
  tmp___8 = p;
  p ++;
  tm->tm_hour = *tmp___8;
  tmp___9 = p;
  p ++;
  tm->tm_min = *tmp___9;
  len -= 4UL;
  }
  if (syntax_bits & 2U) {
    {
    {
    tmp___10 = year(tm, (int const *)p, len, syntax_bits);
    }
    if (tmp___10) {
      {
      return (1);
      }
    }
    }
  }
  if (! dot) {
    {
    {
    tm->tm_sec = 0;
    }
    }
  } else {
    {
    {
    dot ++;
    }
    if (! ((unsigned int )*(dot + 0) - 48U <= 9U)) {
      {
      return (1);
      }
    } else {
      {
      if (! ((unsigned int )*(dot + 1) - 48U <= 9U)) {
        {
        return (1);
        }
      }
      }
    }
    {
    seconds = (10 * (int )((int const )*(dot + 0) - 48) + (int )*(dot + 1)) - 48;
    tm->tm_sec = seconds;
    }
    }
  }
  return (0);
}
}
_Bool posixtime(time_t *p , char const *s , unsigned int syntax_bits )
{
  struct tm tm0 ;
  struct tm tm1 ;
  struct tm const *tm ;
  time_t t ;
  int tmp ;
  struct tm *tmp___0 ;
  time_t dummy ;
  char buf___1[16] ;
  char *b ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  {
  {
  tmp = posix_time_parse(& tm0, s, syntax_bits);
  }
  if (tmp) {
    {
    return ((_Bool)0);
    }
  }
  {
  tm1 = tm0;
  tm1.tm_isdst = -1;
  t = mktime(& tm1);
  }
  if (t != -1L) {
    {
    {
    tm = (struct tm const *)(& tm1);
    }
    }
  } else {
    {
    {
    tmp___0 = localtime((time_t const *)(& t));
    tm = (struct tm const *)tmp___0;
    }
    if (! tm) {
      {
      return ((_Bool)0);
      }
    }
    }
  }
  if ((((((tm0.tm_year ^ (int )tm->tm_year) | (tm0.tm_mon ^ (int )tm->tm_mon)) | (tm0.tm_mday ^ (int )tm->tm_mday)) | (tm0.tm_hour ^ (int )tm->tm_hour)) | (tm0.tm_min ^ (int )tm->tm_min)) | (tm0.tm_sec ^ (int )tm->tm_sec)) {
    {
    if (tm0.tm_sec != 60) {
      {
      return ((_Bool)0);
      }
    }
    {
    tmp___1 = stpcpy((char *)((char * __restrict )(buf___1)), (char const *)((char const * __restrict )s));
    b = tmp___1;
    strcpy((char *)((char * __restrict )(b - 2)), (char const *)((char const * __restrict )"59"));
    tmp___2 = posixtime(& dummy, (char const *)(buf___1), syntax_bits);
    }
    if (! tmp___2) {
      {
      return ((_Bool)0);
      }
    }
    }
  }
  {
  *p = t;
  }
  return ((_Bool)1);
}
}
int posix2_version(void)
{
  long v ;
  char const *s ;
  char *tmp ;
  char *e ;
  long i ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  {
  {
  v = 200809L;
  tmp = getenv((char const *)"_POSIX2_VERSION");
  s = (char const *)tmp;
  }
  if (s) {
    {
    if (*s) {
      {
      {
      tmp___0 = strtol((char const * __restrict )s, (char ** __restrict )(& e),
                       10);
      i = tmp___0;
      }
      if (! *e) {
        {
        {
        v = i;
        }
        }
      }
      }
    }
    }
  }
  if (v < (-0x7FFFFFFF-1)) {
    {
    {
    tmp___2 = (-0x7FFFFFFF-1);
    }
    }
  } else {
    {
    if (v < 2147483647L) {
      {
      {
      tmp___1 = v;
      }
      }
    } else {
      {
      {
      tmp___1 = 2147483647L;
      }
      }
    }
    {
    tmp___2 = tmp___1;
    }
    }
  }
  return ((int )tmp___2);
}
}
__inline extern int __signbitf(float __x ) __attribute__((__nothrow__, __const__)) ;
__inline extern int __signbitf(float __x )
{
  int __m ;
  {
  {
  __asm__ ("pmovmskb %1, %0": "=r" (__m): "x" (__x));
  }
  return (__m & 8);
}
}
__inline extern int __signbit(double __x ) __attribute__((__nothrow__, __const__)) ;
__inline extern int __signbit(double __x )
{
  int __m ;
  {
  {
  __asm__ ("pmovmskb %1, %0": "=r" (__m): "x" (__x));
  }
  return (__m & 128);
}
}
double printf_frexp(double x , int *expptr )
{
  int exponent ;
  {
  {
  x = frexp(x, & exponent);
  x += x;
  exponent --;
  }
  if (exponent < -1022) {
    {
    {
    x = ldexp(x, exponent - -1022);
    exponent = -1022;
    }
    }
  }
  {
  *expptr = exponent;
  }
  return (x);
}
}
long double printf_frexpl(long double x , int *expptr )
{
  int exponent ;
  fpucw_t oldcw ;
  fpucw_t _cw ;
  fpucw_t _ncw ;
  fpucw_t _ncw___0 ;
  {
  {
  __asm__ volatile ("fnstcw %0": "=m" (_cw));
  oldcw = _cw;
  _ncw = (fpucw_t )(((int )oldcw & -769) | 768);
  __asm__ volatile ("fldcw %0": : "m" (_ncw));
  x = frexpl(x, & exponent);
  x += x;
  exponent --;
  }
  if (exponent < -16382) {
    {
    {
    x = ldexpl(x, exponent - -16382);
    exponent = -16382;
    }
    }
  }
  {
  _ncw___0 = oldcw;
  __asm__ volatile ("fldcw %0": : "m" (_ncw___0));
  *expptr = exponent;
  }
  return (x);
}
}
void set_program_name(char const *argv0 )
{
  char const *slash ;
  char const *base ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  {
  if ((unsigned long )argv0 == (unsigned long )((void *)0)) {
    {
    { if(!(argv0 == 0)) { reach_error(); abort(); } };
    {
    fputs((char const * __restrict )"A NULL argv[0] was passed through an exec system call.\n",
          (FILE * __restrict )stderr);
    { if(!(stdlib_allocator.die == 0)) { reach_error(); abort(); } };
    { if(!(argmatch_die == & __argmatch_die)) { reach_error(); abort(); } };
    { if(!(rpl_optind == 1)) { reach_error(); abort(); } };
    { if(!(rpl_opterr == 1)) { reach_error(); abort(); } };
    { if(!(program_name == 0)) { reach_error(); abort(); } };
    { if(!(argv0 == 0)) { reach_error(); abort(); } };
    { if(!(rpl_optarg == 0)) { reach_error(); abort(); } };
    { if(!(rpl_optopt == 63)) { reach_error(); abort(); } };
    { if(!(last_cherror == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_addr == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_addrlen == 0U)) { reach_error(); abort(); } };
    { if(!(hints.ai_canonname == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_family == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_flags == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_next == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_protocol == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_socktype == 0)) { reach_error(); abort(); } };
    { if(!(file_name == 0)) { reach_error(); abort(); } };
    { if(!(file_name___0 == 0)) { reach_error(); abort(); } };
    { if(!(ignore_EPIPE == (_Bool)0)) { reach_error(); abort(); } };
    { if(!(user_alist == 0)) { reach_error(); abort(); } };
    { if(!(nouser_alist == 0)) { reach_error(); abort(); } };
    { if(!(group_alist == 0)) { reach_error(); abort(); } };
    { if(!(nogroup_alist == 0)) { reach_error(); abort(); } };
    { if(!(default_quoting_options.flags == 0)) { reach_error(); abort(); } };
    { if(!(default_quoting_options.left_quote == 0)) { reach_error(); abort(); } };
    { if(!(default_quoting_options.right_quote == 0)) { reach_error(); abort(); } };
    { if(!(nslots == 1U)) { reach_error(); abort(); } };
    { if(!(slotvec0.size == 256UL)) { reach_error(); abort(); } };
    { if(!(slotvec0.val == & slot0[0LL])) { reach_error(); abort(); } };
    { if(!(slotvec == & slotvec0)) { reach_error(); abort(); } };
    { if(!(saved_delim == 0)) { reach_error(); abort(); } };
    { if(!(initialized == 0)) { reach_error(); abort(); } };
    { if(!(is_utf8 == 0)) { reach_error(); abort(); } };
    { if(!(ht == 0)) { reach_error(); abort(); } };
    { if(!(new_dst_res == 0)) { reach_error(); abort(); } };
    { if(!(utimensat_works_really == 0)) { reach_error(); abort(); } };
    { if(!(lutimensat_works_really == 0)) { reach_error(); abort(); } };
    { if(!(initialized___0 == (_Bool)0)) { reach_error(); abort(); } };
    { if(!(can_write == (_Bool)0)) { reach_error(); abort(); } };
    { if(!(have_dupfd_cloexec == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.__first_nonopt == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.__initialized == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.__last_nonopt == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.__nextchar == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.__posixly_correct == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.rpl_optarg == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.rpl_opterr == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.rpl_optind == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.rpl_optopt == 0)) { reach_error(); abort(); } };
    { if(!(buf == 0)) { reach_error(); abort(); } };
    { if(!(bufsize == 0UL)) { reach_error(); abort(); } };
    { if(!(have_follow_really == 0)) { reach_error(); abort(); } };
    { if(!(proc_status == 0)) { reach_error(); abort(); } };
    { if(!(utimensat_works_really___0 == 0)) { reach_error(); abort(); } };
    { if(!(slotvec->size == 256UL)) { reach_error(); abort(); } };
    { if(!(slotvec->val == & slot0[0LL])) { reach_error(); abort(); } };
    { if(!((_Bool )default_tuning.is_n_buckets == (_Bool)0)) { reach_error(); abort(); } };
    { if(!((int )fresh_once == 0)) { reach_error(); abort(); } };
    { if(!((unsigned int )default_quoting_options.style == 0U)) { reach_error(); abort(); } };
    { if(!((unsigned int )getopt_data.__ordering == 0U)) { reach_error(); abort(); } };
    { if(!((unsigned long )utf8_to_local == 0UL)) { reach_error(); abort(); } };
    { if(!((void *)stdlib_allocator.allocate == (void *)(& malloc))) { reach_error(); abort(); } };
    { if(!((void *)stdlib_allocator.free == (void *)(& free))) { reach_error(); abort(); } };
    { if(!((void *)stdlib_allocator.reallocate == (void *)(& realloc))) { reach_error(); abort(); } };
    abort();
    { if(!(stdlib_allocator.die == 0)) { reach_error(); abort(); } };
    { if(!(argmatch_die == & __argmatch_die)) { reach_error(); abort(); } };
    { if(!(rpl_optind == 1)) { reach_error(); abort(); } };
    { if(!(rpl_opterr == 1)) { reach_error(); abort(); } };
    { if(!(program_name == 0)) { reach_error(); abort(); } };
    { if(!(rpl_optarg == 0)) { reach_error(); abort(); } };
    { if(!(rpl_optopt == 63)) { reach_error(); abort(); } };
    { if(!(last_cherror == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_addr == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_addrlen == 0U)) { reach_error(); abort(); } };
    { if(!(hints.ai_canonname == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_family == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_flags == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_next == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_protocol == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_socktype == 0)) { reach_error(); abort(); } };
    { if(!(file_name == 0)) { reach_error(); abort(); } };
    { if(!(file_name___0 == 0)) { reach_error(); abort(); } };
    { if(!(ignore_EPIPE == (_Bool)0)) { reach_error(); abort(); } };
    { if(!(user_alist == 0)) { reach_error(); abort(); } };
    { if(!(nouser_alist == 0)) { reach_error(); abort(); } };
    { if(!(group_alist == 0)) { reach_error(); abort(); } };
    { if(!(nogroup_alist == 0)) { reach_error(); abort(); } };
    { if(!(default_quoting_options.flags == 0)) { reach_error(); abort(); } };
    { if(!(default_quoting_options.left_quote == 0)) { reach_error(); abort(); } };
    { if(!(default_quoting_options.right_quote == 0)) { reach_error(); abort(); } };
    { if(!(nslots == 1U)) { reach_error(); abort(); } };
    { if(!(slotvec0.size == 256UL)) { reach_error(); abort(); } };
    { if(!(slotvec0.val == & slot0[0LL])) { reach_error(); abort(); } };
    { if(!(slotvec == & slotvec0)) { reach_error(); abort(); } };
    { if(!(saved_delim == 0)) { reach_error(); abort(); } };
    { if(!(initialized == 0)) { reach_error(); abort(); } };
    { if(!(is_utf8 == 0)) { reach_error(); abort(); } };
    { if(!(ht == 0)) { reach_error(); abort(); } };
    { if(!(new_dst_res == 0)) { reach_error(); abort(); } };
    { if(!(utimensat_works_really == 0)) { reach_error(); abort(); } };
    { if(!(lutimensat_works_really == 0)) { reach_error(); abort(); } };
    { if(!(initialized___0 == (_Bool)0)) { reach_error(); abort(); } };
    { if(!(can_write == (_Bool)0)) { reach_error(); abort(); } };
    { if(!(have_dupfd_cloexec == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.__first_nonopt == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.__initialized == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.__last_nonopt == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.__nextchar == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.__posixly_correct == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.rpl_optarg == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.rpl_opterr == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.rpl_optind == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.rpl_optopt == 0)) { reach_error(); abort(); } };
    { if(!(buf == 0)) { reach_error(); abort(); } };
    { if(!(bufsize == 0UL)) { reach_error(); abort(); } };
    { if(!(have_follow_really == 0)) { reach_error(); abort(); } };
    { if(!(proc_status == 0)) { reach_error(); abort(); } };
    { if(!(utimensat_works_really___0 == 0)) { reach_error(); abort(); } };
    { if(!(slotvec->size == 256UL)) { reach_error(); abort(); } };
    { if(!(slotvec->val == & slot0[0LL])) { reach_error(); abort(); } };
    { if(!((_Bool )default_tuning.is_n_buckets == (_Bool)0)) { reach_error(); abort(); } };
    { if(!((int )fresh_once == 0)) { reach_error(); abort(); } };
    { if(!((unsigned int )default_quoting_options.style == 0U)) { reach_error(); abort(); } };
    { if(!((unsigned int )getopt_data.__ordering == 0U)) { reach_error(); abort(); } };
    { if(!((unsigned long )utf8_to_local == 0UL)) { reach_error(); abort(); } };
    { if(!((void *)stdlib_allocator.allocate == (void *)(& malloc))) { reach_error(); abort(); } };
    { if(!((void *)stdlib_allocator.free == (void *)(& free))) { reach_error(); abort(); } };
    { if(!((void *)stdlib_allocator.reallocate == (void *)(& realloc))) { reach_error(); abort(); } };
    }
    }
  }
  {
  { if(!(stdlib_allocator.die == 0)) { reach_error(); abort(); } };
  { if(!(argmatch_die == & __argmatch_die)) { reach_error(); abort(); } };
  { if(!(rpl_optind == 1)) { reach_error(); abort(); } };
  { if(!(rpl_opterr == 1)) { reach_error(); abort(); } };
  { if(!(program_name == 0)) { reach_error(); abort(); } };
  { if(!(rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(rpl_optopt == 63)) { reach_error(); abort(); } };
  { if(!(last_cherror == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addr == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addrlen == 0U)) { reach_error(); abort(); } };
  { if(!(hints.ai_canonname == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_family == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_flags == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_next == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_protocol == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_socktype == 0)) { reach_error(); abort(); } };
  { if(!(file_name == 0)) { reach_error(); abort(); } };
  { if(!(file_name___0 == 0)) { reach_error(); abort(); } };
  { if(!(ignore_EPIPE == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(user_alist == 0)) { reach_error(); abort(); } };
  { if(!(nouser_alist == 0)) { reach_error(); abort(); } };
  { if(!(group_alist == 0)) { reach_error(); abort(); } };
  { if(!(nogroup_alist == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.flags == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.left_quote == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.right_quote == 0)) { reach_error(); abort(); } };
  { if(!(nslots == 1U)) { reach_error(); abort(); } };
  { if(!(slotvec0.size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec0.val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!(slotvec == & slotvec0)) { reach_error(); abort(); } };
  { if(!(saved_delim == 0)) { reach_error(); abort(); } };
  { if(!(initialized == 0)) { reach_error(); abort(); } };
  { if(!(is_utf8 == 0)) { reach_error(); abort(); } };
  { if(!(ht == 0)) { reach_error(); abort(); } };
  { if(!(new_dst_res == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(lutimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(initialized___0 == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(can_write == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(have_dupfd_cloexec == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__first_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__initialized == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__last_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__nextchar == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__posixly_correct == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_opterr == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optind == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optopt == 0)) { reach_error(); abort(); } };
  { if(!(buf == 0)) { reach_error(); abort(); } };
  { if(!(bufsize == 0UL)) { reach_error(); abort(); } };
  { if(!(have_follow_really == 0)) { reach_error(); abort(); } };
  { if(!(proc_status == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really___0 == 0)) { reach_error(); abort(); } };
  { if(!(slotvec->size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec->val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!((_Bool )default_tuning.is_n_buckets == (_Bool)0)) { reach_error(); abort(); } };
  { if(!((int )fresh_once == 0)) { reach_error(); abort(); } };
  { if(!((unsigned int )default_quoting_options.style == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned int )getopt_data.__ordering == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned long )utf8_to_local == 0UL)) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.allocate == (void *)(& malloc))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.free == (void *)(& free))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.reallocate == (void *)(& realloc))) { reach_error(); abort(); } };
  {
  tmp = strrchr(argv0, '/');
  slash = (char const *)tmp;
  }
  }
  if ((unsigned long )slash != (unsigned long )((void *)0)) {
    {
    {
    base = slash + 1;
    }
    }
  } else {
    {
    { if(!(slash == 0)) { reach_error(); abort(); } };
    {
    base = argv0;
    }
    }
  }
  {
  { if(!(stdlib_allocator.die == 0)) { reach_error(); abort(); } };
  { if(!(argmatch_die == & __argmatch_die)) { reach_error(); abort(); } };
  { if(!(rpl_optind == 1)) { reach_error(); abort(); } };
  { if(!(rpl_opterr == 1)) { reach_error(); abort(); } };
  { if(!(program_name == 0)) { reach_error(); abort(); } };
  { if(!(rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(rpl_optopt == 63)) { reach_error(); abort(); } };
  { if(!(last_cherror == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addr == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addrlen == 0U)) { reach_error(); abort(); } };
  { if(!(hints.ai_canonname == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_family == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_flags == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_next == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_protocol == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_socktype == 0)) { reach_error(); abort(); } };
  { if(!(file_name == 0)) { reach_error(); abort(); } };
  { if(!(file_name___0 == 0)) { reach_error(); abort(); } };
  { if(!(ignore_EPIPE == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(user_alist == 0)) { reach_error(); abort(); } };
  { if(!(nouser_alist == 0)) { reach_error(); abort(); } };
  { if(!(group_alist == 0)) { reach_error(); abort(); } };
  { if(!(nogroup_alist == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.flags == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.left_quote == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.right_quote == 0)) { reach_error(); abort(); } };
  { if(!(nslots == 1U)) { reach_error(); abort(); } };
  { if(!(slotvec0.size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec0.val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!(slotvec == & slotvec0)) { reach_error(); abort(); } };
  { if(!(saved_delim == 0)) { reach_error(); abort(); } };
  { if(!(initialized == 0)) { reach_error(); abort(); } };
  { if(!(is_utf8 == 0)) { reach_error(); abort(); } };
  { if(!(ht == 0)) { reach_error(); abort(); } };
  { if(!(new_dst_res == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(lutimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(initialized___0 == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(can_write == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(have_dupfd_cloexec == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__first_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__initialized == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__last_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__nextchar == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__posixly_correct == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_opterr == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optind == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optopt == 0)) { reach_error(); abort(); } };
  { if(!(buf == 0)) { reach_error(); abort(); } };
  { if(!(bufsize == 0UL)) { reach_error(); abort(); } };
  { if(!(have_follow_really == 0)) { reach_error(); abort(); } };
  { if(!(proc_status == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really___0 == 0)) { reach_error(); abort(); } };
  { if(!(slotvec->size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec->val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!((_Bool )default_tuning.is_n_buckets == (_Bool)0)) { reach_error(); abort(); } };
  { if(!((int )fresh_once == 0)) { reach_error(); abort(); } };
  { if(!((unsigned int )default_quoting_options.style == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned int )getopt_data.__ordering == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned long )utf8_to_local == 0UL)) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.allocate == (void *)(& malloc))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.free == (void *)(& free))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.reallocate == (void *)(& realloc))) { reach_error(); abort(); } };
  if (base - argv0 >= 7L) {
    {
    if (0) {
      {
      if (0) {
        {
        {
        __s1_len___0 = __builtin_strlen(base - 7);
        __s2_len___0 = __builtin_strlen((char const *)"/.libs/");
        }
        if (! ((size_t )((void const *)((base - 7) + 1)) - (size_t )((void const *)(base - 7)) == 1UL)) {
          {
          goto _L___2;
          }
        } else {
          {
          if (__s1_len___0 >= 4UL) {
            {
            _L___2:
            if (! ((size_t )((void const *)("/.libs/" + 1)) - (size_t )((void const *)"/.libs/") == 1UL)) {
              {
              {
              tmp___21 = 1;
              }
              }
            } else {
              {
              if (__s2_len___0 >= 4UL) {
                {
                {
                tmp___21 = 1;
                }
                }
              } else {
                {
                {
                tmp___21 = 0;
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            tmp___21 = 0;
            }
            }
          }
          }
        }
        if (tmp___21) {
          {
          {
          tmp___16 = __builtin_strcmp(base - 7, (char const *)"/.libs/");
          tmp___20 = tmp___16;
          }
          }
        } else {
          {
          {
          tmp___19 = __builtin_strcmp(base - 7, (char const *)"/.libs/");
          tmp___20 = tmp___19;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___19 = __builtin_strcmp(base - 7, (char const *)"/.libs/");
        tmp___20 = tmp___19;
        }
        }
      }
      {
      tmp___23 = tmp___20;
      }
      }
    } else {
      {
      {
      tmp___22 = strncmp(base - 7, (char const *)"/.libs/", (size_t )7);
      tmp___23 = tmp___22;
      }
      }
    }
    {
    { if(!(stdlib_allocator.die == 0)) { reach_error(); abort(); } };
    { if(!(argmatch_die == & __argmatch_die)) { reach_error(); abort(); } };
    { if(!(rpl_optind == 1)) { reach_error(); abort(); } };
    { if(!(rpl_opterr == 1)) { reach_error(); abort(); } };
    { if(!(program_name == 0)) { reach_error(); abort(); } };
    { if(!(rpl_optarg == 0)) { reach_error(); abort(); } };
    { if(!(rpl_optopt == 63)) { reach_error(); abort(); } };
    { if(!(last_cherror == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_addr == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_addrlen == 0U)) { reach_error(); abort(); } };
    { if(!(hints.ai_canonname == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_family == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_flags == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_next == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_protocol == 0)) { reach_error(); abort(); } };
    { if(!(hints.ai_socktype == 0)) { reach_error(); abort(); } };
    { if(!(file_name == 0)) { reach_error(); abort(); } };
    { if(!(file_name___0 == 0)) { reach_error(); abort(); } };
    { if(!(ignore_EPIPE == (_Bool)0)) { reach_error(); abort(); } };
    { if(!(user_alist == 0)) { reach_error(); abort(); } };
    { if(!(nouser_alist == 0)) { reach_error(); abort(); } };
    { if(!(group_alist == 0)) { reach_error(); abort(); } };
    { if(!(nogroup_alist == 0)) { reach_error(); abort(); } };
    { if(!(default_quoting_options.flags == 0)) { reach_error(); abort(); } };
    { if(!(default_quoting_options.left_quote == 0)) { reach_error(); abort(); } };
    { if(!(default_quoting_options.right_quote == 0)) { reach_error(); abort(); } };
    { if(!(nslots == 1U)) { reach_error(); abort(); } };
    { if(!(slotvec0.size == 256UL)) { reach_error(); abort(); } };
    { if(!(slotvec0.val == & slot0[0LL])) { reach_error(); abort(); } };
    { if(!(slotvec == & slotvec0)) { reach_error(); abort(); } };
    { if(!(saved_delim == 0)) { reach_error(); abort(); } };
    { if(!(initialized == 0)) { reach_error(); abort(); } };
    { if(!(is_utf8 == 0)) { reach_error(); abort(); } };
    { if(!(ht == 0)) { reach_error(); abort(); } };
    { if(!(new_dst_res == 0)) { reach_error(); abort(); } };
    { if(!(utimensat_works_really == 0)) { reach_error(); abort(); } };
    { if(!(lutimensat_works_really == 0)) { reach_error(); abort(); } };
    { if(!(initialized___0 == (_Bool)0)) { reach_error(); abort(); } };
    { if(!(can_write == (_Bool)0)) { reach_error(); abort(); } };
    { if(!(have_dupfd_cloexec == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.__first_nonopt == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.__initialized == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.__last_nonopt == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.__nextchar == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.__posixly_correct == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.rpl_optarg == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.rpl_opterr == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.rpl_optind == 0)) { reach_error(); abort(); } };
    { if(!(getopt_data.rpl_optopt == 0)) { reach_error(); abort(); } };
    { if(!(buf == 0)) { reach_error(); abort(); } };
    { if(!(bufsize == 0UL)) { reach_error(); abort(); } };
    { if(!(have_follow_really == 0)) { reach_error(); abort(); } };
    { if(!(proc_status == 0)) { reach_error(); abort(); } };
    { if(!(utimensat_works_really___0 == 0)) { reach_error(); abort(); } };
    { if(!(slotvec->size == 256UL)) { reach_error(); abort(); } };
    { if(!(slotvec->val == & slot0[0LL])) { reach_error(); abort(); } };
    { if(!((_Bool )default_tuning.is_n_buckets == (_Bool)0)) { reach_error(); abort(); } };
    { if(!((int )fresh_once == 0)) { reach_error(); abort(); } };
    { if(!((unsigned int )default_quoting_options.style == 0U)) { reach_error(); abort(); } };
    { if(!((unsigned int )getopt_data.__ordering == 0U)) { reach_error(); abort(); } };
    { if(!((unsigned long )utf8_to_local == 0UL)) { reach_error(); abort(); } };
    { if(!((void *)stdlib_allocator.allocate == (void *)(& malloc))) { reach_error(); abort(); } };
    { if(!((void *)stdlib_allocator.free == (void *)(& free))) { reach_error(); abort(); } };
    { if(!((void *)stdlib_allocator.reallocate == (void *)(& realloc))) { reach_error(); abort(); } };
    if (tmp___23 == 0) {
      {
      { if(!(tmp___23 == 0)) { reach_error(); abort(); } };
      {
      argv0 = base;
      }
      if (0) {
        {
        if (0) {
          {
          {
          __s1_len = __builtin_strlen(base);
          __s2_len = __builtin_strlen((char const *)"lt-");
          }
          if (! ((size_t )((void const *)(base + 1)) - (size_t )((void const *)base) == 1UL)) {
            {
            goto _L___0;
            }
          } else {
            {
            if (__s1_len >= 4UL) {
              {
              _L___0:
              if (! ((size_t )((void const *)("lt-" + 1)) - (size_t )((void const *)"lt-") == 1UL)) {
                {
                {
                tmp___8 = 1;
                }
                }
              } else {
                {
                if (__s2_len >= 4UL) {
                  {
                  {
                  tmp___8 = 1;
                  }
                  }
                } else {
                  {
                  {
                  tmp___8 = 0;
                  }
                  }
                }
                }
              }
              }
            } else {
              {
              {
              tmp___8 = 0;
              }
              }
            }
            }
          }
          if (tmp___8) {
            {
            {
            tmp___3 = __builtin_strcmp(base, (char const *)"lt-");
            tmp___7 = tmp___3;
            }
            }
          } else {
            {
            {
            tmp___6 = __builtin_strcmp(base, (char const *)"lt-");
            tmp___7 = tmp___6;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___6 = __builtin_strcmp(base, (char const *)"lt-");
          tmp___7 = tmp___6;
          }
          }
        }
        {
        tmp___10 = tmp___7;
        }
        }
      } else {
        {
        {
        tmp___9 = strncmp(base, (char const *)"lt-", (size_t )3);
        tmp___10 = tmp___9;
        }
        }
      }
      {
      { if(!(stdlib_allocator.die == 0)) { reach_error(); abort(); } };
      { if(!(argmatch_die == & __argmatch_die)) { reach_error(); abort(); } };
      { if(!(rpl_optind == 1)) { reach_error(); abort(); } };
      { if(!(rpl_opterr == 1)) { reach_error(); abort(); } };
      { if(!(program_name == 0)) { reach_error(); abort(); } };
      { if(!(tmp___23 == 0)) { reach_error(); abort(); } };
      { if(!(rpl_optarg == 0)) { reach_error(); abort(); } };
      { if(!(rpl_optopt == 63)) { reach_error(); abort(); } };
      { if(!(last_cherror == 0)) { reach_error(); abort(); } };
      { if(!(hints.ai_addr == 0)) { reach_error(); abort(); } };
      { if(!(hints.ai_addrlen == 0U)) { reach_error(); abort(); } };
      { if(!(hints.ai_canonname == 0)) { reach_error(); abort(); } };
      { if(!(hints.ai_family == 0)) { reach_error(); abort(); } };
      { if(!(hints.ai_flags == 0)) { reach_error(); abort(); } };
      { if(!(hints.ai_next == 0)) { reach_error(); abort(); } };
      { if(!(hints.ai_protocol == 0)) { reach_error(); abort(); } };
      { if(!(hints.ai_socktype == 0)) { reach_error(); abort(); } };
      { if(!(file_name == 0)) { reach_error(); abort(); } };
      { if(!(file_name___0 == 0)) { reach_error(); abort(); } };
      { if(!(ignore_EPIPE == (_Bool)0)) { reach_error(); abort(); } };
      { if(!(user_alist == 0)) { reach_error(); abort(); } };
      { if(!(nouser_alist == 0)) { reach_error(); abort(); } };
      { if(!(group_alist == 0)) { reach_error(); abort(); } };
      { if(!(nogroup_alist == 0)) { reach_error(); abort(); } };
      { if(!(default_quoting_options.flags == 0)) { reach_error(); abort(); } };
      { if(!(default_quoting_options.left_quote == 0)) { reach_error(); abort(); } };
      { if(!(default_quoting_options.right_quote == 0)) { reach_error(); abort(); } };
      { if(!(nslots == 1U)) { reach_error(); abort(); } };
      { if(!(slotvec0.size == 256UL)) { reach_error(); abort(); } };
      { if(!(slotvec0.val == & slot0[0LL])) { reach_error(); abort(); } };
      { if(!(slotvec == & slotvec0)) { reach_error(); abort(); } };
      { if(!(saved_delim == 0)) { reach_error(); abort(); } };
      { if(!(initialized == 0)) { reach_error(); abort(); } };
      { if(!(is_utf8 == 0)) { reach_error(); abort(); } };
      { if(!(ht == 0)) { reach_error(); abort(); } };
      { if(!(new_dst_res == 0)) { reach_error(); abort(); } };
      { if(!(utimensat_works_really == 0)) { reach_error(); abort(); } };
      { if(!(lutimensat_works_really == 0)) { reach_error(); abort(); } };
      { if(!(initialized___0 == (_Bool)0)) { reach_error(); abort(); } };
      { if(!(can_write == (_Bool)0)) { reach_error(); abort(); } };
      { if(!(have_dupfd_cloexec == 0)) { reach_error(); abort(); } };
      { if(!(getopt_data.__first_nonopt == 0)) { reach_error(); abort(); } };
      { if(!(getopt_data.__initialized == 0)) { reach_error(); abort(); } };
      { if(!(getopt_data.__last_nonopt == 0)) { reach_error(); abort(); } };
      { if(!(getopt_data.__nextchar == 0)) { reach_error(); abort(); } };
      { if(!(getopt_data.__posixly_correct == 0)) { reach_error(); abort(); } };
      { if(!(getopt_data.rpl_optarg == 0)) { reach_error(); abort(); } };
      { if(!(getopt_data.rpl_opterr == 0)) { reach_error(); abort(); } };
      { if(!(getopt_data.rpl_optind == 0)) { reach_error(); abort(); } };
      { if(!(getopt_data.rpl_optopt == 0)) { reach_error(); abort(); } };
      { if(!(buf == 0)) { reach_error(); abort(); } };
      { if(!(bufsize == 0UL)) { reach_error(); abort(); } };
      { if(!(have_follow_really == 0)) { reach_error(); abort(); } };
      { if(!(proc_status == 0)) { reach_error(); abort(); } };
      { if(!(utimensat_works_really___0 == 0)) { reach_error(); abort(); } };
      { if(!(slotvec->size == 256UL)) { reach_error(); abort(); } };
      { if(!(slotvec->val == & slot0[0LL])) { reach_error(); abort(); } };
      { if(!((_Bool )default_tuning.is_n_buckets == (_Bool)0)) { reach_error(); abort(); } };
      { if(!((int )fresh_once == 0)) { reach_error(); abort(); } };
      { if(!((unsigned int )default_quoting_options.style == 0U)) { reach_error(); abort(); } };
      { if(!((unsigned int )getopt_data.__ordering == 0U)) { reach_error(); abort(); } };
      { if(!((unsigned long )utf8_to_local == 0UL)) { reach_error(); abort(); } };
      { if(!((void *)stdlib_allocator.allocate == (void *)(& malloc))) { reach_error(); abort(); } };
      { if(!((void *)stdlib_allocator.free == (void *)(& free))) { reach_error(); abort(); } };
      { if(!((void *)stdlib_allocator.reallocate == (void *)(& realloc))) { reach_error(); abort(); } };
      if (tmp___10 == 0) {
        {
        { if(!(tmp___10 == 0)) { reach_error(); abort(); } };
        {
        argv0 = base + 3;
        program_invocation_short_name = (char *)argv0;
        }
        }
      }
      }
      }
    }
    }
    }
  }
  }
  {
  program_name = argv0;
  program_invocation_name = (char *)argv0;
  }
  return;
}
}
static _Bool mbsstr_trimmed_wordbounded(char const *string , char const *sub )
{
  char *tsub ;
  char *tmp ;
  _Bool found ;
  char const *tsub_in_string ;
  char *tmp___0 ;
  mbui_iterator_t string_iter ;
  _Bool word_boundary_before ;
  _Bool word_boundary_after ;
  mbchar_t last_char_before_tsub ;
  int tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t tsub_iter ;
  int tmp___3 ;
  int tmp___4 ;
  mbchar_t first_char_after_tsub ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool word_boundary_before___0 ;
  char const *p ;
  _Bool word_boundary_after___0 ;
  unsigned short const **tmp___8 ;
  size_t tmp___9 ;
  unsigned short const **tmp___10 ;
  size_t tmp___11 ;
  {
  {
  tmp = trim2(sub, 2);
  tsub = tmp;
  found = (_Bool)0;
  }
  {
  while (1) {
    while_continue: ;
    if (! ((int const )*string != 0)) {
      {
      goto while_break;
      }
    }
    {
    tmp___0 = mbsstr(string, (char const *)tsub);
    tsub_in_string = (char const *)tmp___0;
    }
    if ((unsigned long )tsub_in_string == (unsigned long )((void *)0)) {
      {
      goto while_break;
      }
    } else {
      {
      {
      tmp___11 = __ctype_get_mb_cur_max();
      }
      if (tmp___11 > 1UL) {
        {
        {
        string_iter.cur.ptr = string;
        string_iter.in_shift = (_Bool)0;
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
        string_iter.next_done = (_Bool)0;
        word_boundary_before = (_Bool)1;
        }
        if ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string) {
          {
          {
          while (1) {
            while_continue___0: ;
            if (! 1) {
              {
              goto while_break___0;
              }
            }
            {
            mbuiter_multi_next(& string_iter);
            }
            if (string_iter.cur.wc_valid) {
              {
              if (string_iter.cur.wc == 0) {
                {
                {
                tmp___1 = 0;
                }
                }
              } else {
                {
                {
                tmp___1 = 1;
                }
                }
              }
              }
            } else {
              {
              {
              tmp___1 = 1;
              }
              }
            }
            if (! tmp___1) {
              {
              {
              abort();
              }
              }
            }
            {
            last_char_before_tsub = string_iter.cur;
            string_iter.cur.ptr += string_iter.cur.bytes;
            string_iter.next_done = (_Bool)0;
            }
            if (! ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string)) {
              {
              goto while_break___0;
              }
            }
          }
          while_break___0: ;
          }
          if (last_char_before_tsub.wc_valid) {
            {
            {
            tmp___2 = iswalnum((wint_t )last_char_before_tsub.wc);
            }
            if (tmp___2) {
              {
              {
              word_boundary_before = (_Bool)0;
              }
              }
            }
            }
          }
          }
        }
        {
        string_iter.cur.ptr = tsub_in_string;
        string_iter.in_shift = (_Bool)0;
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
        string_iter.next_done = (_Bool)0;
        tsub_iter.cur.ptr = (char const *)tsub;
        tsub_iter.in_shift = (_Bool)0;
        memset((void *)(& tsub_iter.state), '\000', sizeof(mbstate_t ));
        tsub_iter.next_done = (_Bool)0;
        }
        {
        while (1) {
          while_continue___1: ;
          if (! 1) {
            {
            goto while_break___1;
            }
          }
          {
          mbuiter_multi_next(& tsub_iter);
          }
          if (tsub_iter.cur.wc_valid) {
            {
            if (tsub_iter.cur.wc == 0) {
              {
              {
              tmp___4 = 0;
              }
              }
            } else {
              {
              {
              tmp___4 = 1;
              }
              }
            }
            }
          } else {
            {
            {
            tmp___4 = 1;
            }
            }
          }
          if (! tmp___4) {
            {
            goto while_break___1;
            }
          }
          {
          mbuiter_multi_next(& string_iter);
          }
          if (string_iter.cur.wc_valid) {
            {
            if (string_iter.cur.wc == 0) {
              {
              {
              tmp___3 = 0;
              }
              }
            } else {
              {
              {
              tmp___3 = 1;
              }
              }
            }
            }
          } else {
            {
            {
            tmp___3 = 1;
            }
            }
          }
          if (! tmp___3) {
            {
            {
            abort();
            }
            }
          }
          {
          string_iter.cur.ptr += string_iter.cur.bytes;
          string_iter.next_done = (_Bool)0;
          tsub_iter.cur.ptr += tsub_iter.cur.bytes;
          tsub_iter.next_done = (_Bool)0;
          }
        }
        while_break___1: ;
        }
        {
        word_boundary_after = (_Bool)1;
        mbuiter_multi_next(& string_iter);
        }
        if (string_iter.cur.wc_valid) {
          {
          if (string_iter.cur.wc == 0) {
            {
            {
            tmp___6 = 0;
            }
            }
          } else {
            {
            {
            tmp___6 = 1;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___6 = 1;
          }
          }
        }
        if (tmp___6) {
          {
          {
          first_char_after_tsub = string_iter.cur;
          }
          if (first_char_after_tsub.wc_valid) {
            {
            {
            tmp___5 = iswalnum((wint_t )first_char_after_tsub.wc);
            }
            if (tmp___5) {
              {
              {
              word_boundary_after = (_Bool)0;
              }
              }
            }
            }
          }
          }
        }
        if (word_boundary_before) {
          {
          if (word_boundary_after) {
            {
            {
            found = (_Bool)1;
            }
            goto while_break;
            }
          }
          }
        }
        {
        string_iter.cur.ptr = tsub_in_string;
        string_iter.in_shift = (_Bool)0;
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
        string_iter.next_done = (_Bool)0;
        mbuiter_multi_next(& string_iter);
        }
        if (string_iter.cur.wc_valid) {
          {
          if (string_iter.cur.wc == 0) {
            {
            {
            tmp___7 = 0;
            }
            }
          } else {
            {
            {
            tmp___7 = 1;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___7 = 1;
          }
          }
        }
        if (! tmp___7) {
          {
          goto while_break;
          }
        }
        {
        string = tsub_in_string + string_iter.cur.bytes;
        }
        }
      } else {
        {
        {
        word_boundary_before___0 = (_Bool)1;
        }
        if ((unsigned long )string < (unsigned long )tsub_in_string) {
          {
          {
          tmp___8 = __ctype_b_loc();
          }
          if ((int const )*(*tmp___8 + (int )((unsigned char )*(tsub_in_string + -1))) & 8) {
            {
            {
            word_boundary_before___0 = (_Bool)0;
            }
            }
          }
          }
        }
        {
        tmp___9 = strlen((char const *)tsub);
        p = tsub_in_string + tmp___9;
        word_boundary_after___0 = (_Bool)1;
        }
        if ((int const )*p != 0) {
          {
          {
          tmp___10 = __ctype_b_loc();
          }
          if ((int const )*(*tmp___10 + (int )((unsigned char )*p)) & 8) {
            {
            {
            word_boundary_after___0 = (_Bool)0;
            }
            }
          }
          }
        }
        if (word_boundary_before___0) {
          {
          if (word_boundary_after___0) {
            {
            {
            found = (_Bool)1;
            }
            goto while_break;
            }
          }
          }
        }
        if ((int const )*tsub_in_string == 0) {
          {
          goto while_break;
          }
        }
        {
        string = tsub_in_string + 1;
        }
        }
      }
      }
    }
  }
  while_break: ;
  }
  {
  free((void *)tsub);
  }
  return (found);
}
}
char const *proper_name(char const *name )
{
  char const *translation ;
  char *tmp ;
  char *result ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  _Bool tmp___7 ;
  {
  {
  tmp = dcgettext((char const *)((void *)0), name, 5);
  translation = (char const *)tmp;
  }
  if ((unsigned long )translation != (unsigned long )name) {
    {
    {
    tmp___7 = mbsstr_trimmed_wordbounded(translation, name);
    }
    if (tmp___7) {
      {
      return (translation);
      }
    } else {
      {
      if (sizeof(char ) == 1UL) {
        {
        {
        tmp___0 = strlen(translation);
        tmp___1 = strlen(name);
        tmp___2 = xmalloc((((tmp___0 + 2UL) + tmp___1) + 1UL) + 1UL);
        tmp___6 = tmp___2;
        }
        }
      } else {
        {
        {
        tmp___3 = strlen(translation);
        tmp___4 = strlen(name);
        tmp___5 = xnmalloc((((tmp___3 + 2UL) + tmp___4) + 1UL) + 1UL, sizeof(char ));
        tmp___6 = tmp___5;
        }
        }
      }
      {
      result = (char *)tmp___6;
      sprintf((char *)((char * __restrict )result), (char const *)((char const * __restrict )"%s (%s)"),
              translation, name);
      }
      return ((char const *)result);
      }
    }
    }
  } else {
    {
    return (name);
    }
  }
}
}
char const *proper_name_utf8(char const *name_ascii , char const *name_utf8 )
{
  char const *translation ;
  char *tmp ;
  char const *locale_code ;
  char const *tmp___0 ;
  char *alloc_name_converted ;
  char *alloc_name_converted_translit ;
  char const *name_converted ;
  char const *name_converted_translit ;
  char const *name ;
  char *converted_translit ;
  size_t len ;
  size_t tmp___1 ;
  char *locale_code_translit ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___6 ;
  int tmp___7 ;
  char const *tmp___8 ;
  char *result ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  _Bool tmp___18 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  {
  {
  tmp = dcgettext((char const *)((void *)0), name_ascii, 5);
  translation = (char const *)tmp;
  tmp___0 = locale_charset();
  locale_code = tmp___0;
  alloc_name_converted = (char *)((void *)0);
  alloc_name_converted_translit = (char *)((void *)0);
  name_converted = (char const *)((void *)0);
  name_converted_translit = (char const *)((void *)0);
  tmp___7 = c_strcasecmp(locale_code, (char const *)"UTF-8");
  }
  if (tmp___7 != 0) {
    {
    {
    alloc_name_converted = xstr_iconv(name_utf8, (char const *)"UTF-8", locale_code);
    name_converted = (char const *)alloc_name_converted;
    tmp___1 = strlen(locale_code);
    len = tmp___1;
    }
    if (sizeof(char ) == 1UL) {
      {
      {
      tmp___2 = xmalloc((len + 10UL) + 1UL);
      tmp___4 = tmp___2;
      }
      }
    } else {
      {
      {
      tmp___3 = xnmalloc((len + 10UL) + 1UL, sizeof(char ));
      tmp___4 = tmp___3;
      }
      }
    }
    {
    locale_code_translit = (char *)tmp___4;
    memcpy((void *)((void * __restrict )locale_code_translit), (void const *)((void const * __restrict )locale_code),
           len);
    memcpy((void *)((void * __restrict )(locale_code_translit + len)), (void const *)((void const * __restrict )"//TRANSLIT"),
           (size_t )11);
    converted_translit = xstr_iconv(name_utf8, (char const *)"UTF-8", (char const *)locale_code_translit);
    free((void *)locale_code_translit);
    }
    if ((unsigned long )converted_translit != (unsigned long )((void *)0)) {
      {
      {
      tmp___6 = __builtin_strchr(converted_translit, '?');
      }
      if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
        {
        {
        free((void *)converted_translit);
        }
        }
      } else {
        {
        {
        alloc_name_converted_translit = converted_translit;
        name_converted_translit = (char const *)alloc_name_converted_translit;
        }
        }
      }
      }
    }
    }
  } else {
    {
    {
    name_converted = name_utf8;
    name_converted_translit = name_utf8;
    }
    }
  }
  if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
    {
    {
    name = name_converted;
    }
    }
  } else {
    {
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
      {
      {
      tmp___8 = name_converted_translit;
      }
      }
    } else {
      {
      {
      tmp___8 = name_ascii;
      }
      }
    }
    {
    name = tmp___8;
    }
    }
  }
  if (0) {
    {
    {
    __s1_len = __builtin_strlen(translation);
    __s2_len = __builtin_strlen(name_ascii);
    }
    if (! ((size_t )((void const *)(translation + 1)) - (size_t )((void const *)translation) == 1UL)) {
      {
      goto _L___3;
      }
    } else {
      {
      if (__s1_len >= 4UL) {
        {
        _L___3:
        if (! ((size_t )((void const *)(name_ascii + 1)) - (size_t )((void const *)name_ascii) == 1UL)) {
          {
          {
          tmp___25 = 1;
          }
          }
        } else {
          {
          if (__s2_len >= 4UL) {
            {
            {
            tmp___25 = 1;
            }
            }
          } else {
            {
            {
            tmp___25 = 0;
            }
            }
          }
          }
        }
        }
      } else {
        {
        {
        tmp___25 = 0;
        }
        }
      }
      }
    }
    if (tmp___25) {
      {
      {
      tmp___20 = __builtin_strcmp(translation, name_ascii);
      tmp___24 = tmp___20;
      }
      }
    } else {
      {
      {
      tmp___23 = __builtin_strcmp(translation, name_ascii);
      tmp___24 = tmp___23;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___23 = __builtin_strcmp(translation, name_ascii);
    tmp___24 = tmp___23;
    }
    }
  }
  if (tmp___24 != 0) {
    {
    {
    tmp___16 = mbsstr_trimmed_wordbounded(translation, name_ascii);
    }
    if (tmp___16) {
      {
      goto _L;
      }
    } else {
      {
      if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
        {
        {
        tmp___17 = mbsstr_trimmed_wordbounded(translation, name_converted);
        }
        if (tmp___17) {
          {
          goto _L;
          }
        } else {
          {
          goto _L___1;
          }
        }
        }
      } else {
        {
        _L___1:
        if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
          {
          {
          tmp___18 = mbsstr_trimmed_wordbounded(translation, name_converted_translit);
          }
          if (tmp___18) {
            {
            _L:
            if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
              {
              {
              free((void *)alloc_name_converted);
              }
              }
            }
            if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
              {
              {
              free((void *)alloc_name_converted_translit);
              }
              }
            }
            return (translation);
            }
          } else {
            {
            goto _L___0;
            }
          }
          }
        } else {
          {
          _L___0:
          if (sizeof(char ) == 1UL) {
            {
            {
            tmp___9 = strlen(translation);
            tmp___10 = strlen(name);
            tmp___11 = xmalloc((((tmp___9 + 2UL) + tmp___10) + 1UL) + 1UL);
            tmp___15 = tmp___11;
            }
            }
          } else {
            {
            {
            tmp___12 = strlen(translation);
            tmp___13 = strlen(name);
            tmp___14 = xnmalloc((((tmp___12 + 2UL) + tmp___13) + 1UL) + 1UL, sizeof(char ));
            tmp___15 = tmp___14;
            }
            }
          }
          {
          result = (char *)tmp___15;
          sprintf((char *)((char * __restrict )result), (char const *)((char const * __restrict )"%s (%s)"),
                  translation, name);
          }
          if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
            {
            {
            free((void *)alloc_name_converted);
            }
            }
          }
          if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
            {
            {
            free((void *)alloc_name_converted_translit);
            }
            }
          }
          return ((char const *)result);
          }
        }
        }
      }
      }
    }
    }
  } else {
    {
    if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
      {
      if ((unsigned long )alloc_name_converted != (unsigned long )name) {
        {
        {
        free((void *)alloc_name_converted);
        }
        }
      }
      }
    }
    if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
      {
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )name) {
        {
        {
        free((void *)alloc_name_converted_translit);
        }
        }
      }
      }
    }
    return (name);
    }
  }
}
}
char const *quote_n(int n , char const *name )
{
  char *tmp ;
  {
  {
  tmp = quotearg_n_style(n, (enum quoting_style )6, name);
  }
  return ((char const *)tmp);
}
}
char const *quote(char const *name )
{
  char const *tmp ;
  {
  {
  tmp = quote_n(0, name);
  }
  return (tmp);
}
}
__inline static char *xcharalloc(size_t n ) __attribute__((__malloc__, __alloc_size__(1))) ;
__inline static char *xcharalloc(size_t n )
{
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  {
  if (sizeof(char ) == 1UL) {
    {
    {
    tmp = xmalloc(n);
    tmp___1 = tmp;
    }
    }
  } else {
    {
    {
    tmp___0 = xnmalloc(n, sizeof(char ));
    tmp___1 = tmp___0;
    }
    }
  }
  return ((char *)tmp___1);
}
}
struct quoting_options *clone_quoting_options(struct quoting_options *o )
{
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  {
  {
  tmp = __errno_location();
  e = *tmp;
  }
  if (o) {
    {
    {
    tmp___0 = o;
    }
    }
  } else {
    {
    {
    tmp___0 = & default_quoting_options;
    }
    }
  }
  {
  tmp___1 = xmemdup((void const *)tmp___0, sizeof(*o));
  p = (struct quoting_options *)tmp___1;
  tmp___2 = __errno_location();
  *tmp___2 = e;
  }
  return (p);
}
}
enum quoting_style get_quoting_style(struct quoting_options *o )
{
  struct quoting_options *tmp ;
  {
  if (o) {
    {
    {
    tmp = o;
    }
    }
  } else {
    {
    {
    tmp = & default_quoting_options;
    }
    }
  }
  return (tmp->style);
}
}
void set_quoting_style(struct quoting_options *o , enum quoting_style s )
{
  struct quoting_options *tmp ;
  {
  if (o) {
    {
    {
    tmp = o;
    }
    }
  } else {
    {
    {
    tmp = & default_quoting_options;
    }
    }
  }
  {
  tmp->style = s;
  }
  return;
}
}
int set_char_quoting(struct quoting_options *o , char c , int i )
{
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;
  {
  {
  uc = (unsigned char )c;
  }
  if (o) {
    {
    {
    tmp = o;
    }
    }
  } else {
    {
    {
    tmp = & default_quoting_options;
    }
    }
  }
  {
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
  r = (int )((*p >> shift) & 1U);
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
  }
  return (r);
}
}
int set_quoting_flags(struct quoting_options *o , int i )
{
  int r ;
  {
  if (! o) {
    {
    {
    o = & default_quoting_options;
    }
    }
  }
  {
  r = o->flags;
  o->flags = i;
  }
  return (r);
}
}
void set_custom_quoting(struct quoting_options *o , char const *left_quote , char const *right_quote )
{
  {
  if (! o) {
    {
    {
    o = & default_quoting_options;
    }
    }
  }
  {
  o->style = (enum quoting_style )8;
  }
  if (! left_quote) {
    {
    {
    abort();
    }
    }
  } else {
    {
    if (! right_quote) {
      {
      {
      abort();
      }
      }
    }
    }
  }
  {
  o->left_quote = left_quote;
  o->right_quote = right_quote;
  }
  return;
}
}
static struct quoting_options quoting_options_from_style(enum quoting_style style )
{
  struct quoting_options o ;
  {
  {
  o.style = (enum quoting_style )0;
  { if(!((unsigned int )o.style == 0U)) { reach_error(); abort(); } };
  o.flags = 0;
  { if(!(o.flags == 0)) { reach_error(); abort(); } };
  o.quote_these_too[0] = 0U;
  o.quote_these_too[1] = 0U;
  o.quote_these_too[2] = 0U;
  o.quote_these_too[3] = 0U;
  o.quote_these_too[4] = 0U;
  o.quote_these_too[5] = 0U;
  o.quote_these_too[6] = 0U;
  o.quote_these_too[7] = 0U;
  o.left_quote = (char const *)0;
  { if(!(o.left_quote == 0)) { reach_error(); abort(); } };
  o.right_quote = (char const *)0;
  { if(!(o.right_quote == 0)) { reach_error(); abort(); } };
  }
  if ((unsigned int )style == 8U) {
    {
    {
    abort();
    { if(!(o.flags == 0)) { reach_error(); abort(); } };
    { if(!(o.left_quote == 0)) { reach_error(); abort(); } };
    { if(!(o.right_quote == 0)) { reach_error(); abort(); } };
    { if(!((unsigned int )style == 6U)) { reach_error(); abort(); } };
    { if(!((unsigned int )o.style == 0U)) { reach_error(); abort(); } };
    }
    }
  }
  {
  { if(!(o.flags == 0)) { reach_error(); abort(); } };
  { if(!(o.left_quote == 0)) { reach_error(); abort(); } };
  { if(!(o.right_quote == 0)) { reach_error(); abort(); } };
  { if(!((unsigned int )style == 6U)) { reach_error(); abort(); } };
  { if(!((unsigned int )o.style == 0U)) { reach_error(); abort(); } };
  {
  o.style = style;
  { if(!((unsigned int )o.style == 6U)) { reach_error(); abort(); } };
  }
  }
  return (o);
}
}
static char const *gettext_quote(char const *msgid , enum quoting_style s )
{
  char const *translation ;
  char *tmp ;
  {
  {
  tmp = dcgettext((char const *)((void *)0), msgid, 5);
  translation = (char const *)tmp;
  }
  if ((unsigned long )translation == (unsigned long )msgid) {
    {
    if ((unsigned int )s == 7U) {
      {
      {
      translation = (char const *)"\"";
      }
      }
    }
    }
  }
  return (translation);
}
}
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const *quote_these_too ,
                                       char const *left_quote , char const *right_quote )
{
  size_t i ;
  size_t len ;
  char const *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  int tmp___0 ;
  int tmp___1 ;
  size_t m ;
  _Bool printable ;
  unsigned short const **tmp___2 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___3 ;
  size_t j ;
  int tmp___4 ;
  int tmp___5 ;
  size_t ilim ;
  int tmp___6 ;
  size_t tmp___7 ;
  {
  {
  len = (size_t )0;
  { if(!(len == 0UL)) { reach_error(); abort(); } };
  quote_string = (char const *)0;
  { if(!(quote_string == 0)) { reach_error(); abort(); } };
  quote_string_len = (size_t )0;
  { if(!(quote_string_len == 0UL)) { reach_error(); abort(); } };
  backslash_escapes = (_Bool)0;
  { if(!(backslash_escapes == (_Bool)0)) { reach_error(); abort(); } };
  tmp = __ctype_get_mb_cur_max();
  unibyte_locale = (_Bool )(tmp == 1UL);
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
  }
  {
  if ((int )quoting_style == 4) {
    {
    goto case_4;
    }
  }
  if ((int )quoting_style == 3) {
    {
    goto case_3;
    }
  }
  if ((int )quoting_style == 5) {
    {
    goto case_5;
    }
  }
  if ((int )quoting_style == 8) {
    {
    goto case_8;
    }
  }
  if ((int )quoting_style == 7) {
    {
    goto case_8;
    }
  }
  if ((int )quoting_style == 6) {
    {
    goto case_8;
    }
  }
  if ((int )quoting_style == 1) {
    {
    goto case_1;
    }
  }
  if ((int )quoting_style == 2) {
    {
    goto case_2;
    }
  }
  if ((int )quoting_style == 0) {
    {
    goto case_0;
    }
  }
  goto switch_default;
  case_4:
  {
  quoting_style = (enum quoting_style )3;
  elide_outer_quotes = (_Bool)1;
  }
  case_3:
  if (! elide_outer_quotes) {
    {
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      if (len < buffersize) {
        {
        {
        *(buffer + len) = (char )'\"';
        }
        }
      }
      {
      len ++;
      }
      goto while_break;
    }
    while_break: ;
    }
    }
  }
  {
  backslash_escapes = (_Bool)1;
  quote_string = (char const *)"\"";
  quote_string_len = (size_t )1;
  }
  goto switch_break;
  case_5:
  {
  backslash_escapes = (_Bool)1;
  elide_outer_quotes = (_Bool)0;
  }
  goto switch_break;
  case_8:
  case_7:
  case_6:
  if ((unsigned int )quoting_style != 8U) {
    {
    { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
    {
    left_quote = gettext_quote((char const *)"`", quoting_style);
    right_quote = gettext_quote((char const *)"\'", quoting_style);
    }
    }
  }
  {
  { if(!(argsize == 18446744073709551615UL)) { reach_error(); abort(); } };
  { if(!(flags == 1)) { reach_error(); abort(); } };
  { if(!(len == 0UL)) { reach_error(); abort(); } };
  { if(!(quote_string == 0)) { reach_error(); abort(); } };
  { if(!(quote_string_len == 0UL)) { reach_error(); abort(); } };
  { if(!(backslash_escapes == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
  { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
  if (! elide_outer_quotes) {
    {
    { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
    {
    quote_string = left_quote;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! *quote_string) {
        {
        goto while_break___0;
        }
      }
      {
      while (1) {
        while_continue___1: ;
        if (! 1) {
          {
          goto while_break___1;
          }
        }
        if (len < buffersize) {
          {
          { if(!(buffersize != 0UL)) { reach_error(); abort(); } };
          {
          *(buffer + len) = (char )*quote_string;
          }
          }
        }
        {
        { if(!(argsize == 18446744073709551615UL)) { reach_error(); abort(); } };
        { if(!(flags == 1)) { reach_error(); abort(); } };
        { if(!(quote_string_len == 0UL)) { reach_error(); abort(); } };
        { if(!(backslash_escapes == (_Bool)0)) { reach_error(); abort(); } };
        { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
        { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
        {
        len ++;
        }
        }
        goto while_break___1;
      }
      while_break___1: ;
      }
      {
      quote_string ++;
      }
    }
    while_break___0: ;
    }
    }
  }
  }
  {
  { if(!(argsize == 18446744073709551615UL)) { reach_error(); abort(); } };
  { if(!(flags == 1)) { reach_error(); abort(); } };
  { if(!(quote_string_len == 0UL)) { reach_error(); abort(); } };
  { if(!(backslash_escapes == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
  { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
  {
  backslash_escapes = (_Bool)1;
  { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
  quote_string = right_quote;
  quote_string_len = strlen(quote_string);
  }
  }
  goto switch_break;
  case_1:
  {
  quoting_style = (enum quoting_style )2;
  elide_outer_quotes = (_Bool)1;
  }
  case_2:
  if (! elide_outer_quotes) {
    {
    {
    while (1) {
      while_continue___2: ;
      if (! 1) {
        {
        goto while_break___2;
        }
      }
      if (len < buffersize) {
        {
        {
        *(buffer + len) = (char )'\'';
        }
        }
      }
      {
      len ++;
      }
      goto while_break___2;
    }
    while_break___2: ;
    }
    }
  }
  {
  quote_string = (char const *)"\'";
  quote_string_len = (size_t )1;
  }
  goto switch_break;
  case_0:
  {
  elide_outer_quotes = (_Bool)0;
  }
  goto switch_break;
  switch_default:
  {
  abort();
  }
  switch_break: ;
  }
  {
  i = (size_t )0;
  }
  {
  while (1) {
    while_continue___3: ;
    if (! 1) {
      {
      goto while_break___3;
      }
    }
    if (argsize == 0xffffffffffffffffUL) {
      {
      { if(!(argsize == 18446744073709551615UL)) { reach_error(); abort(); } };
      {
      tmp___6 = (int const )*(arg + i) == 0;
      }
      }
    } else {
      {
      { if(!(argsize != 18446744073709551615UL)) { reach_error(); abort(); } };
      {
      tmp___6 = i == argsize;
      }
      }
    }
    {
    { if(!(flags == 1)) { reach_error(); abort(); } };
    { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
    { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
    { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
    if (tmp___6) {
      {
      goto while_break___3;
      }
    }
    }
    {
    is_right_quote = (_Bool)0;
    { if(!(is_right_quote == (_Bool)0)) { reach_error(); abort(); } };
    }
    if (backslash_escapes) {
      {
      { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
      if (quote_string_len) {
        {
        { if(!(quote_string_len != 0UL)) { reach_error(); abort(); } };
        if (i + quote_string_len <= argsize) {
          {
          { if(!(quote_string_len != 0UL)) { reach_error(); abort(); } };
          {
          tmp___0 = memcmp((void const *)(arg + i), (void const *)quote_string,
                           quote_string_len);
          }
          if (tmp___0 == 0) {
            {
            { if(!(tmp___0 == 0)) { reach_error(); abort(); } };
            if (elide_outer_quotes) {
              {
              goto force_outer_quoting_style;
              }
            }
            {
            is_right_quote = (_Bool)1;
            }
            }
          }
          }
        }
        }
      }
      }
    }
    {
    c = (unsigned char )*(arg + i);
    }
    {
    if ((int )c == 0) {
      {
      goto case_0___0;
      }
    }
    if ((int )c == 63) {
      {
      goto case_63;
      }
    }
    if ((int )c == 7) {
      {
      goto case_7___0;
      }
    }
    if ((int )c == 8) {
      {
      goto case_8___0;
      }
    }
    if ((int )c == 12) {
      {
      goto case_12;
      }
    }
    if ((int )c == 10) {
      {
      goto case_10;
      }
    }
    if ((int )c == 13) {
      {
      goto case_13;
      }
    }
    if ((int )c == 9) {
      {
      goto case_9;
      }
    }
    if ((int )c == 11) {
      {
      goto case_11;
      }
    }
    if ((int )c == 92) {
      {
      goto case_92;
      }
    }
    if ((int )c == 125) {
      {
      goto case_125;
      }
    }
    if ((int )c == 123) {
      {
      goto case_125;
      }
    }
    if ((int )c == 126) {
      {
      goto case_126;
      }
    }
    if ((int )c == 35) {
      {
      goto case_126;
      }
    }
    if ((int )c == 124) {
      {
      goto case_124;
      }
    }
    if ((int )c == 96) {
      {
      goto case_124;
      }
    }
    if ((int )c == 94) {
      {
      goto case_124;
      }
    }
    if ((int )c == 91) {
      {
      goto case_124;
      }
    }
    if ((int )c == 62) {
      {
      goto case_124;
      }
    }
    if ((int )c == 61) {
      {
      goto case_124;
      }
    }
    if ((int )c == 60) {
      {
      goto case_124;
      }
    }
    if ((int )c == 59) {
      {
      goto case_124;
      }
    }
    if ((int )c == 42) {
      {
      goto case_124;
      }
    }
    if ((int )c == 41) {
      {
      goto case_124;
      }
    }
    if ((int )c == 40) {
      {
      goto case_124;
      }
    }
    if ((int )c == 38) {
      {
      goto case_124;
      }
    }
    if ((int )c == 36) {
      {
      goto case_124;
      }
    }
    if ((int )c == 34) {
      {
      goto case_124;
      }
    }
    if ((int )c == 33) {
      {
      goto case_124;
      }
    }
    if ((int )c == 32) {
      {
      goto case_124;
      }
    }
    if ((int )c == 39) {
      {
      goto case_39___0;
      }
    }
    if ((int )c == 122) {
      {
      goto case_122;
      }
    }
    if ((int )c == 121) {
      {
      goto case_122;
      }
    }
    if ((int )c == 120) {
      {
      goto case_122;
      }
    }
    if ((int )c == 119) {
      {
      goto case_122;
      }
    }
    if ((int )c == 118) {
      {
      goto case_122;
      }
    }
    if ((int )c == 117) {
      {
      goto case_122;
      }
    }
    if ((int )c == 116) {
      {
      goto case_122;
      }
    }
    if ((int )c == 115) {
      {
      goto case_122;
      }
    }
    if ((int )c == 114) {
      {
      goto case_122;
      }
    }
    if ((int )c == 113) {
      {
      goto case_122;
      }
    }
    if ((int )c == 112) {
      {
      goto case_122;
      }
    }
    if ((int )c == 111) {
      {
      goto case_122;
      }
    }
    if ((int )c == 110) {
      {
      goto case_122;
      }
    }
    if ((int )c == 109) {
      {
      goto case_122;
      }
    }
    if ((int )c == 108) {
      {
      goto case_122;
      }
    }
    if ((int )c == 107) {
      {
      goto case_122;
      }
    }
    if ((int )c == 106) {
      {
      goto case_122;
      }
    }
    if ((int )c == 105) {
      {
      goto case_122;
      }
    }
    if ((int )c == 104) {
      {
      goto case_122;
      }
    }
    if ((int )c == 103) {
      {
      goto case_122;
      }
    }
    if ((int )c == 102) {
      {
      goto case_122;
      }
    }
    if ((int )c == 101) {
      {
      goto case_122;
      }
    }
    if ((int )c == 100) {
      {
      goto case_122;
      }
    }
    if ((int )c == 99) {
      {
      goto case_122;
      }
    }
    if ((int )c == 98) {
      {
      goto case_122;
      }
    }
    if ((int )c == 97) {
      {
      goto case_122;
      }
    }
    if ((int )c == 95) {
      {
      goto case_122;
      }
    }
    if ((int )c == 93) {
      {
      goto case_122;
      }
    }
    if ((int )c == 90) {
      {
      goto case_122;
      }
    }
    if ((int )c == 89) {
      {
      goto case_122;
      }
    }
    if ((int )c == 88) {
      {
      goto case_122;
      }
    }
    if ((int )c == 87) {
      {
      goto case_122;
      }
    }
    if ((int )c == 86) {
      {
      goto case_122;
      }
    }
    if ((int )c == 85) {
      {
      goto case_122;
      }
    }
    if ((int )c == 84) {
      {
      goto case_122;
      }
    }
    if ((int )c == 83) {
      {
      goto case_122;
      }
    }
    if ((int )c == 82) {
      {
      goto case_122;
      }
    }
    if ((int )c == 81) {
      {
      goto case_122;
      }
    }
    if ((int )c == 80) {
      {
      goto case_122;
      }
    }
    if ((int )c == 79) {
      {
      goto case_122;
      }
    }
    if ((int )c == 78) {
      {
      goto case_122;
      }
    }
    if ((int )c == 77) {
      {
      goto case_122;
      }
    }
    if ((int )c == 76) {
      {
      goto case_122;
      }
    }
    if ((int )c == 75) {
      {
      goto case_122;
      }
    }
    if ((int )c == 74) {
      {
      goto case_122;
      }
    }
    if ((int )c == 73) {
      {
      goto case_122;
      }
    }
    if ((int )c == 72) {
      {
      goto case_122;
      }
    }
    if ((int )c == 71) {
      {
      goto case_122;
      }
    }
    if ((int )c == 70) {
      {
      goto case_122;
      }
    }
    if ((int )c == 69) {
      {
      goto case_122;
      }
    }
    if ((int )c == 68) {
      {
      goto case_122;
      }
    }
    if ((int )c == 67) {
      {
      goto case_122;
      }
    }
    if ((int )c == 66) {
      {
      goto case_122;
      }
    }
    if ((int )c == 65) {
      {
      goto case_122;
      }
    }
    if ((int )c == 58) {
      {
      goto case_122;
      }
    }
    if ((int )c == 57) {
      {
      goto case_122;
      }
    }
    if ((int )c == 56) {
      {
      goto case_122;
      }
    }
    if ((int )c == 55) {
      {
      goto case_122;
      }
    }
    if ((int )c == 54) {
      {
      goto case_122;
      }
    }
    if ((int )c == 53) {
      {
      goto case_122;
      }
    }
    if ((int )c == 52) {
      {
      goto case_122;
      }
    }
    if ((int )c == 51) {
      {
      goto case_122;
      }
    }
    if ((int )c == 50) {
      {
      goto case_122;
      }
    }
    if ((int )c == 49) {
      {
      goto case_122;
      }
    }
    if ((int )c == 48) {
      {
      goto case_122;
      }
    }
    if ((int )c == 47) {
      {
      goto case_122;
      }
    }
    if ((int )c == 46) {
      {
      goto case_122;
      }
    }
    if ((int )c == 45) {
      {
      goto case_122;
      }
    }
    if ((int )c == 44) {
      {
      goto case_122;
      }
    }
    if ((int )c == 43) {
      {
      goto case_122;
      }
    }
    if ((int )c == 37) {
      {
      goto case_122;
      }
    }
    goto switch_default___2;
    case_0___0:
    if (backslash_escapes) {
      {
      { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
      if (elide_outer_quotes) {
        {
        goto force_outer_quoting_style;
        }
      }
      {
      while (1) {
        while_continue___4: ;
        if (! 1) {
          {
          goto while_break___4;
          }
        }
        if (len < buffersize) {
          {
          { if(!(buffersize != 0UL)) { reach_error(); abort(); } };
          {
          *(buffer + len) = (char )'\\';
          }
          }
        }
        {
        { if(!(flags == 1)) { reach_error(); abort(); } };
        { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
        { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
        { if(!(c == (unsigned char)0)) { reach_error(); abort(); } };
        { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
        { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
        {
        len ++;
        }
        }
        goto while_break___4;
      }
      while_break___4: ;
      }
      if (i + 1UL < argsize) {
        {
        { if(!(argsize != 0UL)) { reach_error(); abort(); } };
        if (48 <= (int )*(arg + (i + 1UL))) {
          {
          if ((int const )*(arg + (i + 1UL)) <= 57) {
            {
            {
            while (1) {
              while_continue___5: ;
              if (! 1) {
                {
                goto while_break___5;
                }
              }
              if (len < buffersize) {
                {
                { if(!(buffersize != 0UL)) { reach_error(); abort(); } };
                {
                *(buffer + len) = (char )'0';
                }
                }
              }
              {
              { if(!(flags == 1)) { reach_error(); abort(); } };
              { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
              { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
              { if(!(c == (unsigned char)0)) { reach_error(); abort(); } };
              { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
              { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
              { if(!(argsize != 0UL)) { reach_error(); abort(); } };
              {
              len ++;
              }
              }
              goto while_break___5;
            }
            while_break___5: ;
            }
            {
            while (1) {
              while_continue___6: ;
              if (! 1) {
                {
                goto while_break___6;
                }
              }
              if (len < buffersize) {
                {
                { if(!(buffersize != 0UL)) { reach_error(); abort(); } };
                {
                *(buffer + len) = (char )'0';
                }
                }
              }
              {
              { if(!(flags == 1)) { reach_error(); abort(); } };
              { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
              { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
              { if(!(c == (unsigned char)0)) { reach_error(); abort(); } };
              { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
              { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
              { if(!(argsize != 0UL)) { reach_error(); abort(); } };
              {
              len ++;
              }
              }
              goto while_break___6;
            }
            while_break___6: ;
            }
            }
          }
          }
        }
        }
      }
      {
      c = (unsigned char )'0';
      }
      }
    } else {
      {
      if (flags & 1) {
        {
        goto __Cont;
        }
      }
      }
    }
    goto switch_break___0;
    case_63:
    {
    if ((int )quoting_style == 2) {
      {
      goto case_2___0;
      }
    }
    if ((int )quoting_style == 3) {
      {
      goto case_3___0;
      }
    }
    goto switch_default___1;
    case_2___0:
    if (elide_outer_quotes) {
      {
      goto force_outer_quoting_style;
      }
    }
    goto switch_break___1;
    case_3___0:
    if (flags & 4) {
      {
      if (i + 2UL < argsize) {
        {
        if ((int const )*(arg + (i + 1UL)) == 63) {
          {
          {
          if ((int )*(arg + (i + 2UL)) == 62) {
            {
            goto case_62;
            }
          }
          if ((int )*(arg + (i + 2UL)) == 61) {
            {
            goto case_62;
            }
          }
          if ((int )*(arg + (i + 2UL)) == 60) {
            {
            goto case_62;
            }
          }
          if ((int )*(arg + (i + 2UL)) == 47) {
            {
            goto case_62;
            }
          }
          if ((int )*(arg + (i + 2UL)) == 45) {
            {
            goto case_62;
            }
          }
          if ((int )*(arg + (i + 2UL)) == 41) {
            {
            goto case_62;
            }
          }
          if ((int )*(arg + (i + 2UL)) == 40) {
            {
            goto case_62;
            }
          }
          if ((int )*(arg + (i + 2UL)) == 39) {
            {
            goto case_62;
            }
          }
          if ((int )*(arg + (i + 2UL)) == 33) {
            {
            goto case_62;
            }
          }
          goto switch_default___0;
          case_62:
          case_61:
          case_60:
          case_47:
          case_45:
          case_41:
          case_40:
          case_39:
          case_33:
          if (elide_outer_quotes) {
            {
            goto force_outer_quoting_style;
            }
          }
          {
          c = (unsigned char )*(arg + (i + 2UL));
          i += 2UL;
          }
          {
          while (1) {
            while_continue___7: ;
            if (! 1) {
              {
              goto while_break___7;
              }
            }
            if (len < buffersize) {
              {
              {
              *(buffer + len) = (char )'?';
              }
              }
            }
            {
            len ++;
            }
            goto while_break___7;
          }
          while_break___7: ;
          }
          {
          while (1) {
            while_continue___8: ;
            if (! 1) {
              {
              goto while_break___8;
              }
            }
            if (len < buffersize) {
              {
              {
              *(buffer + len) = (char )'\"';
              }
              }
            }
            {
            len ++;
            }
            goto while_break___8;
          }
          while_break___8: ;
          }
          {
          while (1) {
            while_continue___9: ;
            if (! 1) {
              {
              goto while_break___9;
              }
            }
            if (len < buffersize) {
              {
              {
              *(buffer + len) = (char )'\"';
              }
              }
            }
            {
            len ++;
            }
            goto while_break___9;
          }
          while_break___9: ;
          }
          {
          while (1) {
            while_continue___10: ;
            if (! 1) {
              {
              goto while_break___10;
              }
            }
            if (len < buffersize) {
              {
              {
              *(buffer + len) = (char )'?';
              }
              }
            }
            {
            len ++;
            }
            goto while_break___10;
          }
          while_break___10: ;
          }
          goto switch_break___2;
          switch_default___0:
          goto switch_break___2;
          switch_break___2: ;
          }
          }
        }
        }
      }
      }
    }
    goto switch_break___1;
    switch_default___1:
    goto switch_break___1;
    switch_break___1: ;
    }
    goto switch_break___0;
    case_7___0:
    {
    esc = (unsigned char )'a';
    }
    goto c_escape;
    case_8___0:
    {
    esc = (unsigned char )'b';
    }
    goto c_escape;
    case_12:
    {
    esc = (unsigned char )'f';
    }
    goto c_escape;
    case_10:
    {
    esc = (unsigned char )'n';
    }
    goto c_and_shell_escape;
    case_13:
    {
    esc = (unsigned char )'r';
    }
    goto c_and_shell_escape;
    case_9:
    {
    esc = (unsigned char )'t';
    }
    goto c_and_shell_escape;
    case_11:
    {
    esc = (unsigned char )'v';
    }
    goto c_escape;
    case_92:
    {
    esc = c;
    { if(!(esc == (unsigned char)92)) { reach_error(); abort(); } };
    }
    if (backslash_escapes) {
      {
      { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
      if (elide_outer_quotes) {
        {
        if (quote_string_len) {
          {
          goto store_c;
          }
        }
        }
      }
      }
    }
    c_and_shell_escape:
    if ((unsigned int )quoting_style == 2U) {
      {
      if (elide_outer_quotes) {
        {
        goto force_outer_quoting_style;
        }
      }
      }
    }
    c_escape:
    if (backslash_escapes) {
      {
      { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
      {
      c = esc;
      }
      goto store_escape;
      }
    }
    goto switch_break___0;
    case_125:
    case_123:
    {
    { if(!(flags == 1)) { reach_error(); abort(); } };
    { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
    { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
    { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
    { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)0)) { reach_error(); abort(); } };
    if (argsize == 0xffffffffffffffffUL) {
      {
      { if(!(argsize == 18446744073709551615UL)) { reach_error(); abort(); } };
      {
      tmp___1 = (int const )*(arg + 1) == 0;
      }
      }
    } else {
      {
      { if(!(argsize != 18446744073709551615UL)) { reach_error(); abort(); } };
      {
      tmp___1 = argsize == 1UL;
      }
      }
    }
    }
    {
    { if(!(flags == 1)) { reach_error(); abort(); } };
    { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
    { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
    { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
    { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)0)) { reach_error(); abort(); } };
    if (! tmp___1) {
      {
      goto switch_break___0;
      }
    }
    }
    case_126:
    case_35:
    if (i != 0UL) {
      {
      goto switch_break___0;
      }
    }
    case_124:
    case_96:
    case_94:
    case_91:
    case_62___0:
    case_61___0:
    case_60___0:
    case_59:
    case_42:
    case_41___0:
    case_40___0:
    case_38:
    case_36:
    case_34:
    case_33___0:
    case_32:
    if ((unsigned int )quoting_style == 2U) {
      {
      if (elide_outer_quotes) {
        {
        goto force_outer_quoting_style;
        }
      }
      }
    }
    goto switch_break___0;
    case_39___0:
    if ((unsigned int )quoting_style == 2U) {
      {
      if (elide_outer_quotes) {
        {
        goto force_outer_quoting_style;
        }
      }
      {
      while (1) {
        while_continue___11: ;
        if (! 1) {
          {
          goto while_break___11;
          }
        }
        if (len < buffersize) {
          {
          {
          *(buffer + len) = (char )'\'';
          }
          }
        }
        {
        len ++;
        }
        goto while_break___11;
      }
      while_break___11: ;
      }
      {
      while (1) {
        while_continue___12: ;
        if (! 1) {
          {
          goto while_break___12;
          }
        }
        if (len < buffersize) {
          {
          {
          *(buffer + len) = (char )'\\';
          }
          }
        }
        {
        len ++;
        }
        goto while_break___12;
      }
      while_break___12: ;
      }
      {
      while (1) {
        while_continue___13: ;
        if (! 1) {
          {
          goto while_break___13;
          }
        }
        if (len < buffersize) {
          {
          {
          *(buffer + len) = (char )'\'';
          }
          }
        }
        {
        len ++;
        }
        goto while_break___13;
      }
      while_break___13: ;
      }
      }
    }
    goto switch_break___0;
    case_122:
    case_121:
    case_120:
    case_119:
    case_118:
    case_117:
    case_116:
    case_115:
    case_114:
    case_113:
    case_112:
    case_111:
    case_110:
    case_109:
    case_108:
    case_107:
    case_106:
    case_105:
    case_104:
    case_103:
    case_102:
    case_101:
    case_100:
    case_99:
    case_98:
    case_97:
    case_95:
    case_93:
    case_90:
    case_89:
    case_88:
    case_87:
    case_86:
    case_85:
    case_84:
    case_83:
    case_82:
    case_81:
    case_80:
    case_79:
    case_78:
    case_77:
    case_76:
    case_75:
    case_74:
    case_73:
    case_72:
    case_71:
    case_70:
    case_69:
    case_68:
    case_67:
    case_66:
    case_65:
    case_58:
    case_57:
    case_56:
    case_55:
    case_54:
    case_53:
    case_52:
    case_51:
    case_50:
    case_49:
    case_48:
    case_47___0:
    case_46:
    case_45___0:
    case_44:
    case_43:
    case_37:
    goto switch_break___0;
    switch_default___2:
    if (unibyte_locale) {
      {
      { if(!(unibyte_locale != (_Bool)0)) { reach_error(); abort(); } };
      {
      m = (size_t )1;
      { if(!(m == 1UL)) { reach_error(); abort(); } };
      tmp___2 = __ctype_b_loc();
      printable = (_Bool )(((int const )*(*tmp___2 + (int )c) & 16384) != 0);
      }
      }
    } else {
      {
      { if(!(unibyte_locale == (_Bool)0)) { reach_error(); abort(); } };
      {
      memset((void *)(& mbstate), 0, sizeof(mbstate));
      { if(!(flags == 1)) { reach_error(); abort(); } };
      { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
      { if(!(unibyte_locale == (_Bool)0)) { reach_error(); abort(); } };
      { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
      { if(!(mbstate.__count == 0)) { reach_error(); abort(); } };
      { if(!(mbstate.__value.__wch == 0U)) { reach_error(); abort(); } };
      { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
      { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)0)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)7)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)8)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)9)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)10)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)11)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)12)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)13)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)32)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)33)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)34)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)35)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)36)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)37)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)38)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)39)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)40)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)41)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)42)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)43)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)44)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)45)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)46)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)47)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)48)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)49)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)50)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)51)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)52)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)53)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)54)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)55)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)56)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)57)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)58)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)59)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)60)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)61)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)62)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)63)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)65)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)66)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)67)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)68)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)69)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)70)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)71)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)72)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)73)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)74)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)75)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)76)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)77)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)78)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)79)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)80)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)81)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)82)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)83)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)84)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)85)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)86)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)87)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)88)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)89)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)90)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)91)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)92)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)93)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)94)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)95)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)96)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)97)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)98)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)99)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)100)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)101)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)102)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)103)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)104)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)105)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)106)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)107)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)108)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)109)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)110)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)111)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)112)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)113)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)114)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)115)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)116)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)117)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)118)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)119)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)120)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)121)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)122)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)123)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)124)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)125)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)126)) { reach_error(); abort(); } };
      m = (size_t )0;
      { if(!(m == 0UL)) { reach_error(); abort(); } };
      printable = (_Bool)1;
      { if(!(printable == (_Bool)1)) { reach_error(); abort(); } };
      }
      if (argsize == 0xffffffffffffffffUL) {
        {
        { if(!(argsize == 18446744073709551615UL)) { reach_error(); abort(); } };
        {
        argsize = strlen(arg);
        }
        }
      }
      {
      { if(!(flags == 1)) { reach_error(); abort(); } };
      { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
      { if(!(unibyte_locale == (_Bool)0)) { reach_error(); abort(); } };
      { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
      { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
      { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)0)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)7)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)8)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)9)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)10)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)11)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)12)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)13)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)32)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)33)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)34)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)35)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)36)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)37)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)38)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)39)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)40)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)41)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)42)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)43)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)44)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)45)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)46)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)47)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)48)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)49)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)50)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)51)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)52)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)53)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)54)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)55)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)56)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)57)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)58)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)59)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)60)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)61)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)62)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)63)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)65)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)66)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)67)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)68)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)69)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)70)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)71)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)72)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)73)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)74)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)75)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)76)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)77)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)78)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)79)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)80)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)81)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)82)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)83)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)84)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)85)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)86)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)87)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)88)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)89)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)90)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)91)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)92)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)93)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)94)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)95)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)96)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)97)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)98)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)99)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)100)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)101)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)102)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)103)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)104)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)105)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)106)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)107)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)108)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)109)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)110)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)111)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)112)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)113)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)114)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)115)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)116)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)117)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)118)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)119)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)120)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)121)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)122)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)123)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)124)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)125)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)126)) { reach_error(); abort(); } };
      {
      while (1) {
        while_continue___14: ;
        if (! 1) {
          {
          goto while_break___14;
          }
        }
        {
        tmp___3 = mbrtowc((wchar_t * __restrict )(& w), (char const * __restrict )(arg + (i + m)),
                          argsize - (i + m), & mbstate);
        bytes = tmp___3;
        }
        if (bytes == 0UL) {
          {
          goto while_break___14;
          }
        } else {
          {
          { if(!(bytes != 0UL)) { reach_error(); abort(); } };
          if (bytes == 0xffffffffffffffffUL) {
            {
            { if(!(bytes == 18446744073709551615UL)) { reach_error(); abort(); } };
            {
            printable = (_Bool)0;
            }
            goto while_break___14;
            }
          } else {
            {
            { if(!(bytes != 0UL)) { reach_error(); abort(); } };
            { if(!(bytes != 18446744073709551615UL)) { reach_error(); abort(); } };
            if (bytes == 0xfffffffffffffffeUL) {
              {
              { if(!(bytes == 18446744073709551614UL)) { reach_error(); abort(); } };
              {
              printable = (_Bool)0;
              { if(!(printable == (_Bool)0)) { reach_error(); abort(); } };
              }
              {
              while (1) {
                while_continue___15: ;
                if (! 1) {
                  {
                  goto while_break___15;
                  }
                }
                if (i + m < argsize) {
                  {
                  { if(!(argsize != 0UL)) { reach_error(); abort(); } };
                  if (! *(arg + (i + m))) {
                    {
                    goto while_break___15;
                    }
                  }
                  }
                } else {
                  {
                  goto while_break___15;
                  }
                }
                {
                m ++;
                }
              }
              while_break___15: ;
              }
              goto while_break___14;
              }
            } else {
              {
              { if(!(bytes != 0UL)) { reach_error(); abort(); } };
              { if(!(bytes != 18446744073709551614UL)) { reach_error(); abort(); } };
              { if(!(bytes != 18446744073709551615UL)) { reach_error(); abort(); } };
              if (elide_outer_quotes) {
                {
                if ((unsigned int )quoting_style == 2U) {
                  {
                  {
                  j = (size_t )1;
                  }
                  {
                  while (1) {
                    while_continue___16: ;
                    if (! (j < bytes)) {
                      {
                      goto while_break___16;
                      }
                    }
                    {
                    if ((int )*(arg + ((i + m) + j)) == 124) {
                      {
                      goto case_124___0;
                      }
                    }
                    if ((int )*(arg + ((i + m) + j)) == 96) {
                      {
                      goto case_124___0;
                      }
                    }
                    if ((int )*(arg + ((i + m) + j)) == 94) {
                      {
                      goto case_124___0;
                      }
                    }
                    if ((int )*(arg + ((i + m) + j)) == 92) {
                      {
                      goto case_124___0;
                      }
                    }
                    if ((int )*(arg + ((i + m) + j)) == 91) {
                      {
                      goto case_124___0;
                      }
                    }
                    goto switch_default___3;
                    case_124___0:
                    case_96___0:
                    case_94___0:
                    case_92___0:
                    case_91___0:
                    goto force_outer_quoting_style;
                    switch_default___3:
                    goto switch_break___3;
                    switch_break___3: ;
                    }
                    {
                    j ++;
                    }
                  }
                  while_break___16: ;
                  }
                  }
                }
                }
              }
              {
              tmp___4 = iswprint((wint_t )w);
              }
              if (! tmp___4) {
                {
                { if(!(tmp___4 == 0)) { reach_error(); abort(); } };
                {
                printable = (_Bool)0;
                }
                }
              }
              {
              { if(!(flags == 1)) { reach_error(); abort(); } };
              { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
              { if(!(unibyte_locale == (_Bool)0)) { reach_error(); abort(); } };
              { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
              { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
              { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)0)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)7)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)8)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)9)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)10)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)11)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)12)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)13)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)32)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)33)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)34)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)35)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)36)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)37)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)38)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)39)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)40)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)41)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)42)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)43)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)44)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)45)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)46)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)47)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)48)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)49)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)50)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)51)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)52)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)53)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)54)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)55)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)56)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)57)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)58)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)59)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)60)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)61)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)62)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)63)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)65)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)66)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)67)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)68)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)69)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)70)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)71)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)72)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)73)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)74)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)75)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)76)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)77)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)78)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)79)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)80)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)81)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)82)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)83)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)84)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)85)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)86)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)87)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)88)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)89)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)90)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)91)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)92)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)93)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)94)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)95)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)96)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)97)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)98)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)99)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)100)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)101)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)102)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)103)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)104)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)105)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)106)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)107)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)108)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)109)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)110)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)111)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)112)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)113)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)114)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)115)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)116)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)117)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)118)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)119)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)120)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)121)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)122)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)123)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)124)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)125)) { reach_error(); abort(); } };
              { if(!(c != (unsigned char)126)) { reach_error(); abort(); } };
              { if(!(bytes != 0UL)) { reach_error(); abort(); } };
              { if(!(bytes != 18446744073709551614UL)) { reach_error(); abort(); } };
              { if(!(bytes != 18446744073709551615UL)) { reach_error(); abort(); } };
              {
              m += bytes;
              }
              }
              }
            }
            }
          }
          }
        }
        {
        tmp___5 = mbsinit((mbstate_t const *)(& mbstate));
        }
        if (tmp___5) {
          {
          goto while_break___14;
          }
        }
      }
      while_break___14: ;
      }
      }
      }
    }
    {
    { if(!(flags == 1)) { reach_error(); abort(); } };
    { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
    { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
    { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
    { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)0)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)7)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)8)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)9)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)10)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)11)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)12)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)13)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)32)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)33)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)34)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)35)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)36)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)37)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)38)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)39)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)40)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)41)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)42)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)43)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)44)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)45)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)46)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)47)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)48)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)49)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)50)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)51)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)52)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)53)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)54)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)55)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)56)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)57)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)58)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)59)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)60)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)61)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)62)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)63)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)65)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)66)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)67)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)68)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)69)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)70)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)71)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)72)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)73)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)74)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)75)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)76)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)77)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)78)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)79)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)80)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)81)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)82)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)83)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)84)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)85)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)86)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)87)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)88)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)89)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)90)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)91)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)92)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)93)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)94)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)95)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)96)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)97)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)98)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)99)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)100)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)101)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)102)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)103)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)104)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)105)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)106)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)107)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)108)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)109)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)110)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)111)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)112)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)113)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)114)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)115)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)116)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)117)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)118)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)119)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)120)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)121)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)122)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)123)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)124)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)125)) { reach_error(); abort(); } };
    { if(!(c != (unsigned char)126)) { reach_error(); abort(); } };
    if (1UL < m) {
      {
      goto _L___0;
      }
    } else {
      {
      if (backslash_escapes) {
        {
        { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
        if (! printable) {
          {
          _L___0:
          {
          { if(!(flags == 1)) { reach_error(); abort(); } };
          { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
          { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
          { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
          { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)0)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)7)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)8)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)9)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)10)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)11)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)12)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)13)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)32)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)33)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)34)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)35)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)36)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)37)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)38)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)39)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)40)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)41)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)42)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)43)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)44)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)45)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)46)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)47)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)48)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)49)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)50)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)51)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)52)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)53)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)54)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)55)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)56)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)57)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)58)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)59)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)60)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)61)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)62)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)63)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)65)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)66)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)67)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)68)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)69)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)70)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)71)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)72)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)73)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)74)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)75)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)76)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)77)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)78)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)79)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)80)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)81)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)82)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)83)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)84)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)85)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)86)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)87)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)88)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)89)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)90)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)91)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)92)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)93)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)94)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)95)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)96)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)97)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)98)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)99)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)100)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)101)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)102)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)103)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)104)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)105)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)106)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)107)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)108)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)109)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)110)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)111)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)112)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)113)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)114)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)115)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)116)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)117)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)118)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)119)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)120)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)121)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)122)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)123)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)124)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)125)) { reach_error(); abort(); } };
          { if(!(c != (unsigned char)126)) { reach_error(); abort(); } };
          {
          ilim = i + m;
          }
          }
          {
          while (1) {
            while_continue___17: ;
            if (! 1) {
              {
              goto while_break___17;
              }
            }
            if (backslash_escapes) {
              {
              { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
              if (! printable) {
                {
                { if(!(printable == (_Bool)0)) { reach_error(); abort(); } };
                if (elide_outer_quotes) {
                  {
                  goto force_outer_quoting_style;
                  }
                }
                {
                while (1) {
                  while_continue___18: ;
                  if (! 1) {
                    {
                    goto while_break___18;
                    }
                  }
                  if (len < buffersize) {
                    {
                    { if(!(buffersize != 0UL)) { reach_error(); abort(); } };
                    {
                    *(buffer + len) = (char )'\\';
                    }
                    }
                  }
                  {
                  { if(!(flags == 1)) { reach_error(); abort(); } };
                  { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
                  { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
                  { if(!(printable == (_Bool)0)) { reach_error(); abort(); } };
                  { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
                  { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
                  {
                  len ++;
                  }
                  }
                  goto while_break___18;
                }
                while_break___18: ;
                }
                {
                while (1) {
                  while_continue___19: ;
                  if (! 1) {
                    {
                    goto while_break___19;
                    }
                  }
                  if (len < buffersize) {
                    {
                    { if(!(buffersize != 0UL)) { reach_error(); abort(); } };
                    {
                    *(buffer + len) = (char )(48 + ((int )c >> 6));
                    }
                    }
                  }
                  {
                  { if(!(flags == 1)) { reach_error(); abort(); } };
                  { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
                  { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
                  { if(!(printable == (_Bool)0)) { reach_error(); abort(); } };
                  { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
                  { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
                  {
                  len ++;
                  }
                  }
                  goto while_break___19;
                }
                while_break___19: ;
                }
                {
                while (1) {
                  while_continue___20: ;
                  if (! 1) {
                    {
                    goto while_break___20;
                    }
                  }
                  if (len < buffersize) {
                    {
                    { if(!(buffersize != 0UL)) { reach_error(); abort(); } };
                    {
                    *(buffer + len) = (char )(48 + (((int )c >> 3) & 7));
                    }
                    }
                  }
                  {
                  { if(!(flags == 1)) { reach_error(); abort(); } };
                  { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
                  { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
                  { if(!(printable == (_Bool)0)) { reach_error(); abort(); } };
                  { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
                  { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
                  {
                  len ++;
                  }
                  }
                  goto while_break___20;
                }
                while_break___20: ;
                }
                {
                c = (unsigned char )(48 + ((int )c & 7));
                }
                }
              } else {
                {
                goto _L;
                }
              }
              }
            } else {
              {
              _L:
              {
              { if(!(flags == 1)) { reach_error(); abort(); } };
              { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
              { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
              { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
              { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
              { if(!(printable != (_Bool)0)) { reach_error(); abort(); } };
              if (is_right_quote) {
                {
                { if(!(is_right_quote != (_Bool)0)) { reach_error(); abort(); } };
                {
                while (1) {
                  while_continue___21: ;
                  if (! 1) {
                    {
                    goto while_break___21;
                    }
                  }
                  if (len < buffersize) {
                    {
                    { if(!(buffersize != 0UL)) { reach_error(); abort(); } };
                    {
                    *(buffer + len) = (char )'\\';
                    }
                    }
                  }
                  {
                  { if(!(flags == 1)) { reach_error(); abort(); } };
                  { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
                  { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
                  { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
                  { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
                  { if(!(is_right_quote != (_Bool)0)) { reach_error(); abort(); } };
                  { if(!(printable != (_Bool)0)) { reach_error(); abort(); } };
                  {
                  len ++;
                  }
                  }
                  goto while_break___21;
                }
                while_break___21: ;
                }
                {
                is_right_quote = (_Bool)0;
                }
                }
              }
              }
              }
            }
            if (ilim <= i + 1UL) {
              {
              goto while_break___17;
              }
            }
            {
            while (1) {
              while_continue___22: ;
              if (! 1) {
                {
                goto while_break___22;
                }
              }
              if (len < buffersize) {
                {
                { if(!(buffersize != 0UL)) { reach_error(); abort(); } };
                {
                *(buffer + len) = (char )c;
                }
                }
              }
              {
              { if(!(flags == 1)) { reach_error(); abort(); } };
              { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
              { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
              { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
              { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
              { if(!(ilim != 0UL)) { reach_error(); abort(); } };
              {
              len ++;
              }
              }
              goto while_break___22;
            }
            while_break___22: ;
            }
            {
            i ++;
            c = (unsigned char )*(arg + i);
            }
          }
          while_break___17: ;
          }
          goto store_c;
          }
        }
        }
      }
      }
    }
    }
    switch_break___0: ;
    }
    if (backslash_escapes) {
      {
      goto _L___3;
      }
    } else {
      {
      if (elide_outer_quotes) {
        {
        _L___3:
        {
        { if(!(flags == 1)) { reach_error(); abort(); } };
        { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
        { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
        { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
        { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
        { if(!(c != (unsigned char)0)) { reach_error(); abort(); } };
        if (quote_these_too) {
          {
          if (! (*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) & (unsigned int const )(1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
            {
            goto _L___2;
            }
          }
          }
        } else {
          {
          goto _L___2;
          }
        }
        }
        }
      } else {
        {
        { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
        _L___2:
        if (! is_right_quote) {
          {
          goto store_c;
          }
        }
        }
      }
      }
    }
    store_escape:
    if (elide_outer_quotes) {
      {
      goto force_outer_quoting_style;
      }
    }
    {
    while (1) {
      while_continue___23: ;
      if (! 1) {
        {
        goto while_break___23;
        }
      }
      if (len < buffersize) {
        {
        { if(!(buffersize != 0UL)) { reach_error(); abort(); } };
        {
        *(buffer + len) = (char )'\\';
        }
        }
      }
      {
      { if(!(flags == 1)) { reach_error(); abort(); } };
      { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
      { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
      { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
      { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
      { if(!(c != (unsigned char)0)) { reach_error(); abort(); } };
      {
      len ++;
      }
      }
      goto while_break___23;
    }
    while_break___23: ;
    }
    store_c:
    {
    while (1) {
      while_continue___24: ;
      if (! 1) {
        {
        goto while_break___24;
        }
      }
      if (len < buffersize) {
        {
        { if(!(buffersize != 0UL)) { reach_error(); abort(); } };
        {
        *(buffer + len) = (char )c;
        }
        }
      }
      {
      { if(!(flags == 1)) { reach_error(); abort(); } };
      { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
      { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
      { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
      { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
      {
      len ++;
      }
      }
      goto while_break___24;
    }
    while_break___24: ;
    }
    __Cont:
    {
    { if(!(flags == 1)) { reach_error(); abort(); } };
    { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
    { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
    { if(!(tmp___6 == 0)) { reach_error(); abort(); } };
    { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
    {
    i ++;
    }
    }
  }
  while_break___3: ;
  }
  if (len == 0UL) {
    {
    { if(!(len == 0UL)) { reach_error(); abort(); } };
    if ((unsigned int )quoting_style == 2U) {
      {
      if (elide_outer_quotes) {
        {
        goto force_outer_quoting_style;
        }
      }
      }
    }
    }
  }
  if (quote_string) {
    {
    if (! elide_outer_quotes) {
      {
      { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
      {
      while (1) {
        while_continue___25: ;
        if (! *quote_string) {
          {
          goto while_break___25;
          }
        }
        {
        while (1) {
          while_continue___26: ;
          if (! 1) {
            {
            goto while_break___26;
            }
          }
          if (len < buffersize) {
            {
            { if(!(buffersize != 0UL)) { reach_error(); abort(); } };
            {
            *(buffer + len) = (char )*quote_string;
            }
            }
          }
          {
          { if(!(flags == 1)) { reach_error(); abort(); } };
          { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
          { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
          { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
          { if(!(tmp___6 != 0)) { reach_error(); abort(); } };
          {
          len ++;
          }
          }
          goto while_break___26;
        }
        while_break___26: ;
        }
        {
        quote_string ++;
        }
      }
      while_break___25: ;
      }
      }
    }
    }
  }
  if (len < buffersize) {
    {
    { if(!(buffersize != 0UL)) { reach_error(); abort(); } };
    {
    *(buffer + len) = (char )'\000';
    }
    }
  }
  {
  { if(!(flags == 1)) { reach_error(); abort(); } };
  { if(!(backslash_escapes == (_Bool)1)) { reach_error(); abort(); } };
  { if(!(elide_outer_quotes == (_Bool)0)) { reach_error(); abort(); } };
  { if(!((unsigned int )quoting_style == 6U)) { reach_error(); abort(); } };
  { if(!(tmp___6 != 0)) { reach_error(); abort(); } };
  return (len);
  }
  force_outer_quoting_style:
  {
  tmp___7 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const *)((void *)0),
                                     left_quote, right_quote);
  }
  return (tmp___7);
}
}
size_t quotearg_buffer(char *buffer , size_t buffersize , char const *arg , size_t argsize ,
                       struct quoting_options const *o )
{
  struct quoting_options const *p ;
  struct quoting_options const *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;
  {
  if (o) {
    {
    {
    tmp = o;
    }
    }
  } else {
    {
    {
    tmp = (struct quoting_options const *)(& default_quoting_options);
    }
    }
  }
  {
  p = tmp;
  tmp___0 = __errno_location();
  e = *tmp___0;
  tmp___1 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const *)(p->quote_these_too),
                                     (char const *)p->left_quote, (char const *)p->right_quote);
  r = tmp___1;
  tmp___2 = __errno_location();
  *tmp___2 = e;
  }
  return (r);
}
}
char *quotearg_alloc(char const *arg , size_t argsize , struct quoting_options const *o )
{
  char *tmp ;
  {
  {
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  }
  return (tmp);
}
}
char *quotearg_alloc_mem(char const *arg , size_t argsize , size_t *size , struct quoting_options const *o )
{
  struct quoting_options const *p ;
  struct quoting_options const *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize___0 ;
  size_t tmp___2 ;
  char *buf___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  {
  if (o) {
    {
    {
    tmp = o;
    }
    }
  } else {
    {
    {
    tmp = (struct quoting_options const *)(& default_quoting_options);
    }
    }
  }
  {
  p = tmp;
  tmp___0 = __errno_location();
  e = *tmp___0;
  }
  if (size) {
    {
    {
    tmp___1 = 0;
    }
    }
  } else {
    {
    {
    tmp___1 = 1;
    }
    }
  }
  {
  flags = (int )(p->flags | (int )((int const )tmp___1));
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const *)(p->quote_these_too),
                                     (char const *)p->left_quote, (char const *)p->right_quote);
  bufsize___0 = tmp___2 + 1UL;
  tmp___3 = xcharalloc(bufsize___0);
  buf___1 = tmp___3;
  quotearg_buffer_restyled(buf___1, bufsize___0, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const *)(p->quote_these_too), (char const *)p->left_quote,
                           (char const *)p->right_quote);
  tmp___4 = __errno_location();
  *tmp___4 = e;
  }
  if (size) {
    {
    {
    *size = bufsize___0 - 1UL;
    }
    }
  }
  return (buf___1);
}
}
void quotearg_free(void)
{
  struct slotvec *sv ;
  unsigned int i ;
  {
  {
  sv = slotvec;
  i = 1U;
  }
  {
  while (1) {
    while_continue: ;
    if (! (i < nslots)) {
      {
      goto while_break;
      }
    }
    {
    free((void *)(sv + i)->val);
    i ++;
    }
  }
  while_break: ;
  }
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
    {
    free((void *)(sv + 0)->val);
    slotvec0.size = sizeof(slot0);
    slotvec0.val = slot0;
    }
    }
  }
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
    {
    free((void *)sv);
    slotvec = & slotvec0;
    }
    }
  }
  {
  nslots = 1U;
  }
  return;
}
}
static char *quotearg_n_options(int n , char const *arg , size_t argsize , struct quoting_options const *options )
{
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;
  {
  {
  tmp = __errno_location();
  e = *tmp;
  n0 = (unsigned int )n;
  { if(!(n0 == 0U)) { reach_error(); abort(); } };
  sv = slotvec;
  { if(!(sv == & slotvec0)) { reach_error(); abort(); } };
  }
  if (n < 0) {
    {
    {
    abort();
    { if(!(n == 0)) { reach_error(); abort(); } };
    { if(!(argsize == 18446744073709551615UL)) { reach_error(); abort(); } };
    { if(!(n0 == 0U)) { reach_error(); abort(); } };
    { if(!(sv == & slotvec0)) { reach_error(); abort(); } };
    { if(!(((struct quoting_options *)options)->flags == 0)) { reach_error(); abort(); } };
    { if(!(((struct quoting_options *)options)->left_quote == 0)) { reach_error(); abort(); } };
    { if(!(((struct quoting_options *)options)->right_quote == 0)) { reach_error(); abort(); } };
    { if(!((unsigned int )((struct quoting_options *)options)->style == 6U)) { reach_error(); abort(); } };
    }
    }
  }
  {
  { if(!(n == 0)) { reach_error(); abort(); } };
  { if(!(argsize == 18446744073709551615UL)) { reach_error(); abort(); } };
  { if(!(n0 == 0U)) { reach_error(); abort(); } };
  { if(!(sv == & slotvec0)) { reach_error(); abort(); } };
  { if(!(((struct quoting_options *)options)->flags == 0)) { reach_error(); abort(); } };
  { if(!(((struct quoting_options *)options)->left_quote == 0)) { reach_error(); abort(); } };
  { if(!(((struct quoting_options *)options)->right_quote == 0)) { reach_error(); abort(); } };
  { if(!((unsigned int )((struct quoting_options *)options)->style == 6U)) { reach_error(); abort(); } };
  if (nslots <= n0) {
    {
    {
    n1 = (size_t )(n0 + 1U);
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
    }
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
      {
      {
      tmp___0 = -1;
      }
      }
    } else {
      {
      {
      tmp___0 = -2;
      }
      }
    }
    if ((size_t )tmp___0 / sizeof(*sv) < n1) {
      {
      {
      xalloc_die();
      }
      }
    }
    if (preallocated) {
      {
      {
      tmp___1 = (struct slotvec *)((void *)0);
      }
      }
    } else {
      {
      {
      tmp___1 = sv;
      }
      }
    }
    {
    tmp___2 = xrealloc((void *)tmp___1, n1 * sizeof(*sv));
    sv = (struct slotvec *)tmp___2;
    slotvec = sv;
    }
    if (preallocated) {
      {
      {
      *sv = slotvec0;
      }
      }
    }
    {
    memset((void *)(sv + nslots), 0, (n1 - (size_t )nslots) * sizeof(*sv));
    nslots = (unsigned int )n1;
    { if(!(nslots == 1U)) { reach_error(); abort(); } };
    }
    }
  }
  }
  {
  { if(!(n == 0)) { reach_error(); abort(); } };
  { if(!(argsize == 18446744073709551615UL)) { reach_error(); abort(); } };
  { if(!(n0 == 0U)) { reach_error(); abort(); } };
  { if(!(sv == & slotvec0)) { reach_error(); abort(); } };
  { if(!(((struct quoting_options *)options)->flags == 0)) { reach_error(); abort(); } };
  { if(!(((struct quoting_options *)options)->left_quote == 0)) { reach_error(); abort(); } };
  { if(!(((struct quoting_options *)options)->right_quote == 0)) { reach_error(); abort(); } };
  { if(!((unsigned int )((struct quoting_options *)options)->style == 6U)) { reach_error(); abort(); } };
  {
  size = (sv + n)->size;
  val = (sv + n)->val;
  flags = (int )(options->flags | 1);
  { if(!(flags == 1)) { reach_error(); abort(); } };
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const *)(options->quote_these_too),
                                     (char const *)options->left_quote, (char const *)options->right_quote);
  qsize = tmp___3;
  }
  }
  if (size <= qsize) {
    {
    {
    size = qsize + 1UL;
    (sv + n)->size = size;
    }
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
      {
      free((void *)val);
      { if(!(n == 0)) { reach_error(); abort(); } };
      { if(!(argsize == 18446744073709551615UL)) { reach_error(); abort(); } };
      { if(!(n0 == 0U)) { reach_error(); abort(); } };
      { if(!(sv == & slotvec0)) { reach_error(); abort(); } };
      { if(!(flags == 1)) { reach_error(); abort(); } };
      { if(!(((struct quoting_options *)options)->flags == 0)) { reach_error(); abort(); } };
      { if(!(((struct quoting_options *)options)->left_quote == 0)) { reach_error(); abort(); } };
      { if(!(((struct quoting_options *)options)->right_quote == 0)) { reach_error(); abort(); } };
      { if(!((unsigned int )((struct quoting_options *)options)->style == 6U)) { reach_error(); abort(); } };
      }
      }
    }
    {
    { if(!(n == 0)) { reach_error(); abort(); } };
    { if(!(argsize == 18446744073709551615UL)) { reach_error(); abort(); } };
    { if(!(n0 == 0U)) { reach_error(); abort(); } };
    { if(!(sv == & slotvec0)) { reach_error(); abort(); } };
    { if(!(flags == 1)) { reach_error(); abort(); } };
    { if(!(((struct quoting_options *)options)->flags == 0)) { reach_error(); abort(); } };
    { if(!(((struct quoting_options *)options)->left_quote == 0)) { reach_error(); abort(); } };
    { if(!(((struct quoting_options *)options)->right_quote == 0)) { reach_error(); abort(); } };
    { if(!((unsigned int )((struct quoting_options *)options)->style == 6U)) { reach_error(); abort(); } };
    {
    val = xcharalloc(size);
    (sv + n)->val = val;
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const *)(options->quote_these_too),
                             (char const *)options->left_quote, (char const *)options->right_quote);
    { if(!(n == 0)) { reach_error(); abort(); } };
    { if(!(argsize == 18446744073709551615UL)) { reach_error(); abort(); } };
    { if(!(n0 == 0U)) { reach_error(); abort(); } };
    { if(!(sv == & slotvec0)) { reach_error(); abort(); } };
    { if(!(flags == 1)) { reach_error(); abort(); } };
    { if(!(((struct quoting_options *)options)->flags == 0)) { reach_error(); abort(); } };
    { if(!(((struct quoting_options *)options)->left_quote == 0)) { reach_error(); abort(); } };
    { if(!(((struct quoting_options *)options)->right_quote == 0)) { reach_error(); abort(); } };
    { if(!((unsigned int )((struct quoting_options *)options)->style == 6U)) { reach_error(); abort(); } };
    }
    }
    }
  }
  {
  { if(!(n == 0)) { reach_error(); abort(); } };
  { if(!(argsize == 18446744073709551615UL)) { reach_error(); abort(); } };
  { if(!(n0 == 0U)) { reach_error(); abort(); } };
  { if(!(sv == & slotvec0)) { reach_error(); abort(); } };
  { if(!(flags == 1)) { reach_error(); abort(); } };
  { if(!(((struct quoting_options *)options)->flags == 0)) { reach_error(); abort(); } };
  { if(!(((struct quoting_options *)options)->left_quote == 0)) { reach_error(); abort(); } };
  { if(!(((struct quoting_options *)options)->right_quote == 0)) { reach_error(); abort(); } };
  { if(!((unsigned int )((struct quoting_options *)options)->style == 6U)) { reach_error(); abort(); } };
  {
  tmp___4 = __errno_location();
  *tmp___4 = e;
  }
  }
  return (val);
}
}
char *quotearg_n(int n , char const *arg )
{
  char *tmp ;
  {
  {
  tmp = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options const *)(& default_quoting_options));
  }
  return (tmp);
}
}
char *quotearg_n_mem(int n , char const *arg , size_t argsize )
{
  char *tmp ;
  {
  {
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options const *)(& default_quoting_options));
  }
  return (tmp);
}
}
char *quotearg(char const *arg )
{
  char *tmp ;
  {
  {
  tmp = quotearg_n(0, arg);
  }
  return (tmp);
}
}
char *quotearg_mem(char const *arg , size_t argsize )
{
  char *tmp ;
  {
  {
  tmp = quotearg_n_mem(0, arg, argsize);
  }
  return (tmp);
}
}
char *quotearg_n_style(int n , enum quoting_style s , char const *arg )
{
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;
  {
  {
  tmp = quoting_options_from_style(s);
  { if(!(tmp.flags == 0)) { reach_error(); abort(); } };
  { if(!(tmp.left_quote == 0)) { reach_error(); abort(); } };
  { if(!(tmp.right_quote == 0)) { reach_error(); abort(); } };
  { if(!((unsigned int )tmp.style == 6U)) { reach_error(); abort(); } };
  o = tmp;
  { if(!(o.flags == 0)) { reach_error(); abort(); } };
  { if(!(o.left_quote == 0)) { reach_error(); abort(); } };
  { if(!(o.right_quote == 0)) { reach_error(); abort(); } };
  { if(!((unsigned int )o.style == 6U)) { reach_error(); abort(); } };
  tmp___0 = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options const *)(& o));
  }
  return (tmp___0);
}
}
char *quotearg_n_style_mem(int n , enum quoting_style s , char const *arg , size_t argsize )
{
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;
  {
  {
  tmp = quoting_options_from_style(s);
  o = tmp;
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options const *)(& o));
  }
  return (tmp___0);
}
}
char *quotearg_style(enum quoting_style s , char const *arg )
{
  char *tmp ;
  {
  {
  tmp = quotearg_n_style(0, s, arg);
  }
  return (tmp);
}
}
char *quotearg_style_mem(enum quoting_style s , char const *arg , size_t argsize )
{
  char *tmp ;
  {
  {
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
  }
  return (tmp);
}
}
char *quotearg_char_mem(char const *arg , size_t argsize , char ch )
{
  struct quoting_options options ;
  char *tmp ;
  {
  {
  options = default_quoting_options;
  set_char_quoting(& options, ch, 1);
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options const *)(& options));
  }
  return (tmp);
}
}
char *quotearg_char(char const *arg , char ch )
{
  char *tmp ;
  {
  {
  tmp = quotearg_char_mem(arg, (size_t )-1, ch);
  }
  return (tmp);
}
}
char *quotearg_colon(char const *arg )
{
  char *tmp ;
  {
  {
  tmp = quotearg_char(arg, (char )':');
  }
  return (tmp);
}
}
char *quotearg_colon_mem(char const *arg , size_t argsize )
{
  char *tmp ;
  {
  {
  tmp = quotearg_char_mem(arg, argsize, (char )':');
  }
  return (tmp);
}
}
char *quotearg_n_custom(int n , char const *left_quote , char const *right_quote ,
                        char const *arg )
{
  char *tmp ;
  {
  {
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg, (size_t )-1);
  }
  return (tmp);
}
}
char *quotearg_n_custom_mem(int n , char const *left_quote , char const *right_quote ,
                            char const *arg , size_t argsize )
{
  struct quoting_options o ;
  char *tmp ;
  {
  {
  o = default_quoting_options;
  set_custom_quoting(& o, left_quote, right_quote);
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options const *)(& o));
  }
  return (tmp);
}
}
char *quotearg_custom(char const *left_quote , char const *right_quote , char const *arg )
{
  char *tmp ;
  {
  {
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg);
  }
  return (tmp);
}
}
char *quotearg_custom_mem(char const *left_quote , char const *right_quote , char const *arg ,
                          size_t argsize )
{
  char *tmp ;
  {
  {
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg, argsize);
  }
  return (tmp);
}
}
struct randint_source *randint_new(struct randread_source *source )
{
  struct randint_source *s ;
  void *tmp ;
  randint tmp___0 ;
  {
  {
  tmp = xmalloc(sizeof(*s));
  s = (struct randint_source *)tmp;
  s->source = source;
  tmp___0 = (randint )0;
  s->randmax = tmp___0;
  s->randnum = tmp___0;
  }
  return (s);
}
}
struct randint_source *randint_all_new(char const *name , size_t bytes_bound )
{
  struct randread_source *source ;
  struct randread_source *tmp ;
  struct randint_source *tmp___0 ;
  struct randint_source *tmp___1 ;
  {
  {
  tmp = randread_new(name, bytes_bound);
  source = tmp;
  }
  if (source) {
    {
    {
    tmp___0 = randint_new(source);
    tmp___1 = tmp___0;
    }
    }
  } else {
    {
    {
    tmp___1 = (struct randint_source *)((void *)0);
    }
    }
  }
  return (tmp___1);
}
}
struct randread_source *randint_get_source(struct randint_source const *s ) __attribute__((__pure__)) ;
struct randread_source *randint_get_source(struct randint_source const *s )
{
  {
  return ((struct randread_source *)s->source);
}
}
__inline static randint shift_left(randint x )
{
  {
  return (x << 8);
}
}
randint randint_genmax(struct randint_source *s , randint genmax )
{
  struct randread_source *source ;
  randint randnum ;
  randint randmax ;
  randint choices ;
  size_t i ;
  randint rmax ;
  unsigned char buf___1[sizeof(randnum)] ;
  randint tmp ;
  randint tmp___0 ;
  randint tmp___1 ;
  randint tmp___2 ;
  randint excess_choices ;
  randint unusable_choices ;
  randint last_usable_choice ;
  randint reduced_randnum ;
  {
  {
  source = s->source;
  randnum = s->randnum;
  randmax = s->randmax;
  choices = genmax + 1UL;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (randmax < genmax) {
      {
      {
      i = (size_t )0;
      rmax = randmax;
      }
      {
      while (1) {
        while_continue___0: ;
        if (! 1) {
          {
          goto while_break___0;
          }
        }
        {
        tmp = shift_left(rmax);
        rmax = tmp + 255UL;
        i ++;
        }
        if (! (rmax < genmax)) {
          {
          goto while_break___0;
          }
        }
      }
      while_break___0: ;
      }
      {
      randread(source, (void *)(buf___1), i);
      i = (size_t )0;
      }
      {
      while (1) {
        while_continue___1: ;
        if (! 1) {
          {
          goto while_break___1;
          }
        }
        {
        tmp___0 = shift_left(randnum);
        randnum = tmp___0 + (randint )buf___1[i];
        tmp___1 = shift_left(randmax);
        randmax = tmp___1 + 255UL;
        i ++;
        }
        if (! (randmax < genmax)) {
          {
          goto while_break___1;
          }
        }
      }
      while_break___1: ;
      }
      }
    }
    if (randmax == genmax) {
      {
      {
      tmp___2 = (randint )0;
      s->randmax = tmp___2;
      s->randnum = tmp___2;
      }
      return (randnum);
      }
    } else {
      {
      {
      excess_choices = randmax - genmax;
      unusable_choices = excess_choices % choices;
      last_usable_choice = randmax - unusable_choices;
      reduced_randnum = randnum % choices;
      }
      if (randnum <= last_usable_choice) {
        {
        {
        s->randnum = randnum / choices;
        s->randmax = excess_choices / choices;
        }
        return (reduced_randnum);
        }
      }
      {
      randnum = reduced_randnum;
      randmax = unusable_choices - 1UL;
      }
      }
    }
  }
  while_break: ;
  }
  return (0UL);
}
}
void randint_free(struct randint_source *s )
{
  {
  {
  memset((void *)s, 0, sizeof(*s));
  free((void *)s);
  }
  return;
}
}
int randint_all_free(struct randint_source *s )
{
  int r ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;
  {
  {
  tmp = randread_free(s->source);
  r = tmp;
  tmp___0 = __errno_location();
  e = *tmp___0;
  randint_free(s);
  tmp___1 = __errno_location();
  *tmp___1 = e;
  }
  return (r);
}
}
__inline static randint randint_choose(struct randint_source *s , randint choices )
{
  randint tmp ;
  {
  {
  tmp = randint_genmax(s, choices - 1UL);
  }
  return (tmp);
}
}
static size_t ceil_lg(size_t n ) __attribute__((__const__)) ;
static size_t ceil_lg(size_t n )
{
  size_t b ;
  {
  {
  b = (size_t )0;
  n --;
  }
  {
  while (1) {
    while_continue: ;
    if (! (n != 0UL)) {
      {
      goto while_break;
      }
    }
    {
    b ++;
    n /= 2UL;
    }
  }
  while_break: ;
  }
  return (b);
}
}
size_t randperm_bound(size_t h , size_t n ) __attribute__((__const__)) ;
size_t randperm_bound(size_t h , size_t n )
{
  size_t lg_n ;
  size_t tmp ;
  size_t ar ;
  size_t bound ;
  {
  {
  tmp = ceil_lg(n);
  lg_n = tmp;
  ar = lg_n * h;
  bound = ((ar + 8UL) - 1UL) / 8UL;
  }
  return (bound);
}
}
static void swap(size_t *v , size_t i , size_t j )
{
  size_t t ;
  {
  {
  t = *(v + i);
  *(v + i) = *(v + j);
  *(v + j) = t;
  }
  return;
}
}
static size_t sparse_hash_(void const *x , size_t table_size )
{
  struct sparse_ent_ const *ent ;
  {
  {
  ent = (struct sparse_ent_ const *)x;
  }
  return ((size_t )(ent->index % (unsigned long )((unsigned long const )table_size)));
}
}
static _Bool sparse_cmp_(void const *x , void const *y )
{
  struct sparse_ent_ const *ent1 ;
  struct sparse_ent_ const *ent2 ;
  {
  {
  ent1 = (struct sparse_ent_ const *)x;
  ent2 = (struct sparse_ent_ const *)y;
  }
  return ((_Bool )(ent1->index == ent2->index));
}
}
static sparse_map *sparse_new(size_t size_hint )
{
  Hash_table *tmp ;
  {
  {
  tmp = hash_initialize(size_hint, (Hash_tuning const *)((void *)0), & sparse_hash_,
                        & sparse_cmp_, & free);
  }
  return (tmp);
}
}
static void sparse_swap(sparse_map *sv , size_t *v , size_t i , size_t j )
{
  struct sparse_ent_ *v1 ;
  struct sparse_ent_ __constr_expr_0 ;
  void *tmp ;
  struct sparse_ent_ *v2 ;
  struct sparse_ent_ __constr_expr_1 ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t t ;
  void *tmp___5 ;
  void *tmp___6 ;
  {
  {
  __constr_expr_0.index = i;
  __constr_expr_0.val = (size_t )0;
  tmp = hash_delete(sv, (void const *)(& __constr_expr_0));
  v1 = (struct sparse_ent_ *)tmp;
  __constr_expr_1.index = j;
  __constr_expr_1.val = (size_t )0;
  tmp___0 = hash_delete(sv, (void const *)(& __constr_expr_1));
  v2 = (struct sparse_ent_ *)tmp___0;
  }
  if (! v1) {
    {
    {
    tmp___1 = xmalloc(sizeof(*v1));
    v1 = (struct sparse_ent_ *)tmp___1;
    tmp___2 = i;
    v1->val = tmp___2;
    v1->index = tmp___2;
    }
    }
  }
  if (! v2) {
    {
    {
    tmp___3 = xmalloc(sizeof(*v2));
    v2 = (struct sparse_ent_ *)tmp___3;
    tmp___4 = j;
    v2->val = tmp___4;
    v2->index = tmp___4;
    }
    }
  }
  {
  t = v1->val;
  v1->val = v2->val;
  v2->val = t;
  tmp___5 = hash_insert(sv, (void const *)v1);
  }
  if (! tmp___5) {
    {
    {
    xalloc_die();
    }
    }
  }
  {
  tmp___6 = hash_insert(sv, (void const *)v2);
  }
  if (! tmp___6) {
    {
    {
    xalloc_die();
    }
    }
  }
  {
  *(v + i) = v1->val;
  }
  return;
}
}
static void sparse_free(sparse_map *sv )
{
  {
  {
  hash_free(sv);
  }
  return;
}
}
size_t *randperm_new(struct randint_source *r , size_t h , size_t n )
{
  size_t *v ;
  void *tmp ;
  _Bool sparse ;
  int tmp___0 ;
  size_t i ;
  sparse_map *sv ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t j ;
  randint tmp___3 ;
  void *tmp___4 ;
  {
  {
  if ((int )h == 0) {
    {
    goto case_0;
    }
  }
  if ((int )h == 1) {
    {
    goto case_1;
    }
  }
  goto switch_default;
  case_0:
  {
  v = (size_t *)((void *)0);
  }
  goto switch_break;
  case_1:
  {
  tmp = xmalloc(sizeof(*v));
  v = (size_t *)tmp;
  *(v + 0) = randint_choose(r, n);
  }
  goto switch_break;
  switch_default:
  if (n >= 131072UL) {
    {
    if (n / h >= 32UL) {
      {
      {
      tmp___0 = 1;
      }
      }
    } else {
      {
      {
      tmp___0 = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___0 = 0;
    }
    }
  }
  {
  sparse = (_Bool )tmp___0;
  }
  if (sparse) {
    {
    {
    sv = sparse_new(h * 2UL);
    }
    if ((unsigned long )sv == (unsigned long )((void *)0)) {
      {
      {
      xalloc_die();
      }
      }
    }
    {
    tmp___1 = xnmalloc(h, sizeof(*v));
    v = (size_t *)tmp___1;
    }
    }
  } else {
    {
    {
    sv = (sparse_map *)((void *)0);
    tmp___2 = xnmalloc(n, sizeof(*v));
    v = (size_t *)tmp___2;
    i = (size_t )0;
    }
    {
    while (1) {
      while_continue: ;
      if (! (i < n)) {
        {
        goto while_break;
        }
      }
      {
      *(v + i) = i;
      i ++;
      }
    }
    while_break: ;
    }
    }
  }
  {
  i = (size_t )0;
  }
  {
  while (1) {
    while_continue___0: ;
    if (! (i < h)) {
      {
      goto while_break___0;
      }
    }
    {
    tmp___3 = randint_choose(r, n - i);
    j = i + tmp___3;
    }
    if (sparse) {
      {
      {
      sparse_swap(sv, v, i, j);
      }
      }
    } else {
      {
      {
      swap(v, i, j);
      }
      }
    }
    {
    i ++;
    }
  }
  while_break___0: ;
  }
  if (sparse) {
    {
    {
    sparse_free(sv);
    }
    }
  } else {
    {
    {
    tmp___4 = xnrealloc((void *)v, h, sizeof(*v));
    v = (size_t *)tmp___4;
    }
    }
  }
  goto switch_break;
  switch_break: ;
  }
  return (v);
}
}
static void randread_error(void const *file_name___1 ) __attribute__((__noreturn__)) ;
static void randread_error(void const *file_name___1 )
{
  char *tmp ;
  char const *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  {
  if (file_name___1) {
    {
    {
    tmp = quotearg_colon((char const *)file_name___1);
    tmp___2 = __errno_location();
    }
    if (*tmp___2 == 0) {
      {
      {
      tmp___1 = (char const *)"%s: end of file";
      }
      }
    } else {
      {
      {
      tmp___1 = (char const *)"%s: read error";
      }
      }
    }
    {
    tmp___3 = dcgettext((char const *)((void *)0), tmp___1, 5);
    tmp___4 = __errno_location();
    error((int )exit_failure, *tmp___4, (char const *)tmp___3, tmp);
    }
    }
  }
  {
  abort();
  }
}
}
static struct randread_source *simple_new(FILE *source , void const *handler_arg )
{
  struct randread_source *s ;
  void *tmp ;
  {
  {
  tmp = xmalloc(sizeof(*s));
  s = (struct randread_source *)tmp;
  s->source = source;
  s->handler = & randread_error;
  s->handler_arg = handler_arg;
  }
  return (s);
}
}
static void get_nonce(void *buffer , size_t bufsize___0 , size_t bytes_bound )
{
  char *buf___1 ;
  ssize_t seeded ;
  int fd ;
  int tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  struct timeval v ;
  size_t nbytes ;
  unsigned long tmp___2 ;
  pid_t v___0 ;
  size_t nbytes___0 ;
  unsigned long tmp___3 ;
  pid_t v___1 ;
  size_t nbytes___1 ;
  unsigned long tmp___4 ;
  uid_t v___2 ;
  size_t nbytes___2 ;
  unsigned long tmp___5 ;
  uid_t v___3 ;
  size_t nbytes___3 ;
  unsigned long tmp___6 ;
  ssize_t tmp___7 ;
  ssize_t tmp___8 ;
  {
  {
  buf___1 = (char *)buffer;
  seeded = (ssize_t )0;
  tmp = open((char const *)"/dev/urandom", 0);
  fd = tmp;
  }
  if (0 <= fd) {
    {
    if (bufsize___0 < bytes_bound) {
      {
      {
      tmp___0 = bufsize___0;
      }
      }
    } else {
      {
      {
      tmp___0 = bytes_bound;
      }
      }
    }
    {
    tmp___8 = read(fd, (void *)buf___1, tmp___0);
    tmp___7 = tmp___8;
    tmp___1 = tmp___7;
    seeded = tmp___1;
    }
    if (seeded < 0L) {
      {
      {
      seeded = (ssize_t )0;
      }
      }
    }
    {
    close(fd);
    }
    }
  }
  if ((size_t )seeded < bufsize___0) {
    {
    if (sizeof(v) < bufsize___0 - (size_t )seeded) {
      {
      {
      tmp___2 = sizeof(v);
      }
      }
    } else {
      {
      {
      tmp___2 = bufsize___0 - (size_t )seeded;
      }
      }
    }
    {
    nbytes = tmp___2;
    gettimeofday((struct timeval * __restrict )(& v), (__timezone_ptr_t )((void *)0));
    memcpy((void *)((void * __restrict )(buf___1 + seeded)), (void const *)((void const * __restrict )(& v)),
           nbytes);
    seeded = (ssize_t )((size_t )seeded + nbytes);
    }
    }
  }
  if ((size_t )seeded < bufsize___0) {
    {
    if (sizeof(v___0) < bufsize___0 - (size_t )seeded) {
      {
      {
      tmp___3 = sizeof(v___0);
      }
      }
    } else {
      {
      {
      tmp___3 = bufsize___0 - (size_t )seeded;
      }
      }
    }
    {
    nbytes___0 = tmp___3;
    v___0 = getpid();
    memcpy((void *)((void * __restrict )(buf___1 + seeded)), (void const *)((void const * __restrict )(& v___0)),
           nbytes___0);
    seeded = (ssize_t )((size_t )seeded + nbytes___0);
    }
    }
  }
  if ((size_t )seeded < bufsize___0) {
    {
    if (sizeof(v___1) < bufsize___0 - (size_t )seeded) {
      {
      {
      tmp___4 = sizeof(v___1);
      }
      }
    } else {
      {
      {
      tmp___4 = bufsize___0 - (size_t )seeded;
      }
      }
    }
    {
    nbytes___1 = tmp___4;
    v___1 = getppid();
    memcpy((void *)((void * __restrict )(buf___1 + seeded)), (void const *)((void const * __restrict )(& v___1)),
           nbytes___1);
    seeded = (ssize_t )((size_t )seeded + nbytes___1);
    }
    }
  }
  if ((size_t )seeded < bufsize___0) {
    {
    if (sizeof(v___2) < bufsize___0 - (size_t )seeded) {
      {
      {
      tmp___5 = sizeof(v___2);
      }
      }
    } else {
      {
      {
      tmp___5 = bufsize___0 - (size_t )seeded;
      }
      }
    }
    {
    nbytes___2 = tmp___5;
    v___2 = getuid();
    memcpy((void *)((void * __restrict )(buf___1 + seeded)), (void const *)((void const * __restrict )(& v___2)),
           nbytes___2);
    seeded = (ssize_t )((size_t )seeded + nbytes___2);
    }
    }
  }
  if ((size_t )seeded < bufsize___0) {
    {
    if (sizeof(v___3) < bufsize___0 - (size_t )seeded) {
      {
      {
      tmp___6 = sizeof(v___3);
      }
      }
    } else {
      {
      {
      tmp___6 = bufsize___0 - (size_t )seeded;
      }
      }
    }
    {
    nbytes___3 = tmp___6;
    v___3 = getgid();
    memcpy((void *)((void * __restrict )(buf___1 + seeded)), (void const *)((void const * __restrict )(& v___3)),
           nbytes___3);
    seeded = (ssize_t )((size_t )seeded + nbytes___3);
    }
    }
  }
  return;
}
}
struct randread_source *randread_new(char const *name , size_t bytes_bound )
{
  struct randread_source *tmp ;
  FILE *source ;
  struct randread_source *s ;
  unsigned long tmp___0 ;
  {
  if (bytes_bound == 0UL) {
    {
    {
    tmp = simple_new((FILE *)((void *)0), (void const *)((void *)0));
    }
    return (tmp);
    }
  } else {
    {
    {
    source = (FILE *)((void *)0);
    }
    if (name) {
      {
      {
      source = fopen_safer(name, (char const *)"rb");
      }
      if (! source) {
        {
        return ((struct randread_source *)((void *)0));
        }
      }
      }
    }
    {
    s = simple_new(source, (void const *)name);
    }
    if (source) {
      {
      if (sizeof(s->buf.c) < bytes_bound) {
        {
        {
        tmp___0 = sizeof(s->buf.c);
        }
        }
      } else {
        {
        {
        tmp___0 = bytes_bound;
        }
        }
      }
      {
      setvbuf((FILE * __restrict )source, (char * __restrict )(s->buf.c), 0, tmp___0);
      }
      }
    } else {
      {
      {
      s->buf.isaac.buffered = (size_t )0;
      get_nonce((void *)(s->buf.isaac.state.m), sizeof(s->buf.isaac.state.m), bytes_bound);
      isaac_seed(& s->buf.isaac.state);
      }
      }
    }
    return (s);
    }
  }
}
}
void randread_set_handler(struct randread_source *s , void (*handler)(void const * ) )
{
  {
  {
  s->handler = handler;
  }
  return;
}
}
void randread_set_handler_arg(struct randread_source *s , void const *handler_arg )
{
  {
  {
  s->handler_arg = handler_arg;
  }
  return;
}
}
static void readsource(struct randread_source *s , unsigned char *p , size_t size )
{
  size_t inbytes ;
  size_t tmp ;
  int fread_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  {
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___5 = fread_unlocked((void *)((void * __restrict )p), sizeof(*p), size, (FILE *)((FILE * __restrict )s->source));
    tmp___4 = tmp___5;
    tmp = tmp___4;
    inbytes = tmp;
    tmp___0 = __errno_location();
    fread_errno = *tmp___0;
    p += inbytes;
    size -= inbytes;
    }
    if (size == 0UL) {
      {
      goto while_break;
      }
    }
    {
    tmp___1 = __errno_location();
    tmp___3 = ferror_unlocked(s->source);
    }
    if (tmp___3) {
      {
      {
      *tmp___1 = fread_errno;
      }
      }
    } else {
      {
      {
      *tmp___1 = 0;
      }
      }
    }
    {
    (*(s->handler))(s->handler_arg);
    }
  }
  while_break: ;
  }
  return;
}
}
static void readisaac(struct isaac *isaac , unsigned char *p , size_t size )
{
  size_t inbytes ;
  isaac_word *wp ;
  {
  {
  inbytes = isaac->buffered;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (size <= inbytes) {
      {
      {
      memcpy((void *)((void * __restrict )p), (void const *)((void const * __restrict )((isaac->data.b + (unsigned long )(1 << 8) * sizeof(isaac_word )) - inbytes)),
             size);
      isaac->buffered = inbytes - size;
      }
      return;
      }
    }
    {
    memcpy((void *)((void * __restrict )p), (void const *)((void const * __restrict )((isaac->data.b + (unsigned long )(1 << 8) * sizeof(isaac_word )) - inbytes)),
           inbytes);
    p += inbytes;
    size -= inbytes;
    wp = (isaac_word *)p;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! ((unsigned long )(1 << 8) * sizeof(isaac_word ) <= size)) {
        {
        goto while_break___0;
        }
      }
      {
      isaac_refill(& isaac->state, wp);
      wp += 1 << 8;
      size -= (unsigned long )(1 << 8) * sizeof(isaac_word );
      }
      if (size == 0UL) {
        {
        {
        isaac->buffered = (size_t )0;
        }
        return;
        }
      }
    }
    while_break___0: ;
    }
    {
    p = (unsigned char *)wp;
    isaac_refill(& isaac->state, isaac->data.w);
    inbytes = (unsigned long )(1 << 8) * sizeof(isaac_word );
    }
  }
  while_break: ;
  }
  return;
}
}
void randread(struct randread_source *s , void *buf___1 , size_t size )
{
  {
  if (s->source) {
    {
    {
    readsource(s, (unsigned char *)buf___1, size);
    }
    }
  } else {
    {
    {
    readisaac(& s->buf.isaac, (unsigned char *)buf___1, size);
    }
    }
  }
  return;
}
}
int randread_free(struct randread_source *s )
{
  FILE *source ;
  int tmp ;
  int tmp___0 ;
  {
  {
  source = s->source;
  memset((void *)s, 0, sizeof(*s));
  free((void *)s);
  }
  if (source) {
    {
    {
    tmp = rpl_fclose(source);
    tmp___0 = tmp;
    }
    }
  } else {
    {
    {
    tmp___0 = 0;
    }
    }
  }
  return (tmp___0);
}
}
__inline static isaac_word just(isaac_word a )
{
  isaac_word desired_bits ;
  {
  {
  desired_bits = ((1UL << 1) << ((1 << 6) - 1)) - 1UL;
  }
  return (a & desired_bits);
}
}
__inline static isaac_word ind(isaac_word const *m , isaac_word x )
{
  isaac_word tmp ;
  {
  if (sizeof(*m) * 8UL == (unsigned long )(1 << 6)) {
    {
    {
    tmp = *((isaac_word *)((char *)m + (x & (unsigned long )((1 << 8) - 1) * sizeof(*m))));
    }
    }
  } else {
    {
    {
    tmp = (isaac_word )*(m + (x / (isaac_word )((1 << 6) / 8) & (unsigned long )((1 << 8) - 1)));
    }
    }
  }
  return (tmp);
}
}
void isaac_refill(struct isaac_state *s , isaac_word *result )
{
  isaac_word a ;
  isaac_word b ;
  isaac_word *m ;
  isaac_word *r ;
  isaac_word x ;
  isaac_word y ;
  isaac_word tmp ;
  isaac_word tmp___0 ;
  isaac_word tmp___1 ;
  isaac_word tmp___2 ;
  isaac_word x___0 ;
  isaac_word y___0 ;
  isaac_word tmp___3 ;
  isaac_word tmp___4 ;
  isaac_word tmp___5 ;
  isaac_word tmp___6 ;
  isaac_word tmp___7 ;
  isaac_word tmp___8 ;
  isaac_word x___1 ;
  isaac_word y___1 ;
  isaac_word tmp___9 ;
  isaac_word tmp___10 ;
  isaac_word tmp___11 ;
  isaac_word tmp___12 ;
  isaac_word x___2 ;
  isaac_word y___2 ;
  isaac_word tmp___13 ;
  isaac_word tmp___14 ;
  isaac_word tmp___15 ;
  isaac_word tmp___16 ;
  isaac_word tmp___17 ;
  isaac_word tmp___18 ;
  isaac_word x___3 ;
  isaac_word y___3 ;
  isaac_word tmp___19 ;
  isaac_word tmp___20 ;
  isaac_word tmp___21 ;
  isaac_word tmp___22 ;
  isaac_word x___4 ;
  isaac_word y___4 ;
  isaac_word tmp___23 ;
  isaac_word tmp___24 ;
  isaac_word tmp___25 ;
  isaac_word tmp___26 ;
  isaac_word tmp___27 ;
  isaac_word tmp___28 ;
  isaac_word x___5 ;
  isaac_word y___5 ;
  isaac_word tmp___29 ;
  isaac_word tmp___30 ;
  isaac_word tmp___31 ;
  isaac_word tmp___32 ;
  isaac_word x___6 ;
  isaac_word y___6 ;
  isaac_word tmp___33 ;
  isaac_word tmp___34 ;
  isaac_word tmp___35 ;
  isaac_word tmp___36 ;
  isaac_word tmp___37 ;
  isaac_word tmp___38 ;
  {
  {
  a = s->a;
  (s->c) ++;
  b = s->b + s->c;
  m = s->m;
  r = result;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (1 << 6 == 32) {
      {
      {
      tmp = a;
      }
      }
    } else {
      {
      {
      tmp = (isaac_word )0;
      }
      }
    }
    if (1 << 6 == 32) {
      {
      {
      tmp___0 = a << 13;
      }
      }
    } else {
      {
      {
      tmp___0 = ~ (a ^ (a << 21));
      }
      }
    }
    {
    a = (tmp ^ tmp___0) + *(m + 128);
    x = *(m + 0);
    tmp___1 = ind((isaac_word const *)(s->m), x);
    y = (tmp___1 + a) + b;
    *(m + 0) = y;
    tmp___2 = ind((isaac_word const *)(s->m), y >> 8);
    b = just(tmp___2 + x);
    *(r + 0) = b;
    }
    if (1 << 6 == 32) {
      {
      {
      tmp___3 = a;
      }
      }
    } else {
      {
      {
      tmp___3 = (isaac_word )0;
      }
      }
    }
    if (1 << 6 == 32) {
      {
      {
      tmp___4 = just(a);
      tmp___6 = tmp___4 >> 6;
      }
      }
    } else {
      {
      {
      tmp___5 = just(a);
      tmp___6 = a ^ (tmp___5 >> 5);
      }
      }
    }
    {
    a = (tmp___3 ^ tmp___6) + *(m + 129);
    x___0 = *(m + 1);
    tmp___7 = ind((isaac_word const *)(s->m), x___0);
    y___0 = (tmp___7 + a) + b;
    *(m + 1) = y___0;
    tmp___8 = ind((isaac_word const *)(s->m), y___0 >> 8);
    b = just(tmp___8 + x___0);
    *(r + 1) = b;
    }
    if (1 << 6 == 32) {
      {
      {
      tmp___9 = a;
      }
      }
    } else {
      {
      {
      tmp___9 = (isaac_word )0;
      }
      }
    }
    if (1 << 6 == 32) {
      {
      {
      tmp___10 = a << 2;
      }
      }
    } else {
      {
      {
      tmp___10 = a ^ (a << 12);
      }
      }
    }
    {
    a = (tmp___9 ^ tmp___10) + *(m + 130);
    x___1 = *(m + 2);
    tmp___11 = ind((isaac_word const *)(s->m), x___1);
    y___1 = (tmp___11 + a) + b;
    *(m + 2) = y___1;
    tmp___12 = ind((isaac_word const *)(s->m), y___1 >> 8);
    b = just(tmp___12 + x___1);
    *(r + 2) = b;
    }
    if (1 << 6 == 32) {
      {
      {
      tmp___13 = a;
      }
      }
    } else {
      {
      {
      tmp___13 = (isaac_word )0;
      }
      }
    }
    if (1 << 6 == 32) {
      {
      {
      tmp___14 = just(a);
      tmp___16 = tmp___14 >> 16;
      }
      }
    } else {
      {
      {
      tmp___15 = just(a);
      tmp___16 = a ^ (tmp___15 >> 33);
      }
      }
    }
    {
    a = (tmp___13 ^ tmp___16) + *(m + 131);
    x___2 = *(m + 3);
    tmp___17 = ind((isaac_word const *)(s->m), x___2);
    y___2 = (tmp___17 + a) + b;
    *(m + 3) = y___2;
    tmp___18 = ind((isaac_word const *)(s->m), y___2 >> 8);
    b = just(tmp___18 + x___2);
    *(r + 3) = b;
    r += 4;
    m += 4;
    }
    if (! ((unsigned long )m < (unsigned long )(s->m + 128))) {
      {
      goto while_break;
      }
    }
  }
  while_break: ;
  }
  {
  while (1) {
    while_continue___0: ;
    if (! 1) {
      {
      goto while_break___0;
      }
    }
    if (1 << 6 == 32) {
      {
      {
      tmp___19 = a;
      }
      }
    } else {
      {
      {
      tmp___19 = (isaac_word )0;
      }
      }
    }
    if (1 << 6 == 32) {
      {
      {
      tmp___20 = a << 13;
      }
      }
    } else {
      {
      {
      tmp___20 = ~ (a ^ (a << 21));
      }
      }
    }
    {
    a = (tmp___19 ^ tmp___20) + *(m + -128);
    x___3 = *(m + 0);
    tmp___21 = ind((isaac_word const *)(s->m), x___3);
    y___3 = (tmp___21 + a) + b;
    *(m + 0) = y___3;
    tmp___22 = ind((isaac_word const *)(s->m), y___3 >> 8);
    b = just(tmp___22 + x___3);
    *(r + 0) = b;
    }
    if (1 << 6 == 32) {
      {
      {
      tmp___23 = a;
      }
      }
    } else {
      {
      {
      tmp___23 = (isaac_word )0;
      }
      }
    }
    if (1 << 6 == 32) {
      {
      {
      tmp___24 = just(a);
      tmp___26 = tmp___24 >> 6;
      }
      }
    } else {
      {
      {
      tmp___25 = just(a);
      tmp___26 = a ^ (tmp___25 >> 5);
      }
      }
    }
    {
    a = (tmp___23 ^ tmp___26) + *(m + -127);
    x___4 = *(m + 1);
    tmp___27 = ind((isaac_word const *)(s->m), x___4);
    y___4 = (tmp___27 + a) + b;
    *(m + 1) = y___4;
    tmp___28 = ind((isaac_word const *)(s->m), y___4 >> 8);
    b = just(tmp___28 + x___4);
    *(r + 1) = b;
    }
    if (1 << 6 == 32) {
      {
      {
      tmp___29 = a;
      }
      }
    } else {
      {
      {
      tmp___29 = (isaac_word )0;
      }
      }
    }
    if (1 << 6 == 32) {
      {
      {
      tmp___30 = a << 2;
      }
      }
    } else {
      {
      {
      tmp___30 = a ^ (a << 12);
      }
      }
    }
    {
    a = (tmp___29 ^ tmp___30) + *(m + -126);
    x___5 = *(m + 2);
    tmp___31 = ind((isaac_word const *)(s->m), x___5);
    y___5 = (tmp___31 + a) + b;
    *(m + 2) = y___5;
    tmp___32 = ind((isaac_word const *)(s->m), y___5 >> 8);
    b = just(tmp___32 + x___5);
    *(r + 2) = b;
    }
    if (1 << 6 == 32) {
      {
      {
      tmp___33 = a;
      }
      }
    } else {
      {
      {
      tmp___33 = (isaac_word )0;
      }
      }
    }
    if (1 << 6 == 32) {
      {
      {
      tmp___34 = just(a);
      tmp___36 = tmp___34 >> 16;
      }
      }
    } else {
      {
      {
      tmp___35 = just(a);
      tmp___36 = a ^ (tmp___35 >> 33);
      }
      }
    }
    {
    a = (tmp___33 ^ tmp___36) + *(m + -125);
    x___6 = *(m + 3);
    tmp___37 = ind((isaac_word const *)(s->m), x___6);
    y___6 = (tmp___37 + a) + b;
    *(m + 3) = y___6;
    tmp___38 = ind((isaac_word const *)(s->m), y___6 >> 8);
    b = just(tmp___38 + x___6);
    *(r + 3) = b;
    r += 4;
    m += 4;
    }
    if (! ((unsigned long )m < (unsigned long )(s->m + (1 << 8)))) {
      {
      goto while_break___0;
      }
    }
  }
  while_break___0: ;
  }
  {
  s->a = a;
  s->b = b;
  }
  return;
}
}
void isaac_seed(struct isaac_state *s )
{
  isaac_word a ;
  unsigned long tmp ;
  isaac_word b ;
  unsigned long tmp___0 ;
  isaac_word c ;
  unsigned long tmp___1 ;
  isaac_word d ;
  unsigned long tmp___2 ;
  isaac_word e ;
  unsigned long tmp___3 ;
  isaac_word f ;
  unsigned long tmp___4 ;
  isaac_word g ;
  unsigned long tmp___5 ;
  isaac_word h ;
  unsigned long tmp___6 ;
  int i ;
  isaac_word tmp___7 ;
  isaac_word tmp___8 ;
  isaac_word tmp___9 ;
  isaac_word tmp___10 ;
  int i___0 ;
  isaac_word tmp___11 ;
  isaac_word tmp___12 ;
  isaac_word tmp___13 ;
  isaac_word tmp___14 ;
  isaac_word tmp___15 ;
  isaac_word tmp___16 ;
  {
  if (1 << 6 == 32) {
    {
    {
    tmp = 325574490UL;
    }
    }
  } else {
    {
    {
    tmp = 7240739780546808700UL;
    }
    }
  }
  {
  a = tmp;
  }
  if (1 << 6 == 32) {
    {
    {
    tmp___0 = 2514026585UL;
    }
    }
  } else {
    {
    {
    tmp___0 = 0xb9f8b322c73ac862UL;
    }
    }
  }
  {
  b = tmp___0;
  }
  if (1 << 6 == 32) {
    {
    {
    tmp___1 = 3273014859UL;
    }
    }
  } else {
    {
    {
    tmp___1 = 0x8c0ea5053d4712a0UL;
    }
    }
  }
  {
  c = tmp___1;
  }
  if (1 << 6 == 32) {
    {
    {
    tmp___2 = 255990488UL;
    }
    }
  } else {
    {
    {
    tmp___2 = 0xb29b2e824a595524UL;
    }
    }
  }
  {
  d = tmp___2;
  }
  if (1 << 6 == 32) {
    {
    {
    tmp___3 = 3643427448UL;
    }
    }
  } else {
    {
    {
    tmp___3 = 0x82f053db8355e0ceUL;
    }
    }
  }
  {
  e = tmp___3;
  }
  if (1 << 6 == 32) {
    {
    {
    tmp___4 = 2769960009UL;
    }
    }
  } else {
    {
    {
    tmp___4 = 5259722845879046933UL;
    }
    }
  }
  {
  f = tmp___4;
  }
  if (1 << 6 == 32) {
    {
    {
    tmp___5 = 3304057371UL;
    }
    }
  } else {
    {
    {
    tmp___5 = 0xae985bf2cbfc89edUL;
    }
    }
  }
  {
  g = tmp___5;
  }
  if (1 << 6 == 32) {
    {
    {
    tmp___6 = 811634969UL;
    }
    }
  } else {
    {
    {
    tmp___6 = 0x98f5704f6c44c0abUL;
    }
    }
  }
  {
  h = tmp___6;
  i = 0;
  }
  {
  while (1) {
    while_continue: ;
    if (! (i < 1 << 8)) {
      {
      goto while_break;
      }
    }
    {
    a += s->m[i];
    b += s->m[i + 1];
    c += s->m[i + 2];
    d += s->m[i + 3];
    e += s->m[i + 4];
    f += s->m[i + 5];
    g += s->m[i + 6];
    h += s->m[i + 7];
    a -= e;
    tmp___7 = just(h);
    f ^= tmp___7 >> 9;
    h += a;
    b -= f;
    g ^= a << 9;
    a += b;
    c -= g;
    tmp___8 = just(b);
    h ^= tmp___8 >> 23;
    b += c;
    d -= h;
    a ^= c << 15;
    c += d;
    e -= a;
    tmp___9 = just(d);
    b ^= tmp___9 >> 14;
    d += e;
    f -= b;
    c ^= e << 20;
    e += f;
    g -= c;
    tmp___10 = just(f);
    d ^= tmp___10 >> 17;
    f += g;
    h -= d;
    e ^= g << 14;
    g += h;
    s->m[i] = a;
    s->m[i + 1] = b;
    s->m[i + 2] = c;
    s->m[i + 3] = d;
    s->m[i + 4] = e;
    s->m[i + 5] = f;
    s->m[i + 6] = g;
    s->m[i + 7] = h;
    i += 8;
    }
  }
  while_break: ;
  }
  {
  i___0 = 0;
  }
  {
  while (1) {
    while_continue___0: ;
    if (! (i___0 < 1 << 8)) {
      {
      goto while_break___0;
      }
    }
    {
    a += s->m[i___0];
    b += s->m[i___0 + 1];
    c += s->m[i___0 + 2];
    d += s->m[i___0 + 3];
    e += s->m[i___0 + 4];
    f += s->m[i___0 + 5];
    g += s->m[i___0 + 6];
    h += s->m[i___0 + 7];
    a -= e;
    tmp___11 = just(h);
    f ^= tmp___11 >> 9;
    h += a;
    b -= f;
    g ^= a << 9;
    a += b;
    c -= g;
    tmp___12 = just(b);
    h ^= tmp___12 >> 23;
    b += c;
    d -= h;
    a ^= c << 15;
    c += d;
    e -= a;
    tmp___13 = just(d);
    b ^= tmp___13 >> 14;
    d += e;
    f -= b;
    c ^= e << 20;
    e += f;
    g -= c;
    tmp___14 = just(f);
    d ^= tmp___14 >> 17;
    f += g;
    h -= d;
    e ^= g << 14;
    g += h;
    s->m[i___0] = a;
    s->m[i___0 + 1] = b;
    s->m[i___0 + 2] = c;
    s->m[i___0 + 3] = d;
    s->m[i___0 + 4] = e;
    s->m[i___0 + 5] = f;
    s->m[i___0 + 6] = g;
    s->m[i___0 + 7] = h;
    i___0 += 8;
    }
  }
  while_break___0: ;
  }
  {
  tmp___16 = (isaac_word )0;
  s->c = tmp___16;
  tmp___15 = tmp___16;
  s->b = tmp___15;
  s->a = tmp___15;
  }
  return;
}
}
char *fread_file(FILE *stream , size_t *length )
{
  char *buf___1 ;
  size_t alloc ;
  struct stat st ;
  off_t pos ;
  __off_t tmp ;
  off_t alloc_off ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  size_t size ;
  int save_errno ;
  size_t requested ;
  size_t count ;
  size_t tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  char *smaller_buf ;
  void *tmp___7 ;
  char *new_buf ;
  int *tmp___8 ;
  void *tmp___9 ;
  int *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  {
  {
  buf___1 = (char *)((void *)0);
  alloc = (size_t )8192;
  tmp___1 = fileno(stream);
  tmp___2 = fstat(tmp___1, & st);
  }
  if (tmp___2 >= 0) {
    {
    if ((st.st_mode & 61440U) == 32768U) {
      {
      {
      tmp = ftello(stream);
      pos = tmp;
      }
      if (pos >= 0L) {
        {
        if (pos < st.st_size) {
          {
          {
          alloc_off = st.st_size - pos;
          }
          if (0xfffffffffffffffeUL < (unsigned long )alloc_off) {
            {
            {
            tmp___0 = __errno_location();
            *tmp___0 = 12;
            }
            return ((char *)((void *)0));
            }
          }
          {
          alloc = (size_t )(alloc_off + 1L);
          }
          }
        }
        }
      }
      }
    }
    }
  }
  {
  tmp___3 = malloc(alloc);
  buf___1 = (char *)tmp___3;
  }
  if (! buf___1) {
    {
    return ((char *)((void *)0));
    }
  }
  {
  size = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    requested = alloc - size;
    tmp___12 = fread((void *)((void * __restrict )(buf___1 + size)), (size_t )1,
                     requested, (FILE *)((FILE * __restrict )stream));
    tmp___11 = tmp___12;
    tmp___4 = tmp___11;
    count = tmp___4;
    size += count;
    }
    if (count != requested) {
      {
      {
      tmp___5 = __errno_location();
      save_errno = *tmp___5;
      tmp___6 = ferror(stream);
      }
      if (tmp___6) {
        {
        goto while_break;
        }
      }
      if (size < alloc - 1UL) {
        {
        {
        tmp___7 = realloc((void *)buf___1, size + 1UL);
        smaller_buf = (char *)tmp___7;
        }
        if ((unsigned long )smaller_buf != (unsigned long )((void *)0)) {
          {
          {
          buf___1 = smaller_buf;
          }
          }
        }
        }
      }
      {
      *(buf___1 + size) = (char )'\000';
      *length = size;
      }
      return (buf___1);
      }
    }
    if (alloc == 0xffffffffffffffffUL) {
      {
      {
      save_errno = 12;
      }
      goto while_break;
      }
    }
    if (alloc < 0xffffffffffffffffUL - alloc / 2UL) {
      {
      {
      alloc += alloc / 2UL;
      }
      }
    } else {
      {
      {
      alloc = 0xffffffffffffffffUL;
      }
      }
    }
    {
    tmp___9 = realloc((void *)buf___1, alloc);
    new_buf = (char *)tmp___9;
    }
    if (! new_buf) {
      {
      {
      tmp___8 = __errno_location();
      save_errno = *tmp___8;
      }
      goto while_break;
      }
    }
    {
    buf___1 = new_buf;
    }
  }
  while_break: ;
  }
  {
  free((void *)buf___1);
  tmp___10 = __errno_location();
  *tmp___10 = save_errno;
  }
  return ((char *)((void *)0));
}
}
static char *internal_read_file(char const *filename , size_t *length , char const *mode )
{
  FILE *stream ;
  FILE *tmp ;
  char *out ;
  int save_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  {
  {
  tmp = fopen((char const * __restrict )filename, (char const * __restrict )mode);
  stream = tmp;
  }
  if (! stream) {
    {
    return ((char *)((void *)0));
    }
  }
  {
  out = fread_file(stream, length);
  tmp___0 = __errno_location();
  save_errno = *tmp___0;
  tmp___3 = rpl_fclose(stream);
  }
  if (tmp___3 != 0) {
    {
    if (out) {
      {
      {
      tmp___1 = __errno_location();
      save_errno = *tmp___1;
      free((void *)out);
      }
      }
    }
    {
    tmp___2 = __errno_location();
    *tmp___2 = save_errno;
    }
    return ((char *)((void *)0));
    }
  }
  return (out);
}
}
char *read_file(char const *filename , size_t *length )
{
  char *tmp ;
  {
  {
  tmp = internal_read_file(filename, length, (char const *)"r");
  }
  return (tmp);
}
}
char *read_binary_file(char const *filename , size_t *length )
{
  char *tmp ;
  {
  {
  tmp = internal_read_file(filename, length, (char const *)"rb");
  }
  return (tmp);
}
}
void init_tokenbuffer(token_buffer *tokenbuffer )
{
  {
  {
  tokenbuffer->size = (size_t )0;
  tokenbuffer->buffer = (char *)((void *)0);
  }
  return;
}
}
size_t readtoken(FILE *stream , char const *delim , size_t n_delim , token_buffer *tokenbuffer )
{
  char *p ;
  int c ;
  size_t i ;
  size_t n ;
  _Bool same_delimiters ;
  size_t j ;
  unsigned char ch ;
  void *tmp ;
  size_t tmp___0 ;
  {
  if ((unsigned long )delim == (unsigned long )((void *)0)) {
    {
    if ((unsigned long )saved_delim == (unsigned long )((void *)0)) {
      {
      {
      abort();
      }
      }
    }
    }
  }
  {
  same_delimiters = (_Bool)0;
  }
  if ((unsigned long )delim != (unsigned long )saved_delim) {
    {
    if ((unsigned long )saved_delim != (unsigned long )((void *)0)) {
      {
      {
      same_delimiters = (_Bool)1;
      i = (size_t )0;
      }
      {
      while (1) {
        while_continue: ;
        if (! (i < n_delim)) {
          {
          goto while_break;
          }
        }
        if ((int const )*(delim + i) != (int const )*(saved_delim + i)) {
          {
          {
          same_delimiters = (_Bool)0;
          }
          goto while_break;
          }
        }
        {
        i ++;
        }
      }
      while_break: ;
      }
      }
    }
    }
  }
  if (! same_delimiters) {
    {
    {
    saved_delim = delim;
    memset((void *)(isdelim), 0, sizeof(isdelim));
    j = (size_t )0;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! (j < n_delim)) {
        {
        goto while_break___0;
        }
      }
      {
      ch = (unsigned char )*(delim + j);
      isdelim[ch] = (char)1;
      j ++;
      }
    }
    while_break___0: ;
    }
    }
  }
  {
  c = getc_unlocked(stream);
  }
  {
  while (1) {
    while_continue___1: ;
    if (! 1) {
      {
      goto while_break___1;
      }
    }
    if (c >= 0) {
      {
      if (! isdelim[c]) {
        {
        goto while_break___1;
        }
      }
      }
    } else {
      {
      goto while_break___1;
      }
    }
    {
    c = getc_unlocked(stream);
    }
  }
  while_break___1: ;
  }
  {
  p = tokenbuffer->buffer;
  n = tokenbuffer->size;
  i = (size_t )0;
  }
  {
  while (1) {
    while_continue___2: ;
    if (! 1) {
      {
      goto while_break___2;
      }
    }
    if (c < 0) {
      {
      if (i == 0UL) {
        {
        return ((size_t )-1);
        }
      }
      }
    }
    if (i == n) {
      {
      {
      tmp = x2nrealloc((void *)p, & n, sizeof(*p));
      p = (char *)tmp;
      }
      }
    }
    if (c < 0) {
      {
      {
      *(p + i) = (char)0;
      }
      goto while_break___2;
      }
    }
    if (isdelim[c]) {
      {
      {
      *(p + i) = (char)0;
      }
      goto while_break___2;
      }
    }
    {
    tmp___0 = i;
    i ++;
    *(p + tmp___0) = (char )c;
    c = getc_unlocked(stream);
    }
  }
  while_break___2: ;
  }
  {
  tokenbuffer->buffer = p;
  tokenbuffer->size = n;
  }
  return (i);
}
}
size_t readtokens(FILE *stream , size_t projected_n_tokens , char const *delim ,
                  size_t n_delim , char ***tokens_out , size_t **token_lengths )
{
  token_buffer tb ;
  token_buffer *token ;
  char **tokens ;
  size_t *lengths ;
  size_t sz ;
  size_t n_tokens ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  size_t token_length ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  {
  {
  token = & tb;
  }
  if (projected_n_tokens == 0UL) {
    {
    {
    projected_n_tokens = (size_t )64;
    }
    }
  } else {
    {
    {
    projected_n_tokens ++;
    }
    }
  }
  {
  sz = projected_n_tokens;
  tmp = xnmalloc(sz, sizeof(*tokens));
  tokens = (char **)tmp;
  tmp___0 = xnmalloc(sz, sizeof(*lengths));
  lengths = (size_t *)tmp___0;
  n_tokens = (size_t )0;
  init_tokenbuffer(token);
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___2 = readtoken(stream, delim, n_delim, token);
    token_length = tmp___2;
    }
    if (n_tokens >= sz) {
      {
      {
      tmp___3 = x2nrealloc((void *)tokens, & sz, sizeof(*tokens));
      tokens = (char **)tmp___3;
      tmp___4 = xnrealloc((void *)lengths, sz, sizeof(*lengths));
      lengths = (size_t *)tmp___4;
      }
      }
    }
    if (token_length == 0xffffffffffffffffUL) {
      {
      {
      *(tokens + n_tokens) = (char *)((void *)0);
      *(lengths + n_tokens) = (size_t )0;
      }
      goto while_break;
      }
    }
    {
    tmp___5 = xnmalloc(token_length + 1UL, sizeof(*tmp___1));
    tmp___1 = (char *)tmp___5;
    *(lengths + n_tokens) = token_length;
    tmp___6 = memcpy((void *)((void * __restrict )tmp___1), (void const *)((void const * __restrict )token->buffer),
                     token_length + 1UL);
    *(tokens + n_tokens) = (char *)tmp___6;
    n_tokens ++;
    }
  }
  while_break: ;
  }
  {
  free((void *)token->buffer);
  *tokens_out = tokens;
  }
  if ((unsigned long )token_lengths != (unsigned long )((void *)0)) {
    {
    {
    *token_lengths = lengths;
    }
    }
  } else {
    {
    {
    free((void *)lengths);
    }
    }
  }
  return (n_tokens);
}
}
void readtokens0_init(struct Tokens *t )
{
  {
  {
  t->n_tok = (size_t )0;
  t->tok = (char **)((void *)0);
  t->tok_len = (size_t *)((void *)0);
  _obstack_begin(& t->o_data, 0, 0, (void *(*)(long ))(& malloc), & free);
  _obstack_begin(& t->o_tok, 0, 0, (void *(*)(long ))(& malloc), & free);
  _obstack_begin(& t->o_tok_len, 0, 0, (void *(*)(long ))(& malloc), & free);
  }
  return;
}
}
void readtokens0_free(struct Tokens *t )
{
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;
  struct obstack *__o___0 ;
  void *__obj___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  void *__obj___1 ;
  char *tmp___1 ;
  {
  {
  __o = & t->o_data;
  __obj = (void *)0;
  }
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
    {
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
      {
      {
      tmp = (char *)__obj;
      __o->object_base = tmp;
      __o->next_free = tmp;
      }
      }
    } else {
      {
      {
      obstack_free(__o, __obj);
      }
      }
    }
    }
  } else {
    {
    {
    obstack_free(__o, __obj);
    }
    }
  }
  {
  __o___0 = & t->o_tok;
  __obj___0 = (void *)0;
  }
  if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___0->chunk)) {
    {
    if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___0->chunk_limit)) {
      {
      {
      tmp___0 = (char *)__obj___0;
      __o___0->object_base = tmp___0;
      __o___0->next_free = tmp___0;
      }
      }
    } else {
      {
      {
      obstack_free(__o___0, __obj___0);
      }
      }
    }
    }
  } else {
    {
    {
    obstack_free(__o___0, __obj___0);
    }
    }
  }
  {
  __o___1 = & t->o_tok_len;
  __obj___1 = (void *)0;
  }
  if ((unsigned long )__obj___1 > (unsigned long )((void *)__o___1->chunk)) {
    {
    if ((unsigned long )__obj___1 < (unsigned long )((void *)__o___1->chunk_limit)) {
      {
      {
      tmp___1 = (char *)__obj___1;
      __o___1->object_base = tmp___1;
      __o___1->next_free = tmp___1;
      }
      }
    } else {
      {
      {
      obstack_free(__o___1, __obj___1);
      }
      }
    }
    }
  } else {
    {
    {
    obstack_free(__o___1, __obj___1);
    }
    }
  }
  return;
}
}
static void save_token(struct Tokens *t )
{
  size_t len ;
  struct obstack const *__o ;
  char const *s ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;
  struct obstack *__o___0 ;
  struct obstack *__o1___0 ;
  struct obstack *__o___1 ;
  int __len ;
  {
  {
  __o = (struct obstack const *)(& t->o_data);
  len = (size_t )((unsigned int )(__o->next_free - __o->object_base) - 1U);
  __o1 = & t->o_data;
  __value = (void *)__o1->object_base;
  }
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
    {
    {
    __o1->maybe_empty_object = 1U;
    }
    }
  }
  if (sizeof(long ) < sizeof(void *)) {
    {
    {
    tmp = __o1->object_base;
    }
    }
  } else {
    {
    {
    tmp = (char *)0;
    }
    }
  }
  if (sizeof(long ) < sizeof(void *)) {
    {
    {
    tmp___0 = __o1->object_base;
    }
    }
  } else {
    {
    {
    tmp___0 = (char *)0;
    }
    }
  }
  {
  __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
  }
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
    {
    {
    __o1->next_free = __o1->chunk_limit;
    }
    }
  }
  {
  __o1->object_base = __o1->next_free;
  s = (char const *)__value;
  __o___0 = & t->o_tok;
  }
  if ((unsigned long )(__o___0->next_free + sizeof(void *)) > (unsigned long )__o___0->chunk_limit) {
    {
    {
    _obstack_newchunk(__o___0, (int )sizeof(void *));
    }
    }
  }
  {
  __o1___0 = __o___0;
  *((void const **)__o1___0->next_free) = (void const *)s;
  __o1___0->next_free += sizeof(void const *);
  __o___1 = & t->o_tok_len;
  __len = (int )sizeof(len);
  }
  if ((unsigned long )(__o___1->next_free + __len) > (unsigned long )__o___1->chunk_limit) {
    {
    {
    _obstack_newchunk(__o___1, __len);
    }
    }
  }
  {
  memcpy((void *)((void * __restrict )__o___1->next_free), (void const *)((void const * __restrict )(& len)),
         (size_t )__len);
  __o___1->next_free += __len;
  (t->n_tok) ++;
  }
  return;
}
}
_Bool readtokens0(FILE *in , struct Tokens *t )
{
  int c ;
  int tmp ;
  size_t len ;
  struct obstack const *__o ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  char *tmp___1 ;
  struct obstack *__o___2 ;
  struct obstack *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct obstack *__o1___1 ;
  void *__value___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  {
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp = fgetc(in);
    c = tmp;
    }
    if (c == -1) {
      {
      {
      __o = (struct obstack const *)(& t->o_data);
      len = (size_t )((unsigned int )(__o->next_free - __o->object_base));
      }
      if (len) {
        {
        {
        __o___0 = & t->o_data;
        }
        if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
          {
          {
          _obstack_newchunk(__o___0, 1);
          }
          }
        }
        {
        tmp___0 = __o___0->next_free;
        (__o___0->next_free) ++;
        *tmp___0 = (char )'\000';
        save_token(t);
        }
        }
      }
      goto while_break;
      }
    }
    {
    __o___1 = & t->o_data;
    }
    if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
      {
      {
      _obstack_newchunk(__o___1, 1);
      }
      }
    }
    {
    tmp___1 = __o___1->next_free;
    (__o___1->next_free) ++;
    *tmp___1 = (char )c;
    }
    if (c == 0) {
      {
      {
      save_token(t);
      }
      }
    }
  }
  while_break: ;
  }
  {
  __o___2 = & t->o_tok;
  }
  if ((unsigned long )(__o___2->next_free + sizeof(void *)) > (unsigned long )__o___2->chunk_limit) {
    {
    {
    _obstack_newchunk(__o___2, (int )sizeof(void *));
    }
    }
  }
  {
  __o1 = __o___2;
  *((void const **)__o1->next_free) = (void const *)((void *)0);
  __o1->next_free += sizeof(void const *);
  __o1___0 = & t->o_tok;
  __value = (void *)__o1___0->object_base;
  }
  if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
    {
    {
    __o1___0->maybe_empty_object = 1U;
    }
    }
  }
  if (sizeof(long ) < sizeof(void *)) {
    {
    {
    tmp___2 = __o1___0->object_base;
    }
    }
  } else {
    {
    {
    tmp___2 = (char *)0;
    }
    }
  }
  if (sizeof(long ) < sizeof(void *)) {
    {
    {
    tmp___3 = __o1___0->object_base;
    }
    }
  } else {
    {
    {
    tmp___3 = (char *)0;
    }
    }
  }
  {
  __o1___0->next_free = tmp___2 + (((__o1___0->next_free - tmp___3) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
  }
  if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
    {
    {
    __o1___0->next_free = __o1___0->chunk_limit;
    }
    }
  }
  {
  __o1___0->object_base = __o1___0->next_free;
  t->tok = (char **)__value;
  __o1___1 = & t->o_tok_len;
  __value___0 = (void *)__o1___1->object_base;
  }
  if ((unsigned long )__o1___1->next_free == (unsigned long )__value___0) {
    {
    {
    __o1___1->maybe_empty_object = 1U;
    }
    }
  }
  if (sizeof(long ) < sizeof(void *)) {
    {
    {
    tmp___4 = __o1___1->object_base;
    }
    }
  } else {
    {
    {
    tmp___4 = (char *)0;
    }
    }
  }
  if (sizeof(long ) < sizeof(void *)) {
    {
    {
    tmp___5 = __o1___1->object_base;
    }
    }
  } else {
    {
    {
    tmp___5 = (char *)0;
    }
    }
  }
  {
  __o1___1->next_free = tmp___4 + (((__o1___1->next_free - tmp___5) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
  }
  if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
    {
    {
    __o1___1->next_free = __o1___1->chunk_limit;
    }
    }
  }
  {
  __o1___1->object_base = __o1___1->next_free;
  t->tok_len = (size_t *)__value___0;
  tmp___6 = ferror(in);
  }
  if (tmp___6) {
    {
    {
    tmp___7 = 0;
    }
    }
  } else {
    {
    {
    tmp___7 = 1;
    }
    }
  }
  return ((_Bool )tmp___7);
}
}
size_t safe_read(int fd , void *buf___1 , size_t count )
{
  ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  {
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___3 = read(fd, buf___1, count);
    tmp___2 = tmp___3;
    tmp = tmp___2;
    result = tmp;
    }
    if (0L <= result) {
      {
      return ((size_t )result);
      }
    } else {
      {
      {
      tmp___1 = __errno_location();
      }
      if (*tmp___1 == 4) {
        {
        goto __Cont;
        }
      } else {
        {
        {
        tmp___0 = __errno_location();
        }
        if (*tmp___0 == 22) {
          {
          if (2147475456UL < count) {
            {
            {
            count = (size_t )2147475456;
            }
            }
          } else {
            {
            return ((size_t )result);
            }
          }
          }
        } else {
          {
          return ((size_t )result);
          }
        }
        }
      }
      }
    }
    __Cont:
    {
    }
  }
  while_break: ;
  }
  return (0UL);
}
}
size_t safe_write(int fd , void const *buf___1 , size_t count )
{
  ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  {
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp = write(fd, buf___1, count);
    result = tmp;
    }
    if (0L <= result) {
      {
      return ((size_t )result);
      }
    } else {
      {
      {
      tmp___1 = __errno_location();
      }
      if (*tmp___1 == 4) {
        {
        goto __Cont;
        }
      } else {
        {
        {
        tmp___0 = __errno_location();
        }
        if (*tmp___0 == 22) {
          {
          if (2147475456UL < count) {
            {
            {
            count = (size_t )2147475456;
            }
            }
          } else {
            {
            return ((size_t )result);
            }
          }
          }
        } else {
          {
          return ((size_t )result);
          }
        }
        }
      }
      }
    }
    __Cont:
    {
    }
  }
  while_break: ;
  }
  return (0UL);
}
}
_Bool same_name(char const *source , char const *dest )
{
  char const *source_basename ;
  char *tmp ;
  char const *dest_basename ;
  char *tmp___0 ;
  size_t source_baselen ;
  size_t tmp___1 ;
  size_t dest_baselen ;
  size_t tmp___2 ;
  _Bool identical_basenames ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool compare_dirs ;
  _Bool same ;
  struct stat source_dir_stats ;
  struct stat dest_dir_stats ;
  char *source_dirname ;
  char *dest_dirname ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  {
  {
  tmp = last_component(source);
  source_basename = (char const *)tmp;
  tmp___0 = last_component(dest);
  dest_basename = (char const *)tmp___0;
  tmp___1 = base_len(source_basename);
  source_baselen = tmp___1;
  tmp___2 = base_len(dest_basename);
  dest_baselen = tmp___2;
  }
  if (source_baselen == dest_baselen) {
    {
    {
    tmp___3 = memcmp((void const *)source_basename, (void const *)dest_basename,
                     dest_baselen);
    }
    if (tmp___3 == 0) {
      {
      {
      tmp___4 = 1;
      }
      }
    } else {
      {
      {
      tmp___4 = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___4 = 0;
    }
    }
  }
  {
  identical_basenames = (_Bool )tmp___4;
  compare_dirs = identical_basenames;
  same = (_Bool)0;
  }
  if (compare_dirs) {
    {
    {
    source_dirname = dir_name(source);
    dest_dirname = dir_name(dest);
    tmp___6 = stat((char const *)((char const * __restrict )source_dirname),
                   (struct stat *)((struct stat * __restrict )(& source_dir_stats)));
    }
    if (tmp___6) {
      {
      {
      tmp___5 = __errno_location();
      error(1, *tmp___5, (char const *)"%s", source_dirname);
      }
      }
    }
    {
    tmp___8 = stat((char const *)((char const * __restrict )dest_dirname), (struct stat *)((struct stat * __restrict )(& dest_dir_stats)));
    }
    if (tmp___8) {
      {
      {
      tmp___7 = __errno_location();
      error(1, *tmp___7, (char const *)"%s", dest_dirname);
      }
      }
    }
    if (source_dir_stats.st_ino == dest_dir_stats.st_ino) {
      {
      if (source_dir_stats.st_dev == dest_dir_stats.st_dev) {
        {
        {
        tmp___9 = 1;
        }
        }
      } else {
        {
        {
        tmp___9 = 0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___9 = 0;
      }
      }
    }
    {
    same = (_Bool )tmp___9;
    free((void *)source_dirname);
    free((void *)dest_dirname);
    }
    }
  }
  return (same);
}
}
int save_cwd(struct saved_cwd *cwd )
{
  int tmp ;
  {
  {
  cwd->name = (char *)((void *)0);
  cwd->desc = open_safer((char const *)".", 0);
  }
  if (cwd->desc < 0) {
    {
    {
    cwd->name = rpl_getcwd((char *)((void *)0), (size_t )0);
    }
    if (cwd->name) {
      {
      {
      tmp = 0;
      }
      }
    } else {
      {
      {
      tmp = -1;
      }
      }
    }
    return (tmp);
    }
  }
  {
  set_cloexec_flag(cwd->desc, (_Bool)1);
  }
  return (0);
}
}
int restore_cwd(struct saved_cwd const *cwd )
{
  int tmp ;
  int tmp___0 ;
  {
  if (0 <= (int )cwd->desc) {
    {
    {
    tmp = fchdir((int )cwd->desc);
    }
    return (tmp);
    }
  } else {
    {
    {
    tmp___0 = chdir_long((char *)cwd->name);
    }
    return (tmp___0);
    }
  }
}
}
void free_cwd(struct saved_cwd *cwd )
{
  {
  if (cwd->desc >= 0) {
    {
    {
    close(cwd->desc);
    }
    }
  }
  {
  free((void *)cwd->name);
  }
  return;
}
}
char *streamsavedir(DIR *dirp )
{
  char *name_space ;
  size_t allocated ;
  size_t used ;
  int save_errno ;
  void *tmp ;
  struct dirent const *dp ;
  char const *entry ;
  int *tmp___0 ;
  struct dirent *tmp___1 ;
  size_t entry_size ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  {
  {
  allocated = (size_t )512;
  used = (size_t )0;
  }
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
    {
    return ((char *)((void *)0));
    }
  }
  {
  tmp = xmalloc(allocated);
  name_space = (char *)tmp;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___0 = __errno_location();
    *tmp___0 = 0;
    tmp___1 = readdir(dirp);
    dp = (struct dirent const *)tmp___1;
    }
    if (! dp) {
      {
      goto while_break;
      }
    }
    {
    entry = (char const *)(dp->d_name);
    }
    if ((int const )*(entry + 0) != 46) {
      {
      {
      tmp___5 = 0;
      }
      }
    } else {
      {
      if ((int const )*(entry + 1) != 46) {
        {
        {
        tmp___4 = 1;
        }
        }
      } else {
        {
        {
        tmp___4 = 2;
        }
        }
      }
      {
      tmp___5 = tmp___4;
      }
      }
    }
    if ((int const )*(entry + tmp___5) != 0) {
      {
      {
      tmp___2 = strlen((char const *)(dp->d_name));
      entry_size = tmp___2 + 1UL;
      }
      if (used + entry_size < used) {
        {
        {
        xalloc_die();
        }
        }
      }
      if (allocated <= used + entry_size) {
        {
        {
        while (1) {
          while_continue___0: ;
          if (! 1) {
            {
            goto while_break___0;
            }
          }
          if (2UL * allocated < allocated) {
            {
            {
            xalloc_die();
            }
            }
          }
          {
          allocated *= 2UL;
          }
          if (! (allocated <= used + entry_size)) {
            {
            goto while_break___0;
            }
          }
        }
        while_break___0: ;
        }
        {
        tmp___3 = xrealloc((void *)name_space, allocated);
        name_space = (char *)tmp___3;
        }
        }
      }
      {
      memcpy((void *)((void * __restrict )(name_space + used)), (void const *)((void const * __restrict )entry),
             entry_size);
      used += entry_size;
      }
      }
    }
  }
  while_break: ;
  }
  {
  *(name_space + used) = (char )'\000';
  tmp___6 = __errno_location();
  save_errno = *tmp___6;
  }
  if (save_errno != 0) {
    {
    {
    free((void *)name_space);
    tmp___7 = __errno_location();
    *tmp___7 = save_errno;
    }
    return ((char *)((void *)0));
    }
  }
  return (name_space);
}
}
static char *savedirstream(DIR *dirp )
{
  char *name_space ;
  char *tmp ;
  int save_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  {
  {
  tmp = streamsavedir(dirp);
  name_space = tmp;
  }
  if (dirp) {
    {
    {
    tmp___2 = closedir(dirp);
    }
    if (tmp___2 != 0) {
      {
      {
      tmp___0 = __errno_location();
      save_errno = *tmp___0;
      free((void *)name_space);
      tmp___1 = __errno_location();
      *tmp___1 = save_errno;
      }
      return ((char *)((void *)0));
      }
    }
    }
  }
  return (name_space);
}
}
char *savedir(char const *dir )
{
  DIR *tmp ;
  char *tmp___0 ;
  {
  {
  tmp = opendir_safer(dir);
  tmp___0 = savedirstream(tmp);
  }
  return (tmp___0);
}
}
char *fdsavedir(int fd )
{
  DIR *tmp ;
  char *tmp___0 ;
  {
  {
  tmp = fdopendir(fd);
  tmp___0 = savedirstream(tmp);
  }
  return (tmp___0);
}
}
__inline static void savewd_init(struct savewd *wd )
{
  {
  {
  wd->state = (enum __anonenum_state_18 )0;
  }
  return;
}
}
__inline extern int __sigismember(__sigset_t const *__set , int __sig )
{
  unsigned long __mask ;
  unsigned long __word ;
  int tmp ;
  {
  {
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
  }
  if (__set->__val[__word] & __mask) {
    {
    {
    tmp = 1;
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  return (tmp);
}
}
__inline extern int __sigaddset(__sigset_t *__set , int __sig )
{
  unsigned long __mask ;
  unsigned long __word ;
  {
  {
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
  __set->__val[__word] |= __mask;
  }
  return (0);
}
}
__inline extern int __sigdelset(__sigset_t *__set , int __sig )
{
  unsigned long __mask ;
  unsigned long __word ;
  {
  {
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
  __set->__val[__word] &= ~ __mask;
  }
  return (0);
}
}
static _Bool savewd_save(struct savewd *wd )
{
  int fd ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  {
  {
  if ((int )wd->state == 0) {
    {
    goto case_0;
    }
  }
  if ((int )wd->state == 3) {
    {
    goto case_3;
    }
  }
  if ((int )wd->state == 5) {
    {
    goto case_5;
    }
  }
  if ((int )wd->state == 4) {
    {
    goto case_5;
    }
  }
  if ((int )wd->state == 2) {
    {
    goto case_5;
    }
  }
  if ((int )wd->state == 1) {
    {
    goto case_5;
    }
  }
  goto switch_default;
  case_0:
  {
  tmp = open_safer((char const *)".", 0);
  fd = tmp;
  }
  if (0 <= fd) {
    {
    {
    wd->state = (enum __anonenum_state_18 )1;
    wd->val.fd = fd;
    }
    goto switch_break;
    }
  }
  {
  tmp___1 = __errno_location();
  }
  if (*tmp___1 != 13) {
    {
    {
    tmp___2 = __errno_location();
    }
    if (*tmp___2 != 116) {
      {
      {
      wd->state = (enum __anonenum_state_18 )4;
      tmp___0 = __errno_location();
      wd->val.errnum = *tmp___0;
      }
      goto switch_break;
      }
    }
    }
  }
  {
  wd->state = (enum __anonenum_state_18 )3;
  wd->val.child = -1;
  }
  case_3:
  if (wd->val.child < 0) {
    {
    {
    wd->val.child = fork();
    }
    if (wd->val.child != 0) {
      {
      if (0 < wd->val.child) {
        {
        return ((_Bool)1);
        }
      }
      {
      wd->state = (enum __anonenum_state_18 )4;
      tmp___3 = __errno_location();
      wd->val.errnum = *tmp___3;
      }
      }
    }
    }
  }
  goto switch_break;
  case_5:
  case_4:
  case_2:
  case_1:
  goto switch_break;
  switch_default:
  {
  __assert_fail((char const *)"0", (char const *)"savewd.c", 89U, (char const *)"savewd_save");
  }
  switch_break: ;
  }
  return ((_Bool)0);
}
}
int savewd_chdir(struct savewd *wd , char const *dir , int options , int *open_result )
{
  int fd ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int e ;
  int *tmp___6 ;
  int *tmp___7 ;
  {
  {
  fd = -1;
  result = 0;
  }
  if (open_result) {
    {
    goto _L;
    }
  } else {
    {
    if (options & 1) {
      {
      _L:
      if (options & 1) {
        {
        {
        tmp = 131072;
        }
        }
      } else {
        {
        {
        tmp = 0;
        }
        }
      }
      {
      tmp___0 = open(dir, 67840 | tmp);
      fd = tmp___0;
      }
      if (open_result) {
        {
        {
        *(open_result + 0) = fd;
        tmp___1 = __errno_location();
        *(open_result + 1) = *tmp___1;
        }
        }
      }
      if (fd < 0) {
        {
        {
        tmp___2 = __errno_location();
        }
        if (*tmp___2 != 13) {
          {
          {
          result = -1;
          }
          }
        } else {
          {
          if (options & 2) {
            {
            {
            result = -1;
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  if (result == 0) {
    {
    if (0 <= fd) {
      {
      if (! (options & 4)) {
        {
        goto _L___0;
        }
      }
      }
    } else {
      {
      _L___0:
      {
      tmp___5 = savewd_save(wd);
      }
      if (tmp___5) {
        {
        {
        open_result = (int *)((void *)0);
        result = -2;
        }
        }
      } else {
        {
        if (fd < 0) {
          {
          {
          tmp___3 = chdir(dir);
          result = tmp___3;
          }
          }
        } else {
          {
          {
          tmp___4 = fchdir(fd);
          result = tmp___4;
          }
          }
        }
        if (result == 0) {
          {
          {
          if ((int )wd->state == 1) {
            {
            goto case_1;
            }
          }
          if ((int )wd->state == 5) {
            {
            goto case_5;
            }
          }
          if ((int )wd->state == 2) {
            {
            goto case_5;
            }
          }
          if ((int )wd->state == 4) {
            {
            goto case_5;
            }
          }
          if ((int )wd->state == 3) {
            {
            goto case_3;
            }
          }
          goto switch_default;
          case_1:
          {
          wd->state = (enum __anonenum_state_18 )2;
          }
          goto switch_break;
          case_5:
          case_2:
          case_4:
          goto switch_break;
          case_3:
          if (! (wd->val.child == 0)) {
            {
            {
            __assert_fail((char const *)"wd->val.child == 0", (char const *)"savewd.c",
                          145U, (char const *)"savewd_chdir");
            }
            }
          }
          goto switch_break;
          switch_default:
          {
          __assert_fail((char const *)"0", (char const *)"savewd.c", 149U, (char const *)"savewd_chdir");
          }
          switch_break: ;
          }
          }
        }
        }
      }
      }
    }
    }
  }
  if (0 <= fd) {
    {
    if (! open_result) {
      {
      {
      tmp___6 = __errno_location();
      e = *tmp___6;
      close(fd);
      tmp___7 = __errno_location();
      *tmp___7 = e;
      }
      }
    }
    }
  }
  return (result);
}
}
int savewd_restore(struct savewd *wd , int status )
{
  int chdir_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  pid_t child ;
  int child_status ;
  int *tmp___2 ;
  __pid_t tmp___3 ;
  union __anonunion_50 __constr_expr_0 ;
  union __anonunion_51 __constr_expr_1 ;
  union __anonunion_52 __constr_expr_2 ;
  {
  {
  if ((int )wd->state == 1) {
    {
    goto case_1;
    }
  }
  if ((int )wd->state == 0) {
    {
    goto case_1;
    }
  }
  if ((int )wd->state == 2) {
    {
    goto case_2;
    }
  }
  if ((int )wd->state == 4) {
    {
    goto case_4;
    }
  }
  if ((int )wd->state == 3) {
    {
    goto case_3;
    }
  }
  goto switch_default;
  case_1:
  case_0:
  goto switch_break;
  case_2:
  {
  tmp___0 = fchdir(wd->val.fd);
  }
  if (tmp___0 == 0) {
    {
    {
    wd->state = (enum __anonenum_state_18 )1;
    }
    goto switch_break;
    }
  } else {
    {
    {
    tmp = __errno_location();
    chdir_errno = *tmp;
    close(wd->val.fd);
    wd->state = (enum __anonenum_state_18 )4;
    wd->val.errnum = chdir_errno;
    }
    }
  }
  case_4:
  {
  tmp___1 = __errno_location();
  *tmp___1 = wd->val.errnum;
  }
  return (-1);
  case_3:
  {
  child = wd->val.child;
  }
  if (child == 0) {
    {
    {
    _exit(status);
    }
    }
  }
  if (0 < child) {
    {
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      {
      tmp___3 = waitpid(child, & child_status, 0);
      }
      if (! (tmp___3 < 0)) {
        {
        goto while_break;
        }
      }
      {
      tmp___2 = __errno_location();
      }
      if (! (*tmp___2 == 4)) {
        {
        {
        __assert_fail((char const *)"(*__errno_location ()) == 4", (char const *)"savewd.c",
                      206U, (char const *)"savewd_restore");
        }
        }
      }
    }
    while_break: ;
    }
    {
    wd->val.child = -1;
    __constr_expr_1.__in = child_status;
    }
    if (! ((__constr_expr_1.__i & 127) == 0)) {
      {
      {
      __constr_expr_0.__in = child_status;
      raise(__constr_expr_0.__i & 127);
      }
      }
    }
    {
    __constr_expr_2.__in = child_status;
    }
    return ((__constr_expr_2.__i & 65280) >> 8);
    }
  }
  goto switch_break;
  switch_default:
  {
  __assert_fail((char const *)"0", (char const *)"savewd.c", 216U, (char const *)"savewd_restore");
  }
  switch_break: ;
  }
  return (0);
}
}
void savewd_finish(struct savewd *wd )
{
  {
  {
  if ((int )wd->state == 4) {
    {
    goto case_4;
    }
  }
  if ((int )wd->state == 0) {
    {
    goto case_4;
    }
  }
  if ((int )wd->state == 2) {
    {
    goto case_2;
    }
  }
  if ((int )wd->state == 1) {
    {
    goto case_2;
    }
  }
  if ((int )wd->state == 3) {
    {
    goto case_3;
    }
  }
  goto switch_default;
  case_4:
  case_0:
  goto switch_break;
  case_2:
  case_1:
  {
  close(wd->val.fd);
  }
  goto switch_break;
  case_3:
  if (! (wd->val.child < 0)) {
    {
    {
    __assert_fail((char const *)"wd->val.child < 0", (char const *)"savewd.c",
                  237U, (char const *)"savewd_finish");
    }
    }
  }
  goto switch_break;
  switch_default:
  {
  __assert_fail((char const *)"0", (char const *)"savewd.c", 241U, (char const *)"savewd_finish");
  }
  switch_break: ;
  }
  {
  wd->state = (enum __anonenum_state_18 )5;
  }
  return;
}
}
__inline static _Bool savewd_delegating(struct savewd const *wd )
{
  int tmp ;
  {
  if ((unsigned int const )wd->state == 3U) {
    {
    if (0 < (int )wd->val.child) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  return ((_Bool )tmp);
}
}
int savewd_process_files(int n_files , char **file , int (*act)(char * , struct savewd * ,
                                                                void * ) , void *options )
{
  int i ;
  int last_relative ;
  int exit_status ;
  struct savewd wd ;
  int s ;
  int tmp ;
  _Bool tmp___0 ;
  int r ;
  int tmp___1 ;
  int s___0 ;
  int tmp___2 ;
  {
  {
  i = 0;
  exit_status = 0;
  savewd_init(& wd);
  last_relative = n_files - 1;
  }
  {
  while (1) {
    while_continue: ;
    if (! (0 <= last_relative)) {
      {
      goto while_break;
      }
    }
    if (! ((int )*(*(file + last_relative) + 0) == 47)) {
      {
      goto while_break;
      }
    }
    {
    last_relative --;
    }
  }
  while_break: ;
  }
  {
  while (1) {
    while_continue___0: ;
    if (! (i < last_relative)) {
      {
      goto while_break___0;
      }
    }
    {
    tmp___0 = savewd_delegating((struct savewd const *)(& wd));
    }
    if (! tmp___0) {
      {
      {
      tmp = (*act)(*(file + i), & wd, options);
      s = tmp;
      }
      if (exit_status < s) {
        {
        {
        exit_status = s;
        }
        }
      }
      }
    }
    if (! ((int )*(*(file + (i + 1)) + 0) == 47)) {
      {
      {
      tmp___1 = savewd_restore(& wd, exit_status);
      r = tmp___1;
      }
      if (exit_status < r) {
        {
        {
        exit_status = r;
        }
        }
      }
      }
    }
    {
    i ++;
    }
  }
  while_break___0: ;
  }
  {
  savewd_finish(& wd);
  }
  {
  while (1) {
    while_continue___1: ;
    if (! (i < n_files)) {
      {
      goto while_break___1;
      }
    }
    {
    tmp___2 = (*act)(*(file + i), & wd, options);
    s___0 = tmp___2;
    }
    if (exit_status < s___0) {
      {
      {
      exit_status = s___0;
      }
      }
    }
    {
    i ++;
    }
  }
  while_break___1: ;
  }
  return (exit_status);
}
}
int settime(struct timespec const *ts )
{
  int r ;
  int tmp ;
  int *tmp___0 ;
  struct timeval tv ;
  int tmp___1 ;
  {
  {
  tmp = clock_settime(0, ts);
  r = tmp;
  }
  if (r == 0) {
    {
    return (r);
    }
  } else {
    {
    {
    tmp___0 = __errno_location();
    }
    if (*tmp___0 == 1) {
      {
      return (r);
      }
    }
    }
  }
  {
  tv.tv_sec = (time_t )ts->tv_sec;
  tv.tv_usec = (__suseconds_t )(ts->tv_nsec / 1000L);
  tmp___1 = settimeofday((struct timeval const *)(& tv), (struct timezone const *)0);
  }
  return (tmp___1);
}
}
int gl_sockets_startup(int version __attribute__((__unused__)) )
{
  {
  return (0);
}
}
int gl_sockets_cleanup(void)
{
  {
  return (0);
}
}
int mkstemp_safer(char *templ )
{
  int tmp ;
  int tmp___0 ;
  {
  {
  tmp = mkstemp(templ);
  tmp___0 = fd_safer(tmp);
  }
  return (tmp___0);
}
}
static char *memcpy_lowcase(char *dest , char const *src , size_t len )
{
  int __res ;
  __int32_t const **tmp___0 ;
  size_t tmp___1 ;
  {
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___1 = len;
    len --;
    }
    if (! (tmp___1 > 0UL)) {
      {
      goto while_break;
      }
    }
    if (sizeof((unsigned char )*(src + len)) > 1UL) {
      {
      {
      __res = tolower((int )((unsigned char )*(src + len)));
      }
      }
    } else {
      {
      {
      tmp___0 = __ctype_tolower_loc();
      __res = (int )*(*tmp___0 + (int )((unsigned char )*(src + len)));
      }
      }
    }
    {
    *(dest + len) = (char )__res;
    }
  }
  while_break: ;
  }
  return (dest);
}
}
static char *memcpy_uppcase(char *dest , char const *src , size_t len )
{
  int __res ;
  __int32_t const **tmp___0 ;
  size_t tmp___1 ;
  {
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___1 = len;
    len --;
    }
    if (! (tmp___1 > 0UL)) {
      {
      goto while_break;
      }
    }
    if (sizeof((unsigned char )*(src + len)) > 1UL) {
      {
      {
      __res = toupper((int )((unsigned char )*(src + len)));
      }
      }
    } else {
      {
      {
      tmp___0 = __ctype_toupper_loc();
      __res = (int )*(*tmp___0 + (int )((unsigned char )*(src + len)));
      }
      }
    }
    {
    *(dest + len) = (char )__res;
    }
  }
  while_break: ;
  }
  return (dest);
}
}
static size_t strftime_case____0(_Bool upcase , char *s , size_t maxsize , char const *format ,
                                 struct tm const *tp , int ut , int ns )
{
  int hour12 ;
  char const *zone ;
  size_t i ;
  char *p ;
  char const *f ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___1[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  size_t _n ;
  size_t _w ;
  int tmp ;
  size_t _incr ;
  size_t tmp___0 ;
  size_t _delta ;
  char const *tmp___1 ;
  size_t _n___0 ;
  size_t _w___0 ;
  int tmp___2 ;
  size_t _incr___0 ;
  size_t tmp___3 ;
  size_t _delta___0 ;
  size_t len ;
  size_t tmp___4 ;
  size_t _n___1 ;
  size_t _w___1 ;
  int tmp___5 ;
  size_t _incr___1 ;
  size_t tmp___6 ;
  size_t _delta___1 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t _n___2 ;
  size_t _w___2 ;
  int tmp___11 ;
  size_t _incr___2 ;
  size_t tmp___12 ;
  size_t _delta___2 ;
  int century ;
  int tmp___13 ;
  int tmp___14 ;
  size_t _n___3 ;
  size_t _w___3 ;
  int tmp___15 ;
  size_t _incr___3 ;
  size_t tmp___16 ;
  size_t _delta___3 ;
  int padding ;
  size_t _n___4 ;
  size_t _w___4 ;
  int tmp___17 ;
  size_t _incr___4 ;
  size_t tmp___18 ;
  size_t _delta___4 ;
  size_t _n___5 ;
  size_t _w___5 ;
  int tmp___19 ;
  size_t _incr___5 ;
  size_t tmp___20 ;
  size_t _delta___5 ;
  size_t _n___6 ;
  size_t _w___6 ;
  int tmp___21 ;
  size_t _incr___6 ;
  size_t tmp___22 ;
  size_t _delta___6 ;
  size_t _n___7 ;
  size_t _w___7 ;
  int tmp___23 ;
  size_t _incr___7 ;
  size_t tmp___24 ;
  size_t _delta___7 ;
  int j ;
  size_t _n___8 ;
  size_t _w___8 ;
  int tmp___25 ;
  size_t _incr___8 ;
  size_t tmp___26 ;
  size_t _delta___8 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___27 ;
  size_t _n___9 ;
  size_t _w___9 ;
  int tmp___28 ;
  size_t _incr___9 ;
  size_t tmp___29 ;
  size_t _delta___9 ;
  int year___0 ;
  int tmp___30 ;
  int year_adjust ;
  int days ;
  int tmp___31 ;
  int tmp___32 ;
  int d___0 ;
  int tmp___33 ;
  int tmp___34 ;
  int yy ;
  int tmp___35 ;
  int yy___0 ;
  size_t _n___10 ;
  size_t tmp___36 ;
  size_t _w___10 ;
  int tmp___37 ;
  size_t _incr___10 ;
  size_t tmp___38 ;
  size_t _delta___10 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  size_t _n___11 ;
  size_t _w___11 ;
  int tmp___39 ;
  size_t _incr___11 ;
  size_t tmp___40 ;
  size_t _delta___11 ;
  {
  {
  hour12 = (int )tp->tm_hour;
  i = (size_t )0;
  p = s;
  zone = (char const *)((void *)0);
  zone = (char const *)tp->tm_zone;
  }
  if (hour12 > 12) {
    {
    {
    hour12 -= 12;
    }
    }
  } else {
    {
    if (hour12 == 0) {
      {
      {
      hour12 = 12;
      }
      }
    }
    }
  }
  {
  f = format;
  }
  {
  while (1) {
    while_continue: ;
    if (! ((int const )*f != 0)) {
      {
      goto while_break;
      }
    }
    {
    pad = 0;
    digits = 0;
    width = -1;
    to_lowcase = (_Bool)0;
    to_uppcase = upcase;
    change_case = (_Bool)0;
    }
    if ((int const )*f != 37) {
      {
      {
      while (1) {
        while_continue___0: ;
        if (! 1) {
          {
          goto while_break___0;
          }
        }
        {
        _n = (size_t )1;
        }
        if (width < 0) {
          {
          {
          tmp = 0;
          }
          }
        } else {
          {
          {
          tmp = width;
          }
          }
        }
        {
        _w = (size_t )tmp;
        }
        if (_n < _w) {
          {
          {
          tmp___0 = _w;
          }
          }
        } else {
          {
          {
          tmp___0 = _n;
          }
          }
        }
        {
        _incr = tmp___0;
        }
        if (_incr >= maxsize - i) {
          {
          return ((size_t )0);
          }
        }
        if (p) {
          {
          if (digits == 0) {
            {
            if (_n < _w) {
              {
              {
              _delta = (size_t )width - _n;
              }
              if (pad == 48) {
                {
                {
                memset((void *)p, '0', _delta);
                p += _delta;
                }
                }
              } else {
                {
                {
                memset((void *)p, ' ', _delta);
                p += _delta;
                }
                }
              }
              }
            }
            }
          }
          {
          *p = (char )*f;
          p += _n;
          }
          }
        }
        {
        i += _incr;
        }
        goto while_break___0;
      }
      while_break___0: ;
      }
      goto __Cont;
      }
    }
    {
    while (1) {
      while_continue___1: ;
      if (! 1) {
        {
        goto while_break___1;
        }
      }
      {
      f ++;
      }
      {
      if ((int )*f == 48) {
        {
        goto case_48;
        }
      }
      if ((int )*f == 45) {
        {
        goto case_48;
        }
      }
      if ((int )*f == 95) {
        {
        goto case_48;
        }
      }
      if ((int )*f == 94) {
        {
        goto case_94;
        }
      }
      if ((int )*f == 35) {
        {
        goto case_35;
        }
      }
      goto switch_default;
      case_48:
      case_45:
      case_95:
      {
      pad = (int )*f;
      }
      goto while_continue___1;
      case_94:
      {
      to_uppcase = (_Bool)1;
      }
      goto while_continue___1;
      case_35:
      {
      change_case = (_Bool)1;
      }
      goto while_continue___1;
      switch_default:
      goto switch_break;
      switch_break: ;
      }
      goto while_break___1;
    }
    while_break___1: ;
    }
    if ((unsigned int )*f - 48U <= 9U) {
      {
      {
      width = 0;
      }
      {
      while (1) {
        while_continue___2: ;
        if (! 1) {
          {
          goto while_break___2;
          }
        }
        if (width > 214748364) {
          {
          {
          width = 2147483647;
          }
          }
        } else {
          {
          if (width == 214748364) {
            {
            if ((int const )*f - 48 > 7) {
              {
              {
              width = 2147483647;
              }
              }
            } else {
              {
              {
              width *= 10;
              width += (int )((int const )*f - 48);
              }
              }
            }
            }
          } else {
            {
            {
            width *= 10;
            width += (int )((int const )*f - 48);
            }
            }
          }
          }
        }
        {
        f ++;
        }
        if (! ((unsigned int )*f - 48U <= 9U)) {
          {
          goto while_break___2;
          }
        }
      }
      while_break___2: ;
      }
      }
    }
    {
    if ((int )*f == 79) {
      {
      goto case_79;
      }
    }
    if ((int )*f == 69) {
      {
      goto case_79;
      }
    }
    goto switch_default___0;
    case_79:
    case_69:
    {
    tmp___1 = f;
    f ++;
    modifier = (int )*tmp___1;
    }
    goto switch_break___0;
    switch_default___0:
    {
    modifier = 0;
    }
    goto switch_break___0;
    switch_break___0: ;
    }
    {
    format_char = (int )*f;
    }
    {
    if (format_char == 37) {
      {
      goto case_37;
      }
    }
    if (format_char == 97) {
      {
      goto case_97;
      }
    }
    if (format_char == 65) {
      {
      goto case_65;
      }
    }
    if (format_char == 104) {
      {
      goto case_104;
      }
    }
    if (format_char == 98) {
      {
      goto case_104;
      }
    }
    if (format_char == 66) {
      {
      goto case_66;
      }
    }
    if (format_char == 99) {
      {
      goto case_99;
      }
    }
    if (format_char == 67) {
      {
      goto case_67;
      }
    }
    if (format_char == 120) {
      {
      goto case_120;
      }
    }
    if (format_char == 68) {
      {
      goto case_68;
      }
    }
    if (format_char == 100) {
      {
      goto case_100;
      }
    }
    if (format_char == 101) {
      {
      goto case_101;
      }
    }
    if (format_char == 70) {
      {
      goto case_70;
      }
    }
    if (format_char == 72) {
      {
      goto case_72;
      }
    }
    if (format_char == 73) {
      {
      goto case_73;
      }
    }
    if (format_char == 107) {
      {
      goto case_107;
      }
    }
    if (format_char == 108) {
      {
      goto case_108;
      }
    }
    if (format_char == 106) {
      {
      goto case_106;
      }
    }
    if (format_char == 77) {
      {
      goto case_77;
      }
    }
    if (format_char == 109) {
      {
      goto case_109;
      }
    }
    if (format_char == 78) {
      {
      goto case_78;
      }
    }
    if (format_char == 110) {
      {
      goto case_110;
      }
    }
    if (format_char == 80) {
      {
      goto case_80;
      }
    }
    if (format_char == 112) {
      {
      goto case_112;
      }
    }
    if (format_char == 82) {
      {
      goto case_82;
      }
    }
    if (format_char == 114) {
      {
      goto case_114;
      }
    }
    if (format_char == 83) {
      {
      goto case_83;
      }
    }
    if (format_char == 115) {
      {
      goto case_115;
      }
    }
    if (format_char == 88) {
      {
      goto case_88;
      }
    }
    if (format_char == 84) {
      {
      goto case_84;
      }
    }
    if (format_char == 116) {
      {
      goto case_116;
      }
    }
    if (format_char == 117) {
      {
      goto case_117;
      }
    }
    if (format_char == 85) {
      {
      goto case_85;
      }
    }
    if (format_char == 71) {
      {
      goto case_71;
      }
    }
    if (format_char == 103) {
      {
      goto case_71;
      }
    }
    if (format_char == 86) {
      {
      goto case_71;
      }
    }
    if (format_char == 87) {
      {
      goto case_87;
      }
    }
    if (format_char == 119) {
      {
      goto case_119;
      }
    }
    if (format_char == 89) {
      {
      goto case_89;
      }
    }
    if (format_char == 121) {
      {
      goto case_121;
      }
    }
    if (format_char == 90) {
      {
      goto case_90;
      }
    }
    if (format_char == 58) {
      {
      goto case_58;
      }
    }
    if (format_char == 122) {
      {
      goto case_122;
      }
    }
    if (format_char == 0) {
      {
      goto case_0___0;
      }
    }
    goto switch_default___3;
    case_37:
    if (modifier != 0) {
      {
      goto switch_default___3;
      }
    }
    {
    while (1) {
      while_continue___3: ;
      if (! 1) {
        {
        goto while_break___3;
        }
      }
      {
      _n___0 = (size_t )1;
      }
      if (width < 0) {
        {
        {
        tmp___2 = 0;
        }
        }
      } else {
        {
        {
        tmp___2 = width;
        }
        }
      }
      {
      _w___0 = (size_t )tmp___2;
      }
      if (_n___0 < _w___0) {
        {
        {
        tmp___3 = _w___0;
        }
        }
      } else {
        {
        {
        tmp___3 = _n___0;
        }
        }
      }
      {
      _incr___0 = tmp___3;
      }
      if (_incr___0 >= maxsize - i) {
        {
        return ((size_t )0);
        }
      }
      if (p) {
        {
        if (digits == 0) {
          {
          if (_n___0 < _w___0) {
            {
            {
            _delta___0 = (size_t )width - _n___0;
            }
            if (pad == 48) {
              {
              {
              memset((void *)p, '0', _delta___0);
              p += _delta___0;
              }
              }
            } else {
              {
              {
              memset((void *)p, ' ', _delta___0);
              p += _delta___0;
              }
              }
            }
            }
          }
          }
        }
        {
        *p = (char )*f;
        p += _n___0;
        }
        }
      }
      {
      i += _incr___0;
      }
      goto while_break___3;
    }
    while_break___3: ;
    }
    goto switch_break___1;
    case_97:
    if (modifier != 0) {
      {
      goto switch_default___3;
      }
    }
    if (change_case) {
      {
      {
      to_uppcase = (_Bool)1;
      to_lowcase = (_Bool)0;
      }
      }
    }
    goto underlying_strftime;
    case_65:
    if (modifier != 0) {
      {
      goto switch_default___3;
      }
    }
    if (change_case) {
      {
      {
      to_uppcase = (_Bool)1;
      to_lowcase = (_Bool)0;
      }
      }
    }
    goto underlying_strftime;
    case_104:
    case_98:
    if (change_case) {
      {
      {
      to_uppcase = (_Bool)1;
      to_lowcase = (_Bool)0;
      }
      }
    }
    if (modifier != 0) {
      {
      goto switch_default___3;
      }
    }
    goto underlying_strftime;
    case_66:
    if (modifier != 0) {
      {
      goto switch_default___3;
      }
    }
    if (change_case) {
      {
      {
      to_uppcase = (_Bool)1;
      to_lowcase = (_Bool)0;
      }
      }
    }
    goto underlying_strftime;
    case_99:
    if (modifier == 79) {
      {
      goto switch_default___3;
      }
    }
    goto underlying_strftime;
    subformat:
    {
    tmp___4 = strftime_case____0(to_uppcase, (char *)((void *)0), (size_t )-1, subfmt,
                                 tp, ut, ns);
    len = tmp___4;
    }
    {
    while (1) {
      while_continue___4: ;
      if (! 1) {
        {
        goto while_break___4;
        }
      }
      {
      _n___1 = len;
      }
      if (width < 0) {
        {
        {
        tmp___5 = 0;
        }
        }
      } else {
        {
        {
        tmp___5 = width;
        }
        }
      }
      {
      _w___1 = (size_t )tmp___5;
      }
      if (_n___1 < _w___1) {
        {
        {
        tmp___6 = _w___1;
        }
        }
      } else {
        {
        {
        tmp___6 = _n___1;
        }
        }
      }
      {
      _incr___1 = tmp___6;
      }
      if (_incr___1 >= maxsize - i) {
        {
        return ((size_t )0);
        }
      }
      if (p) {
        {
        if (digits == 0) {
          {
          if (_n___1 < _w___1) {
            {
            {
            _delta___1 = (size_t )width - _n___1;
            }
            if (pad == 48) {
              {
              {
              memset((void *)p, '0', _delta___1);
              p += _delta___1;
              }
              }
            } else {
              {
              {
              memset((void *)p, ' ', _delta___1);
              p += _delta___1;
              }
              }
            }
            }
          }
          }
        }
        {
        strftime_case____0(to_uppcase, p, maxsize - i, subfmt, tp, ut, ns);
        p += _n___1;
        }
        }
      }
      {
      i += _incr___1;
      }
      goto while_break___4;
    }
    while_break___4: ;
    }
    goto switch_break___1;
    underlying_strftime:
    {
    u = ufmt;
    tmp___7 = u;
    u ++;
    *tmp___7 = (char )' ';
    tmp___8 = u;
    u ++;
    *tmp___8 = (char )'%';
    }
    if (modifier != 0) {
      {
      {
      tmp___9 = u;
      u ++;
      *tmp___9 = (char )modifier;
      }
      }
    }
    {
    tmp___10 = u;
    u ++;
    *tmp___10 = (char )format_char;
    *u = (char )'\000';
    len___0 = strftime((char * __restrict )(ubuf), sizeof(ubuf), (char const * __restrict )(ufmt),
                       (struct tm const * __restrict )tp);
    }
    if (len___0 != 0UL) {
      {
      {
      while (1) {
        while_continue___5: ;
        if (! 1) {
          {
          goto while_break___5;
          }
        }
        {
        _n___2 = len___0 - 1UL;
        }
        if (width < 0) {
          {
          {
          tmp___11 = 0;
          }
          }
        } else {
          {
          {
          tmp___11 = width;
          }
          }
        }
        {
        _w___2 = (size_t )tmp___11;
        }
        if (_n___2 < _w___2) {
          {
          {
          tmp___12 = _w___2;
          }
          }
        } else {
          {
          {
          tmp___12 = _n___2;
          }
          }
        }
        {
        _incr___2 = tmp___12;
        }
        if (_incr___2 >= maxsize - i) {
          {
          return ((size_t )0);
          }
        }
        if (p) {
          {
          if (digits == 0) {
            {
            if (_n___2 < _w___2) {
              {
              {
              _delta___2 = (size_t )width - _n___2;
              }
              if (pad == 48) {
                {
                {
                memset((void *)p, '0', _delta___2);
                p += _delta___2;
                }
                }
              } else {
                {
                {
                memset((void *)p, ' ', _delta___2);
                p += _delta___2;
                }
                }
              }
              }
            }
            }
          }
          if (to_lowcase) {
            {
            {
            memcpy_lowcase(p, (char const *)(ubuf + 1), _n___2);
            }
            }
          } else {
            {
            if (to_uppcase) {
              {
              {
              memcpy_uppcase(p, (char const *)(ubuf + 1), _n___2);
              }
              }
            } else {
              {
              {
              memcpy((void *)((void * __restrict )((void *)p)), (void const *)((void const * __restrict )((void const *)(ubuf + 1))),
                     _n___2);
              }
              }
            }
            }
          }
          {
          p += _n___2;
          }
          }
        }
        {
        i += _incr___2;
        }
        goto while_break___5;
      }
      while_break___5: ;
      }
      }
    }
    goto switch_break___1;
    case_67:
    if (modifier == 79) {
      {
      goto switch_default___3;
      }
    }
    if (modifier == 69) {
      {
      goto underlying_strftime;
      }
    }
    {
    century = (int )(tp->tm_year / 100 + 19);
    }
    if (tp->tm_year % 100 < 0) {
      {
      if (0 < century) {
        {
        {
        tmp___13 = 1;
        }
        }
      } else {
        {
        {
        tmp___13 = 0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___13 = 0;
      }
      }
    }
    {
    century -= tmp___13;
    digits = 2;
    negative_number = (_Bool )(tp->tm_year < -1900);
    u_number_value = (unsigned int )century;
    }
    goto do_signed_number;
    case_120:
    if (modifier == 79) {
      {
      goto switch_default___3;
      }
    }
    goto underlying_strftime;
    case_68:
    if (modifier != 0) {
      {
      goto switch_default___3;
      }
    }
    {
    subfmt = (char const *)"%m/%d/%y";
    }
    goto subformat;
    case_100:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = (int )tp->tm_mday;
    }
    goto do_number;
    case_101:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = (int )tp->tm_mday;
    }
    goto do_number_spacepad;
    do_tz_offset:
    {
    always_output_a_sign = (_Bool)1;
    }
    goto do_number_body;
    do_number_spacepad:
    if (pad != 48) {
      {
      if (pad != 45) {
        {
        {
        pad = '_';
        }
        }
      }
      }
    }
    do_number:
    {
    negative_number = (_Bool )(number_value < 0);
    u_number_value = (unsigned int )number_value;
    }
    do_signed_number:
    {
    always_output_a_sign = (_Bool)0;
    tz_colon_mask = 0;
    }
    do_number_body:
    if (modifier == 79) {
      {
      if (! negative_number) {
        {
        goto underlying_strftime;
        }
      }
      }
    }
    {
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
    }
    if (negative_number) {
      {
      {
      u_number_value = - u_number_value;
      }
      }
    }
    {
    while (1) {
      while_continue___6: ;
      if (! 1) {
        {
        goto while_break___6;
        }
      }
      if (tz_colon_mask & 1) {
        {
        {
        bufp --;
        *bufp = (char )':';
        }
        }
      }
      {
      tz_colon_mask >>= 1;
      bufp --;
      *bufp = (char )(u_number_value % 10U + 48U);
      u_number_value /= 10U;
      }
      if (! (u_number_value != 0U)) {
        {
        if (! (tz_colon_mask != 0)) {
          {
          goto while_break___6;
          }
        }
        }
      }
    }
    while_break___6: ;
    }
    do_number_sign_and_padding:
    if (digits < width) {
      {
      {
      digits = width;
      }
      }
    }
    if (negative_number) {
      {
      {
      sign_char = (char )'-';
      }
      }
    } else {
      {
      if (always_output_a_sign) {
        {
        {
        tmp___14 = '+';
        }
        }
      } else {
        {
        {
        tmp___14 = 0;
        }
        }
      }
      {
      sign_char = (char )tmp___14;
      }
      }
    }
    if (pad == 45) {
      {
      if (sign_char) {
        {
        {
        while (1) {
          while_continue___7: ;
          if (! 1) {
            {
            goto while_break___7;
            }
          }
          {
          _n___3 = (size_t )1;
          }
          if (width < 0) {
            {
            {
            tmp___15 = 0;
            }
            }
          } else {
            {
            {
            tmp___15 = width;
            }
            }
          }
          {
          _w___3 = (size_t )tmp___15;
          }
          if (_n___3 < _w___3) {
            {
            {
            tmp___16 = _w___3;
            }
            }
          } else {
            {
            {
            tmp___16 = _n___3;
            }
            }
          }
          {
          _incr___3 = tmp___16;
          }
          if (_incr___3 >= maxsize - i) {
            {
            return ((size_t )0);
            }
          }
          if (p) {
            {
            if (digits == 0) {
              {
              if (_n___3 < _w___3) {
                {
                {
                _delta___3 = (size_t )width - _n___3;
                }
                if (pad == 48) {
                  {
                  {
                  memset((void *)p, '0', _delta___3);
                  p += _delta___3;
                  }
                  }
                } else {
                  {
                  {
                  memset((void *)p, ' ', _delta___3);
                  p += _delta___3;
                  }
                  }
                }
                }
              }
              }
            }
            {
            *p = sign_char;
            p += _n___3;
            }
            }
          }
          {
          i += _incr___3;
          }
          goto while_break___7;
        }
        while_break___7: ;
        }
        }
      }
      }
    } else {
      {
      {
      padding = (int )(((long )digits - ((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp)) - (long )(! (! sign_char)));
      }
      if (padding > 0) {
        {
        if (pad == 95) {
          {
          if ((size_t )padding >= maxsize - i) {
            {
            return ((size_t )0);
            }
          }
          if (p) {
            {
            {
            memset((void *)p, ' ', (size_t )padding);
            p += padding;
            }
            }
          }
          {
          i += (size_t )padding;
          }
          if (width > padding) {
            {
            {
            width -= padding;
            }
            }
          } else {
            {
            {
            width = 0;
            }
            }
          }
          if (sign_char) {
            {
            {
            while (1) {
              while_continue___8: ;
              if (! 1) {
                {
                goto while_break___8;
                }
              }
              {
              _n___4 = (size_t )1;
              }
              if (width < 0) {
                {
                {
                tmp___17 = 0;
                }
                }
              } else {
                {
                {
                tmp___17 = width;
                }
                }
              }
              {
              _w___4 = (size_t )tmp___17;
              }
              if (_n___4 < _w___4) {
                {
                {
                tmp___18 = _w___4;
                }
                }
              } else {
                {
                {
                tmp___18 = _n___4;
                }
                }
              }
              {
              _incr___4 = tmp___18;
              }
              if (_incr___4 >= maxsize - i) {
                {
                return ((size_t )0);
                }
              }
              if (p) {
                {
                if (digits == 0) {
                  {
                  if (_n___4 < _w___4) {
                    {
                    {
                    _delta___4 = (size_t )width - _n___4;
                    }
                    if (pad == 48) {
                      {
                      {
                      memset((void *)p, '0', _delta___4);
                      p += _delta___4;
                      }
                      }
                    } else {
                      {
                      {
                      memset((void *)p, ' ', _delta___4);
                      p += _delta___4;
                      }
                      }
                    }
                    }
                  }
                  }
                }
                {
                *p = sign_char;
                p += _n___4;
                }
                }
              }
              {
              i += _incr___4;
              }
              goto while_break___8;
            }
            while_break___8: ;
            }
            }
          }
          }
        } else {
          {
          if ((size_t )digits >= maxsize - i) {
            {
            return ((size_t )0);
            }
          }
          if (sign_char) {
            {
            {
            while (1) {
              while_continue___9: ;
              if (! 1) {
                {
                goto while_break___9;
                }
              }
              {
              _n___5 = (size_t )1;
              }
              if (width < 0) {
                {
                {
                tmp___19 = 0;
                }
                }
              } else {
                {
                {
                tmp___19 = width;
                }
                }
              }
              {
              _w___5 = (size_t )tmp___19;
              }
              if (_n___5 < _w___5) {
                {
                {
                tmp___20 = _w___5;
                }
                }
              } else {
                {
                {
                tmp___20 = _n___5;
                }
                }
              }
              {
              _incr___5 = tmp___20;
              }
              if (_incr___5 >= maxsize - i) {
                {
                return ((size_t )0);
                }
              }
              if (p) {
                {
                if (digits == 0) {
                  {
                  if (_n___5 < _w___5) {
                    {
                    {
                    _delta___5 = (size_t )width - _n___5;
                    }
                    if (pad == 48) {
                      {
                      {
                      memset((void *)p, '0', _delta___5);
                      p += _delta___5;
                      }
                      }
                    } else {
                      {
                      {
                      memset((void *)p, ' ', _delta___5);
                      p += _delta___5;
                      }
                      }
                    }
                    }
                  }
                  }
                }
                {
                *p = sign_char;
                p += _n___5;
                }
                }
              }
              {
              i += _incr___5;
              }
              goto while_break___9;
            }
            while_break___9: ;
            }
            }
          }
          if (p) {
            {
            {
            memset((void *)p, '0', (size_t )padding);
            p += padding;
            }
            }
          }
          {
          i += (size_t )padding;
          width = 0;
          }
          }
        }
        }
      } else {
        {
        if (sign_char) {
          {
          {
          while (1) {
            while_continue___10: ;
            if (! 1) {
              {
              goto while_break___10;
              }
            }
            {
            _n___6 = (size_t )1;
            }
            if (width < 0) {
              {
              {
              tmp___21 = 0;
              }
              }
            } else {
              {
              {
              tmp___21 = width;
              }
              }
            }
            {
            _w___6 = (size_t )tmp___21;
            }
            if (_n___6 < _w___6) {
              {
              {
              tmp___22 = _w___6;
              }
              }
            } else {
              {
              {
              tmp___22 = _n___6;
              }
              }
            }
            {
            _incr___6 = tmp___22;
            }
            if (_incr___6 >= maxsize - i) {
              {
              return ((size_t )0);
              }
            }
            if (p) {
              {
              if (digits == 0) {
                {
                if (_n___6 < _w___6) {
                  {
                  {
                  _delta___6 = (size_t )width - _n___6;
                  }
                  if (pad == 48) {
                    {
                    {
                    memset((void *)p, '0', _delta___6);
                    p += _delta___6;
                    }
                    }
                  } else {
                    {
                    {
                    memset((void *)p, ' ', _delta___6);
                    p += _delta___6;
                    }
                    }
                  }
                  }
                }
                }
              }
              {
              *p = sign_char;
              p += _n___6;
              }
              }
            }
            {
            i += _incr___6;
            }
            goto while_break___10;
          }
          while_break___10: ;
          }
          }
        }
        }
      }
      }
    }
    {
    while (1) {
      while_continue___11: ;
      if (! 1) {
        {
        goto while_break___11;
        }
      }
      {
      _n___7 = (size_t )((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp);
      }
      if (width < 0) {
        {
        {
        tmp___23 = 0;
        }
        }
      } else {
        {
        {
        tmp___23 = width;
        }
        }
      }
      {
      _w___7 = (size_t )tmp___23;
      }
      if (_n___7 < _w___7) {
        {
        {
        tmp___24 = _w___7;
        }
        }
      } else {
        {
        {
        tmp___24 = _n___7;
        }
        }
      }
      {
      _incr___7 = tmp___24;
      }
      if (_incr___7 >= maxsize - i) {
        {
        return ((size_t )0);
        }
      }
      if (p) {
        {
        if (digits == 0) {
          {
          if (_n___7 < _w___7) {
            {
            {
            _delta___7 = (size_t )width - _n___7;
            }
            if (pad == 48) {
              {
              {
              memset((void *)p, '0', _delta___7);
              p += _delta___7;
              }
              }
            } else {
              {
              {
              memset((void *)p, ' ', _delta___7);
              p += _delta___7;
              }
              }
            }
            }
          }
          }
        }
        if (to_lowcase) {
          {
          {
          memcpy_lowcase(p, (char const *)bufp, _n___7);
          }
          }
        } else {
          {
          if (to_uppcase) {
            {
            {
            memcpy_uppcase(p, (char const *)bufp, _n___7);
            }
            }
          } else {
            {
            {
            memcpy((void *)((void * __restrict )((void *)p)), (void const *)((void const * __restrict )((void const *)bufp)),
                   _n___7);
            }
            }
          }
          }
        }
        {
        p += _n___7;
        }
        }
      }
      {
      i += _incr___7;
      }
      goto while_break___11;
    }
    while_break___11: ;
    }
    goto switch_break___1;
    case_70:
    if (modifier != 0) {
      {
      goto switch_default___3;
      }
    }
    {
    subfmt = (char const *)"%Y-%m-%d";
    }
    goto subformat;
    case_72:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = (int )tp->tm_hour;
    }
    goto do_number;
    case_73:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = hour12;
    }
    goto do_number;
    case_107:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = (int )tp->tm_hour;
    }
    goto do_number_spacepad;
    case_108:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = hour12;
    }
    goto do_number_spacepad;
    case_106:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 3;
    negative_number = (_Bool )(tp->tm_yday < -1);
    u_number_value = (unsigned int )tp->tm_yday + 1U;
    }
    goto do_signed_number;
    case_77:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = (int )tp->tm_min;
    }
    goto do_number;
    case_109:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    negative_number = (_Bool )(tp->tm_mon < -1);
    u_number_value = (unsigned int )tp->tm_mon + 1U;
    }
    goto do_signed_number;
    case_78:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    number_value = ns;
    }
    if (width == -1) {
      {
      {
      width = 9;
      }
      }
    } else {
      {
      {
      j = width;
      }
      {
      while (1) {
        while_continue___12: ;
        if (! (j < 9)) {
          {
          goto while_break___12;
          }
        }
        {
        number_value /= 10;
        j ++;
        }
      }
      while_break___12: ;
      }
      }
    }
    {
    digits = width;
    number_value = number_value;
    }
    goto do_number;
    case_110:
    {
    while (1) {
      while_continue___13: ;
      if (! 1) {
        {
        goto while_break___13;
        }
      }
      {
      _n___8 = (size_t )1;
      }
      if (width < 0) {
        {
        {
        tmp___25 = 0;
        }
        }
      } else {
        {
        {
        tmp___25 = width;
        }
        }
      }
      {
      _w___8 = (size_t )tmp___25;
      }
      if (_n___8 < _w___8) {
        {
        {
        tmp___26 = _w___8;
        }
        }
      } else {
        {
        {
        tmp___26 = _n___8;
        }
        }
      }
      {
      _incr___8 = tmp___26;
      }
      if (_incr___8 >= maxsize - i) {
        {
        return ((size_t )0);
        }
      }
      if (p) {
        {
        if (digits == 0) {
          {
          if (_n___8 < _w___8) {
            {
            {
            _delta___8 = (size_t )width - _n___8;
            }
            if (pad == 48) {
              {
              {
              memset((void *)p, '0', _delta___8);
              p += _delta___8;
              }
              }
            } else {
              {
              {
              memset((void *)p, ' ', _delta___8);
              p += _delta___8;
              }
              }
            }
            }
          }
          }
        }
        {
        *p = (char )'\n';
        p += _n___8;
        }
        }
      }
      {
      i += _incr___8;
      }
      goto while_break___13;
    }
    while_break___13: ;
    }
    goto switch_break___1;
    case_80:
    {
    to_lowcase = (_Bool)1;
    format_char = 'p';
    }
    case_112:
    if (change_case) {
      {
      {
      to_uppcase = (_Bool)0;
      to_lowcase = (_Bool)1;
      }
      }
    }
    goto underlying_strftime;
    case_82:
    {
    subfmt = (char const *)"%H:%M";
    }
    goto subformat;
    case_114:
    goto underlying_strftime;
    case_83:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = (int )tp->tm_sec;
    }
    goto do_number;
    case_115:
    {
    ltm = (struct tm )*tp;
    t = mktime(& ltm);
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
    negative_number = (_Bool )(t < 0L);
    }
    {
    while (1) {
      while_continue___14: ;
      if (! 1) {
        {
        goto while_break___14;
        }
      }
      {
      d = (int )(t % 10L);
      t /= 10L;
      bufp --;
      }
      if (negative_number) {
        {
        {
        tmp___27 = - d;
        }
        }
      } else {
        {
        {
        tmp___27 = d;
        }
        }
      }
      {
      *bufp = (char )(tmp___27 + 48);
      }
      if (! (t != 0L)) {
        {
        goto while_break___14;
        }
      }
    }
    while_break___14: ;
    }
    {
    digits = 1;
    always_output_a_sign = (_Bool)0;
    }
    goto do_number_sign_and_padding;
    case_88:
    if (modifier == 79) {
      {
      goto switch_default___3;
      }
    }
    goto underlying_strftime;
    case_84:
    {
    subfmt = (char const *)"%H:%M:%S";
    }
    goto subformat;
    case_116:
    {
    while (1) {
      while_continue___15: ;
      if (! 1) {
        {
        goto while_break___15;
        }
      }
      {
      _n___9 = (size_t )1;
      }
      if (width < 0) {
        {
        {
        tmp___28 = 0;
        }
        }
      } else {
        {
        {
        tmp___28 = width;
        }
        }
      }
      {
      _w___9 = (size_t )tmp___28;
      }
      if (_n___9 < _w___9) {
        {
        {
        tmp___29 = _w___9;
        }
        }
      } else {
        {
        {
        tmp___29 = _n___9;
        }
        }
      }
      {
      _incr___9 = tmp___29;
      }
      if (_incr___9 >= maxsize - i) {
        {
        return ((size_t )0);
        }
      }
      if (p) {
        {
        if (digits == 0) {
          {
          if (_n___9 < _w___9) {
            {
            {
            _delta___9 = (size_t )width - _n___9;
            }
            if (pad == 48) {
              {
              {
              memset((void *)p, '0', _delta___9);
              p += _delta___9;
              }
              }
            } else {
              {
              {
              memset((void *)p, ' ', _delta___9);
              p += _delta___9;
              }
              }
            }
            }
          }
          }
        }
        {
        *p = (char )'\t';
        p += _n___9;
        }
        }
      }
      {
      i += _incr___9;
      }
      goto while_break___15;
    }
    while_break___15: ;
    }
    goto switch_break___1;
    case_117:
    {
    digits = 1;
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
    }
    goto do_number;
    case_85:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
    }
    goto do_number;
    case_71:
    case_103:
    case_86:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    if (tp->tm_year < 0) {
      {
      {
      tmp___30 = 300;
      }
      }
    } else {
      {
      {
      tmp___30 = -100;
      }
      }
    }
    {
    year___0 = (int )(tp->tm_year + (int )((int const )tmp___30));
    year_adjust = 0;
    tmp___31 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
    days = tmp___31;
    }
    if (days < 0) {
      {
      {
      year_adjust = -1;
      }
      if ((year___0 - 1) % 4 == 0) {
        {
        if ((year___0 - 1) % 100 != 0) {
          {
          {
          tmp___32 = 1;
          }
          }
        } else {
          {
          if ((year___0 - 1) % 400 == 0) {
            {
            {
            tmp___32 = 1;
            }
            }
          } else {
            {
            {
            tmp___32 = 0;
            }
            }
          }
          }
        }
        }
      } else {
        {
        {
        tmp___32 = 0;
        }
        }
      }
      {
      days = iso_week_days((int )(tp->tm_yday + (int )((int const )(365 + tmp___32))),
                           (int )tp->tm_wday);
      }
      }
    } else {
      {
      if (year___0 % 4 == 0) {
        {
        if (year___0 % 100 != 0) {
          {
          {
          tmp___33 = 1;
          }
          }
        } else {
          {
          if (year___0 % 400 == 0) {
            {
            {
            tmp___33 = 1;
            }
            }
          } else {
            {
            {
            tmp___33 = 0;
            }
            }
          }
          }
        }
        }
      } else {
        {
        {
        tmp___33 = 0;
        }
        }
      }
      {
      tmp___34 = iso_week_days((int )(tp->tm_yday - (int )((int const )(365 + tmp___33))),
                               (int )tp->tm_wday);
      d___0 = tmp___34;
      }
      if (0 <= d___0) {
        {
        {
        year_adjust = 1;
        days = d___0;
        }
        }
      }
      }
    }
    {
    if ((int )*f == 103) {
      {
      goto case_103___0;
      }
    }
    if ((int )*f == 71) {
      {
      goto case_71___0;
      }
    }
    goto switch_default___1;
    case_103___0:
    {
    yy = (int )((tp->tm_year % 100 + (int )((int const )year_adjust)) % 100);
    digits = 2;
    }
    if (0 <= yy) {
      {
      {
      number_value = yy;
      }
      }
    } else {
      {
      if (tp->tm_year < (int )((int const )(-1900 - year_adjust))) {
        {
        {
        tmp___35 = - yy;
        }
        }
      } else {
        {
        {
        tmp___35 = yy + 100;
        }
        }
      }
      {
      number_value = tmp___35;
      }
      }
    }
    goto do_number;
    case_71___0:
    {
    digits = 4;
    negative_number = (_Bool )(tp->tm_year < (int )((int const )(-1900 - year_adjust)));
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
    }
    goto do_signed_number;
    switch_default___1:
    {
    digits = 2;
    number_value = days / 7 + 1;
    }
    goto do_number;
    switch_break___2: ;
    }
    case_87:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 2;
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
    }
    goto do_number;
    case_119:
    if (modifier == 69) {
      {
      goto switch_default___3;
      }
    }
    {
    digits = 1;
    number_value = (int )tp->tm_wday;
    }
    goto do_number;
    case_89:
    if (modifier == 69) {
      {
      goto underlying_strftime;
      }
    }
    if (modifier == 79) {
      {
      goto switch_default___3;
      }
    } else {
      {
      {
      digits = 4;
      }
      }
    }
    {
    negative_number = (_Bool )(tp->tm_year < -1900);
    u_number_value = (unsigned int )tp->tm_year + 1900U;
    }
    goto do_signed_number;
    case_121:
    if (modifier == 69) {
      {
      goto underlying_strftime;
      }
    }
    {
    yy___0 = (int )(tp->tm_year % 100);
    }
    if (yy___0 < 0) {
      {
      if (tp->tm_year < -1900) {
        {
        {
        yy___0 = - yy___0;
        }
        }
      } else {
        {
        {
        yy___0 += 100;
        }
        }
      }
      }
    }
    {
    digits = 2;
    number_value = yy___0;
    }
    goto do_number;
    case_90:
    if (change_case) {
      {
      {
      to_uppcase = (_Bool)0;
      to_lowcase = (_Bool)1;
      }
      }
    }
    if (! zone) {
      {
      {
      zone = (char const *)"";
      }
      }
    }
    {
    while (1) {
      while_continue___16: ;
      if (! 1) {
        {
        goto while_break___16;
        }
      }
      {
      tmp___36 = strlen(zone);
      _n___10 = tmp___36;
      }
      if (width < 0) {
        {
        {
        tmp___37 = 0;
        }
        }
      } else {
        {
        {
        tmp___37 = width;
        }
        }
      }
      {
      _w___10 = (size_t )tmp___37;
      }
      if (_n___10 < _w___10) {
        {
        {
        tmp___38 = _w___10;
        }
        }
      } else {
        {
        {
        tmp___38 = _n___10;
        }
        }
      }
      {
      _incr___10 = tmp___38;
      }
      if (_incr___10 >= maxsize - i) {
        {
        return ((size_t )0);
        }
      }
      if (p) {
        {
        if (digits == 0) {
          {
          if (_n___10 < _w___10) {
            {
            {
            _delta___10 = (size_t )width - _n___10;
            }
            if (pad == 48) {
              {
              {
              memset((void *)p, '0', _delta___10);
              p += _delta___10;
              }
              }
            } else {
              {
              {
              memset((void *)p, ' ', _delta___10);
              p += _delta___10;
              }
              }
            }
            }
          }
          }
        }
        if (to_lowcase) {
          {
          {
          memcpy_lowcase(p, zone, _n___10);
          }
          }
        } else {
          {
          if (to_uppcase) {
            {
            {
            memcpy_uppcase(p, zone, _n___10);
            }
            }
          } else {
            {
            {
            memcpy((void *)((void * __restrict )((void *)p)), (void const *)((void const * __restrict )((void const *)zone)),
                   _n___10);
            }
            }
          }
          }
        }
        {
        p += _n___10;
        }
        }
      }
      {
      i += _incr___10;
      }
      goto while_break___16;
    }
    while_break___16: ;
    }
    goto switch_break___1;
    case_58:
    {
    colons = (size_t )1;
    }
    {
    while (1) {
      while_continue___17: ;
      if (! ((int const )*(f + colons) == 58)) {
        {
        goto while_break___17;
        }
      }
      goto __Cont___0;
      __Cont___0:
      {
      colons ++;
      }
    }
    while_break___17: ;
    }
    if ((int const )*(f + colons) != 122) {
      {
      goto switch_default___3;
      }
    }
    {
    f += colons;
    }
    goto do_z_conversion;
    case_122:
    {
    colons = (size_t )0;
    }
    do_z_conversion:
    if (tp->tm_isdst < 0) {
      {
      goto switch_break___1;
      }
    }
    {
    diff = (int )tp->tm_gmtoff;
    hour_diff = (diff / 60) / 60;
    min_diff = (diff / 60) % 60;
    sec_diff = diff % 60;
    }
    {
    if ((int )colons == 0) {
      {
      goto case_0;
      }
    }
    if ((int )colons == 1) {
      {
      goto case_1;
      }
    }
    if ((int )colons == 2) {
      {
      goto case_2;
      }
    }
    if ((int )colons == 3) {
      {
      goto case_3;
      }
    }
    goto switch_default___2;
    case_0:
    {
    digits = 5;
    negative_number = (_Bool )(diff < 0);
    tz_colon_mask = 0;
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
    }
    goto do_tz_offset;
    case_1:
    tz_hh_mm:
    {
    digits = 6;
    negative_number = (_Bool )(diff < 0);
    tz_colon_mask = 4;
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
    }
    goto do_tz_offset;
    case_2:
    tz_hh_mm_ss:
    {
    digits = 9;
    negative_number = (_Bool )(diff < 0);
    tz_colon_mask = 20;
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
    }
    goto do_tz_offset;
    case_3:
    if (sec_diff != 0) {
      {
      goto case_2;
      }
    }
    if (min_diff != 0) {
      {
      goto case_1;
      }
    }
    {
    digits = 3;
    negative_number = (_Bool )(diff < 0);
    tz_colon_mask = 0;
    u_number_value = (unsigned int )hour_diff;
    }
    goto do_tz_offset;
    switch_default___2:
    goto switch_default___3;
    switch_break___3: ;
    }
    case_0___0:
    {
    f --;
    }
    switch_default___3:
    bad_format:
    {
    flen = 1;
    }
    {
    while (1) {
      while_continue___18: ;
      if (! ((int const )*(f + (1 - flen)) != 37)) {
        {
        goto while_break___18;
        }
      }
      goto __Cont___1;
      __Cont___1:
      {
      flen ++;
      }
    }
    while_break___18: ;
    }
    {
    while (1) {
      while_continue___19: ;
      if (! 1) {
        {
        goto while_break___19;
        }
      }
      {
      _n___11 = (size_t )flen;
      }
      if (width < 0) {
        {
        {
        tmp___39 = 0;
        }
        }
      } else {
        {
        {
        tmp___39 = width;
        }
        }
      }
      {
      _w___11 = (size_t )tmp___39;
      }
      if (_n___11 < _w___11) {
        {
        {
        tmp___40 = _w___11;
        }
        }
      } else {
        {
        {
        tmp___40 = _n___11;
        }
        }
      }
      {
      _incr___11 = tmp___40;
      }
      if (_incr___11 >= maxsize - i) {
        {
        return ((size_t )0);
        }
      }
      if (p) {
        {
        if (digits == 0) {
          {
          if (_n___11 < _w___11) {
            {
            {
            _delta___11 = (size_t )width - _n___11;
            }
            if (pad == 48) {
              {
              {
              memset((void *)p, '0', _delta___11);
              p += _delta___11;
              }
              }
            } else {
              {
              {
              memset((void *)p, ' ', _delta___11);
              p += _delta___11;
              }
              }
            }
            }
          }
          }
        }
        if (to_lowcase) {
          {
          {
          memcpy_lowcase(p, f + (1 - flen), _n___11);
          }
          }
        } else {
          {
          if (to_uppcase) {
            {
            {
            memcpy_uppcase(p, f + (1 - flen), _n___11);
            }
            }
          } else {
            {
            {
            memcpy((void *)((void * __restrict )((void *)p)), (void const *)((void const * __restrict )((void const *)(f + (1 - flen)))),
                   _n___11);
            }
            }
          }
          }
        }
        {
        p += _n___11;
        }
        }
      }
      {
      i += _incr___11;
      }
      goto while_break___19;
    }
    while_break___19: ;
    }
    goto switch_break___1;
    switch_break___1: ;
    }
    __Cont:
    {
    f ++;
    }
  }
  while_break: ;
  }
  if (p) {
    {
    if (maxsize != 0UL) {
      {
      {
      *p = (char )'\000';
      }
      }
    }
    }
  }
  return (i);
}
}
size_t nstrftime(char *s , size_t maxsize , char const *format , struct tm const *tp ,
                 int ut , int ns )
{
  size_t tmp ;
  {
  {
  tmp = strftime_case____0((_Bool)0, s, maxsize, format, tp, ut, ns);
  }
  return (tmp);
}
}
int mem_cd_iconv(char const *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp )
{
  size_t length ;
  char *result ;
  size_t count ;
  union __anonunion_tmp_21 tmp ;
  char const *inptr ;
  size_t insize ;
  char *outptr ;
  size_t outsize ;
  size_t res ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *outptr___0 ;
  size_t outsize___0 ;
  size_t res___0 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char const *inptr___0 ;
  size_t insize___0 ;
  char *outptr___1 ;
  size_t outsize___1 ;
  size_t res___1 ;
  size_t tmp___6 ;
  int *tmp___7 ;
  size_t res___2 ;
  size_t tmp___8 ;
  int saved_errno ;
  int *tmp___9 ;
  int *tmp___10 ;
  {
  {
  iconv(cd, (char ** __restrict )((void *)0), (size_t * __restrict )((void *)0),
        (char ** __restrict )((void *)0), (size_t * __restrict )((void *)0));
  count = (size_t )0;
  inptr = src;
  insize = srclen;
  }
  {
  while (1) {
    while_continue: ;
    if (! (insize > 0UL)) {
      {
      goto while_break;
      }
    }
    {
    outptr = tmp.buf;
    outsize = (size_t )4096;
    tmp___0 = iconv(cd, (char ** __restrict )((char **)(& inptr)), (size_t * __restrict )(& insize),
                    (char ** __restrict )(& outptr), (size_t * __restrict )(& outsize));
    res = tmp___0;
    }
    if (res == 0xffffffffffffffffUL) {
      {
      {
      tmp___2 = __errno_location();
      }
      if (! (*tmp___2 == 7)) {
        {
        {
        tmp___1 = __errno_location();
        }
        if (*tmp___1 == 22) {
          {
          goto while_break;
          }
        } else {
          {
          return (-1);
          }
        }
        }
      }
      }
    }
    {
    count += (size_t )(outptr - tmp.buf);
    }
  }
  while_break: ;
  }
  {
  outptr___0 = tmp.buf;
  outsize___0 = (size_t )4096;
  tmp___3 = iconv(cd, (char ** __restrict )((void *)0), (size_t * __restrict )((void *)0),
                  (char ** __restrict )(& outptr___0), (size_t * __restrict )(& outsize___0));
  res___0 = tmp___3;
  }
  if (res___0 == 0xffffffffffffffffUL) {
    {
    return (-1);
    }
  }
  {
  count += (size_t )(outptr___0 - tmp.buf);
  length = count;
  }
  if (length == 0UL) {
    {
    {
    *lengthp = (size_t )0;
    }
    return (0);
    }
  }
  if ((unsigned long )*resultp != (unsigned long )((void *)0)) {
    {
    if (*lengthp >= length) {
      {
      {
      result = *resultp;
      }
      }
    } else {
      {
      goto _L;
      }
    }
    }
  } else {
    {
    _L:
    {
    tmp___4 = malloc(length);
    result = (char *)tmp___4;
    }
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      {
      {
      tmp___5 = __errno_location();
      *tmp___5 = 12;
      }
      return (-1);
      }
    }
    }
  }
  {
  iconv(cd, (char ** __restrict )((void *)0), (size_t * __restrict )((void *)0),
        (char ** __restrict )((void *)0), (size_t * __restrict )((void *)0));
  inptr___0 = src;
  insize___0 = srclen;
  outptr___1 = result;
  outsize___1 = length;
  }
  {
  while (1) {
    while_continue___0: ;
    if (! (insize___0 > 0UL)) {
      {
      goto while_break___0;
      }
    }
    {
    tmp___6 = iconv(cd, (char ** __restrict )((char **)(& inptr___0)), (size_t * __restrict )(& insize___0),
                    (char ** __restrict )(& outptr___1), (size_t * __restrict )(& outsize___1));
    res___1 = tmp___6;
    }
    if (res___1 == 0xffffffffffffffffUL) {
      {
      {
      tmp___7 = __errno_location();
      }
      if (*tmp___7 == 22) {
        {
        goto while_break___0;
        }
      } else {
        {
        goto fail;
        }
      }
      }
    }
  }
  while_break___0: ;
  }
  {
  tmp___8 = iconv(cd, (char ** __restrict )((void *)0), (size_t * __restrict )((void *)0),
                  (char ** __restrict )(& outptr___1), (size_t * __restrict )(& outsize___1));
  res___2 = tmp___8;
  }
  if (res___2 == 0xffffffffffffffffUL) {
    {
    goto fail;
    }
  }
  if (outsize___1 != 0UL) {
    {
    {
    abort();
    }
    }
  }
  {
  *resultp = result;
  *lengthp = length;
  }
  return (0);
  fail:
  if ((unsigned long )result != (unsigned long )*resultp) {
    {
    {
    tmp___9 = __errno_location();
    saved_errno = *tmp___9;
    free((void *)result);
    tmp___10 = __errno_location();
    *tmp___10 = saved_errno;
    }
    }
  }
  return (-1);
}
}
char *str_cd_iconv(char const *src , iconv_t cd )
{
  char *result ;
  size_t result_size ;
  size_t length ;
  char const *inptr ;
  size_t inbytes_remaining ;
  size_t tmp ;
  size_t approx_sqrt_SIZE_MAX ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *outptr ;
  size_t outbytes_remaining ;
  size_t res ;
  size_t tmp___2 ;
  size_t used ;
  size_t newsize ;
  char *newresult ;
  int *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t res___0 ;
  size_t tmp___8 ;
  size_t used___0 ;
  size_t newsize___0 ;
  char *newresult___0 ;
  int *tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *smaller_result ;
  void *tmp___14 ;
  int saved_errno ;
  int *tmp___15 ;
  int *tmp___16 ;
  {
  {
  inptr = src;
  tmp = strlen(src);
  inbytes_remaining = tmp;
  result_size = inbytes_remaining;
  approx_sqrt_SIZE_MAX = 0xffffffffffffffffUL >> (sizeof(size_t ) * 8UL) / 2UL;
  }
  if (result_size <= approx_sqrt_SIZE_MAX / 16UL) {
    {
    {
    result_size *= 16UL;
    }
    }
  }
  {
  result_size ++;
  tmp___0 = malloc(result_size);
  result = (char *)tmp___0;
  }
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
    {
    tmp___1 = __errno_location();
    *tmp___1 = 12;
    }
    return ((char *)((void *)0));
    }
  }
  {
  iconv(cd, (char ** __restrict )((void *)0), (size_t * __restrict )((void *)0),
        (char ** __restrict )((void *)0), (size_t * __restrict )((void *)0));
  outptr = result;
  outbytes_remaining = result_size - 1UL;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___2 = iconv(cd, (char ** __restrict )((char **)(& inptr)), (size_t * __restrict )(& inbytes_remaining),
                    (char ** __restrict )(& outptr), (size_t * __restrict )(& outbytes_remaining));
    res = tmp___2;
    }
    if (res == 0xffffffffffffffffUL) {
      {
      {
      tmp___7 = __errno_location();
      }
      if (*tmp___7 == 22) {
        {
        goto while_break;
        }
      } else {
        {
        {
        tmp___6 = __errno_location();
        }
        if (*tmp___6 == 7) {
          {
          {
          used = (size_t )(outptr - result);
          newsize = result_size * 2UL;
          }
          if (! (newsize > result_size)) {
            {
            {
            tmp___3 = __errno_location();
            *tmp___3 = 12;
            }
            goto failed;
            }
          }
          {
          tmp___4 = realloc((void *)result, newsize);
          newresult = (char *)tmp___4;
          }
          if ((unsigned long )newresult == (unsigned long )((void *)0)) {
            {
            {
            tmp___5 = __errno_location();
            *tmp___5 = 12;
            }
            goto failed;
            }
          }
          {
          result = newresult;
          result_size = newsize;
          outptr = result + used;
          outbytes_remaining = (result_size - 1UL) - used;
          }
          }
        } else {
          {
          goto failed;
          }
        }
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
  }
  while_break: ;
  }
  {
  while (1) {
    while_continue___0: ;
    if (! 1) {
      {
      goto while_break___0;
      }
    }
    {
    tmp___8 = iconv(cd, (char ** __restrict )((void *)0), (size_t * __restrict )((void *)0),
                    (char ** __restrict )(& outptr), (size_t * __restrict )(& outbytes_remaining));
    res___0 = tmp___8;
    }
    if (res___0 == 0xffffffffffffffffUL) {
      {
      {
      tmp___12 = __errno_location();
      }
      if (*tmp___12 == 7) {
        {
        {
        used___0 = (size_t )(outptr - result);
        newsize___0 = result_size * 2UL;
        }
        if (! (newsize___0 > result_size)) {
          {
          {
          tmp___9 = __errno_location();
          *tmp___9 = 12;
          }
          goto failed;
          }
        }
        {
        tmp___10 = realloc((void *)result, newsize___0);
        newresult___0 = (char *)tmp___10;
        }
        if ((unsigned long )newresult___0 == (unsigned long )((void *)0)) {
          {
          {
          tmp___11 = __errno_location();
          *tmp___11 = 12;
          }
          goto failed;
          }
        }
        {
        result = newresult___0;
        result_size = newsize___0;
        outptr = result + used___0;
        outbytes_remaining = (result_size - 1UL) - used___0;
        }
        }
      } else {
        {
        goto failed;
        }
      }
      }
    } else {
      {
      goto while_break___0;
      }
    }
  }
  while_break___0: ;
  }
  {
  tmp___13 = outptr;
  outptr ++;
  *tmp___13 = (char )'\000';
  length = (size_t )(outptr - result);
  }
  if (length < result_size) {
    {
    {
    tmp___14 = realloc((void *)result, length);
    smaller_result = (char *)tmp___14;
    }
    if ((unsigned long )smaller_result != (unsigned long )((void *)0)) {
      {
      {
      result = smaller_result;
      }
      }
    }
    }
  }
  return (result);
  failed:
  {
  tmp___15 = __errno_location();
  saved_errno = *tmp___15;
  free((void *)result);
  tmp___16 = __errno_location();
  *tmp___16 = saved_errno;
  }
  return ((char *)((void *)0));
}
}
char *str_iconv(char const *src , char const *from_codeset , char const *to_codeset )
{
  char *result ;
  char *tmp___4 ;
  int *tmp___5 ;
  iconv_t cd ;
  char *result___0 ;
  int saved_errno ;
  int *tmp___6 ;
  int *tmp___7 ;
  int saved_errno___0 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  {
  if ((int const )*src == 0) {
    {
    goto _L;
    }
  } else {
    {
    {
    tmp___11 = c_strcasecmp(from_codeset, to_codeset);
    }
    if (tmp___11 == 0) {
      {
      _L:
      {
      tmp___4 = __strdup(src);
      result = tmp___4;
      }
      if ((unsigned long )result == (unsigned long )((void *)0)) {
        {
        {
        tmp___5 = __errno_location();
        *tmp___5 = 12;
        }
        }
      }
      return (result);
      }
    } else {
      {
      {
      cd = iconv_open(to_codeset, from_codeset);
      }
      if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
        {
        return ((char *)((void *)0));
        }
      }
      {
      result___0 = str_cd_iconv(src, cd);
      }
      if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
        {
        {
        tmp___6 = __errno_location();
        saved_errno = *tmp___6;
        iconv_close(cd);
        tmp___7 = __errno_location();
        *tmp___7 = saved_errno;
        }
        }
      } else {
        {
        {
        tmp___10 = iconv_close(cd);
        }
        if (tmp___10 < 0) {
          {
          {
          tmp___8 = __errno_location();
          saved_errno___0 = *tmp___8;
          free((void *)result___0);
          tmp___9 = __errno_location();
          *tmp___9 = saved_errno___0;
          }
          return ((char *)((void *)0));
          }
        }
        }
      }
      return (result___0);
      }
    }
    }
  }
}
}
size_t strnlen1(char const *string , size_t maxlen )
{
  char const *end ;
  void *tmp ;
  {
  {
  tmp = memchr((void const *)string, '\000', maxlen);
  end = (char const *)tmp;
  }
  if ((unsigned long )end != (unsigned long )((void *)0)) {
    {
    return ((size_t )((end - string) + 1L));
    }
  } else {
    {
    return (maxlen);
    }
  }
}
}
__inline static _Bool __attribute__((__pure__)) check_x_suffix(char const *s ,
                                                                size_t len )
{
  unsigned long tmp___8 ;
  {
  {
  tmp___8 = __builtin_strspn(s, (char const *)"X");
  }
  return ((_Bool __attribute__((__pure__)) )(len <= tmp___8));
}
}
int gen_tempname_len(char *tmpl , int suffixlen , int flags , int kind , size_t x_suffix_len )
{
  size_t len ;
  char *XXXXXX ;
  unsigned int count ;
  int fd ;
  int save_errno ;
  int *tmp ;
  struct stat st ;
  struct randint_source *rand_src ;
  unsigned int attempts ;
  int *tmp___0 ;
  _Bool __attribute__((__pure__)) tmp___1 ;
  size_t i ;
  randint tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int saved_errno ;
  int *tmp___10 ;
  int *tmp___11 ;
  {
  {
  fd = -1;
  tmp = __errno_location();
  save_errno = *tmp;
  attempts = 238328U;
  len = strlen((char const *)tmpl);
  }
  if (len < x_suffix_len + (size_t )suffixlen) {
    {
    {
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    }
    return (-1);
    }
  } else {
    {
    {
    tmp___1 = check_x_suffix((char const *)(tmpl + ((len - x_suffix_len) - (size_t )suffixlen)),
                             x_suffix_len);
    }
    if (! tmp___1) {
      {
      {
      tmp___0 = __errno_location();
      *tmp___0 = 22;
      }
      return (-1);
      }
    }
    }
  }
  {
  XXXXXX = tmpl + ((len - x_suffix_len) - (size_t )suffixlen);
  rand_src = randint_all_new((char const *)((void *)0), x_suffix_len);
  }
  if (! rand_src) {
    {
    return (-1);
    }
  }
  {
  count = 0U;
  }
  {
  while (1) {
    while_continue: ;
    if (! (count < attempts)) {
      {
      goto while_break;
      }
    }
    {
    i = (size_t )0;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! (i < x_suffix_len)) {
        {
        goto while_break___0;
        }
      }
      {
      tmp___2 = randint_genmax(rand_src, sizeof(letters) - 2UL);
      *(XXXXXX + i) = (char )letters[tmp___2];
      i ++;
      }
    }
    while_break___0: ;
    }
    {
    if (kind == 0) {
      {
      goto case_0;
      }
    }
    if (kind == 1) {
      {
      goto case_1;
      }
    }
    if (kind == 2) {
      {
      goto case_2;
      }
    }
    goto switch_default;
    case_0:
    {
    tmp___3 = open((char const *)tmpl, (((flags & -4) | 2) | 64) | 128, 384);
    fd = tmp___3;
    }
    goto switch_break;
    case_1:
    {
    fd = mkdir((char const *)tmpl, (__mode_t )448);
    }
    goto switch_break;
    case_2:
    {
    tmp___6 = lstat((char const *)((char const * __restrict )tmpl), (struct stat *)((struct stat * __restrict )(& st)));
    }
    if (tmp___6 < 0) {
      {
      {
      tmp___5 = __errno_location();
      }
      if (*tmp___5 == 2) {
        {
        {
        tmp___4 = __errno_location();
        *tmp___4 = save_errno;
        fd = 0;
        }
        goto done;
        }
      } else {
        {
        {
        fd = -1;
        }
        goto done;
        }
      }
      }
    }
    goto __Cont;
    switch_default:
    {
    __assert_fail((char const *)"! \"invalid KIND in __gen_tempname\"", (char const *)"tempname.c",
                  296U, (char const *)"gen_tempname_len");
    abort();
    }
    switch_break: ;
    }
    if (fd >= 0) {
      {
      {
      tmp___7 = __errno_location();
      *tmp___7 = save_errno;
      }
      goto done;
      }
    } else {
      {
      {
      tmp___8 = __errno_location();
      }
      if (*tmp___8 != 17) {
        {
        {
        fd = -1;
        }
        goto done;
        }
      }
      }
    }
    __Cont:
    {
    count ++;
    }
  }
  while_break: ;
  }
  {
  randint_all_free(rand_src);
  tmp___9 = __errno_location();
  *tmp___9 = 17;
  }
  return (-1);
  done:
  {
  tmp___10 = __errno_location();
  saved_errno = *tmp___10;
  randint_all_free(rand_src);
  tmp___11 = __errno_location();
  *tmp___11 = saved_errno;
  }
  return (fd);
}
}
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind )
{
  int tmp ;
  {
  {
  tmp = gen_tempname_len(tmpl, suffixlen, flags, kind, (size_t )6);
  }
  return (tmp);
}
}
__inline static void mbiter_multi_next(struct mbiter_multi *iter )
{
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  {
  if (iter->next_done) {
    {
    return;
    }
  }
  if (iter->in_shift) {
    {
    goto with_shift;
    }
  }
  {
  tmp___1 = is_basic((char )*(iter->cur.ptr));
  }
  if (tmp___1) {
    {
    {
    iter->cur.bytes = (size_t )1;
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
    iter->cur.wc_valid = (_Bool)1;
    }
    }
  } else {
    {
    {
    tmp = mbsinit((mbstate_t const *)(& iter->state));
    }
    if (! tmp) {
      {
      {
      __assert_fail((char const *)"mbsinit (&iter->state)", (char const *)"mbiter.h",
                    134U, (char const *)"mbiter_multi_next");
      }
      }
    }
    {
    iter->in_shift = (_Bool)1;
    }
    with_shift:
    {
    iter->cur.bytes = mbrtowc((wchar_t * __restrict )(& iter->cur.wc), (char const * __restrict )iter->cur.ptr,
                              (size_t )(iter->limit - iter->cur.ptr), & iter->state);
    }
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
      {
      {
      iter->cur.bytes = (size_t )1;
      iter->cur.wc_valid = (_Bool)0;
      }
      }
    } else {
      {
      if (iter->cur.bytes == 0xfffffffffffffffeUL) {
        {
        {
        iter->cur.bytes = (size_t )(iter->limit - iter->cur.ptr);
        iter->cur.wc_valid = (_Bool)0;
        }
        }
      } else {
        {
        if (iter->cur.bytes == 0UL) {
          {
          {
          iter->cur.bytes = (size_t )1;
          }
          if (! ((int const )*(iter->cur.ptr) == 0)) {
            {
            {
            __assert_fail((char const *)"*iter->cur.ptr == \'\\0\'", (char const *)"mbiter.h",
                          161U, (char const *)"mbiter_multi_next");
            }
            }
          }
          if (! (iter->cur.wc == 0)) {
            {
            {
            __assert_fail((char const *)"iter->cur.wc == 0", (char const *)"mbiter.h",
                          162U, (char const *)"mbiter_multi_next");
            }
            }
          }
          }
        }
        {
        iter->cur.wc_valid = (_Bool)1;
        tmp___0 = mbsinit((mbstate_t const *)(& iter->state));
        }
        if (tmp___0) {
          {
          {
          iter->in_shift = (_Bool)0;
          }
          }
        }
        }
      }
      }
    }
    }
  }
  {
  iter->next_done = (_Bool)1;
  }
  return;
}
}
char *trim2(char const *s , int how )
{
  char *d ;
  char *tmp___4 ;
  mbi_iterator_t i ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  unsigned int state ;
  char *r ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *p ;
  unsigned short const **tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  unsigned short const **tmp___17 ;
  size_t tmp___18 ;
  {
  {
  tmp___4 = __strdup(s);
  d = tmp___4;
  }
  if (! d) {
    {
    {
    xalloc_die();
    }
    }
  }
  {
  tmp___18 = __ctype_get_mb_cur_max();
  }
  if (tmp___18 > 1UL) {
    {
    if (how != 0) {
      {
      {
      i.cur.ptr = (char const *)d;
      tmp___5 = strlen((char const *)d);
      i.limit = i.cur.ptr + tmp___5;
      i.in_shift = (_Bool)0;
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
      i.next_done = (_Bool)0;
      }
      {
      while (1) {
        while_continue: ;
        if (! 1) {
          {
          goto while_break;
          }
        }
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
          {
          {
          mbiter_multi_next(& i);
          }
          if (i.cur.wc_valid) {
            {
            {
            tmp___6 = iswspace((wint_t )i.cur.wc);
            }
            if (! tmp___6) {
              {
              goto while_break;
              }
            }
            }
          } else {
            {
            goto while_break;
            }
          }
          }
        } else {
          {
          goto while_break;
          }
        }
        {
        i.cur.ptr += i.cur.bytes;
        i.next_done = (_Bool)0;
        }
      }
      while_break: ;
      }
      {
      tmp___7 = strlen(i.cur.ptr);
      memmove((void *)d, (void const *)i.cur.ptr, tmp___7 + 1UL);
      }
      }
    }
    if (how != 1) {
      {
      {
      state = 0U;
      i.cur.ptr = (char const *)d;
      tmp___8 = strlen((char const *)d);
      i.limit = i.cur.ptr + tmp___8;
      i.in_shift = (_Bool)0;
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
      i.next_done = (_Bool)0;
      }
      {
      while (1) {
        while_continue___0: ;
        if (! 1) {
          {
          goto while_break___0;
          }
        }
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
          {
          {
          mbiter_multi_next(& i);
          }
          }
        } else {
          {
          goto while_break___0;
          }
        }
        if (state == 0U) {
          {
          if (i.cur.wc_valid) {
            {
            {
            tmp___9 = iswspace((wint_t )i.cur.wc);
            }
            if (tmp___9) {
              {
              goto __Cont;
              }
            }
            }
          }
          }
        }
        if (state == 0U) {
          {
          if (i.cur.wc_valid) {
            {
            {
            tmp___10 = iswspace((wint_t )i.cur.wc);
            }
            if (! tmp___10) {
              {
              {
              state = 1U;
              }
              goto __Cont;
              }
            }
            }
          } else {
            {
            {
            state = 1U;
            }
            goto __Cont;
            }
          }
          }
        }
        if (state == 1U) {
          {
          if (i.cur.wc_valid) {
            {
            {
            tmp___11 = iswspace((wint_t )i.cur.wc);
            }
            if (! tmp___11) {
              {
              goto __Cont;
              }
            }
            }
          } else {
            {
            goto __Cont;
            }
          }
          }
        }
        if (state == 1U) {
          {
          if (i.cur.wc_valid) {
            {
            {
            tmp___13 = iswspace((wint_t )i.cur.wc);
            }
            if (tmp___13) {
              {
              {
              state = 2U;
              r = (char *)i.cur.ptr;
              }
              }
            } else {
              {
              goto _L;
              }
            }
            }
          } else {
            {
            goto _L;
            }
          }
          }
        } else {
          {
          _L:
          if (state == 2U) {
            {
            if (i.cur.wc_valid) {
              {
              {
              tmp___12 = iswspace((wint_t )i.cur.wc);
              }
              if (! tmp___12) {
                {
                {
                state = 1U;
                }
                }
              }
              }
            } else {
              {
              {
              state = 1U;
              }
              }
            }
            }
          } else {
            {
            {
            state = 1U;
            }
            }
          }
          }
        }
        __Cont:
        {
        i.cur.ptr += i.cur.bytes;
        i.next_done = (_Bool)0;
        }
      }
      while_break___0: ;
      }
      if (state == 2U) {
        {
        {
        *r = (char )'\000';
        }
        }
      }
      }
    }
    }
  } else {
    {
    if (how != 0) {
      {
      {
      p = d;
      }
      {
      while (1) {
        while_continue___1: ;
        if (! 1) {
          {
          goto while_break___1;
          }
        }
        if (*p) {
          {
          {
          tmp___14 = __ctype_b_loc();
          }
          if (! ((int const )*(*tmp___14 + (int )((unsigned char )*p)) & 8192)) {
            {
            goto while_break___1;
            }
          }
          }
        } else {
          {
          goto while_break___1;
          }
        }
        {
        p ++;
        }
      }
      while_break___1: ;
      }
      {
      tmp___15 = strlen((char const *)p);
      memmove((void *)d, (void const *)p, tmp___15 + 1UL);
      }
      }
    }
    if (how != 1) {
      {
      {
      tmp___16 = strlen((char const *)d);
      p = (d + tmp___16) - 1;
      }
      {
      while (1) {
        while_continue___2: ;
        if (! 1) {
          {
          goto while_break___2;
          }
        }
        if ((unsigned long )p >= (unsigned long )d) {
          {
          {
          tmp___17 = __ctype_b_loc();
          }
          if (! ((int const )*(*tmp___17 + (int )((unsigned char )*p)) & 8192)) {
            {
            goto while_break___2;
            }
          }
          }
        } else {
          {
          goto while_break___2;
          }
        }
        {
        *p = (char )'\000';
        p --;
        }
      }
      while_break___2: ;
      }
      }
    }
    }
  }
  return (d);
}
}
__inline static int u8_uctomb(uint8_t *s , ucs4_t uc , int n )
{
  int tmp ;
  {
  if (uc < 128U) {
    {
    if (n > 0) {
      {
      {
      *(s + 0) = (uint8_t )uc;
      }
      return (1);
      }
    } else {
      {
      {
      tmp = u8_uctomb_aux(s, uc, n);
      }
      return (tmp);
      }
    }
    }
  } else {
    {
    {
    tmp = u8_uctomb_aux(s, uc, n);
    }
    return (tmp);
    }
  }
}
}
long unicode_to_mb(unsigned int code , long (*success)(char const *buf , size_t buflen ,
                                                       void *callback_arg ) , long (*failure)(unsigned int code ,
                                                                                              char const *msg ,
                                                                                              void *callback_arg ) ,
                   void *callback_arg )
{
  char inbuf[6] ;
  int count ;
  char const *charset ;
  char const *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  char outbuf[25] ;
  char const *inptr ;
  size_t inbytesleft ;
  char *outptr ;
  size_t outbytesleft ;
  size_t res ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  {
  if (! initialized) {
    {
    {
    tmp = locale_charset();
    charset = tmp;
    }
    if (0) {
      {
      {
      __s1_len = __builtin_strlen(charset);
      __s2_len = __builtin_strlen((char const *)"UTF-8");
      }
      if (! ((size_t )((void const *)(charset + 1)) - (size_t )((void const *)charset) == 1UL)) {
        {
        goto _L___0;
        }
      } else {
        {
        if (__s1_len >= 4UL) {
          {
          _L___0:
          if (! ((size_t )((void const *)("UTF-8" + 1)) - (size_t )((void const *)"UTF-8") == 1UL)) {
            {
            {
            tmp___6 = 1;
            }
            }
          } else {
            {
            if (__s2_len >= 4UL) {
              {
              {
              tmp___6 = 1;
              }
              }
            } else {
              {
              {
              tmp___6 = 0;
              }
              }
            }
            }
          }
          }
        } else {
          {
          {
          tmp___6 = 0;
          }
          }
        }
        }
      }
      if (tmp___6) {
        {
        {
        tmp___1 = __builtin_strcmp(charset, (char const *)"UTF-8");
        tmp___5 = tmp___1;
        }
        }
      } else {
        {
        {
        tmp___4 = __builtin_strcmp(charset, (char const *)"UTF-8");
        tmp___5 = tmp___4;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___4 = __builtin_strcmp(charset, (char const *)"UTF-8");
      tmp___5 = tmp___4;
      }
      }
    }
    if (tmp___5) {
      {
      {
      tmp___7 = 0;
      }
      }
    } else {
      {
      {
      tmp___7 = 1;
      }
      }
    }
    {
    is_utf8 = tmp___7;
    }
    if (! is_utf8) {
      {
      {
      utf8_to_local = iconv_open(charset, (char const *)"UTF-8");
      }
      if ((unsigned long )utf8_to_local == (unsigned long )((iconv_t )-1)) {
        {
        {
        utf8_to_local = iconv_open((char const *)"ASCII", (char const *)"UTF-8");
        }
        }
      }
      }
    }
    {
    initialized = 1;
    }
    }
  }
  if (! is_utf8) {
    {
    if ((unsigned long )utf8_to_local == (unsigned long )((iconv_t )-1)) {
      {
      {
      tmp___8 = (*failure)(code, (char const *)"iconv function not usable", callback_arg);
      }
      return (tmp___8);
      }
    }
    }
  }
  {
  count = u8_uctomb((unsigned char *)(inbuf), code, (int )sizeof(inbuf));
  }
  if (count < 0) {
    {
    {
    tmp___9 = (*failure)(code, (char const *)"character out of range", callback_arg);
    }
    return (tmp___9);
    }
  }
  if (! is_utf8) {
    {
    {
    inptr = (char const *)(inbuf);
    inbytesleft = (size_t )count;
    outptr = outbuf;
    outbytesleft = sizeof(outbuf);
    res = iconv(utf8_to_local, (char ** __restrict )((char **)(& inptr)), (size_t * __restrict )(& inbytesleft),
                (char ** __restrict )(& outptr), (size_t * __restrict )(& outbytesleft));
    }
    if (inbytesleft > 0UL) {
      {
      {
      tmp___10 = (*failure)(code, (char const *)((void *)0), callback_arg);
      }
      return (tmp___10);
      }
    } else {
      {
      if (res == 0xffffffffffffffffUL) {
        {
        {
        tmp___10 = (*failure)(code, (char const *)((void *)0), callback_arg);
        }
        return (tmp___10);
        }
      }
      }
    }
    {
    res = iconv(utf8_to_local, (char ** __restrict )((void *)0), (size_t * __restrict )((void *)0),
                (char ** __restrict )(& outptr), (size_t * __restrict )(& outbytesleft));
    }
    if (res == 0xffffffffffffffffUL) {
      {
      {
      tmp___11 = (*failure)(code, (char const *)((void *)0), callback_arg);
      }
      return (tmp___11);
      }
    }
    {
    tmp___12 = (*success)((char const *)(outbuf), (size_t )(outptr - outbuf), callback_arg);
    }
    return (tmp___12);
    }
  }
  {
  tmp___13 = (*success)((char const *)(inbuf), (size_t )count, callback_arg);
  }
  return (tmp___13);
}
}
long fwrite_success_callback(char const *buf___1 , size_t buflen , void *callback_arg )
{
  FILE *stream ;
  size_t __x ;
  size_t tmp ;
  {
  {
  stream = (FILE *)callback_arg;
  tmp = rpl_fwrite((void const *)buf___1, (size_t )1, buflen, stream);
  __x = tmp;
  }
  return (0L);
}
}
static long exit_failure_callback(unsigned int code , char const *msg , void *callback_arg __attribute__((__unused__)) )
{
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  {
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
    {
    {
    tmp = dcgettext((char const *)((void *)0), (char const *)"cannot convert U+%04X to local character set",
                    5);
    error(1, 0, (char const *)tmp, code);
    }
    }
  } else {
    {
    {
    tmp___0 = dcgettext((char const *)((void *)0), msg, 5);
    tmp___1 = dcgettext((char const *)((void *)0), (char const *)"cannot convert U+%04X to local character set: %s",
                        5);
    error(1, 0, (char const *)tmp___1, code, tmp___0);
    }
    }
  }
  return (-1L);
}
}
static long fallback_failure_callback(unsigned int code , char const *msg __attribute__((__unused__)) ,
                                      void *callback_arg )
{
  FILE *stream ;
  {
  {
  stream = (FILE *)callback_arg;
  }
  if (code < 65536U) {
    {
    {
    fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )"\\u%04X"),
            code);
    }
    }
  } else {
    {
    {
    fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )"\\U%08X"),
            code);
    }
    }
  }
  return (-1L);
}
}
void print_unicode_char(FILE *stream , unsigned int code , int exit_on_error )
{
  long (*tmp)(unsigned int code , char const *msg , void *callback_arg __attribute__((__unused__)) ) ;
  {
  if (exit_on_error) {
    {
    {
    tmp = & exit_failure_callback;
    }
    }
  } else {
    {
    {
    tmp = & fallback_failure_callback;
    }
    }
  }
  {
  unicode_to_mb(code, & fwrite_success_callback, tmp, (void *)stream);
  }
  return;
}
}
int dup_safer(int fd )
{
  int tmp ;
  {
  {
  tmp = rpl_fcntl(fd, 0, 3);
  }
  return (tmp);
}
}
int fd_safer(int fd )
{
  int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;
  {
  if (0 <= fd) {
    {
    if (fd <= 2) {
      {
      {
      tmp = dup_safer(fd);
      f = tmp;
      tmp___0 = __errno_location();
      e = *tmp___0;
      close(fd);
      tmp___1 = __errno_location();
      *tmp___1 = e;
      fd = f;
      }
      }
    }
    }
  }
  return (fd);
}
}
int pipe_safer(int *fd )
{
  int i ;
  int e ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  {
  {
  tmp___1 = pipe(fd);
  }
  if (tmp___1 == 0) {
    {
    {
    i = 0;
    }
    {
    while (1) {
      while_continue: ;
      if (! (i < 2)) {
        {
        goto while_break;
        }
      }
      {
      *(fd + i) = fd_safer(*(fd + i));
      }
      if (*(fd + i) < 0) {
        {
        {
        tmp = __errno_location();
        e = *tmp;
        close(*(fd + (1 - i)));
        tmp___0 = __errno_location();
        *tmp___0 = e;
        }
        return (-1);
        }
      }
      {
      i ++;
      }
    }
    while_break: ;
    }
    return (0);
    }
  }
  return (-1);
}
}
int u8_mbtoucr(ucs4_t *puc , uint8_t const *s , size_t n )
{
  uint8_t c ;
  {
  {
  c = (uint8_t )*s;
  }
  if ((int )c < 128) {
    {
    {
    *puc = (ucs4_t )c;
    }
    return (1);
    }
  } else {
    {
    if ((int )c >= 194) {
      {
      if ((int )c < 224) {
        {
        if (n >= 2UL) {
          {
          if (((int const )*(s + 1) ^ 128) < 64) {
            {
            {
            *puc = ((unsigned int )((int )c & 31) << 6) | (unsigned int )((int const )*(s + 1) ^ 128);
            }
            return (2);
            }
          }
          }
        } else {
          {
          {
          *puc = (ucs4_t )65533;
          }
          return (-2);
          }
        }
        }
      } else {
        {
        if ((int )c < 240) {
          {
          if (n >= 2UL) {
            {
            if (((int const )*(s + 1) ^ 128) < 64) {
              {
              if ((int )c >= 225) {
                {
                goto _L___0;
                }
              } else {
                {
                if ((int const )*(s + 1) >= 160) {
                  {
                  _L___0:
                  if ((int )c != 237) {
                    {
                    goto _L;
                    }
                  } else {
                    {
                    if ((int const )*(s + 1) < 160) {
                      {
                      _L:
                      if (n >= 3UL) {
                        {
                        if (((int const )*(s + 2) ^ 128) < 64) {
                          {
                          {
                          *puc = (((unsigned int )((int )c & 15) << 12) | ((unsigned int )((int const )*(s + 1) ^ 128) << 6)) | (unsigned int )((int const )*(s + 2) ^ 128);
                          }
                          return (3);
                          }
                        }
                        }
                      } else {
                        {
                        {
                        *puc = (ucs4_t )65533;
                        }
                        return (-2);
                        }
                      }
                      }
                    }
                    }
                  }
                  }
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            *puc = (ucs4_t )65533;
            }
            return (-2);
            }
          }
          }
        } else {
          {
          if ((int )c < 248) {
            {
            if (n >= 2UL) {
              {
              if (((int const )*(s + 1) ^ 128) < 64) {
                {
                if ((int )c >= 241) {
                  {
                  goto _L___2;
                  }
                } else {
                  {
                  if ((int const )*(s + 1) >= 144) {
                    {
                    _L___2:
                    if ((int )c < 244) {
                      {
                      goto _L___1;
                      }
                    } else {
                      {
                      if ((int )c == 244) {
                        {
                        if ((int const )*(s + 1) < 144) {
                          {
                          _L___1:
                          if (n >= 3UL) {
                            {
                            if (((int const )*(s + 2) ^ 128) < 64) {
                              {
                              if (n >= 4UL) {
                                {
                                if (((int const )*(s + 3) ^ 128) < 64) {
                                  {
                                  {
                                  *puc = ((((unsigned int )((int )c & 7) << 18) | ((unsigned int )((int const )*(s + 1) ^ 128) << 12)) | ((unsigned int )((int const )*(s + 2) ^ 128) << 6)) | (unsigned int )((int const )*(s + 3) ^ 128);
                                  }
                                  return (4);
                                  }
                                }
                                }
                              } else {
                                {
                                {
                                *puc = (ucs4_t )65533;
                                }
                                return (-2);
                                }
                              }
                              }
                            }
                            }
                          } else {
                            {
                            {
                            *puc = (ucs4_t )65533;
                            }
                            return (-2);
                            }
                          }
                          }
                        }
                        }
                      }
                      }
                    }
                    }
                  }
                  }
                }
                }
              }
              }
            } else {
              {
              {
              *puc = (ucs4_t )65533;
              }
              return (-2);
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  {
  *puc = (ucs4_t )65533;
  }
  return (-1);
}
}
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n )
{
  int count ;
  {
  if (uc < 128U) {
    {
    return (-2);
    }
  } else {
    {
    if (uc < 2048U) {
      {
      {
      count = 2;
      }
      }
    } else {
      {
      if (uc < 65536U) {
        {
        if (uc < 55296U) {
          {
          {
          count = 3;
          }
          }
        } else {
          {
          if (uc >= 57344U) {
            {
            {
            count = 3;
            }
            }
          } else {
            {
            return (-1);
            }
          }
          }
        }
        }
      } else {
        {
        if (uc < 1114112U) {
          {
          {
          count = 4;
          }
          }
        } else {
          {
          return (-1);
          }
        }
        }
      }
      }
    }
    }
  }
  if (n < count) {
    {
    return (-2);
    }
  }
  {
  if (count == 4) {
    {
    goto case_4;
    }
  }
  if (count == 3) {
    {
    goto case_3;
    }
  }
  if (count == 2) {
    {
    goto case_2;
    }
  }
  goto switch_break;
  case_4:
  {
  *(s + 3) = (uint8_t )(128U | (uc & 63U));
  uc >>= 6;
  uc |= 65536U;
  }
  case_3:
  {
  *(s + 2) = (uint8_t )(128U | (uc & 63U));
  uc >>= 6;
  uc |= 2048U;
  }
  case_2:
  {
  *(s + 1) = (uint8_t )(128U | (uc & 63U));
  uc >>= 6;
  uc |= 192U;
  *(s + 0) = (uint8_t )uc;
  }
  switch_break: ;
  }
  return (count);
}
}
__inline static int streq9(char const *s1 , char const *s2 )
{
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  {
  if (0) {
    {
    {
    __s1_len = __builtin_strlen(s1 + 9);
    __s2_len = __builtin_strlen(s2 + 9);
    }
    if (! ((size_t )((void const *)((s1 + 9) + 1)) - (size_t )((void const *)(s1 + 9)) == 1UL)) {
      {
      goto _L___0;
      }
    } else {
      {
      if (__s1_len >= 4UL) {
        {
        _L___0:
        if (! ((size_t )((void const *)((s2 + 9) + 1)) - (size_t )((void const *)(s2 + 9)) == 1UL)) {
          {
          {
          tmp___5 = 1;
          }
          }
        } else {
          {
          if (__s2_len >= 4UL) {
            {
            {
            tmp___5 = 1;
            }
            }
          } else {
            {
            {
            tmp___5 = 0;
            }
            }
          }
          }
        }
        }
      } else {
        {
        {
        tmp___5 = 0;
        }
        }
      }
      }
    }
    if (tmp___5) {
      {
      {
      tmp___0 = __builtin_strcmp(s1 + 9, s2 + 9);
      tmp___4 = tmp___0;
      }
      }
    } else {
      {
      {
      tmp___3 = __builtin_strcmp(s1 + 9, s2 + 9);
      tmp___4 = tmp___3;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___3 = __builtin_strcmp(s1 + 9, s2 + 9);
    tmp___4 = tmp___3;
    }
    }
  }
  return (tmp___4 == 0);
}
}
__inline static int streq8(char const *s1 , char const *s2 , char s28 )
{
  int tmp ;
  {
  if ((int const )*(s1 + 8) == (int const )s28) {
    {
    if ((int )s28 == 0) {
      {
      return (1);
      }
    } else {
      {
      {
      tmp = streq9(s1, s2);
      }
      return (tmp);
      }
    }
    }
  } else {
    {
    return (0);
    }
  }
}
}
__inline static int streq7(char const *s1 , char const *s2 , char s27 , char s28 )
{
  int tmp ;
  {
  if ((int const )*(s1 + 7) == (int const )s27) {
    {
    if ((int )s27 == 0) {
      {
      return (1);
      }
    } else {
      {
      {
      tmp = streq8(s1, s2, s28);
      }
      return (tmp);
      }
    }
    }
  } else {
    {
    return (0);
    }
  }
}
}
__inline static int streq6(char const *s1 , char const *s2 , char s26 , char s27 ,
                           char s28 )
{
  int tmp ;
  {
  if ((int const )*(s1 + 6) == (int const )s26) {
    {
    if ((int )s26 == 0) {
      {
      return (1);
      }
    } else {
      {
      {
      tmp = streq7(s1, s2, s27, s28);
      }
      return (tmp);
      }
    }
    }
  } else {
    {
    return (0);
    }
  }
}
}
__inline static int streq5(char const *s1 , char const *s2 , char s25 , char s26 ,
                           char s27 , char s28 )
{
  int tmp ;
  {
  if ((int const )*(s1 + 5) == (int const )s25) {
    {
    if ((int )s25 == 0) {
      {
      return (1);
      }
    } else {
      {
      {
      tmp = streq6(s1, s2, s26, s27, s28);
      }
      return (tmp);
      }
    }
    }
  } else {
    {
    return (0);
    }
  }
}
}
__inline static int streq4(char const *s1 , char const *s2 , char s24 , char s25 ,
                           char s26 , char s27 , char s28 )
{
  int tmp ;
  {
  if ((int const )*(s1 + 4) == (int const )s24) {
    {
    if ((int )s24 == 0) {
      {
      return (1);
      }
    } else {
      {
      {
      tmp = streq5(s1, s2, s25, s26, s27, s28);
      }
      return (tmp);
      }
    }
    }
  } else {
    {
    return (0);
    }
  }
}
}
__inline static int streq3(char const *s1 , char const *s2 , char s23 , char s24 ,
                           char s25 , char s26 , char s27 , char s28 )
{
  int tmp ;
  {
  if ((int const )*(s1 + 3) == (int const )s23) {
    {
    if ((int )s23 == 0) {
      {
      return (1);
      }
    } else {
      {
      {
      tmp = streq4(s1, s2, s24, s25, s26, s27, s28);
      }
      return (tmp);
      }
    }
    }
  } else {
    {
    return (0);
    }
  }
}
}
__inline static int streq2(char const *s1 , char const *s2 , char s22 , char s23 ,
                           char s24 , char s25 , char s26 , char s27 , char s28 )
{
  int tmp ;
  {
  if ((int const )*(s1 + 2) == (int const )s22) {
    {
    if ((int )s22 == 0) {
      {
      return (1);
      }
    } else {
      {
      {
      tmp = streq3(s1, s2, s23, s24, s25, s26, s27, s28);
      }
      return (tmp);
      }
    }
    }
  } else {
    {
    return (0);
    }
  }
}
}
__inline static int streq1(char const *s1 , char const *s2 , char s21 , char s22 ,
                           char s23 , char s24 , char s25 , char s26 , char s27 ,
                           char s28 )
{
  int tmp ;
  {
  if ((int const )*(s1 + 1) == (int const )s21) {
    {
    if ((int )s21 == 0) {
      {
      return (1);
      }
    } else {
      {
      {
      tmp = streq2(s1, s2, s22, s23, s24, s25, s26, s27, s28);
      }
      return (tmp);
      }
    }
    }
  } else {
    {
    return (0);
    }
  }
}
}
__inline static int streq0(char const *s1 , char const *s2 , char s20 , char s21 ,
                           char s22 , char s23 , char s24 , char s25 , char s26 ,
                           char s27 , char s28 )
{
  int tmp ;
  {
  if ((int const )*(s1 + 0) == (int const )s20) {
    {
    if ((int )s20 == 0) {
      {
      return (1);
      }
    } else {
      {
      {
      tmp = streq1(s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);
      }
      return (tmp);
      }
    }
    }
  } else {
    {
    return (0);
    }
  }
}
}
static int is_cjk_encoding(char const *encoding )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  {
  {
  tmp = streq0(encoding, (char const *)"EUC-JP", (char )'E', (char )'U', (char )'C',
               (char )'-', (char )'J', (char )'P', (char)0, (char)0, (char)0);
  }
  if (tmp) {
    {
    return (1);
    }
  } else {
    {
    {
    tmp___0 = streq0(encoding, (char const *)"GB2312", (char )'G', (char )'B', (char )'2',
                     (char )'3', (char )'1', (char )'2', (char)0, (char)0, (char)0);
    }
    if (tmp___0) {
      {
      return (1);
      }
    } else {
      {
      {
      tmp___1 = streq0(encoding, (char const *)"GBK", (char )'G', (char )'B', (char )'K',
                       (char)0, (char)0, (char)0, (char)0, (char)0, (char)0);
      }
      if (tmp___1) {
        {
        return (1);
        }
      } else {
        {
        {
        tmp___2 = streq0(encoding, (char const *)"EUC-TW", (char )'E', (char )'U',
                         (char )'C', (char )'-', (char )'T', (char )'W', (char)0,
                         (char)0, (char)0);
        }
        if (tmp___2) {
          {
          return (1);
          }
        } else {
          {
          {
          tmp___3 = streq0(encoding, (char const *)"BIG5", (char )'B', (char )'I',
                           (char )'G', (char )'5', (char)0, (char)0, (char)0, (char)0,
                           (char)0);
          }
          if (tmp___3) {
            {
            return (1);
            }
          } else {
            {
            {
            tmp___4 = streq0(encoding, (char const *)"EUC-KR", (char )'E', (char )'U',
                             (char )'C', (char )'-', (char )'K', (char )'R', (char)0,
                             (char)0, (char)0);
            }
            if (tmp___4) {
              {
              return (1);
              }
            } else {
              {
              {
              tmp___5 = streq0(encoding, (char const *)"CP949", (char )'C', (char )'P',
                               (char )'9', (char )'4', (char )'9', (char)0, (char)0,
                               (char)0, (char)0);
              }
              if (tmp___5) {
                {
                return (1);
                }
              } else {
                {
                {
                tmp___6 = streq0(encoding, (char const *)"JOHAB", (char )'J', (char )'O',
                                 (char )'H', (char )'A', (char )'B', (char)0, (char)0,
                                 (char)0, (char)0);
                }
                if (tmp___6) {
                  {
                  return (1);
                  }
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  return (0);
}
}
int uc_width(ucs4_t uc , char const *encoding )
{
  int ind___0 ;
  int tmp ;
  int tmp___0 ;
  {
  if (uc >> 9 < 240U) {
    {
    {
    ind___0 = (int )nonspacing_table_ind[uc >> 9];
    }
    if (ind___0 >= 0) {
      {
      if (((int const )nonspacing_table_data[(unsigned int )(64 * ind___0) + ((uc >> 3) & 63U)] >> (uc & 7U)) & 1) {
        {
        if (uc > 0U) {
          {
          if (uc < 160U) {
            {
            return (-1);
            }
          } else {
            {
            return (0);
            }
          }
          }
        } else {
          {
          return (0);
          }
        }
        }
      }
      }
    }
    }
  } else {
    {
    if (uc >> 9 == (ucs4_t )(917504 >> 9)) {
      {
      if (uc >= 917760U) {
        {
        if (uc <= 917999U) {
          {
          return (0);
          }
        }
        }
      } else {
        {
        if (uc >= 917536U) {
          {
          {
          tmp = uc <= 917631U;
          }
          }
        } else {
          {
          {
          tmp = uc == 917505U;
          }
          }
        }
        if (tmp) {
          {
          return (0);
          }
        }
        }
      }
      }
    }
    }
  }
  if (uc >= 4352U) {
    {
    if (uc < 4448U) {
      {
      return (2);
      }
    } else {
      {
      if (uc >= 9001U) {
        {
        if (uc < 9003U) {
          {
          return (2);
          }
        } else {
          {
          goto _L___9;
          }
        }
        }
      } else {
        {
        _L___9:
        if (uc >= 11904U) {
          {
          if (uc < 42192U) {
            {
            if (! (uc == 12351U)) {
              {
              if (uc >= 19904U) {
                {
                if (uc < 19968U) {
                  {
                  goto _L___8;
                  }
                } else {
                  {
                  return (2);
                  }
                }
                }
              } else {
                {
                return (2);
                }
              }
              }
            } else {
              {
              goto _L___8;
              }
            }
            }
          } else {
            {
            goto _L___8;
            }
          }
          }
        } else {
          {
          _L___8:
          if (uc >= 44032U) {
            {
            if (uc < 55204U) {
              {
              return (2);
              }
            } else {
              {
              goto _L___5;
              }
            }
            }
          } else {
            {
            _L___5:
            if (uc >= 63744U) {
              {
              if (uc < 64256U) {
                {
                return (2);
                }
              } else {
                {
                goto _L___4;
                }
              }
              }
            } else {
              {
              _L___4:
              if (uc >= 65040U) {
                {
                if (uc < 65056U) {
                  {
                  return (2);
                  }
                } else {
                  {
                  goto _L___3;
                  }
                }
                }
              } else {
                {
                _L___3:
                if (uc >= 65072U) {
                  {
                  if (uc < 65136U) {
                    {
                    return (2);
                    }
                  } else {
                    {
                    goto _L___2;
                    }
                  }
                  }
                } else {
                  {
                  _L___2:
                  if (uc >= 65280U) {
                    {
                    if (uc < 65377U) {
                      {
                      return (2);
                      }
                    } else {
                      {
                      goto _L___1;
                      }
                    }
                    }
                  } else {
                    {
                    _L___1:
                    if (uc >= 65504U) {
                      {
                      if (uc < 65511U) {
                        {
                        return (2);
                        }
                      } else {
                        {
                        goto _L___0;
                        }
                      }
                      }
                    } else {
                      {
                      _L___0:
                      if (uc >= 131072U) {
                        {
                        if (uc <= 196607U) {
                          {
                          return (2);
                          }
                        } else {
                          {
                          goto _L;
                          }
                        }
                        }
                      } else {
                        {
                        _L:
                        if (uc >= 196608U) {
                          {
                          if (uc <= 262143U) {
                            {
                            return (2);
                            }
                          }
                          }
                        }
                        }
                      }
                      }
                    }
                    }
                  }
                  }
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  if (uc >= 161U) {
    {
    if (uc < 65377U) {
      {
      if (uc != 8361U) {
        {
        {
        tmp___0 = is_cjk_encoding(encoding);
        }
        if (tmp___0) {
          {
          return (2);
          }
        }
        }
      }
      }
    }
    }
  }
  return (1);
}
}
static char const *parse_with_separator(char const *spec , char const *separator ,
                                          uid_t *uid , gid_t *gid , char **username ,
                                          char **groupname )
{
  char const *error_msg ;
  struct passwd *pwd ;
  struct group *grp ;
  char *u ;
  char const *g ;
  char *gname ;
  uid_t unum ;
  gid_t gnum ;
  char *tmp ;
  size_t ulen ;
  void *tmp___0 ;
  struct passwd *tmp___1 ;
  _Bool use_login_group ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  strtol_error tmp___4 ;
  char buf___1[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char *tmp___5 ;
  char *tmp___6 ;
  struct group *tmp___7 ;
  unsigned long tmp___8 ;
  strtol_error tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  {
  {
  gname = (char *)((void *)0);
  unum = *uid;
  gnum = *gid;
  error_msg = (char const *)((void *)0);
  tmp = (char *)((void *)0);
  *groupname = tmp;
  *username = tmp;
  u = (char *)((void *)0);
  }
  if ((unsigned long )separator == (unsigned long )((void *)0)) {
    {
    if (*spec) {
      {
      {
      u = xstrdup(spec);
      }
      }
    }
    }
  } else {
    {
    {
    ulen = (size_t )(separator - spec);
    }
    if (ulen != 0UL) {
      {
      {
      tmp___0 = xmemdup((void const *)spec, ulen + 1UL);
      u = (char *)tmp___0;
      *(u + ulen) = (char )'\000';
      }
      }
    }
    }
  }
  if ((unsigned long )separator == (unsigned long )((void *)0)) {
    {
    {
    g = (char const *)((void *)0);
    }
    }
  } else {
    {
    if ((int const )*(separator + 1) == 0) {
      {
      {
      g = (char const *)((void *)0);
      }
      }
    } else {
      {
      {
      g = separator + 1;
      }
      }
    }
    }
  }
  if ((unsigned long )u != (unsigned long )((void *)0)) {
    {
    if ((int )*u == 43) {
      {
      {
      pwd = (struct passwd *)((void *)0);
      }
      }
    } else {
      {
      {
      tmp___1 = getpwnam((char const *)u);
      pwd = tmp___1;
      }
      }
    }
    if ((unsigned long )pwd == (unsigned long )((void *)0)) {
      {
      if ((unsigned long )separator != (unsigned long )((void *)0)) {
        {
        if ((unsigned long )g == (unsigned long )((void *)0)) {
          {
          {
          tmp___2 = 1;
          }
          }
        } else {
          {
          {
          tmp___2 = 0;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___2 = 0;
        }
        }
      }
      {
      use_login_group = (_Bool )tmp___2;
      }
      if (use_login_group) {
        {
        {
        error_msg = E_bad_spec;
        }
        }
      } else {
        {
        {
        tmp___4 = xstrtoul((char const *)u, (char **)((void *)0), 10, & tmp___3,
                           (char const *)"");
        }
        if ((unsigned int )tmp___4 == 0U) {
          {
          if (tmp___3 <= 4294967295UL) {
            {
            if ((uid_t )tmp___3 != 4294967295U) {
              {
              {
              unum = (uid_t )tmp___3;
              }
              }
            } else {
              {
              {
              error_msg = E_invalid_user;
              }
              }
            }
            }
          } else {
            {
            {
            error_msg = E_invalid_user;
            }
            }
          }
          }
        } else {
          {
          {
          error_msg = E_invalid_user;
          }
          }
        }
        }
      }
      }
    } else {
      {
      {
      unum = pwd->pw_uid;
      }
      if ((unsigned long )g == (unsigned long )((void *)0)) {
        {
        if ((unsigned long )separator != (unsigned long )((void *)0)) {
          {
          {
          gnum = pwd->pw_gid;
          grp = getgrgid(gnum);
          }
          if (grp) {
            {
            {
            tmp___6 = grp->gr_name;
            }
            }
          } else {
            {
            {
            tmp___12 = umaxtostr((uintmax_t )gnum, buf___1);
            tmp___11 = tmp___12;
            tmp___5 = tmp___11;
            tmp___6 = tmp___5;
            }
            }
          }
          {
          gname = xstrdup((char const *)tmp___6);
          endgrent();
          }
          }
        }
        }
      }
      }
    }
    {
    endpwent();
    }
    }
  }
  if ((unsigned long )g != (unsigned long )((void *)0)) {
    {
    if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
      {
      if ((int const )*g == 43) {
        {
        {
        grp = (struct group *)((void *)0);
        }
        }
      } else {
        {
        {
        tmp___7 = getgrnam(g);
        grp = tmp___7;
        }
        }
      }
      if ((unsigned long )grp == (unsigned long )((void *)0)) {
        {
        {
        tmp___9 = xstrtoul(g, (char **)((void *)0), 10, & tmp___8, (char const *)"");
        }
        if ((unsigned int )tmp___9 == 0U) {
          {
          if (tmp___8 <= 4294967295UL) {
            {
            if ((gid_t )tmp___8 != 4294967295U) {
              {
              {
              gnum = (gid_t )tmp___8;
              }
              }
            } else {
              {
              {
              error_msg = E_invalid_group;
              }
              }
            }
            }
          } else {
            {
            {
            error_msg = E_invalid_group;
            }
            }
          }
          }
        } else {
          {
          {
          error_msg = E_invalid_group;
          }
          }
        }
        }
      } else {
        {
        {
        gnum = grp->gr_gid;
        }
        }
      }
      {
      endgrent();
      gname = xstrdup(g);
      }
      }
    }
    }
  }
  if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
    {
    {
    *uid = unum;
    *gid = gnum;
    *username = u;
    *groupname = gname;
    u = (char *)((void *)0);
    }
    }
  } else {
    {
    {
    free((void *)gname);
    }
    }
  }
  {
  free((void *)u);
  tmp___10 = dcgettext((char const *)((void *)0), error_msg, 5);
  }
  return ((char const *)tmp___10);
}
}
char const *parse_user_spec(char const *spec , uid_t *uid , gid_t *gid , char **username ,
                              char **groupname )
{
  char const *colon ;
  char *tmp___0 ;
  char const *error_msg ;
  char const *tmp___1 ;
  char const *dot ;
  char *tmp___3 ;
  char const *tmp___4 ;
  {
  {
  tmp___0 = __builtin_strchr((char *)spec, ':');
  colon = (char const *)tmp___0;
  tmp___1 = parse_with_separator(spec, colon, uid, gid, username, groupname);
  error_msg = tmp___1;
  }
  if (! colon) {
    {
    if (error_msg) {
      {
      {
      tmp___3 = __builtin_strchr((char *)spec, '.');
      dot = (char const *)tmp___3;
      }
      if (dot) {
        {
        {
        tmp___4 = parse_with_separator(spec, dot, uid, gid, username, groupname);
        }
        if (! tmp___4) {
          {
          {
          error_msg = (char const *)((void *)0);
          }
          }
        }
        }
      }
      }
    }
    }
  }
  return (error_msg);
}
}
__inline static long get_stat_atime_ns(struct stat const *st )
{
  {
  return ((long )st->st_atim.tv_nsec);
}
}
__inline static long get_stat_ctime_ns(struct stat const *st )
{
  {
  return ((long )st->st_ctim.tv_nsec);
}
}
__inline static long get_stat_mtime_ns(struct stat const *st )
{
  {
  return ((long )st->st_mtim.tv_nsec);
}
}
static size_t dev_info_hash(void const *x , size_t table_size )
{
  struct fs_res const *p ;
  {
  {
  p = (struct fs_res const *)x;
  }
  return ((size_t )(p->dev % (unsigned long )((unsigned long const )table_size)));
}
}
static _Bool dev_info_compare(void const *x , void const *y )
{
  struct fs_res const *a ;
  struct fs_res const *b ;
  {
  {
  a = (struct fs_res const *)x;
  b = (struct fs_res const *)y;
  }
  return ((_Bool )(a->dev == b->dev));
}
}
int utimecmp(char const *dst_name , struct stat const *dst_stat , struct stat const *src_stat ,
             int options )
{
  time_t dst_s ;
  time_t src_s ;
  int dst_ns ;
  long tmp ;
  int src_ns ;
  long tmp___0 ;
  struct fs_res *dst_res ;
  struct fs_res tmp_dst_res ;
  int res ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  time_t dst_a_s ;
  time_t dst_c_s ;
  time_t dst_m_s ;
  int dst_a_ns ;
  long tmp___4 ;
  int dst_c_ns ;
  long tmp___5 ;
  int dst_m_ns ;
  _Bool odd_second ;
  int a ;
  int c ;
  int m ;
  int SR10 ;
  struct timespec timespec[2] ;
  struct stat dst_status ;
  time_t s ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int stat_result ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  int old_res ;
  int a___0 ;
  long tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  {
  {
  dst_s = (time_t )dst_stat->st_mtim.tv_sec;
  src_s = (time_t )src_stat->st_mtim.tv_sec;
  tmp = get_stat_mtime_ns(dst_stat);
  dst_ns = (int )tmp;
  tmp___0 = get_stat_mtime_ns(src_stat);
  src_ns = (int )tmp___0;
  }
  if (options & 1) {
    {
    {
    dst_res = (struct fs_res *)((void *)0);
    }
    if (dst_s == src_s) {
      {
      if (dst_ns == src_ns) {
        {
        return (0);
        }
      }
      }
    }
    if (dst_s <= src_s - 2L) {
      {
      return (-1);
      }
    }
    if (src_s <= dst_s - 2L) {
      {
      return (1);
      }
    }
    if (! ht) {
      {
      {
      ht = hash_initialize((size_t )16, (Hash_tuning const *)((void *)0), & dev_info_hash,
                           & dev_info_compare, & free);
      }
      }
    }
    if (ht) {
      {
      if (! new_dst_res) {
        {
        {
        tmp___1 = malloc(sizeof(*new_dst_res));
        new_dst_res = (struct fs_res *)tmp___1;
        }
        if (! new_dst_res) {
          {
          goto low_memory;
          }
        }
        {
        new_dst_res->resolution = 2000000000;
        new_dst_res->exact = (_Bool)0;
        }
        }
      }
      {
      new_dst_res->dev = (dev_t )dst_stat->st_dev;
      tmp___2 = hash_insert(ht, (void const *)new_dst_res);
      dst_res = (struct fs_res *)tmp___2;
      }
      if (! dst_res) {
        {
        goto low_memory;
        }
      }
      if ((unsigned long )dst_res == (unsigned long )new_dst_res) {
        {
        {
        new_dst_res = (struct fs_res *)((void *)0);
        }
        }
      }
      }
    } else {
      {
      low_memory:
      if (ht) {
        {
        {
        tmp_dst_res.dev = (dev_t )dst_stat->st_dev;
        tmp___3 = hash_lookup((Hash_table const *)ht, (void const *)(& tmp_dst_res));
        dst_res = (struct fs_res *)tmp___3;
        }
        }
      }
      if (! dst_res) {
        {
        {
        dst_res = & tmp_dst_res;
        dst_res->resolution = 2000000000;
        dst_res->exact = (_Bool)0;
        }
        }
      }
      }
    }
    {
    res = dst_res->resolution;
    }
    if (! dst_res->exact) {
      {
      {
      dst_a_s = (time_t )dst_stat->st_atim.tv_sec;
      dst_c_s = (time_t )dst_stat->st_ctim.tv_sec;
      dst_m_s = dst_s;
      tmp___4 = get_stat_atime_ns(dst_stat);
      dst_a_ns = (int )tmp___4;
      tmp___5 = get_stat_ctime_ns(dst_stat);
      dst_c_ns = (int )tmp___5;
      dst_m_ns = dst_ns;
      odd_second = (_Bool )(((dst_a_s | dst_c_s) | dst_m_s) & 1L);
      a = dst_a_ns;
      c = dst_c_ns;
      m = dst_m_ns;
      SR10 = 1;
      SR10 *= 10;
      }
      if (((a % SR10 | c % SR10) | m % SR10) != 0) {
        {
        {
        res = 1;
        }
        }
      } else {
        {
        {
        res = SR10;
        a /= SR10;
        c /= SR10;
        m /= SR10;
        }
        {
        while (1) {
          while_continue: ;
          if (! 1) {
            {
            goto while_break;
            }
          }
          if (res < dst_res->resolution) {
            {
            if (! (((a % 10 | c % 10) | m % 10) == 0)) {
              {
              goto while_break;
              }
            }
            }
          } else {
            {
            goto while_break;
            }
          }
          if (res == 1000000000) {
            {
            if (! odd_second) {
              {
              {
              res *= 2;
              }
              }
            }
            goto while_break;
            }
          }
          {
          res *= 10;
          a /= 10;
          c /= 10;
          m /= 10;
          }
        }
        while_break: ;
        }
        }
      }
      {
      dst_res->resolution = res;
      }
      if (1 < res) {
        {
        {
        src_ns = src_ns;
        s = src_s & (long )(~ (res == 2000000000));
        }
        if (src_s < dst_s) {
          {
          return (1);
          }
        } else {
          {
          if (src_s == dst_s) {
            {
            if (src_ns <= dst_ns) {
              {
              return (1);
              }
            }
            }
          }
          }
        }
        if (dst_s < s) {
          {
          return (-1);
          }
        } else {
          {
          if (dst_s == s) {
            {
            if (dst_ns < src_ns - src_ns % res) {
              {
              return (-1);
              }
            }
            }
          }
          }
        }
        {
        timespec[0].tv_sec = dst_a_s;
        timespec[0].tv_nsec = (long )dst_a_ns;
        timespec[1].tv_sec = dst_m_s | (long )(res == 2000000000);
        timespec[1].tv_nsec = (long )(dst_m_ns + res / 9);
        }
        if ((dst_stat->st_mode & 61440U) == 40960U) {
          {
          {
          tmp___6 = lutimens(dst_name, (struct timespec const *)(timespec));
          tmp___8 = tmp___6;
          }
          }
        } else {
          {
          {
          tmp___7 = utimens(dst_name, (struct timespec const *)(timespec));
          tmp___8 = tmp___7;
          }
          }
        }
        if (tmp___8 != 0) {
          {
          return (-2);
          }
        }
        if ((dst_stat->st_mode & 61440U) == 40960U) {
          {
          {
          tmp___9 = lstat((char const *)((char const * __restrict )dst_name),
                          (struct stat *)((struct stat * __restrict )(& dst_status)));
          tmp___11 = tmp___9;
          }
          }
        } else {
          {
          {
          tmp___10 = stat((char const *)((char const * __restrict )dst_name),
                          (struct stat *)((struct stat * __restrict )(& dst_status)));
          tmp___11 = tmp___10;
          }
          }
        }
        {
        stat_result = tmp___11;
        tmp___12 = get_stat_mtime_ns((struct stat const *)(& dst_status));
        }
        if (((long )stat_result | (dst_status.st_mtim.tv_sec ^ dst_m_s)) | (tmp___12 ^ (long )dst_m_ns)) {
          {
          {
          timespec[1].tv_sec = dst_m_s;
          timespec[1].tv_nsec = (long )dst_m_ns;
          }
          if ((dst_stat->st_mode & 61440U) == 40960U) {
            {
            {
            lutimens(dst_name, (struct timespec const *)(timespec));
            }
            }
          } else {
            {
            {
            utimens(dst_name, (struct timespec const *)(timespec));
            }
            }
          }
          }
        }
        if (stat_result != 0) {
          {
          return (-2);
          }
        }
        {
        old_res = res;
        tmp___13 = get_stat_mtime_ns((struct stat const *)(& dst_status));
        a___0 = (int )(1000000000L * (dst_status.st_mtim.tv_sec & 1L) + tmp___13);
        res = 1;
        a___0 /= res;
        }
        {
        while (1) {
          while_continue___0: ;
          if (! (a___0 % 10 == 0)) {
            {
            goto while_break___0;
            }
          }
          if (res == 1000000000) {
            {
            {
            res *= 2;
            }
            goto while_break___0;
            }
          }
          {
          res *= 10;
          }
          if (res == old_res) {
            {
            goto while_break___0;
            }
          }
          {
          a___0 /= 10;
          }
        }
        while_break___0: ;
        }
        }
      }
      {
      dst_res->resolution = res;
      dst_res->exact = (_Bool)1;
      }
      }
    }
    {
    src_s &= (long )(~ (res == 2000000000));
    src_ns -= src_ns % res;
    }
    }
  }
  if (dst_s < src_s) {
    {
    {
    tmp___16 = -1;
    }
    }
  } else {
    {
    if (dst_s > src_s) {
      {
      {
      tmp___15 = 1;
      }
      }
    } else {
      {
      if (dst_ns < src_ns) {
        {
        {
        tmp___14 = -1;
        }
        }
      } else {
        {
        {
        tmp___14 = dst_ns > src_ns;
        }
        }
      }
      {
      tmp___15 = tmp___14;
      }
      }
    }
    {
    tmp___16 = tmp___15;
    }
    }
  }
  return (tmp___16);
}
}
__inline static struct timespec get_stat_atime(struct stat const *st )
{
  {
  return ((struct timespec )st->st_atim);
}
}
__inline static struct timespec get_stat_mtime(struct stat const *st )
{
  {
  return ((struct timespec )st->st_mtim);
}
}
static int validate_timespec(struct timespec *timespec )
{
  int result ;
  int utime_omit_count ;
  int *tmp ;
  {
  {
  result = 0;
  utime_omit_count = 0;
  }
  if (! timespec) {
    {
    {
    __assert_fail((char const *)"timespec", (char const *)"utimens.c", 89U, (char const *)"validate_timespec");
    }
    }
  }
  if ((timespec + 0)->tv_nsec != (1L << 30) - 1L) {
    {
    if ((timespec + 0)->tv_nsec != (1L << 30) - 2L) {
      {
      if ((timespec + 0)->tv_nsec < 0L) {
        {
        {
        tmp = __errno_location();
        *tmp = 22;
        }
        return (-1);
        }
      } else {
        {
        if (1000000000L <= (timespec + 0)->tv_nsec) {
          {
          {
          tmp = __errno_location();
          *tmp = 22;
          }
          return (-1);
          }
        } else {
          {
          goto _L___0;
          }
        }
        }
      }
      }
    } else {
      {
      goto _L___0;
      }
    }
    }
  } else {
    {
    _L___0:
    if ((timespec + 1)->tv_nsec != (1L << 30) - 1L) {
      {
      if ((timespec + 1)->tv_nsec != (1L << 30) - 2L) {
        {
        if ((timespec + 1)->tv_nsec < 0L) {
          {
          {
          tmp = __errno_location();
          *tmp = 22;
          }
          return (-1);
          }
        } else {
          {
          if (1000000000L <= (timespec + 1)->tv_nsec) {
            {
            {
            tmp = __errno_location();
            *tmp = 22;
            }
            return (-1);
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
    {
    goto _L___1;
    }
  } else {
    {
    if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
      {
      _L___1:
      {
      (timespec + 0)->tv_sec = (time_t )0;
      result = 1;
      }
      if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
        {
        {
        utime_omit_count ++;
        }
        }
      }
      }
    }
    }
  }
  if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
    {
    goto _L___2;
    }
  } else {
    {
    if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
      {
      _L___2:
      {
      (timespec + 1)->tv_sec = (time_t )0;
      result = 1;
      }
      if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
        {
        {
        utime_omit_count ++;
        }
        }
      }
      }
    }
    }
  }
  return (result + (utime_omit_count == 1));
}
}
static _Bool update_timespec(struct stat const *statbuf , struct timespec **ts )
{
  struct timespec *timespec ;
  {
  {
  timespec = *ts;
  }
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
    {
    if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
      {
      return ((_Bool)1);
      }
    }
    }
  }
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
    {
    if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
      {
      {
      *ts = (struct timespec *)((void *)0);
      }
      return ((_Bool)0);
      }
    }
    }
  }
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
    {
    {
    *(timespec + 0) = get_stat_atime(statbuf);
    }
    }
  } else {
    {
    if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
      {
      {
      gettime(timespec + 0);
      }
      }
    }
    }
  }
  if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
    {
    {
    *(timespec + 1) = get_stat_mtime(statbuf);
    }
    }
  } else {
    {
    if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
      {
      {
      gettime(timespec + 1);
      }
      }
    }
    }
  }
  return ((_Bool)0);
}
}
int fdutimens(int fd , char const *file , struct timespec const *timespec )
{
  struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  struct stat st ;
  int *tmp___0 ;
  int result ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;
  struct timeval timeval[2] ;
  struct timeval *t ;
  int tmp___12 ;
  _Bool abig ;
  _Bool mbig ;
  time_t adiff ;
  time_t mdiff ;
  struct timeval *tt ;
  struct timeval truncated_timeval[2] ;
  long tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  {
  if (timespec) {
    {
    {
    tmp = adjusted_timespec;
    }
    }
  } else {
    {
    {
    tmp = (struct timespec *)((void *)0);
    }
    }
  }
  {
  ts = tmp;
  adjustment_needed = 0;
  }
  if (ts) {
    {
    {
    adjusted_timespec[0] = (struct timespec )*(timespec + 0);
    adjusted_timespec[1] = (struct timespec )*(timespec + 1);
    adjustment_needed = validate_timespec(ts);
    }
    }
  }
  if (adjustment_needed < 0) {
    {
    return (-1);
    }
  }
  if (fd < 0) {
    {
    if (! file) {
      {
      {
      tmp___0 = __errno_location();
      *tmp___0 = 9;
      }
      return (-1);
      }
    }
    }
  }
  if (0 <= utimensat_works_really) {
    {
    if (adjustment_needed == 2) {
      {
      if (fd < 0) {
        {
        {
        tmp___1 = stat((char const *)((char const * __restrict )file), (struct stat *)((struct stat * __restrict )(& st)));
        tmp___3 = tmp___1;
        }
        }
      } else {
        {
        {
        tmp___2 = fstat(fd, & st);
        tmp___3 = tmp___2;
        }
        }
      }
      if (tmp___3) {
        {
        return (-1);
        }
      }
      if ((ts + 0)->tv_nsec == (1L << 30) - 2L) {
        {
        {
        *(ts + 0) = get_stat_atime((struct stat const *)(& st));
        }
        }
      } else {
        {
        if ((ts + 1)->tv_nsec == (1L << 30) - 2L) {
          {
          {
          *(ts + 1) = get_stat_mtime((struct stat const *)(& st));
          }
          }
        }
        }
      }
      {
      adjustment_needed ++;
      }
      }
    }
    if (fd < 0) {
      {
      {
      result = utimensat(-100, file, (struct timespec const *)ts, 0);
      }
      if (0 < result) {
        {
        {
        tmp___4 = __errno_location();
        *tmp___4 = 38;
        }
        }
      }
      if (result == 0) {
        {
        {
        utimensat_works_really = 1;
        }
        return (result);
        }
      } else {
        {
        {
        tmp___5 = __errno_location();
        }
        if (*tmp___5 != 38) {
          {
          {
          utimensat_works_really = 1;
          }
          return (result);
          }
        }
        }
      }
      }
    }
    if (0 <= fd) {
      {
      {
      result = futimens(fd, (struct timespec const *)ts);
      }
      if (0 < result) {
        {
        {
        tmp___6 = __errno_location();
        *tmp___6 = 38;
        }
        }
      }
      if (result == 0) {
        {
        {
        utimensat_works_really = 1;
        }
        return (result);
        }
      } else {
        {
        {
        tmp___7 = __errno_location();
        }
        if (*tmp___7 != 38) {
          {
          {
          utimensat_works_really = 1;
          }
          return (result);
          }
        }
        }
      }
      }
    }
    }
  }
  {
  utimensat_works_really = -1;
  lutimensat_works_really = -1;
  }
  if (adjustment_needed) {
    {
    goto _L;
    }
  } else {
    {
    if (0) {
      {
      _L:
      if (adjustment_needed != 3) {
        {
        if (fd < 0) {
          {
          {
          tmp___8 = stat((char const *)((char const * __restrict )file), (struct stat *)((struct stat * __restrict )(& st)));
          tmp___10 = tmp___8;
          }
          }
        } else {
          {
          {
          tmp___9 = fstat(fd, & st);
          tmp___10 = tmp___9;
          }
          }
        }
        if (tmp___10) {
          {
          return (-1);
          }
        }
        }
      }
      if (ts) {
        {
        {
        tmp___11 = update_timespec((struct stat const *)(& st), & ts);
        }
        if (tmp___11) {
          {
          return (0);
          }
        }
        }
      }
      }
    }
    }
  }
  if (ts) {
    {
    {
    timeval[0].tv_sec = (ts + 0)->tv_sec;
    timeval[0].tv_usec = (ts + 0)->tv_nsec / 1000L;
    timeval[1].tv_sec = (ts + 1)->tv_sec;
    timeval[1].tv_usec = (ts + 1)->tv_nsec / 1000L;
    t = timeval;
    }
    }
  } else {
    {
    {
    t = (struct timeval *)((void *)0);
    }
    }
  }
  if (fd < 0) {
    {
    {
    tmp___12 = futimesat(-100, file, (struct timeval const *)t);
    }
    return (tmp___12);
    }
  } else {
    {
    {
    tmp___16 = futimesat(fd, (char const *)((void *)0), (struct timeval const *)t);
    }
    if (tmp___16 == 0) {
      {
      if (t) {
        {
        {
        abig = (_Bool )(500000L <= (t + 0)->tv_usec);
        mbig = (_Bool )(500000L <= (t + 1)->tv_usec);
        }
        if ((int )abig | (int )mbig) {
          {
          {
          tmp___15 = fstat(fd, & st);
          }
          if (tmp___15 == 0) {
            {
            {
            adiff = st.st_atim.tv_sec - (t + 0)->tv_sec;
            mdiff = st.st_mtim.tv_sec - (t + 1)->tv_sec;
            tt = (struct timeval *)((void *)0);
            truncated_timeval[0] = *(t + 0);
            truncated_timeval[1] = *(t + 1);
            }
            if (abig) {
              {
              if (adiff == 1L) {
                {
                {
                tmp___13 = get_stat_atime_ns((struct stat const *)(& st));
                }
                if (tmp___13 == 0L) {
                  {
                  {
                  tt = truncated_timeval;
                  (tt + 0)->tv_usec = (__suseconds_t )0;
                  }
                  }
                }
                }
              }
              }
            }
            if (mbig) {
              {
              if (mdiff == 1L) {
                {
                {
                tmp___14 = get_stat_mtime_ns((struct stat const *)(& st));
                }
                if (tmp___14 == 0L) {
                  {
                  {
                  tt = truncated_timeval;
                  (tt + 1)->tv_usec = (__suseconds_t )0;
                  }
                  }
                }
                }
              }
              }
            }
            if (tt) {
              {
              {
              futimesat(fd, (char const *)((void *)0), (struct timeval const *)tt);
              }
              }
            }
            }
          }
          }
        }
        }
      }
      return (0);
      }
    }
    }
  }
  if (! file) {
    {
    return (-1);
    }
  }
  {
  tmp___17 = utimes(file, (struct timeval const *)t);
  }
  return (tmp___17);
}
}
int utimens(char const *file , struct timespec const *timespec )
{
  int tmp ;
  {
  {
  tmp = fdutimens(-1, file, timespec);
  }
  return (tmp);
}
}
int lutimens(char const *file , struct timespec const *timespec )
{
  struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  struct stat st ;
  int result ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  {
  if (timespec) {
    {
    {
    tmp = adjusted_timespec;
    }
    }
  } else {
    {
    {
    tmp = (struct timespec *)((void *)0);
    }
    }
  }
  {
  ts = tmp;
  adjustment_needed = 0;
  }
  if (ts) {
    {
    {
    adjusted_timespec[0] = (struct timespec )*(timespec + 0);
    adjusted_timespec[1] = (struct timespec )*(timespec + 1);
    adjustment_needed = validate_timespec(ts);
    }
    }
  }
  if (adjustment_needed < 0) {
    {
    return (-1);
    }
  }
  if (0 <= lutimensat_works_really) {
    {
    if (adjustment_needed == 2) {
      {
      {
      tmp___0 = lstat((char const *)((char const * __restrict )file), (struct stat *)((struct stat * __restrict )(& st)));
      }
      if (tmp___0) {
        {
        return (-1);
        }
      }
      if ((ts + 0)->tv_nsec == (1L << 30) - 2L) {
        {
        {
        *(ts + 0) = get_stat_atime((struct stat const *)(& st));
        }
        }
      } else {
        {
        if ((ts + 1)->tv_nsec == (1L << 30) - 2L) {
          {
          {
          *(ts + 1) = get_stat_mtime((struct stat const *)(& st));
          }
          }
        }
        }
      }
      {
      adjustment_needed ++;
      }
      }
    }
    {
    result = utimensat(-100, file, (struct timespec const *)ts, 256);
    }
    if (0 < result) {
      {
      {
      tmp___1 = __errno_location();
      *tmp___1 = 38;
      }
      }
    }
    if (result == 0) {
      {
      {
      utimensat_works_really = 1;
      lutimensat_works_really = 1;
      }
      return (result);
      }
    } else {
      {
      {
      tmp___2 = __errno_location();
      }
      if (*tmp___2 != 38) {
        {
        {
        utimensat_works_really = 1;
        lutimensat_works_really = 1;
        }
        return (result);
        }
      }
      }
    }
    }
  }
  {
  lutimensat_works_really = -1;
  }
  if (adjustment_needed) {
    {
    goto _L;
    }
  } else {
    {
    if (0) {
      {
      _L:
      if (adjustment_needed != 3) {
        {
        {
        tmp___3 = lstat((char const *)((char const * __restrict )file), (struct stat *)((struct stat * __restrict )(& st)));
        }
        if (tmp___3) {
          {
          return (-1);
          }
        }
        }
      }
      if (ts) {
        {
        {
        tmp___4 = update_timespec((struct stat const *)(& st), & ts);
        }
        if (tmp___4) {
          {
          return (0);
          }
        }
        }
      }
      }
    }
    }
  }
  if (! adjustment_needed) {
    {
    {
    tmp___5 = lstat((char const *)((char const * __restrict )file), (struct stat *)((struct stat * __restrict )(& st)));
    }
    if (tmp___5) {
      {
      return (-1);
      }
    }
    }
  }
  if (! ((st.st_mode & 61440U) == 40960U)) {
    {
    {
    tmp___6 = fdutimens(-1, file, (struct timespec const *)ts);
    }
    return (tmp___6);
    }
  }
  {
  tmp___7 = __errno_location();
  *tmp___7 = 38;
  }
  return (-1);
}
}
void verror(int status , int errnum , char const *format , va_list args )
{
  {
  {
  verror_at_line(status, errnum, (char const *)((void *)0), 0U, format, args);
  }
  return;
}
}
void verror_at_line(int status , int errnum , char const *file , unsigned int line_number ,
                    char const *format , va_list args )
{
  char *message ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  {
  {
  tmp = xvasprintf(format, args);
  message = tmp;
  }
  if (message) {
    {
    if (file) {
      {
      {
      error_at_line(status, errnum, file, line_number, (char const *)"%s", message);
      }
      }
    } else {
      {
      {
      error(status, errnum, (char const *)"%s", message);
      }
      }
    }
    }
  } else {
    {
    {
    tmp___0 = dcgettext((char const *)((void *)0), (char const *)"unable to display error message",
                        5);
    tmp___1 = __errno_location();
    error(0, *tmp___1, (char const *)tmp___0);
    abort();
    }
    }
  }
  {
  free((void *)message);
  }
  return;
}
}
void version_etc_arn(FILE *stream , char const *command_name , char const *package ,
                     char const *version , char const **authors , size_t n_authors )
{
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  {
  if (command_name) {
    {
    {
    fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )"%s (%s) %s\n"),
            command_name, package, version);
    }
    }
  } else {
    {
    {
    fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )"%s %s\n"),
            package, version);
    }
    }
  }
  {
  tmp = dcgettext((char const *)((void *)0), (char const *)"(C)", 5);
  fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )(version_etc_copyright)),
          tmp, 2011);
  tmp___0 = dcgettext((char const *)((void *)0), (char const *)"\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n",
                      5);
  fputs_unlocked((char const * __restrict )tmp___0, (FILE * __restrict )stream);
  }
  {
  if ((int )n_authors == 0) {
    {
    goto case_0;
    }
  }
  if ((int )n_authors == 1) {
    {
    goto case_1;
    }
  }
  if ((int )n_authors == 2) {
    {
    goto case_2;
    }
  }
  if ((int )n_authors == 3) {
    {
    goto case_3;
    }
  }
  if ((int )n_authors == 4) {
    {
    goto case_4;
    }
  }
  if ((int )n_authors == 5) {
    {
    goto case_5;
    }
  }
  if ((int )n_authors == 6) {
    {
    goto case_6;
    }
  }
  if ((int )n_authors == 7) {
    {
    goto case_7;
    }
  }
  if ((int )n_authors == 8) {
    {
    goto case_8;
    }
  }
  if ((int )n_authors == 9) {
    {
    goto case_9;
    }
  }
  goto switch_default;
  case_0:
  {
  abort();
  }
  case_1:
  {
  tmp___1 = dcgettext((char const *)((void *)0), (char const *)"Written by %s.\n",
                      5);
  fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )tmp___1),
          *(authors + 0));
  }
  goto switch_break;
  case_2:
  {
  tmp___2 = dcgettext((char const *)((void *)0), (char const *)"Written by %s and %s.\n",
                      5);
  fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )tmp___2),
          *(authors + 0), *(authors + 1));
  }
  goto switch_break;
  case_3:
  {
  tmp___3 = dcgettext((char const *)((void *)0), (char const *)"Written by %s, %s, and %s.\n",
                      5);
  fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )tmp___3),
          *(authors + 0), *(authors + 1), *(authors + 2));
  }
  goto switch_break;
  case_4:
  {
  tmp___4 = dcgettext((char const *)((void *)0), (char const *)"Written by %s, %s, %s,\nand %s.\n",
                      5);
  fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )tmp___4),
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3));
  }
  goto switch_break;
  case_5:
  {
  tmp___5 = dcgettext((char const *)((void *)0), (char const *)"Written by %s, %s, %s,\n%s, and %s.\n",
                      5);
  fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )tmp___5),
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4));
  }
  goto switch_break;
  case_6:
  {
  tmp___6 = dcgettext((char const *)((void *)0), (char const *)"Written by %s, %s, %s,\n%s, %s, and %s.\n",
                      5);
  fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )tmp___6),
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5));
  }
  goto switch_break;
  case_7:
  {
  tmp___7 = dcgettext((char const *)((void *)0), (char const *)"Written by %s, %s, %s,\n%s, %s, %s, and %s.\n",
                      5);
  fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )tmp___7),
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6));
  }
  goto switch_break;
  case_8:
  {
  tmp___8 = dcgettext((char const *)((void *)0), (char const *)"Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n",
                      5);
  fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )tmp___8),
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7));
  }
  goto switch_break;
  case_9:
  {
  tmp___9 = dcgettext((char const *)((void *)0), (char const *)"Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n",
                      5);
  fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )tmp___9),
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
  goto switch_break;
  switch_default:
  {
  tmp___10 = dcgettext((char const *)((void *)0), (char const *)"Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n",
                       5);
  fprintf((FILE *)((FILE * __restrict )stream), (char const *)((char const * __restrict )tmp___10),
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
  goto switch_break;
  switch_break: ;
  }
  return;
}
}
void version_etc_ar(FILE *stream , char const *command_name , char const *package ,
                    char const *version , char const **authors )
{
  size_t n_authors ;
  {
  {
  n_authors = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! *(authors + n_authors)) {
      {
      goto while_break;
      }
    }
    {
    n_authors ++;
    }
  }
  while_break: ;
  }
  {
  version_etc_arn(stream, command_name, package, version, authors, n_authors);
  }
  return;
}
}
void version_etc_va(FILE *stream , char const *command_name , char const *package ,
                    char const *version , va_list authors )
{
  size_t n_authors ;
  char const *authtab[10] ;
  char const *tmp ;
  char const *tmp___0 ;
  {
  {
  n_authors = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (n_authors < 10UL) {
      {
      {
      tmp___0 = __builtin_va_arg(authors, char const *);
      tmp = tmp___0;
      authtab[n_authors] = tmp;
      }
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
        {
        goto while_break;
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
    {
    n_authors ++;
    }
  }
  while_break: ;
  }
  {
  version_etc_arn(stream, command_name, package, version, (char const **)(authtab),
                  n_authors);
  }
  return;
}
}
void version_etc(FILE *stream , char const *command_name , char const *package ,
                 char const *version , ...) __attribute__((__sentinel__)) ;
void version_etc(FILE *stream , char const *command_name , char const *package ,
                 char const *version , ...)
{
  va_list authors ;
  {
  {
  __builtin_va_start(authors, version);
  version_etc_va(stream, command_name, package, version, authors);
  __builtin_va_end(authors);
  }
  return;
}
}
void emit_bug_reporting_address(void)
{
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  {
  {
  tmp = dcgettext((char const *)((void *)0), (char const *)"\nReport bugs to: %s\n",
                  5);
  printf((char const *)((char const * __restrict )tmp), "bug-coreutils@gnu.org");
  tmp___0 = dcgettext((char const *)((void *)0), (char const *)"%s home page: <%s>\n",
                      5);
  printf((char const *)((char const * __restrict )tmp___0), "GNU coreutils",
         "http://www.gnu.org/software/coreutils/");
  tmp___1 = dcgettext((char const *)((void *)0), (char const *)"General help using GNU software: <http://www.gnu.org/gethelp/>\n",
                      5);
  fputs_unlocked((char const * __restrict )tmp___1, (FILE * __restrict )stdout);
  }
  return;
}
}
_Bool can_write_any_file(void)
{
  _Bool can ;
  __uid_t tmp ;
  {
  if (! initialized___0) {
    {
    {
    can = (_Bool)0;
    tmp = geteuid();
    can = (_Bool )(tmp == 0U);
    can_write = can;
    initialized___0 = (_Bool)1;
    }
    }
  }
  return (can_write);
}
}
void *xmalloc(size_t n ) __attribute__((__malloc__, __alloc_size__(1))) ;
void *xmalloc(size_t n )
{
  void *p ;
  void *tmp ;
  {
  {
  tmp = malloc(n);
  p = tmp;
  }
  if (! p) {
    {
    if (n != 0UL) {
      {
      {
      xalloc_die();
      }
      }
    }
    }
  }
  return (p);
}
}
void *xrealloc(void *p , size_t n ) __attribute__((__alloc_size__(2))) ;
void *xrealloc(void *p , size_t n )
{
  {
  if (! n) {
    {
    if (p) {
      {
      {
      free(p);
      }
      return ((void *)0);
      }
    }
    }
  }
  {
  p = realloc(p, n);
  }
  if (! p) {
    {
    if (n) {
      {
      {
      xalloc_die();
      }
      }
    }
    }
  }
  return (p);
}
}
void *x2realloc(void *p , size_t *pn )
{
  void *tmp ;
  {
  {
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
  return (tmp);
}
}
void *xzalloc(size_t s ) __attribute__((__malloc__, __alloc_size__(1))) ;
void *xzalloc(size_t s )
{
  void *tmp ;
  void *tmp___0 ;
  {
  {
  tmp = xmalloc(s);
  tmp___0 = memset(tmp, 0, s);
  }
  return (tmp___0);
}
}
void *xcalloc(size_t n , size_t s ) __attribute__((__malloc__, __alloc_size__(1,2))) ;
void *xcalloc(size_t n , size_t s )
{
  void *p ;
  {
  {
  p = calloc(n, s);
  }
  if (! p) {
    {
    {
    xalloc_die();
    }
    }
  }
  return (p);
}
}
void *xmemdup(void const *p , size_t s ) __attribute__((__malloc__, __alloc_size__(2))) ;
void *xmemdup(void const *p , size_t s )
{
  void *tmp ;
  void *tmp___0 ;
  {
  {
  tmp = xmalloc(s);
  tmp___0 = memcpy((void *)((void * __restrict )tmp), (void const *)((void const * __restrict )p),
                   s);
  }
  return (tmp___0);
}
}
char *xstrdup(char const *string ) __attribute__((__malloc__)) ;
char *xstrdup(char const *string )
{
  size_t tmp ;
  void *tmp___0 ;
  {
  {
  tmp = strlen(string);
  tmp___0 = xmemdup((void const *)string, tmp + 1UL);
  }
  return ((char *)tmp___0);
}
}
void xalloc_die(void) __attribute__((__noreturn__)) ;
void xalloc_die(void)
{
  char *tmp ;
  {
  {
  tmp = dcgettext((char const *)((void *)0), (char const *)"memory exhausted",
                  5);
  error((int )exit_failure, 0, (char const *)"%s", tmp);
  abort();
  }
}
}
void xfreopen(char const *filename , char const *mode , FILE *fp )
{
  char const *f ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const *tmp___6 ;
  char const *tmp___7 ;
  char const *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  FILE *tmp___11 ;
  {
  {
  tmp___11 = freopen_safer(filename, mode, fp);
  }
  if (! tmp___11) {
    {
    if (filename) {
      {
      {
      tmp___6 = filename;
      }
      }
    } else {
      {
      if ((unsigned long )fp == (unsigned long )stdin) {
        {
        {
        tmp = dcgettext((char const *)((void *)0), (char const *)"stdin", 5);
        tmp___5 = tmp;
        }
        }
      } else {
        {
        if ((unsigned long )fp == (unsigned long )stdout) {
          {
          {
          tmp___0 = dcgettext((char const *)((void *)0), (char const *)"stdout",
                              5);
          tmp___4 = tmp___0;
          }
          }
        } else {
          {
          if ((unsigned long )fp == (unsigned long )stderr) {
            {
            {
            tmp___1 = dcgettext((char const *)((void *)0), (char const *)"stderr",
                                5);
            tmp___3 = tmp___1;
            }
            }
          } else {
            {
            {
            tmp___2 = dcgettext((char const *)((void *)0), (char const *)"unknown stream",
                                5);
            tmp___3 = tmp___2;
            }
            }
          }
          {
          tmp___4 = tmp___3;
          }
          }
        }
        {
        tmp___5 = tmp___4;
        }
        }
      }
      {
      tmp___6 = (char const *)tmp___5;
      }
      }
    }
    {
    f = tmp___6;
    tmp___7 = quote_n(1, mode);
    tmp___8 = quote_n(0, f);
    tmp___9 = dcgettext((char const *)((void *)0), (char const *)"failed to reopen %s with mode %s",
                        5);
    tmp___10 = __errno_location();
    error((int )exit_failure, *tmp___10, (char const *)tmp___9, tmp___8, tmp___7);
    }
    }
  }
  return;
}
}
char *xgetcwd(void)
{
  char *cwd ;
  char *tmp ;
  int *tmp___0 ;
  {
  {
  tmp = rpl_getcwd((char *)((void *)0), (size_t )0);
  cwd = tmp;
  }
  if (! cwd) {
    {
    {
    tmp___0 = __errno_location();
    }
    if (*tmp___0 == 12) {
      {
      {
      xalloc_die();
      }
      }
    }
    }
  }
  return (cwd);
}
}
int xgetgroups(char const *username , gid_t gid , gid_t **groups )
{
  int result ;
  int tmp ;
  int *tmp___0 ;
  {
  {
  tmp = mgetgroups(username, gid, groups);
  result = tmp;
  }
  if (result == -1) {
    {
    {
    tmp___0 = __errno_location();
    }
    if (*tmp___0 == 12) {
      {
      {
      xalloc_die();
      }
      }
    }
    }
  }
  return (result);
}
}
char *xgethostname(void)
{
  char *hostname ;
  size_t size ;
  size_t size_1 ;
  void *tmp ;
  int *tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  {
  {
  hostname = (char *)((void *)0);
  size = (size_t )34;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp = x2realloc((void *)hostname, & size);
    hostname = (char *)tmp;
    size_1 = size - 1UL;
    *(hostname + (size_1 - 1UL)) = (char )'\000';
    tmp___0 = __errno_location();
    *tmp___0 = 0;
    tmp___7 = gethostname(hostname, size_1);
    }
    if (tmp___7 == 0) {
      {
      if (! *(hostname + (size_1 - 1UL))) {
        {
        goto while_break;
        }
      }
      }
    } else {
      {
      {
      tmp___3 = __errno_location();
      }
      if (*tmp___3 != 0) {
        {
        {
        tmp___4 = __errno_location();
        }
        if (*tmp___4 != 36) {
          {
          {
          tmp___5 = __errno_location();
          }
          if (*tmp___5 != 22) {
            {
            {
            tmp___6 = __errno_location();
            }
            if (*tmp___6 != 12) {
              {
              {
              tmp___1 = __errno_location();
              saved_errno = *tmp___1;
              free((void *)hostname);
              tmp___2 = __errno_location();
              *tmp___2 = saved_errno;
              }
              return ((char *)((void *)0));
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
  }
  while_break: ;
  }
  return (hostname);
}
}
static void collate_error(int collation_errno , char const *s1 , size_t s1len ,
                          char const *s2 , size_t s2len )
{
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  {
  {
  tmp = dcgettext((char const *)((void *)0), (char const *)"string comparison failed",
                  5);
  error(0, collation_errno, (char const *)tmp);
  tmp___0 = dcgettext((char const *)((void *)0), (char const *)"Set LC_ALL=\'C\' to work around the problem.",
                      5);
  error(0, 0, (char const *)tmp___0);
  tmp___1 = quotearg_n_style_mem(1, (enum quoting_style )6, s2, s2len);
  tmp___2 = quotearg_n_style_mem(0, (enum quoting_style )6, s1, s1len);
  tmp___3 = dcgettext((char const *)((void *)0), (char const *)"The strings compared were %s and %s.",
                      5);
  error((int )exit_failure, 0, (char const *)tmp___3, tmp___2, tmp___1);
  }
  return;
}
}
int xmemcoll(char *s1 , size_t s1len , char *s2 , size_t s2len )
{
  int diff ;
  int tmp ;
  int collation_errno ;
  int *tmp___0 ;
  {
  {
  tmp = memcoll(s1, s1len, s2, s2len);
  diff = tmp;
  tmp___0 = __errno_location();
  collation_errno = *tmp___0;
  }
  if (collation_errno) {
    {
    {
    collate_error(collation_errno, (char const *)s1, s1len, (char const *)s2,
                  s2len);
    }
    }
  }
  return (diff);
}
}
int xmemcoll0(char const *s1 , size_t s1size , char const *s2 , size_t s2size )
{
  int diff ;
  int tmp ;
  int collation_errno ;
  int *tmp___0 ;
  {
  {
  tmp = memcoll0(s1, s1size, s2, s2size);
  diff = tmp;
  tmp___0 = __errno_location();
  collation_errno = *tmp___0;
  }
  if (collation_errno) {
    {
    {
    collate_error(collation_errno, s1, s1size - 1UL, s2, s2size - 1UL);
    }
    }
  }
  return (diff);
}
}
int xnanosleep(double seconds )
{
  struct timespec ts_sleep ;
  struct timespec tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  {
  {
  tmp = dtotimespec(seconds);
  ts_sleep = tmp;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___0 = __errno_location();
    *tmp___0 = 0;
    tmp___1 = rpl_nanosleep((struct timespec const *)(& ts_sleep), (struct timespec *)((void *)0));
    }
    if (tmp___1 == 0) {
      {
      goto while_break;
      }
    }
    {
    tmp___2 = __errno_location();
    }
    if (*tmp___2 != 4) {
      {
      {
      tmp___3 = __errno_location();
      }
      if (*tmp___3 != 0) {
        {
        return (-1);
        }
      }
      }
    }
  }
  while_break: ;
  }
  return (0);
}
}
int xprintf(char const *format , ...)
{
  va_list args ;
  int retval ;
  {
  {
  __builtin_va_start(args, format);
  retval = xvprintf((char const * __restrict )format, args);
  __builtin_va_end(args);
  }
  return (retval);
}
}
int xvprintf(char const *format , va_list args )
{
  int retval ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  {
  {
  tmp = rpl_vprintf(format, args);
  retval = tmp;
  }
  if (retval < 0) {
    {
    {
    tmp___2 = ferror(stdout);
    }
    if (! tmp___2) {
      {
      {
      tmp___0 = dcgettext((char const *)((void *)0), (char const *)"cannot perform formatted output",
                          5);
      tmp___1 = __errno_location();
      error((int )exit_failure, *tmp___1, (char const *)tmp___0);
      }
      }
    }
    }
  }
  return (retval);
}
}
int xfprintf(FILE *stream , char const *format , ...)
{
  va_list args ;
  int retval ;
  {
  {
  __builtin_va_start(args, format);
  retval = xvfprintf((FILE * __restrict )stream, (char const * __restrict )format,
                     args);
  __builtin_va_end(args);
  }
  return (retval);
}
}
int xvfprintf(FILE *stream , char const *format , va_list args )
{
  int retval ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  {
  {
  tmp = rpl_vfprintf(stream, format, args);
  retval = tmp;
  }
  if (retval < 0) {
    {
    {
    tmp___2 = ferror(stream);
    }
    if (! tmp___2) {
      {
      {
      tmp___0 = dcgettext((char const *)((void *)0), (char const *)"cannot perform formatted output",
                          5);
      tmp___1 = __errno_location();
      error((int )exit_failure, *tmp___1, (char const *)tmp___0);
      }
      }
    }
    }
  }
  return (retval);
}
}
char *xreadlink(char const *filename )
{
  char *result ;
  char *tmp ;
  int *tmp___0 ;
  {
  {
  tmp = areadlink(filename);
  result = tmp;
  }
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
    {
    tmp___0 = __errno_location();
    }
    if (*tmp___0 == 12) {
      {
      {
      xalloc_die();
      }
      }
    }
    }
  }
  return (result);
}
}
int xmem_cd_iconv(char const *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp )
{
  int retval ;
  int tmp ;
  int *tmp___0 ;
  {
  {
  tmp = mem_cd_iconv(src, srclen, cd, resultp, lengthp);
  retval = tmp;
  }
  if (retval < 0) {
    {
    {
    tmp___0 = __errno_location();
    }
    if (*tmp___0 == 12) {
      {
      {
      xalloc_die();
      }
      }
    }
    }
  }
  return (retval);
}
}
char *xstr_cd_iconv(char const *src , iconv_t cd )
{
  char *result ;
  char *tmp ;
  int *tmp___0 ;
  {
  {
  tmp = str_cd_iconv(src, cd);
  result = tmp;
  }
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
    {
    tmp___0 = __errno_location();
    }
    if (*tmp___0 == 12) {
      {
      {
      xalloc_die();
      }
      }
    }
    }
  }
  return (result);
}
}
char *xstr_iconv(char const *src , char const *from_codeset , char const *to_codeset )
{
  char *result ;
  char *tmp ;
  int *tmp___0 ;
  {
  {
  tmp = str_iconv(src, from_codeset, to_codeset);
  result = tmp;
  }
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
    {
    tmp___0 = __errno_location();
    }
    if (*tmp___0 == 12) {
      {
      {
      xalloc_die();
      }
      }
    }
    }
  }
  return (result);
}
}
char *xstrndup(char const *string , size_t n )
{
  char *s ;
  char *tmp___4 ;
  {
  {
  tmp___4 = __strndup(string, n);
  s = tmp___4;
  }
  if (! s) {
    {
    {
    xalloc_die();
    }
    }
  }
  return (s);
}
}
_Bool xstrtod(char const *str , char const **ptr , double *result , double (*convert)(char const * ,
                                                                                          char ** ) )
{
  double val ;
  char *terminator ;
  _Bool ok ;
  int *tmp ;
  int *tmp___0 ;
  {
  {
  ok = (_Bool)1;
  tmp = __errno_location();
  *tmp = 0;
  val = (*convert)(str, & terminator);
  }
  if ((unsigned long )terminator == (unsigned long )str) {
    {
    {
    ok = (_Bool)0;
    }
    }
  } else {
    {
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
      if ((int )*terminator != 0) {
        {
        {
        ok = (_Bool)0;
        }
        }
      } else {
        {
        goto _L;
        }
      }
      }
    } else {
      {
      _L:
      if (val != (double )0) {
        {
        {
        tmp___0 = __errno_location();
        }
        if (*tmp___0 == 34) {
          {
          {
          ok = (_Bool)0;
          }
          }
        }
        }
      }
      }
    }
    }
  }
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    {
    {
    *ptr = (char const *)terminator;
    }
    }
  }
  {
  *result = val;
  }
  return (ok);
}
}
static strtol_error bkm_scale(intmax_t *x , int scale_factor )
{
  {
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
    {
    {
    *x = (-0x7FFFFFFFFFFFFFFF-1);
    }
    return ((strtol_error )1);
    }
  }
  if (9223372036854775807L / (long )scale_factor < *x) {
    {
    {
    *x = 9223372036854775807L;
    }
    return ((strtol_error )1);
    }
  }
  {
  *x *= (intmax_t )scale_factor;
  }
  return ((strtol_error )0);
}
}
static strtol_error bkm_scale_by_power(intmax_t *x , int base , int power )
{
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;
  {
  {
  err = (strtol_error )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___0 = power;
    power --;
    }
    if (! tmp___0) {
      {
      goto while_break;
      }
    }
    {
    tmp = bkm_scale(x, base);
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: ;
  }
  return (err);
}
}
strtol_error xstrtoimax(char const *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const *valid_suffixes )
{
  char *t_ptr ;
  char **p ;
  intmax_t tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___7 ;
  char *tmp___9 ;
  {
  {
  err = (strtol_error )0;
  }
  if (0 <= strtol_base) {
    {
    if (! (strtol_base <= 36)) {
      {
      {
      __assert_fail((char const *)"0 <= strtol_base && strtol_base <= 36", (char const *)"xstrtol.c",
                    83U, (char const *)"xstrtoimax");
      }
      }
    }
    }
  } else {
    {
    {
    __assert_fail((char const *)"0 <= strtol_base && strtol_base <= 36", (char const *)"xstrtol.c",
                  83U, (char const *)"xstrtoimax");
    }
    }
  }
  if (ptr) {
    {
    {
    p = ptr;
    }
    }
  } else {
    {
    {
    p = & t_ptr;
    }
    }
  }
  {
  tmp___1 = __errno_location();
  *tmp___1 = 0;
  tmp = strtoimax((char const *)((char const * __restrict )s), (char **)((char ** __restrict )p),
                  strtol_base);
  }
  if ((unsigned long )*p == (unsigned long )s) {
    {
    if (valid_suffixes) {
      {
      if (*(*p)) {
        {
        {
        tmp___3 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
        }
        if (tmp___3) {
          {
          {
          tmp = (intmax_t )1;
          }
          }
        } else {
          {
          return ((strtol_error )4);
          }
        }
        }
      } else {
        {
        return ((strtol_error )4);
        }
      }
      }
    } else {
      {
      return ((strtol_error )4);
      }
    }
    }
  } else {
    {
    {
    tmp___5 = __errno_location();
    }
    if (*tmp___5 != 0) {
      {
      {
      tmp___4 = __errno_location();
      }
      if (*tmp___4 != 34) {
        {
        return ((strtol_error )4);
        }
      }
      {
      err = (strtol_error )1;
      }
      }
    }
    }
  }
  if (! valid_suffixes) {
    {
    {
    *val = tmp;
    }
    return (err);
    }
  }
  if ((int )*(*p) != 0) {
    {
    {
    base = 1024;
    suffixes = 1;
    tmp___7 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
    }
    if (! tmp___7) {
      {
      {
      *val = tmp;
      }
      return ((strtol_error )((unsigned int )err | 2U));
      }
    }
    {
    tmp___9 = __builtin_strchr((char *)valid_suffixes, '0');
    }
    if (tmp___9) {
      {
      {
      if ((int )*(*(p + 0) + 1) == 105) {
        {
        goto case_105;
        }
      }
      if ((int )*(*(p + 0) + 1) == 68) {
        {
        goto case_68;
        }
      }
      if ((int )*(*(p + 0) + 1) == 66) {
        {
        goto case_68;
        }
      }
      goto switch_break;
      case_105:
      if ((int )*(*(p + 0) + 2) == 66) {
        {
        {
        suffixes += 2;
        }
        }
      }
      goto switch_break;
      case_68:
      case_66:
      {
      base = 1000;
      suffixes ++;
      }
      goto switch_break;
      switch_break: ;
      }
      }
    }
    {
    if ((int )*(*p) == 98) {
      {
      goto case_98;
      }
    }
    if ((int )*(*p) == 66) {
      {
      goto case_66___0;
      }
    }
    if ((int )*(*p) == 99) {
      {
      goto case_99;
      }
    }
    if ((int )*(*p) == 69) {
      {
      goto case_69;
      }
    }
    if ((int )*(*p) == 103) {
      {
      goto case_103;
      }
    }
    if ((int )*(*p) == 71) {
      {
      goto case_103;
      }
    }
    if ((int )*(*p) == 75) {
      {
      goto case_75;
      }
    }
    if ((int )*(*p) == 107) {
      {
      goto case_75;
      }
    }
    if ((int )*(*p) == 109) {
      {
      goto case_109;
      }
    }
    if ((int )*(*p) == 77) {
      {
      goto case_109;
      }
    }
    if ((int )*(*p) == 80) {
      {
      goto case_80;
      }
    }
    if ((int )*(*p) == 116) {
      {
      goto case_116;
      }
    }
    if ((int )*(*p) == 84) {
      {
      goto case_116;
      }
    }
    if ((int )*(*p) == 119) {
      {
      goto case_119;
      }
    }
    if ((int )*(*p) == 89) {
      {
      goto case_89;
      }
    }
    if ((int )*(*p) == 90) {
      {
      goto case_90;
      }
    }
    goto switch_default;
    case_98:
    {
    overflow = bkm_scale(& tmp, 512);
    }
    goto switch_break___0;
    case_66___0:
    {
    overflow = bkm_scale(& tmp, 1024);
    }
    goto switch_break___0;
    case_99:
    {
    overflow = (strtol_error )0;
    }
    goto switch_break___0;
    case_69:
    {
    overflow = bkm_scale_by_power(& tmp, base, 6);
    }
    goto switch_break___0;
    case_103:
    case_71:
    {
    overflow = bkm_scale_by_power(& tmp, base, 3);
    }
    goto switch_break___0;
    case_75:
    case_107:
    {
    overflow = bkm_scale_by_power(& tmp, base, 1);
    }
    goto switch_break___0;
    case_109:
    case_77:
    {
    overflow = bkm_scale_by_power(& tmp, base, 2);
    }
    goto switch_break___0;
    case_80:
    {
    overflow = bkm_scale_by_power(& tmp, base, 5);
    }
    goto switch_break___0;
    case_116:
    case_84:
    {
    overflow = bkm_scale_by_power(& tmp, base, 4);
    }
    goto switch_break___0;
    case_119:
    {
    overflow = bkm_scale(& tmp, 2);
    }
    goto switch_break___0;
    case_89:
    {
    overflow = bkm_scale_by_power(& tmp, base, 8);
    }
    goto switch_break___0;
    case_90:
    {
    overflow = bkm_scale_by_power(& tmp, base, 7);
    }
    goto switch_break___0;
    switch_default:
    {
    *val = tmp;
    }
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: ;
    }
    {
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
    *p += suffixes;
    }
    if (*(*p)) {
      {
      {
      err = (strtol_error )((unsigned int )err | 2U);
      }
      }
    }
    }
  }
  {
  *val = tmp;
  }
  return (err);
}
}
static strtol_error bkm_scale___0(long *x , int scale_factor )
{
  {
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
    {
    {
    *x = (-0x7FFFFFFFFFFFFFFF-1);
    }
    return ((strtol_error )1);
    }
  }
  if (9223372036854775807L / (long )scale_factor < *x) {
    {
    {
    *x = 9223372036854775807L;
    }
    return ((strtol_error )1);
    }
  }
  {
  *x *= (long )scale_factor;
  }
  return ((strtol_error )0);
}
}
static strtol_error bkm_scale_by_power___0(long *x , int base , int power )
{
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;
  {
  {
  err = (strtol_error )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___0 = power;
    power --;
    }
    if (! tmp___0) {
      {
      goto while_break;
      }
    }
    {
    tmp = bkm_scale___0(x, base);
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: ;
  }
  return (err);
}
}
strtol_error xstrtol(char const *s , char **ptr , int strtol_base , long *val ,
                     char const *valid_suffixes )
{
  char *t_ptr ;
  char **p ;
  long tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___7 ;
  char *tmp___9 ;
  {
  {
  err = (strtol_error )0;
  }
  if (0 <= strtol_base) {
    {
    if (! (strtol_base <= 36)) {
      {
      {
      __assert_fail((char const *)"0 <= strtol_base && strtol_base <= 36", (char const *)"xstrtol.c",
                    83U, (char const *)"xstrtol");
      }
      }
    }
    }
  } else {
    {
    {
    __assert_fail((char const *)"0 <= strtol_base && strtol_base <= 36", (char const *)"xstrtol.c",
                  83U, (char const *)"xstrtol");
    }
    }
  }
  if (ptr) {
    {
    {
    p = ptr;
    }
    }
  } else {
    {
    {
    p = & t_ptr;
    }
    }
  }
  {
  tmp___1 = __errno_location();
  *tmp___1 = 0;
  tmp = strtol((char const * __restrict )s, (char ** __restrict )p, strtol_base);
  }
  if ((unsigned long )*p == (unsigned long )s) {
    {
    if (valid_suffixes) {
      {
      if (*(*p)) {
        {
        {
        tmp___3 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
        }
        if (tmp___3) {
          {
          {
          tmp = 1L;
          }
          }
        } else {
          {
          return ((strtol_error )4);
          }
        }
        }
      } else {
        {
        return ((strtol_error )4);
        }
      }
      }
    } else {
      {
      return ((strtol_error )4);
      }
    }
    }
  } else {
    {
    {
    tmp___5 = __errno_location();
    }
    if (*tmp___5 != 0) {
      {
      {
      tmp___4 = __errno_location();
      }
      if (*tmp___4 != 34) {
        {
        return ((strtol_error )4);
        }
      }
      {
      err = (strtol_error )1;
      }
      }
    }
    }
  }
  if (! valid_suffixes) {
    {
    {
    *val = tmp;
    }
    return (err);
    }
  }
  if ((int )*(*p) != 0) {
    {
    {
    base = 1024;
    suffixes = 1;
    tmp___7 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
    }
    if (! tmp___7) {
      {
      {
      *val = tmp;
      }
      return ((strtol_error )((unsigned int )err | 2U));
      }
    }
    {
    tmp___9 = __builtin_strchr((char *)valid_suffixes, '0');
    }
    if (tmp___9) {
      {
      {
      if ((int )*(*(p + 0) + 1) == 105) {
        {
        goto case_105;
        }
      }
      if ((int )*(*(p + 0) + 1) == 68) {
        {
        goto case_68;
        }
      }
      if ((int )*(*(p + 0) + 1) == 66) {
        {
        goto case_68;
        }
      }
      goto switch_break;
      case_105:
      if ((int )*(*(p + 0) + 2) == 66) {
        {
        {
        suffixes += 2;
        }
        }
      }
      goto switch_break;
      case_68:
      case_66:
      {
      base = 1000;
      suffixes ++;
      }
      goto switch_break;
      switch_break: ;
      }
      }
    }
    {
    if ((int )*(*p) == 98) {
      {
      goto case_98;
      }
    }
    if ((int )*(*p) == 66) {
      {
      goto case_66___0;
      }
    }
    if ((int )*(*p) == 99) {
      {
      goto case_99;
      }
    }
    if ((int )*(*p) == 69) {
      {
      goto case_69;
      }
    }
    if ((int )*(*p) == 103) {
      {
      goto case_103;
      }
    }
    if ((int )*(*p) == 71) {
      {
      goto case_103;
      }
    }
    if ((int )*(*p) == 75) {
      {
      goto case_75;
      }
    }
    if ((int )*(*p) == 107) {
      {
      goto case_75;
      }
    }
    if ((int )*(*p) == 109) {
      {
      goto case_109;
      }
    }
    if ((int )*(*p) == 77) {
      {
      goto case_109;
      }
    }
    if ((int )*(*p) == 80) {
      {
      goto case_80;
      }
    }
    if ((int )*(*p) == 116) {
      {
      goto case_116;
      }
    }
    if ((int )*(*p) == 84) {
      {
      goto case_116;
      }
    }
    if ((int )*(*p) == 119) {
      {
      goto case_119;
      }
    }
    if ((int )*(*p) == 89) {
      {
      goto case_89;
      }
    }
    if ((int )*(*p) == 90) {
      {
      goto case_90;
      }
    }
    goto switch_default;
    case_98:
    {
    overflow = bkm_scale___0(& tmp, 512);
    }
    goto switch_break___0;
    case_66___0:
    {
    overflow = bkm_scale___0(& tmp, 1024);
    }
    goto switch_break___0;
    case_99:
    {
    overflow = (strtol_error )0;
    }
    goto switch_break___0;
    case_69:
    {
    overflow = bkm_scale_by_power___0(& tmp, base, 6);
    }
    goto switch_break___0;
    case_103:
    case_71:
    {
    overflow = bkm_scale_by_power___0(& tmp, base, 3);
    }
    goto switch_break___0;
    case_75:
    case_107:
    {
    overflow = bkm_scale_by_power___0(& tmp, base, 1);
    }
    goto switch_break___0;
    case_109:
    case_77:
    {
    overflow = bkm_scale_by_power___0(& tmp, base, 2);
    }
    goto switch_break___0;
    case_80:
    {
    overflow = bkm_scale_by_power___0(& tmp, base, 5);
    }
    goto switch_break___0;
    case_116:
    case_84:
    {
    overflow = bkm_scale_by_power___0(& tmp, base, 4);
    }
    goto switch_break___0;
    case_119:
    {
    overflow = bkm_scale___0(& tmp, 2);
    }
    goto switch_break___0;
    case_89:
    {
    overflow = bkm_scale_by_power___0(& tmp, base, 8);
    }
    goto switch_break___0;
    case_90:
    {
    overflow = bkm_scale_by_power___0(& tmp, base, 7);
    }
    goto switch_break___0;
    switch_default:
    {
    *val = tmp;
    }
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: ;
    }
    {
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
    *p += suffixes;
    }
    if (*(*p)) {
      {
      {
      err = (strtol_error )((unsigned int )err | 2U);
      }
      }
    }
    }
  }
  {
  *val = tmp;
  }
  return (err);
}
}
static strtol_error bkm_scale___1(unsigned long *x , int scale_factor )
{
  {
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
    {
    {
    *x = 0xffffffffffffffffUL;
    }
    return ((strtol_error )1);
    }
  }
  {
  *x *= (unsigned long )scale_factor;
  }
  return ((strtol_error )0);
}
}
static strtol_error bkm_scale_by_power___1(unsigned long *x , int base , int power )
{
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;
  {
  {
  err = (strtol_error )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___0 = power;
    power --;
    }
    if (! tmp___0) {
      {
      goto while_break;
      }
    }
    {
    tmp = bkm_scale___1(x, base);
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: ;
  }
  return (err);
}
}
strtol_error xstrtoul(char const *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const *valid_suffixes )
{
  char *t_ptr ;
  char **p ;
  unsigned long tmp ;
  strtol_error err ;
  char const *q ;
  unsigned char ch ;
  unsigned short const **tmp___0 ;
  int *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___7 ;
  char *tmp___9 ;
  {
  {
  err = (strtol_error )0;
  }
  if (0 <= strtol_base) {
    {
    if (! (strtol_base <= 36)) {
      {
      {
      __assert_fail((char const *)"0 <= strtol_base && strtol_base <= 36", (char const *)"xstrtol.c",
                    83U, (char const *)"xstrtoul");
      }
      }
    }
    }
  } else {
    {
    {
    __assert_fail((char const *)"0 <= strtol_base && strtol_base <= 36", (char const *)"xstrtol.c",
                  83U, (char const *)"xstrtoul");
    }
    }
  }
  if (ptr) {
    {
    {
    p = ptr;
    }
    }
  } else {
    {
    {
    p = & t_ptr;
    }
    }
  }
  {
  q = s;
  ch = (unsigned char )*q;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___0 = __ctype_b_loc();
    }
    if (! ((int const )*(*tmp___0 + (int )ch) & 8192)) {
      {
      goto while_break;
      }
    }
    {
    q ++;
    ch = (unsigned char )*q;
    }
  }
  while_break: ;
  }
  if ((int )ch == 45) {
    {
    return ((strtol_error )4);
    }
  }
  {
  tmp___1 = __errno_location();
  *tmp___1 = 0;
  tmp = strtoul((char const * __restrict )s, (char ** __restrict )p, strtol_base);
  }
  if ((unsigned long )*p == (unsigned long )s) {
    {
    if (valid_suffixes) {
      {
      if (*(*p)) {
        {
        {
        tmp___3 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
        }
        if (tmp___3) {
          {
          {
          tmp = 1UL;
          }
          }
        } else {
          {
          return ((strtol_error )4);
          }
        }
        }
      } else {
        {
        return ((strtol_error )4);
        }
      }
      }
    } else {
      {
      return ((strtol_error )4);
      }
    }
    }
  } else {
    {
    {
    tmp___5 = __errno_location();
    }
    if (*tmp___5 != 0) {
      {
      {
      tmp___4 = __errno_location();
      }
      if (*tmp___4 != 34) {
        {
        return ((strtol_error )4);
        }
      }
      {
      err = (strtol_error )1;
      }
      }
    }
    }
  }
  if (! valid_suffixes) {
    {
    {
    *val = tmp;
    }
    return (err);
    }
  }
  if ((int )*(*p) != 0) {
    {
    {
    base = 1024;
    suffixes = 1;
    tmp___7 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
    }
    if (! tmp___7) {
      {
      {
      *val = tmp;
      }
      return ((strtol_error )((unsigned int )err | 2U));
      }
    }
    {
    tmp___9 = __builtin_strchr((char *)valid_suffixes, '0');
    }
    if (tmp___9) {
      {
      {
      if ((int )*(*(p + 0) + 1) == 105) {
        {
        goto case_105;
        }
      }
      if ((int )*(*(p + 0) + 1) == 68) {
        {
        goto case_68;
        }
      }
      if ((int )*(*(p + 0) + 1) == 66) {
        {
        goto case_68;
        }
      }
      goto switch_break;
      case_105:
      if ((int )*(*(p + 0) + 2) == 66) {
        {
        {
        suffixes += 2;
        }
        }
      }
      goto switch_break;
      case_68:
      case_66:
      {
      base = 1000;
      suffixes ++;
      }
      goto switch_break;
      switch_break: ;
      }
      }
    }
    {
    if ((int )*(*p) == 98) {
      {
      goto case_98;
      }
    }
    if ((int )*(*p) == 66) {
      {
      goto case_66___0;
      }
    }
    if ((int )*(*p) == 99) {
      {
      goto case_99;
      }
    }
    if ((int )*(*p) == 69) {
      {
      goto case_69;
      }
    }
    if ((int )*(*p) == 103) {
      {
      goto case_103;
      }
    }
    if ((int )*(*p) == 71) {
      {
      goto case_103;
      }
    }
    if ((int )*(*p) == 75) {
      {
      goto case_75;
      }
    }
    if ((int )*(*p) == 107) {
      {
      goto case_75;
      }
    }
    if ((int )*(*p) == 109) {
      {
      goto case_109;
      }
    }
    if ((int )*(*p) == 77) {
      {
      goto case_109;
      }
    }
    if ((int )*(*p) == 80) {
      {
      goto case_80;
      }
    }
    if ((int )*(*p) == 116) {
      {
      goto case_116;
      }
    }
    if ((int )*(*p) == 84) {
      {
      goto case_116;
      }
    }
    if ((int )*(*p) == 119) {
      {
      goto case_119;
      }
    }
    if ((int )*(*p) == 89) {
      {
      goto case_89;
      }
    }
    if ((int )*(*p) == 90) {
      {
      goto case_90;
      }
    }
    goto switch_default;
    case_98:
    {
    overflow = bkm_scale___1(& tmp, 512);
    }
    goto switch_break___0;
    case_66___0:
    {
    overflow = bkm_scale___1(& tmp, 1024);
    }
    goto switch_break___0;
    case_99:
    {
    overflow = (strtol_error )0;
    }
    goto switch_break___0;
    case_69:
    {
    overflow = bkm_scale_by_power___1(& tmp, base, 6);
    }
    goto switch_break___0;
    case_103:
    case_71:
    {
    overflow = bkm_scale_by_power___1(& tmp, base, 3);
    }
    goto switch_break___0;
    case_75:
    case_107:
    {
    overflow = bkm_scale_by_power___1(& tmp, base, 1);
    }
    goto switch_break___0;
    case_109:
    case_77:
    {
    overflow = bkm_scale_by_power___1(& tmp, base, 2);
    }
    goto switch_break___0;
    case_80:
    {
    overflow = bkm_scale_by_power___1(& tmp, base, 5);
    }
    goto switch_break___0;
    case_116:
    case_84:
    {
    overflow = bkm_scale_by_power___1(& tmp, base, 4);
    }
    goto switch_break___0;
    case_119:
    {
    overflow = bkm_scale___1(& tmp, 2);
    }
    goto switch_break___0;
    case_89:
    {
    overflow = bkm_scale_by_power___1(& tmp, base, 8);
    }
    goto switch_break___0;
    case_90:
    {
    overflow = bkm_scale_by_power___1(& tmp, base, 7);
    }
    goto switch_break___0;
    switch_default:
    {
    *val = tmp;
    }
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: ;
    }
    {
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
    *p += suffixes;
    }
    if (*(*p)) {
      {
      {
      err = (strtol_error )((unsigned int )err | 2U);
      }
      }
    }
    }
  }
  {
  *val = tmp;
  }
  return (err);
}
}
static void xstrtol_error(enum strtol_error err , int opt_idx , char c , struct rpl_option const *long_options___0 ,
                          char const *arg , int exit_status )
{
  char const *hyphens ;
  char const *msgid ;
  char const *rpl_option ;
  char option_buffer[2] ;
  char *tmp ;
  {
  {
  hyphens = (char const *)"--";
  }
  {
  if ((int )err == 4) {
    {
    goto case_4;
    }
  }
  if ((int )err == 3) {
    {
    goto case_3;
    }
  }
  if ((int )err == 2) {
    {
    goto case_3;
    }
  }
  if ((int )err == 1) {
    {
    goto case_1;
    }
  }
  goto switch_default;
  switch_default:
  {
  abort();
  }
  case_4:
  {
  msgid = (char const *)"invalid %s%s argument `%s\'";
  }
  goto switch_break;
  case_3:
  case_2:
  {
  msgid = (char const *)"invalid suffix in %s%s argument `%s\'";
  }
  goto switch_break;
  case_1:
  {
  msgid = (char const *)"%s%s argument `%s\' too large";
  }
  goto switch_break;
  switch_break: ;
  }
  if (opt_idx < 0) {
    {
    {
    hyphens -= opt_idx;
    option_buffer[0] = c;
    option_buffer[1] = (char )'\000';
    rpl_option = (char const *)(option_buffer);
    }
    }
  } else {
    {
    {
    rpl_option = (char const *)(long_options___0 + opt_idx)->name;
    }
    }
  }
  {
  tmp = dcgettext((char const *)((void *)0), msgid, 5);
  error(exit_status, 0, (char const *)tmp, hyphens, rpl_option, arg);
  }
  return;
}
}
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct rpl_option const *long_options___0 ,
                   char const *arg ) __attribute__((__noreturn__)) ;
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct rpl_option const *long_options___0 ,
                   char const *arg )
{
  {
  {
  xstrtol_error(err, opt_idx, c, long_options___0, arg, (int )exit_failure);
  abort();
  }
}
}
_Bool xstrtold(char const *str , char const **ptr , long double *result , long double (*convert)(char const * ,
                                                                                                     char ** ) )
{
  long double val ;
  char *terminator ;
  _Bool ok ;
  int *tmp ;
  int *tmp___0 ;
  {
  {
  ok = (_Bool)1;
  tmp = __errno_location();
  *tmp = 0;
  val = (*convert)(str, & terminator);
  }
  if ((unsigned long )terminator == (unsigned long )str) {
    {
    {
    ok = (_Bool)0;
    }
    }
  } else {
    {
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
      if ((int )*terminator != 0) {
        {
        {
        ok = (_Bool)0;
        }
        }
      } else {
        {
        goto _L;
        }
      }
      }
    } else {
      {
      _L:
      if (val != (long double )0) {
        {
        {
        tmp___0 = __errno_location();
        }
        if (*tmp___0 == 34) {
          {
          {
          ok = (_Bool)0;
          }
          }
        }
        }
      }
      }
    }
    }
  }
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    {
    {
    *ptr = (char const *)terminator;
    }
    }
  }
  {
  *result = val;
  }
  return (ok);
}
}
static strtol_error bkm_scale___2(uintmax_t *x , int scale_factor )
{
  {
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
    {
    {
    *x = 0xffffffffffffffffUL;
    }
    return ((strtol_error )1);
    }
  }
  {
  *x *= (uintmax_t )scale_factor;
  }
  return ((strtol_error )0);
}
}
static strtol_error bkm_scale_by_power___2(uintmax_t *x , int base , int power )
{
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;
  {
  {
  err = (strtol_error )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___0 = power;
    power --;
    }
    if (! tmp___0) {
      {
      goto while_break;
      }
    }
    {
    tmp = bkm_scale___2(x, base);
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: ;
  }
  return (err);
}
}
strtol_error xstrtoumax(char const *s , char **ptr , int strtol_base , uintmax_t *val ,
                        char const *valid_suffixes )
{
  char *t_ptr ;
  char **p ;
  uintmax_t tmp ;
  strtol_error err ;
  char const *q ;
  unsigned char ch ;
  unsigned short const **tmp___0 ;
  int *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___7 ;
  char *tmp___9 ;
  {
  {
  err = (strtol_error )0;
  }
  if (0 <= strtol_base) {
    {
    if (! (strtol_base <= 36)) {
      {
      {
      __assert_fail((char const *)"0 <= strtol_base && strtol_base <= 36", (char const *)"xstrtol.c",
                    83U, (char const *)"xstrtoumax");
      }
      }
    }
    }
  } else {
    {
    {
    __assert_fail((char const *)"0 <= strtol_base && strtol_base <= 36", (char const *)"xstrtol.c",
                  83U, (char const *)"xstrtoumax");
    }
    }
  }
  if (ptr) {
    {
    {
    p = ptr;
    }
    }
  } else {
    {
    {
    p = & t_ptr;
    }
    }
  }
  {
  q = s;
  ch = (unsigned char )*q;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___0 = __ctype_b_loc();
    }
    if (! ((int const )*(*tmp___0 + (int )ch) & 8192)) {
      {
      goto while_break;
      }
    }
    {
    q ++;
    ch = (unsigned char )*q;
    }
  }
  while_break: ;
  }
  if ((int )ch == 45) {
    {
    return ((strtol_error )4);
    }
  }
  {
  tmp___1 = __errno_location();
  *tmp___1 = 0;
  tmp = strtoumax((char const *)((char const * __restrict )s), (char **)((char ** __restrict )p),
                  strtol_base);
  }
  if ((unsigned long )*p == (unsigned long )s) {
    {
    if (valid_suffixes) {
      {
      if (*(*p)) {
        {
        {
        tmp___3 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
        }
        if (tmp___3) {
          {
          {
          tmp = (uintmax_t )1;
          }
          }
        } else {
          {
          return ((strtol_error )4);
          }
        }
        }
      } else {
        {
        return ((strtol_error )4);
        }
      }
      }
    } else {
      {
      return ((strtol_error )4);
      }
    }
    }
  } else {
    {
    {
    tmp___5 = __errno_location();
    }
    if (*tmp___5 != 0) {
      {
      {
      tmp___4 = __errno_location();
      }
      if (*tmp___4 != 34) {
        {
        return ((strtol_error )4);
        }
      }
      {
      err = (strtol_error )1;
      }
      }
    }
    }
  }
  if (! valid_suffixes) {
    {
    {
    *val = tmp;
    }
    return (err);
    }
  }
  if ((int )*(*p) != 0) {
    {
    {
    base = 1024;
    suffixes = 1;
    tmp___7 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
    }
    if (! tmp___7) {
      {
      {
      *val = tmp;
      }
      return ((strtol_error )((unsigned int )err | 2U));
      }
    }
    {
    tmp___9 = __builtin_strchr((char *)valid_suffixes, '0');
    }
    if (tmp___9) {
      {
      {
      if ((int )*(*(p + 0) + 1) == 105) {
        {
        goto case_105;
        }
      }
      if ((int )*(*(p + 0) + 1) == 68) {
        {
        goto case_68;
        }
      }
      if ((int )*(*(p + 0) + 1) == 66) {
        {
        goto case_68;
        }
      }
      goto switch_break;
      case_105:
      if ((int )*(*(p + 0) + 2) == 66) {
        {
        {
        suffixes += 2;
        }
        }
      }
      goto switch_break;
      case_68:
      case_66:
      {
      base = 1000;
      suffixes ++;
      }
      goto switch_break;
      switch_break: ;
      }
      }
    }
    {
    if ((int )*(*p) == 98) {
      {
      goto case_98;
      }
    }
    if ((int )*(*p) == 66) {
      {
      goto case_66___0;
      }
    }
    if ((int )*(*p) == 99) {
      {
      goto case_99;
      }
    }
    if ((int )*(*p) == 69) {
      {
      goto case_69;
      }
    }
    if ((int )*(*p) == 103) {
      {
      goto case_103;
      }
    }
    if ((int )*(*p) == 71) {
      {
      goto case_103;
      }
    }
    if ((int )*(*p) == 75) {
      {
      goto case_75;
      }
    }
    if ((int )*(*p) == 107) {
      {
      goto case_75;
      }
    }
    if ((int )*(*p) == 109) {
      {
      goto case_109;
      }
    }
    if ((int )*(*p) == 77) {
      {
      goto case_109;
      }
    }
    if ((int )*(*p) == 80) {
      {
      goto case_80;
      }
    }
    if ((int )*(*p) == 116) {
      {
      goto case_116;
      }
    }
    if ((int )*(*p) == 84) {
      {
      goto case_116;
      }
    }
    if ((int )*(*p) == 119) {
      {
      goto case_119;
      }
    }
    if ((int )*(*p) == 89) {
      {
      goto case_89;
      }
    }
    if ((int )*(*p) == 90) {
      {
      goto case_90;
      }
    }
    goto switch_default;
    case_98:
    {
    overflow = bkm_scale___2(& tmp, 512);
    }
    goto switch_break___0;
    case_66___0:
    {
    overflow = bkm_scale___2(& tmp, 1024);
    }
    goto switch_break___0;
    case_99:
    {
    overflow = (strtol_error )0;
    }
    goto switch_break___0;
    case_69:
    {
    overflow = bkm_scale_by_power___2(& tmp, base, 6);
    }
    goto switch_break___0;
    case_103:
    case_71:
    {
    overflow = bkm_scale_by_power___2(& tmp, base, 3);
    }
    goto switch_break___0;
    case_75:
    case_107:
    {
    overflow = bkm_scale_by_power___2(& tmp, base, 1);
    }
    goto switch_break___0;
    case_109:
    case_77:
    {
    overflow = bkm_scale_by_power___2(& tmp, base, 2);
    }
    goto switch_break___0;
    case_80:
    {
    overflow = bkm_scale_by_power___2(& tmp, base, 5);
    }
    goto switch_break___0;
    case_116:
    case_84:
    {
    overflow = bkm_scale_by_power___2(& tmp, base, 4);
    }
    goto switch_break___0;
    case_119:
    {
    overflow = bkm_scale___2(& tmp, 2);
    }
    goto switch_break___0;
    case_89:
    {
    overflow = bkm_scale_by_power___2(& tmp, base, 8);
    }
    goto switch_break___0;
    case_90:
    {
    overflow = bkm_scale_by_power___2(& tmp, base, 7);
    }
    goto switch_break___0;
    switch_default:
    {
    *val = tmp;
    }
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: ;
    }
    {
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
    *p += suffixes;
    }
    if (*(*p)) {
      {
      {
      err = (strtol_error )((unsigned int )err | 2U);
      }
      }
    }
    }
  }
  {
  *val = tmp;
  }
  return (err);
}
}
__inline static size_t __attribute__((__pure__)) xsum(size_t size1 , size_t size2 )
{
  size_t sum ;
  size_t tmp ;
  {
  {
  sum = size1 + size2;
  }
  if (sum >= size1) {
    {
    {
    tmp = sum;
    }
    }
  } else {
    {
    {
    tmp = 0xffffffffffffffffUL;
    }
    }
  }
  return ((size_t __attribute__((__pure__)) )tmp);
}
}
__inline static char *xstrcat(size_t argcount , va_list args )
{
  char *result ;
  va_list ap ;
  size_t totalsize ;
  size_t i ;
  char *p ;
  char const *next ;
  char const *tmp ;
  size_t tmp___0 ;
  size_t __attribute__((__pure__)) tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char const *next___0 ;
  char const *tmp___6 ;
  size_t len ;
  size_t tmp___7 ;
  char const *tmp___8 ;
  char const *tmp___9 ;
  {
  {
  totalsize = (size_t )0;
  __builtin_va_copy(ap, args);
  i = argcount;
  }
  {
  while (1) {
    while_continue: ;
    if (! (i > 0UL)) {
      {
      goto while_break;
      }
    }
    {
    tmp___8 = __builtin_va_arg(ap, char const *);
    tmp = tmp___8;
    next = tmp;
    tmp___0 = strlen(next);
    tmp___1 = xsum(totalsize, tmp___0);
    totalsize = (size_t )tmp___1;
    i --;
    }
  }
  while_break: ;
  }
  {
  __builtin_va_end(ap);
  }
  if (totalsize == 0xffffffffffffffffUL) {
    {
    {
    tmp___2 = __errno_location();
    *tmp___2 = 75;
    }
    return ((char *)((void *)0));
    }
  } else {
    {
    if (totalsize > 2147483647UL) {
      {
      {
      tmp___2 = __errno_location();
      *tmp___2 = 75;
      }
      return ((char *)((void *)0));
      }
    }
    }
  }
  if (sizeof(char ) == 1UL) {
    {
    {
    tmp___3 = xmalloc(totalsize + 1UL);
    tmp___5 = tmp___3;
    }
    }
  } else {
    {
    {
    tmp___4 = xnmalloc(totalsize + 1UL, sizeof(char ));
    tmp___5 = tmp___4;
    }
    }
  }
  {
  result = (char *)tmp___5;
  p = result;
  i = argcount;
  }
  {
  while (1) {
    while_continue___0: ;
    if (! (i > 0UL)) {
      {
      goto while_break___0;
      }
    }
    {
    tmp___9 = __builtin_va_arg(args, char const *);
    tmp___6 = tmp___9;
    next___0 = tmp___6;
    tmp___7 = strlen(next___0);
    len = tmp___7;
    memcpy((void *)((void * __restrict )p), (void const *)((void const * __restrict )next___0),
           len);
    p += len;
    i --;
    }
  }
  while_break___0: ;
  }
  {
  *p = (char )'\000';
  }
  return (result);
}
}
char *xvasprintf(char const *format , va_list args )
{
  char *result ;
  size_t argcount ;
  char const *f ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  {
  {
  argcount = (size_t )0;
  f = format;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if ((int const )*f == 0) {
      {
      {
      tmp = xstrcat(argcount, args);
      }
      return (tmp);
      }
    }
    if ((int const )*f != 37) {
      {
      goto while_break;
      }
    }
    {
    f ++;
    }
    if ((int const )*f != 115) {
      {
      goto while_break;
      }
    }
    {
    f ++;
    argcount ++;
    }
  }
  while_break: ;
  }
  {
  tmp___1 = rpl_vasprintf(& result, format, args);
  }
  if (tmp___1 < 0) {
    {
    {
    tmp___0 = __errno_location();
    }
    if (*tmp___0 == 12) {
      {
      {
      xalloc_die();
      }
      }
    }
    return ((char *)((void *)0));
    }
  }
  return (result);
}
}
char *xasprintf(char const *format , ...)
{
  va_list args ;
  char *result ;
  {
  {
  __builtin_va_start(args, format);
  result = xvasprintf(format, args);
  __builtin_va_end(args);
  }
  return (result);
}
}
_Bool yesno(void)
{
  _Bool yes ;
  char *response ;
  size_t response_size ;
  ssize_t response_len ;
  __ssize_t tmp ;
  int tmp___0 ;
  {
  {
  response = (char *)((void *)0);
  response_size = (size_t )0;
  tmp = getline((char **)((char ** __restrict )(& response)), (size_t *)((size_t * __restrict )(& response_size)),
                (FILE *)((FILE * __restrict )stdin));
  response_len = tmp;
  }
  if (response_len <= 0L) {
    {
    {
    yes = (_Bool)0;
    }
    }
  } else {
    {
    {
    *(response + (response_len - 1L)) = (char )'\000';
    tmp___0 = rpmatch((char const *)response);
    yes = (_Bool )(0 < tmp___0);
    }
    }
  }
  {
  free((void *)response);
  }
  return (yes);
}
}
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max ) __attribute__((__const__)) ;
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max )
{
  size_t size ;
  size_t lcm ;
  size_t m ;
  size_t n ;
  size_t q ;
  size_t r ;
  size_t tmp ;
  {
  if (! a) {
    {
    if (b) {
      {
      {
      size = b;
      }
      }
    } else {
      {
      {
      size = (size_t )8192;
      }
      }
    }
    }
  } else {
    {
    if (b) {
      {
      {
      m = a;
      n = b;
      }
      {
      while (1) {
        while_continue: ;
        if (! 1) {
          {
          goto while_break;
          }
        }
        {
        r = m % n;
        }
        if (! (r != 0UL)) {
          {
          goto while_break;
          }
        }
        goto __Cont;
        __Cont:
        {
        m = n;
        n = r;
        }
      }
      while_break: ;
      }
      {
      q = a / n;
      lcm = q * b;
      }
      if (lcm <= lcm_max) {
        {
        if (lcm / b == q) {
          {
          return (lcm);
          }
        }
        }
      }
      }
    }
    {
    size = a;
    }
    }
  }
  if (size <= lcm_max) {
    {
    {
    tmp = size;
    }
    }
  } else {
    {
    {
    tmp = lcm_max;
    }
    }
  }
  return (tmp);
}
}
char *asnprintf(char *resultbuf , size_t *lengthp , char const *format , ...)
{
  va_list args ;
  char *result ;
  {
  {
  __builtin_va_start(args, format);
  result = vasnprintf(resultbuf, lengthp, format, args);
  __builtin_va_end(args);
  }
  return (result);
}
}
int ( __attribute__((__nonnull__(1,2))) rpl_asprintf)(char **resultp , char const *format
                                                      , ...)
{
  va_list args ;
  int result ;
  {
  {
  __builtin_va_start(args, format);
  result = rpl_vasprintf(resultp, format, args);
  __builtin_va_end(args);
  }
  return (result);
}
}
__inline static void cdb_init(struct cd_buf *cdb )
{
  {
  {
  cdb->fd = -100;
  }
  return;
}
}
__inline static int cdb_fchdir(struct cd_buf const *cdb )
{
  int tmp ;
  {
  {
  tmp = fchdir((int )cdb->fd);
  }
  return (tmp);
}
}
__inline static void cdb_free(struct cd_buf const *cdb )
{
  _Bool close_fail ;
  int tmp ;
  {
  if (0 <= (int )cdb->fd) {
    {
    {
    tmp = close((int )cdb->fd);
    close_fail = (_Bool )tmp;
    }
    if (! (! close_fail)) {
      {
      {
      __assert_fail((char const *)"! close_fail", (char const *)"chdir-long.c",
                    63U, (char const *)"cdb_free");
      }
      }
    }
    }
  }
  return;
}
}
static int cdb_advance_fd(struct cd_buf *cdb , char const *dir )
{
  int new_fd ;
  int tmp ;
  {
  {
  tmp = openat(cdb->fd, dir, 67840);
  new_fd = tmp;
  }
  if (new_fd < 0) {
    {
    return (-1);
    }
  }
  {
  cdb_free((struct cd_buf const *)cdb);
  cdb->fd = new_fd;
  }
  return (0);
}
}
__inline static char *find_non_slash(char const *s )
{
  size_t n_slash ;
  unsigned long tmp___8 ;
  {
  {
  tmp___8 = __builtin_strspn(s, (char const *)"/");
  n_slash = tmp___8;
  }
  return ((char *)s + n_slash);
}
}
int chdir_long(char *dir )
{
  int e ;
  int tmp ;
  int *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  char *dir_end ;
  struct cd_buf cdb ;
  size_t n_leading_slash ;
  unsigned long tmp___11 ;
  int err ;
  char *slash ;
  void *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int err___0 ;
  char *slash___0 ;
  void *tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int saved_errno ;
  int *tmp___19 ;
  int *tmp___20 ;
  {
  {
  tmp = chdir((char const *)dir);
  e = tmp;
  }
  if (e == 0) {
    {
    return (e);
    }
  } else {
    {
    {
    tmp___0 = __errno_location();
    }
    if (*tmp___0 != 36) {
      {
      return (e);
      }
    }
    }
  }
  {
  tmp___1 = strlen((char const *)dir);
  len = tmp___1;
  dir_end = dir + len;
  cdb_init(& cdb);
  }
  if (! (0UL < len)) {
    {
    {
    __assert_fail((char const *)"0 < len", (char const *)"chdir-long.c", 125U,
                  (char const *)"chdir_long");
    }
    }
  }
  if (! (4096UL <= len)) {
    {
    {
    __assert_fail((char const *)"4096 <= len", (char const *)"chdir-long.c", 126U,
                  (char const *)"chdir_long");
    }
    }
  }
  {
  tmp___11 = __builtin_strspn((char const *)dir, (char const *)"/");
  n_leading_slash = tmp___11;
  }
  if (n_leading_slash == 2UL) {
    {
    {
    tmp___12 = memchr((void const *)(dir + 3), '/', (size_t )(dir_end - (dir + 3)));
    slash = (char *)tmp___12;
    }
    if ((unsigned long )slash == (unsigned long )((void *)0)) {
      {
      {
      tmp___13 = __errno_location();
      *tmp___13 = 36;
      }
      return (-1);
      }
    }
    {
    *slash = (char )'\000';
    err = cdb_advance_fd(& cdb, (char const *)dir);
    *slash = (char )'/';
    }
    if (err != 0) {
      {
      goto Fail;
      }
    }
    {
    dir = find_non_slash((char const *)(slash + 1));
    }
    }
  } else {
    {
    if (n_leading_slash) {
      {
      {
      tmp___14 = cdb_advance_fd(& cdb, (char const *)"/");
      }
      if (tmp___14 != 0) {
        {
        goto Fail;
        }
      }
      {
      dir += n_leading_slash;
      }
      }
    }
    }
  }
  if (! ((int )*dir != 47)) {
    {
    {
    __assert_fail((char const *)"*dir != \'/\'", (char const *)"chdir-long.c",
                  161U, (char const *)"chdir_long");
    }
    }
  }
  if (! ((unsigned long )dir <= (unsigned long )dir_end)) {
    {
    {
    __assert_fail((char const *)"dir <= dir_end", (char const *)"chdir-long.c",
                  162U, (char const *)"chdir_long");
    }
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! (4096L <= dir_end - dir)) {
      {
      goto while_break;
      }
    }
    {
    tmp___15 = memrchr((void const *)dir, '/', (size_t )4096);
    slash___0 = (char *)tmp___15;
    }
    if ((unsigned long )slash___0 == (unsigned long )((void *)0)) {
      {
      {
      tmp___16 = __errno_location();
      *tmp___16 = 36;
      }
      return (-1);
      }
    }
    {
    *slash___0 = (char )'\000';
    }
    if (! (slash___0 - dir < 4096L)) {
      {
      {
      __assert_fail((char const *)"slash - dir < 4096", (char const *)"chdir-long.c",
                    178U, (char const *)"chdir_long");
      }
      }
    }
    {
    err___0 = cdb_advance_fd(& cdb, (char const *)dir);
    *slash___0 = (char )'/';
    }
    if (err___0 != 0) {
      {
      goto Fail;
      }
    }
    {
    dir = find_non_slash((char const *)(slash___0 + 1));
    }
  }
  while_break: ;
  }
  if ((unsigned long )dir < (unsigned long )dir_end) {
    {
    {
    tmp___17 = cdb_advance_fd(& cdb, (char const *)dir);
    }
    if (tmp___17 != 0) {
      {
      goto Fail;
      }
    }
    }
  }
  {
  tmp___18 = cdb_fchdir((struct cd_buf const *)(& cdb));
  }
  if (tmp___18 != 0) {
    {
    goto Fail;
    }
  }
  {
  cdb_free((struct cd_buf const *)(& cdb));
  }
  return (0);
  Fail:
  {
  tmp___19 = __errno_location();
  saved_errno = *tmp___19;
  cdb_free((struct cd_buf const *)(& cdb));
  tmp___20 = __errno_location();
  *tmp___20 = saved_errno;
  }
  return (-1);
}
}
int ( __attribute__((__nonnull__(1))) rpl_fclose)(FILE *fp )
{
  int saved_errno ;
  int fd ;
  int result ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __off_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  {
  {
  saved_errno = 0;
  { if(!(saved_errno == 0)) { reach_error(); abort(); } };
  result = 0;
  { if(!(result == 0)) { reach_error(); abort(); } };
  fd = fileno(fp);
  }
  if (fd < 0) {
    {
    { if(!(fd != 0)) { reach_error(); abort(); } };
    {
    tmp = fclose(fp);
    }
    return (tmp);
    }
  }
  {
  tmp___1 = __freading(fp);
  }
  if (tmp___1 != 0) {
    {
    { if(!(tmp___1 != 0)) { reach_error(); abort(); } };
    {
    tmp___2 = fileno(fp);
    tmp___3 = lseek(tmp___2, (__off_t )0, 1);
    }
    if (tmp___3 != -1L) {
      {
      _L:
      {
      { if(!(saved_errno == 0)) { reach_error(); abort(); } };
      { if(!(result == 0)) { reach_error(); abort(); } };
      {
      tmp___4 = rpl_fflush(fp);
      }
      }
      if (tmp___4) {
        {
        { if(!(tmp___4 != 0)) { reach_error(); abort(); } };
        {
        tmp___0 = __errno_location();
        saved_errno = *tmp___0;
        }
        }
      }
      }
    }
    }
  } else {
    {
    goto _L;
    }
  }
  {
  result = fclose(fp);
  }
  if (saved_errno != 0) {
    {
    { if(!(saved_errno != 0)) { reach_error(); abort(); } };
    {
    tmp___5 = __errno_location();
    *tmp___5 = saved_errno;
    result = -1;
    }
    }
  }
  return (result);
}
}
int rpl_fcntl(int fd , int action , ...)
{
  va_list arg ;
  int result ;
  int target ;
  int tmp ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  int saved_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  void *p ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  {
  {
  result = -1;
  { if(!(result == -1)) { reach_error(); abort(); } };
  __builtin_va_start(arg, action);
  { if(!(result == -1)) { reach_error(); abort(); } };
  }
  {
  if (action == 1030) {
    {
    goto case_1030;
    }
  }
  goto switch_default;
  case_1030:
  {
  tmp___6 = __builtin_va_arg(arg, int );
  tmp = tmp___6;
  target = tmp;
  }
  if (0 <= have_dupfd_cloexec) {
    {
    {
    result = fcntl(fd, action, target);
    }
    if (0 <= result) {
      {
      {
      have_dupfd_cloexec = 1;
      }
      }
    } else {
      {
      {
      tmp___0 = __errno_location();
      }
      if (*tmp___0 != 22) {
        {
        {
        have_dupfd_cloexec = 1;
        }
        }
      } else {
        {
        {
        result = rpl_fcntl(fd, 0, target);
        }
        if (result < 0) {
          {
          goto switch_break;
          }
        }
        {
        have_dupfd_cloexec = -1;
        }
        }
      }
      }
    }
    }
  } else {
    {
    {
    result = rpl_fcntl(fd, 0, target);
    }
    }
  }
  if (0 <= result) {
    {
    if (have_dupfd_cloexec == -1) {
      {
      {
      tmp___1 = fcntl(result, 1);
      flags = tmp___1;
      }
      if (flags < 0) {
        {
        goto _L;
        }
      } else {
        {
        {
        tmp___4 = fcntl(result, 2, flags | 1);
        }
        if (tmp___4 == -1) {
          {
          _L:
          {
          tmp___2 = __errno_location();
          saved_errno = *tmp___2;
          close(result);
          tmp___3 = __errno_location();
          *tmp___3 = saved_errno;
          result = -1;
          }
          }
        }
        }
      }
      }
    }
    }
  }
  goto switch_break;
  switch_default:
  {
  tmp___7 = __builtin_va_arg(arg, void *);
  { if(!(result == -1)) { reach_error(); abort(); } };
  tmp___5 = tmp___7;
  p = tmp___5;
  result = fcntl(fd, action, p);
  }
  goto switch_break;
  switch_break: ;
  }
  {
  __builtin_va_end(arg);
  }
  return (result);
}
}
__inline static void clear_ungetc_buffer_preserving_position(FILE *fp )
{
  {
  if (fp->_flags & 256) {
    {
    {
    rpl_fseeko(fp, (off_t )0, 1);
    }
    }
  }
  return;
}
}
int rpl_fflush(FILE *stream )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
    {
    { if(!(stream == 0)) { reach_error(); abort(); } };
    {
    tmp = fflush(stream);
    }
    return (tmp);
    }
  } else {
    {
    {
    tmp___0 = __freading(stream);
    }
    if (! (tmp___0 != 0)) {
      {
      { if(!(tmp___0 == 0)) { reach_error(); abort(); } };
      {
      tmp = fflush(stream);
      }
      return (tmp);
      }
    }
    }
  }
  {
  clear_ungetc_buffer_preserving_position(stream);
  { if(!(tmp___0 != 0)) { reach_error(); abort(); } };
  tmp___1 = fflush(stream);
  }
  return (tmp___1);
}
}
int ( __attribute__((__nonnull__(1))) fpurge)(FILE *fp )
{
  {
  {
  __fpurge(fp);
  }
  return (0);
}
}
int ( __attribute__((__nonnull__(1))) rpl_fseek)(FILE *fp , long offset , int whence )
{
  int tmp ;
  {
  {
  tmp = rpl_fseeko(fp, offset, whence);
  }
  return (tmp);
}
}
int ( __attribute__((__nonnull__(1))) rpl_fseeko)(FILE *fp , off_t offset , int whence )
{
  off_t pos ;
  int tmp ;
  __off_t tmp___0 ;
  int tmp___1 ;
  {
  if ((unsigned long )fp->_IO_read_end == (unsigned long )fp->_IO_read_ptr) {
    {
    if ((unsigned long )fp->_IO_write_ptr == (unsigned long )fp->_IO_write_base) {
      {
      if ((unsigned long )fp->_IO_save_base == (unsigned long )((void *)0)) {
        {
        {
        tmp = fileno(fp);
        tmp___0 = lseek(tmp, offset, whence);
        pos = tmp___0;
        }
        if (pos == -1L) {
          {
          { if(!(pos == -1L)) { reach_error(); abort(); } };
          return (-1);
          }
        }
        {
        fp->_flags &= -17;
        fp->_offset = pos;
        }
        return (0);
        }
      }
      }
    }
    }
  }
  {
  tmp___1 = fseeko(fp, offset, whence);
  }
  return (tmp___1);
}
}
int get_fs_usage(char const *file , char const *disk , struct fs_usage *fsp )
{
  struct statfs fsd ;
  int tmp ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___9 ;
  {
  {
  tmp = statfs(file, & fsd);
  }
  if (tmp < 0) {
    {
    return (-1);
    }
  }
  if (sizeof(fsd.f_bsize) < sizeof(uintmax_t )) {
    {
    if (sizeof(fsd.f_bsize) < sizeof(int )) {
      {
      {
      tmp___1 = - (1 << sizeof(fsd.f_bsize) * 8UL);
      }
      }
    } else {
      {
      {
      tmp___1 = 0;
      }
      }
    }
    if (~ fsd.f_bsize == (long )tmp___1) {
      {
      {
      fsp->fsu_blocksize = 0xffffffffffffffffUL;
      }
      }
    } else {
      {
      {
      fsp->fsu_blocksize = (uintmax_t )fsd.f_bsize;
      }
      }
    }
    }
  } else {
    {
    {
    fsp->fsu_blocksize = (uintmax_t )fsd.f_bsize;
    }
    }
  }
  if (sizeof(fsd.f_blocks) < sizeof(uintmax_t )) {
    {
    if (sizeof(fsd.f_blocks) < sizeof(int )) {
      {
      {
      tmp___3 = - (1 << sizeof(fsd.f_blocks) * 8UL);
      }
      }
    } else {
      {
      {
      tmp___3 = 0;
      }
      }
    }
    if (~ fsd.f_blocks == (__fsblkcnt_t )tmp___3) {
      {
      {
      fsp->fsu_blocks = 0xffffffffffffffffUL;
      }
      }
    } else {
      {
      {
      fsp->fsu_blocks = fsd.f_blocks;
      }
      }
    }
    }
  } else {
    {
    {
    fsp->fsu_blocks = fsd.f_blocks;
    }
    }
  }
  if (sizeof(fsd.f_bfree) < sizeof(uintmax_t )) {
    {
    if (sizeof(fsd.f_bfree) < sizeof(int )) {
      {
      {
      tmp___5 = - (1 << sizeof(fsd.f_bfree) * 8UL);
      }
      }
    } else {
      {
      {
      tmp___5 = 0;
      }
      }
    }
    if (~ fsd.f_bfree == (__fsblkcnt_t )tmp___5) {
      {
      {
      fsp->fsu_bfree = 0xffffffffffffffffUL;
      }
      }
    } else {
      {
      {
      fsp->fsu_bfree = fsd.f_bfree;
      }
      }
    }
    }
  } else {
    {
    {
    fsp->fsu_bfree = fsd.f_bfree;
    }
    }
  }
  {
  fsp->fsu_bavail = fsd.f_bavail | ~ ((fsd.f_bavail & (1UL << (sizeof(fsd.f_bavail) * 8UL - 1UL))) - 1UL);
  fsp->fsu_bavail_top_bit_set = (_Bool )((fsd.f_bavail & (1UL << (sizeof(fsd.f_bavail) * 8UL - 1UL))) != 0UL);
  }
  if (sizeof(fsd.f_files) < sizeof(uintmax_t )) {
    {
    if (sizeof(fsd.f_files) < sizeof(int )) {
      {
      {
      tmp___7 = - (1 << sizeof(fsd.f_files) * 8UL);
      }
      }
    } else {
      {
      {
      tmp___7 = 0;
      }
      }
    }
    if (~ fsd.f_files == (__fsfilcnt_t )tmp___7) {
      {
      {
      fsp->fsu_files = 0xffffffffffffffffUL;
      }
      }
    } else {
      {
      {
      fsp->fsu_files = fsd.f_files;
      }
      }
    }
    }
  } else {
    {
    {
    fsp->fsu_files = fsd.f_files;
    }
    }
  }
  if (sizeof(fsd.f_ffree) < sizeof(uintmax_t )) {
    {
    if (sizeof(fsd.f_ffree) < sizeof(int )) {
      {
      {
      tmp___9 = - (1 << sizeof(fsd.f_ffree) * 8UL);
      }
      }
    } else {
      {
      {
      tmp___9 = 0;
      }
      }
    }
    if (~ fsd.f_ffree == (__fsfilcnt_t )tmp___9) {
      {
      {
      fsp->fsu_ffree = 0xffffffffffffffffUL;
      }
      }
    } else {
      {
      {
      fsp->fsu_ffree = fsd.f_ffree;
      }
      }
    }
    }
  } else {
    {
    {
    fsp->fsu_ffree = fsd.f_ffree;
    }
    }
  }
  return (0);
}
}
static _Bool AD_compare(void const *x , void const *y )
{
  struct Active_dir const *ax ;
  struct Active_dir const *ay ;
  int tmp ;
  {
  {
  ax = (struct Active_dir const *)x;
  ay = (struct Active_dir const *)y;
  }
  if (ax->ino == ay->ino) {
    {
    if (ax->dev == ay->dev) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  return ((_Bool )tmp);
}
}
static size_t AD_hash(void const *x , size_t table_size )
{
  struct Active_dir const *ax ;
  {
  {
  ax = (struct Active_dir const *)x;
  }
  return ((uintmax_t )ax->ino % table_size);
}
}
static _Bool setup_dir(FTS *fts )
{
  void *tmp ;
  {
  if (fts->fts_options & 258) {
    {
    {
    fts->fts_cycle.ht = hash_initialize((size_t )31, (Hash_tuning const *)((void *)0),
                                        & AD_hash, & AD_compare, & free);
    }
    if (! fts->fts_cycle.ht) {
      {
      return ((_Bool)0);
      }
    }
    }
  } else {
    {
    {
    tmp = malloc(sizeof(*(fts->fts_cycle.state)));
    fts->fts_cycle.state = (struct cycle_check_state *)tmp;
    }
    if (! fts->fts_cycle.state) {
      {
      return ((_Bool)0);
      }
    }
    {
    cycle_check_init(fts->fts_cycle.state);
    }
    }
  }
  return ((_Bool)1);
}
}
static _Bool enter_dir(FTS *fts , FTSENT *ent )
{
  struct stat const *st ;
  struct Active_dir *ad ;
  void *tmp ;
  struct Active_dir *ad_from_table ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  {
  if (fts->fts_options & 258) {
    {
    {
    st = (struct stat const *)(ent->fts_statp);
    tmp = malloc(sizeof(*ad));
    ad = (struct Active_dir *)tmp;
    }
    if (! ad) {
      {
      return ((_Bool)0);
      }
    }
    {
    ad->dev = (dev_t )st->st_dev;
    ad->ino = (ino_t )st->st_ino;
    ad->fts_ent = ent;
    tmp___0 = hash_insert(fts->fts_cycle.ht, (void const *)ad);
    ad_from_table = (struct Active_dir *)tmp___0;
    }
    if ((unsigned long )ad_from_table != (unsigned long )ad) {
      {
      {
      free((void *)ad);
      }
      if (! ad_from_table) {
        {
        return ((_Bool)0);
        }
      }
      {
      ent->fts_cycle = ad_from_table->fts_ent;
      ent->fts_info = (unsigned short)2;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___1 = cycle_check(fts->fts_cycle.state, (struct stat const *)(ent->fts_statp));
    }
    if (tmp___1) {
      {
      {
      ent->fts_cycle = ent;
      ent->fts_info = (unsigned short)2;
      }
      }
    }
    }
  }
  return ((_Bool)1);
}
}
static void leave_dir(FTS *fts , FTSENT *ent )
{
  struct stat const *st ;
  struct Active_dir obj ;
  void *found ;
  FTSENT *parent ;
  {
  {
  st = (struct stat const *)(ent->fts_statp);
  }
  if (fts->fts_options & 258) {
    {
    {
    obj.dev = (dev_t )st->st_dev;
    obj.ino = (ino_t )st->st_ino;
    found = hash_delete(fts->fts_cycle.ht, (void const *)(& obj));
    }
    if (! found) {
      {
      {
      abort();
      }
      }
    }
    {
    free(found);
    }
    }
  } else {
    {
    {
    parent = ent->fts_parent;
    }
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
      {
      if (0L <= parent->fts_level) {
        {
        {
        while (1) {
          while_continue: ;
          if (! 1) {
            {
            goto while_break;
            }
          }
          if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
            {
            {
            abort();
            }
            }
          }
          if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t )st->st_ino) {
            {
            if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t )st->st_dev) {
              {
              {
              (fts->fts_cycle.state)->dev_ino.st_dev = parent->fts_statp[0].st_dev;
              (fts->fts_cycle.state)->dev_ino.st_ino = parent->fts_statp[0].st_ino;
              }
              }
            }
            }
          }
          goto while_break;
        }
        while_break: ;
        }
        }
      }
      }
    }
    }
  }
  return;
}
}
static void free_dir(FTS *sp )
{
  {
  if (sp->fts_options & 258) {
    {
    if (sp->fts_cycle.ht) {
      {
      {
      hash_free(sp->fts_cycle.ht);
      }
      }
    }
    }
  } else {
    {
    {
    free((void *)sp->fts_cycle.state);
    }
    }
  }
  return;
}
}
static void fd_ring_clear(I_ring *fd_ring )
{
  int fd ;
  int tmp ;
  _Bool tmp___0 ;
  {
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___0 = i_ring_empty((I_ring const *)fd_ring);
    }
    if (tmp___0) {
      {
      goto while_break;
      }
    }
    {
    tmp = i_ring_pop(fd_ring);
    fd = tmp;
    }
    if (0 <= fd) {
      {
      {
      close(fd);
      }
      }
    }
  }
  while_break: ;
  }
  return;
}
}
static void fts_set_stat_required(FTSENT *p , _Bool required )
{
  {
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (! ((int )p->fts_info == 11)) {
      {
      {
      abort();
      }
      }
    }
    goto while_break;
  }
  while_break: ;
  }
  if (required) {
    {
    {
    p->fts_statp[0].st_size = (__off_t )2;
    }
    }
  } else {
    {
    {
    p->fts_statp[0].st_size = (__off_t )1;
    }
    }
  }
  return;
}
}
__inline static DIR *opendirat(int fd , char const *dir , int extra_flags , int *pdir_fd )
{
  int new_fd ;
  int tmp ;
  DIR *dirp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  {
  {
  tmp = openat_safer(fd, dir, 67840 | extra_flags);
  new_fd = tmp;
  }
  if (new_fd < 0) {
    {
    return ((DIR *)((void *)0));
    }
  }
  {
  set_cloexec_flag(new_fd, (_Bool)1);
  dirp = fdopendir(new_fd);
  }
  if (dirp) {
    {
    {
    *pdir_fd = new_fd;
    }
    }
  } else {
    {
    {
    tmp___0 = __errno_location();
    saved_errno = *tmp___0;
    close(new_fd);
    tmp___1 = __errno_location();
    *tmp___1 = saved_errno;
    }
    }
  }
  return (dirp);
}
}
static void cwd_advance_fd(FTS *sp , int fd , _Bool chdir_down_one )
{
  int old ;
  int prev_fd_in_slot ;
  int tmp ;
  {
  {
  old = sp->fts_cwd_fd;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (! (old != fd)) {
      {
      if (! (old == -100)) {
        {
        {
        abort();
        }
        }
      }
      }
    }
    goto while_break;
  }
  while_break: ;
  }
  if (chdir_down_one) {
    {
    {
    tmp = i_ring_push(& sp->fts_fd_ring, old);
    prev_fd_in_slot = tmp;
    }
    if (0 <= prev_fd_in_slot) {
      {
      {
      close(prev_fd_in_slot);
      }
      }
    }
    }
  } else {
    {
    if (! (sp->fts_options & 4)) {
      {
      if (0 <= old) {
        {
        {
        close(old);
        }
        }
      }
      }
    }
    }
  }
  {
  sp->fts_cwd_fd = fd;
  }
  return;
}
}
__inline static int diropen(FTS const *sp , char const *dir )
{
  int open_flags ;
  int tmp ;
  int tmp___0 ;
  int fd ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  if (sp->fts_options & 16) {
    {
    {
    tmp = 131072;
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  if (sp->fts_options & 2048) {
    {
    {
    tmp___0 = 262144;
    }
    }
  } else {
    {
    {
    tmp___0 = 0;
    }
    }
  }
  {
  open_flags = (67840 | tmp) | tmp___0;
  }
  if (sp->fts_options & 512) {
    {
    {
    tmp___1 = openat_safer((int )sp->fts_cwd_fd, dir, open_flags);
    tmp___3 = tmp___1;
    }
    }
  } else {
    {
    {
    tmp___2 = open_safer(dir, open_flags);
    tmp___3 = tmp___2;
    }
    }
  }
  {
  fd = tmp___3;
  }
  if (0 <= fd) {
    {
    {
    set_cloexec_flag(fd, (_Bool)1);
    }
    }
  }
  return (fd);
}
}
FTS *( __attribute__((__warn_unused_result__)) fts_open)(char **argv , int options ,
                                                         int (*compar)(FTSENT const ** ,
                                                                       FTSENT const ** ) ) __attribute__((__nothrow__)) ;
FTS *( __attribute__((__warn_unused_result__)) fts_open)(char **argv , int options ,
                                                         int (*compar)(FTSENT const ** ,
                                                                       FTSENT const ** ) )
{
  register FTS *sp ;
  register FTSENT *p ;
  register FTSENT *root ;
  register size_t nitems ;
  FTSENT *parent ;
  FTSENT *tmp ;
  _Bool defer_stat ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  size_t maxarglen ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;
  size_t len ;
  size_t tmp___10 ;
  struct _ftsent *tmp___11 ;
  _Bool tmp___12 ;
  int tmp___13 ;
  {
  {
  parent = (FTSENT *)((void *)0);
  tmp = (FTSENT *)((void *)0);
  }
  if (options & -4096) {
    {
    {
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    }
    return ((FTS *)((void *)0));
    }
  }
  if (options & 4) {
    {
    if (options & 512) {
      {
      {
      tmp___1 = __errno_location();
      *tmp___1 = 22;
      }
      return ((FTS *)((void *)0));
      }
    }
    }
  }
  if (! (options & 18)) {
    {
    {
    tmp___2 = __errno_location();
    *tmp___2 = 22;
    }
    return ((FTS *)((void *)0));
    }
  }
  {
  tmp___3 = malloc(sizeof(FTS ));
  sp = (FTS *)tmp___3;
  }
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
    {
    return ((FTS *)((void *)0));
    }
  }
  {
  memset((void *)sp, 0, sizeof(FTS ));
  sp->fts_compar = compar;
  sp->fts_options = options;
  }
  if (sp->fts_options & 2) {
    {
    {
    sp->fts_options |= 4;
    sp->fts_options &= -513;
    }
    }
  }
  {
  sp->fts_cwd_fd = -100;
  tmp___6 = fts_maxarglen(argv);
  maxarglen = tmp___6;
  }
  if (maxarglen > 4096UL) {
    {
    {
    tmp___7 = maxarglen;
    }
    }
  } else {
    {
    {
    tmp___7 = (size_t )4096;
    }
    }
  }
  {
  tmp___8 = fts_palloc(sp, tmp___7);
  }
  if (! tmp___8) {
    {
    goto mem1;
    }
  }
  if ((unsigned long )*argv != (unsigned long )((void *)0)) {
    {
    {
    parent = fts_alloc(sp, (char const *)"", (size_t )0);
    }
    if ((unsigned long )parent == (unsigned long )((void *)0)) {
      {
      goto mem2;
      }
    }
    {
    parent->fts_level = (ptrdiff_t )-1;
    }
    }
  }
  if ((unsigned long )compar == (unsigned long )((void *)0)) {
    {
    {
    tmp___9 = 1;
    }
    }
  } else {
    {
    if (sp->fts_options & 1024) {
      {
      {
      tmp___9 = 1;
      }
      }
    } else {
      {
      {
      tmp___9 = 0;
      }
      }
    }
    }
  }
  {
  defer_stat = (_Bool )tmp___9;
  root = (FTSENT *)((void *)0);
  nitems = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )*argv != (unsigned long )((void *)0))) {
      {
      goto while_break;
      }
    }
    {
    tmp___10 = strlen((char const *)*argv);
    len = tmp___10;
    p = fts_alloc(sp, (char const *)*argv, len);
    }
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
      goto mem3;
      }
    }
    {
    p->fts_level = (ptrdiff_t )0;
    p->fts_parent = parent;
    p->fts_accpath = p->fts_name;
    }
    if (defer_stat) {
      {
      if ((unsigned long )root != (unsigned long )((void *)0)) {
        {
        {
        p->fts_info = (unsigned short)11;
        fts_set_stat_required(p, (_Bool)1);
        }
        }
      } else {
        {
        {
        p->fts_info = fts_stat(sp, p, (_Bool)0);
        }
        }
      }
      }
    } else {
      {
      {
      p->fts_info = fts_stat(sp, p, (_Bool)0);
      }
      }
    }
    if (compar) {
      {
      {
      p->fts_link = root;
      root = p;
      }
      }
    } else {
      {
      {
      p->fts_link = (struct _ftsent *)((void *)0);
      }
      if ((unsigned long )root == (unsigned long )((void *)0)) {
        {
        {
        root = p;
        tmp = root;
        }
        }
      } else {
        {
        {
        tmp->fts_link = p;
        tmp = p;
        }
        }
      }
      }
    }
    {
    argv ++;
    nitems ++;
    }
  }
  while_break: ;
  }
  if (compar) {
    {
    if (nitems > 1UL) {
      {
      {
      root = fts_sort(sp, root, nitems);
      }
      }
    }
    }
  }
  {
  tmp___11 = fts_alloc(sp, (char const *)"", (size_t )0);
  sp->fts_cur = tmp___11;
  }
  if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
    {
    goto mem3;
    }
  }
  {
  (sp->fts_cur)->fts_link = root;
  (sp->fts_cur)->fts_info = (unsigned short)9;
  tmp___12 = setup_dir(sp);
  }
  if (! tmp___12) {
    {
    goto mem3;
    }
  }
  if (! (sp->fts_options & 4)) {
    {
    if (! (sp->fts_options & 512)) {
      {
      {
      tmp___13 = diropen((FTS const *)sp, (char const *)".");
      sp->fts_rfd = tmp___13;
      }
      if (tmp___13 < 0) {
        {
        {
        sp->fts_options |= 4;
        }
        }
      }
      }
    }
    }
  }
  {
  i_ring_init(& sp->fts_fd_ring, -1);
  }
  return (sp);
  mem3:
  {
  fts_lfree(root);
  free((void *)parent);
  }
  mem2:
  {
  free((void *)sp->fts_path);
  }
  mem1:
  {
  free((void *)sp);
  }
  return ((FTS *)((void *)0));
}
}
static void fts_load(FTS *sp , FTSENT *p )
{
  register size_t len ;
  register char *cp ;
  size_t tmp ;
  char *tmp___0 ;
  {
  {
  tmp = p->fts_namelen;
  p->fts_pathlen = tmp;
  len = tmp;
  memmove((void *)sp->fts_path, (void const *)(p->fts_name), len + 1UL);
  cp = strrchr((char const *)(p->fts_name), '/');
  }
  if (cp) {
    {
    if ((unsigned long )cp != (unsigned long )(p->fts_name)) {
      {
      {
      cp ++;
      len = strlen((char const *)cp);
      memmove((void *)(p->fts_name), (void const *)cp, len + 1UL);
      p->fts_namelen = len;
      }
      }
    } else {
      {
      if (*(cp + 1)) {
        {
        {
        cp ++;
        len = strlen((char const *)cp);
        memmove((void *)(p->fts_name), (void const *)cp, len + 1UL);
        p->fts_namelen = len;
        }
        }
      }
      }
    }
    }
  }
  {
  tmp___0 = sp->fts_path;
  p->fts_path = tmp___0;
  p->fts_accpath = tmp___0;
  }
  return;
}
}
int ( __attribute__((__warn_unused_result__)) fts_close)(FTS *sp ) __attribute__((__nothrow__)) ;
int ( __attribute__((__warn_unused_result__)) fts_close)(FTS *sp )
{
  register FTSENT *freep ;
  register FTSENT *p ;
  int saved_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  {
  {
  saved_errno = 0;
  }
  if (sp->fts_cur) {
    {
    {
    p = sp->fts_cur;
    }
    {
    while (1) {
      while_continue: ;
      if (! (p->fts_level >= 0L)) {
        {
        goto while_break;
        }
      }
      {
      freep = p;
      }
      if ((unsigned long )p->fts_link != (unsigned long )((void *)0)) {
        {
        {
        p = p->fts_link;
        }
        }
      } else {
        {
        {
        p = p->fts_parent;
        }
        }
      }
      {
      free((void *)freep);
      }
    }
    while_break: ;
    }
    {
    free((void *)p);
    }
    }
  }
  if (sp->fts_child) {
    {
    {
    fts_lfree(sp->fts_child);
    }
    }
  }
  {
  free((void *)sp->fts_array);
  free((void *)sp->fts_path);
  }
  if (sp->fts_options & 512) {
    {
    if (0 <= sp->fts_cwd_fd) {
      {
      {
      tmp___0 = close(sp->fts_cwd_fd);
      }
      if (tmp___0) {
        {
        {
        tmp = __errno_location();
        saved_errno = *tmp;
        }
        }
      }
      }
    }
    }
  } else {
    {
    if (! (sp->fts_options & 4)) {
      {
      {
      tmp___2 = fchdir(sp->fts_rfd);
      }
      if (tmp___2) {
        {
        {
        tmp___1 = __errno_location();
        saved_errno = *tmp___1;
        }
        }
      }
      {
      tmp___4 = close(sp->fts_rfd);
      }
      if (tmp___4) {
        {
        if (saved_errno == 0) {
          {
          {
          tmp___3 = __errno_location();
          saved_errno = *tmp___3;
          }
          }
        }
        }
      }
      }
    }
    }
  }
  {
  fd_ring_clear(& sp->fts_fd_ring);
  }
  if (sp->fts_leaf_optimization_works_ht) {
    {
    {
    hash_free(sp->fts_leaf_optimization_works_ht);
    }
    }
  }
  {
  free_dir(sp);
  free((void *)sp);
  }
  if (saved_errno) {
    {
    {
    tmp___5 = __errno_location();
    *tmp___5 = saved_errno;
    }
    return (-1);
    }
  }
  return (0);
}
}
static _Bool dirent_inode_sort_may_be_useful(int dir_fd )
{
  struct statfs fs_buf ;
  int tmp ;
  {
  {
  tmp = fstatfs(dir_fd, & fs_buf);
  }
  if (tmp != 0) {
    {
    return ((_Bool)1);
    }
  }
  {
  if ((int )fs_buf.f_type == 26985) {
    {
    goto case_26985;
    }
  }
  if ((int )fs_buf.f_type == 16914836) {
    {
    goto case_26985;
    }
  }
  goto switch_default;
  case_26985:
  case_16914836:
  return ((_Bool)0);
  switch_default:
  return ((_Bool)1);
  switch_break: ;
  }
}
}
static _Bool leaf_optimization_applies(int dir_fd )
{
  struct statfs fs_buf ;
  int tmp ;
  {
  {
  tmp = fstatfs(dir_fd, & fs_buf);
  }
  if (tmp != 0) {
    {
    return ((_Bool)0);
    }
  }
  {
  if ((int )fs_buf.f_type == 1382369651) {
    {
    goto case_1382369651;
    }
  }
  goto switch_default;
  case_1382369651:
  return ((_Bool)1);
  switch_default:
  return ((_Bool)0);
  switch_break: ;
  }
}
}
static size_t LCO_hash(void const *x , size_t table_size )
{
  struct LCO_ent const *ax ;
  {
  {
  ax = (struct LCO_ent const *)x;
  }
  return ((uintmax_t )ax->st_dev % table_size);
}
}
static _Bool LCO_compare(void const *x , void const *y )
{
  struct LCO_ent const *ax ;
  struct LCO_ent const *ay ;
  {
  {
  ax = (struct LCO_ent const *)x;
  ay = (struct LCO_ent const *)y;
  }
  return ((_Bool )(ax->st_dev == ay->st_dev));
}
}
static _Bool link_count_optimize_ok(FTSENT const *p )
{
  FTS *sp ;
  Hash_table *h ;
  struct LCO_ent tmp ;
  struct LCO_ent *ent ;
  _Bool opt_ok ;
  struct LCO_ent *t2 ;
  struct hash_table *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  {
  {
  sp = (FTS *)p->fts_fts;
  h = sp->fts_leaf_optimization_works_ht;
  }
  if (! (sp->fts_options & 512)) {
    {
    return ((_Bool)0);
    }
  }
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
    {
    tmp___0 = hash_initialize((size_t )13, (Hash_tuning const *)((void *)0), & LCO_hash,
                              & LCO_compare, & free);
    sp->fts_leaf_optimization_works_ht = tmp___0;
    h = tmp___0;
    }
    if ((unsigned long )h == (unsigned long )((void *)0)) {
      {
      return ((_Bool)0);
      }
    }
    }
  }
  {
  tmp.st_dev = (dev_t )p->fts_statp[0].st_dev;
  tmp___1 = hash_lookup((Hash_table const *)h, (void const *)(& tmp));
  ent = (struct LCO_ent *)tmp___1;
  }
  if (ent) {
    {
    return (ent->opt_ok);
    }
  }
  {
  tmp___2 = malloc(sizeof(*t2));
  t2 = (struct LCO_ent *)tmp___2;
  }
  if ((unsigned long )t2 == (unsigned long )((void *)0)) {
    {
    return ((_Bool)0);
    }
  }
  {
  opt_ok = leaf_optimization_applies(sp->fts_cwd_fd);
  t2->opt_ok = opt_ok;
  t2->st_dev = (dev_t )p->fts_statp[0].st_dev;
  tmp___3 = hash_insert(h, (void const *)t2);
  ent = (struct LCO_ent *)tmp___3;
  }
  if ((unsigned long )ent == (unsigned long )((void *)0)) {
    {
    {
    free((void *)t2);
    }
    return ((_Bool)0);
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (! ((unsigned long )ent == (unsigned long )t2)) {
      {
      {
      abort();
      }
      }
    }
    goto while_break;
  }
  while_break: ;
  }
  return (opt_ok);
}
}
FTSENT *( __attribute__((__warn_unused_result__)) fts_read)(FTS *sp ) __attribute__((__nothrow__)) ;
FTSENT *( __attribute__((__warn_unused_result__)) fts_read)(FTS *sp )
{
  register FTSENT *p ;
  register FTSENT *tmp ;
  register unsigned short instr ;
  register char *t ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  struct _ftsent *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  FTSENT *parent ;
  _Bool tmp___14 ;
  int *tmp___15 ;
  _Bool tmp___16 ;
  int *tmp___17 ;
  struct _ftsent *tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int saved_errno ;
  int *tmp___25 ;
  int *tmp___26 ;
  int *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int *tmp___30 ;
  int tmp___31 ;
  FTSENT *tmp___32 ;
  {
  if ((unsigned long )sp->fts_cur == (unsigned long )((void *)0)) {
    {
    return ((FTSENT *)((void *)0));
    }
  } else {
    {
    if (sp->fts_options & 8192) {
      {
      return ((FTSENT *)((void *)0));
      }
    }
    }
  }
  {
  p = sp->fts_cur;
  instr = p->fts_instr;
  p->fts_instr = (unsigned short)3;
  }
  if ((int )instr == 1) {
    {
    {
    p->fts_info = fts_stat(sp, p, (_Bool)0);
    }
    return (p);
    }
  }
  if ((int )instr == 2) {
    {
    if ((int )p->fts_info == 12) {
      {
      goto _L;
      }
    } else {
      {
      if ((int )p->fts_info == 13) {
        {
        _L:
        {
        p->fts_info = fts_stat(sp, p, (_Bool)1);
        }
        if ((int )p->fts_info == 1) {
          {
          if (! (sp->fts_options & 4)) {
            {
            {
            tmp___1 = diropen((FTS const *)sp, (char const *)".");
            p->fts_symfd = tmp___1;
            }
            if (tmp___1 < 0) {
              {
              {
              tmp___0 = __errno_location();
              p->fts_errno = *tmp___0;
              p->fts_info = (unsigned short)7;
              }
              }
            } else {
              {
              {
              p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
              }
              }
            }
            }
          }
          }
        }
        goto check_for_dir;
        }
      }
      }
    }
    }
  }
  if ((int )p->fts_info == 1) {
    {
    if ((int )instr == 4) {
      {
      goto _L___0;
      }
    } else {
      {
      if (sp->fts_options & 64) {
        {
        if (p->fts_statp[0].st_dev != sp->fts_dev) {
          {
          _L___0:
          if ((int )p->fts_flags & 2) {
            {
            {
            close(p->fts_symfd);
            }
            }
          }
          if (sp->fts_child) {
            {
            {
            fts_lfree(sp->fts_child);
            sp->fts_child = (struct _ftsent *)((void *)0);
            }
            }
          }
          {
          p->fts_info = (unsigned short)6;
          }
          {
          while (1) {
            while_continue: ;
            if (! 1) {
              {
              goto while_break;
              }
            }
            {
            leave_dir(sp, p);
            }
            goto while_break;
          }
          while_break: ;
          }
          return (p);
          }
        }
        }
      }
      }
    }
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
      {
      if (sp->fts_options & 4096) {
        {
        {
        sp->fts_options &= -4097;
        fts_lfree(sp->fts_child);
        sp->fts_child = (struct _ftsent *)((void *)0);
        }
        }
      }
      }
    }
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
      {
      {
      tmp___3 = fts_safe_changedir(sp, p, -1, (char const *)p->fts_accpath);
      }
      if (tmp___3) {
        {
        {
        tmp___2 = __errno_location();
        p->fts_errno = *tmp___2;
        p->fts_flags = (unsigned short )((int )p->fts_flags | 1);
        p = sp->fts_child;
        }
        {
        while (1) {
          while_continue___0: ;
          if (! ((unsigned long )p != (unsigned long )((void *)0))) {
            {
            goto while_break___0;
            }
          }
          {
          p->fts_accpath = (p->fts_parent)->fts_accpath;
          p = p->fts_link;
          }
        }
        while_break___0: ;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___4 = fts_build(sp, 3);
      sp->fts_child = tmp___4;
      }
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
        {
        if (sp->fts_options & 8192) {
          {
          return ((FTSENT *)((void *)0));
          }
        }
        if (p->fts_errno) {
          {
          if ((int )p->fts_info != 4) {
            {
            {
            p->fts_info = (unsigned short)7;
            }
            }
          }
          }
        }
        {
        while (1) {
          while_continue___1: ;
          if (! 1) {
            {
            goto while_break___1;
            }
          }
          {
          leave_dir(sp, p);
          }
          goto while_break___1;
        }
        while_break___1: ;
        }
        return (p);
        }
      }
      }
    }
    {
    p = sp->fts_child;
    sp->fts_child = (struct _ftsent *)((void *)0);
    }
    goto name;
    }
  }
  next:
  {
  tmp = p;
  }
  if ((unsigned long )p->fts_link == (unsigned long )((void *)0)) {
    {
    if ((p->fts_parent)->fts_dirp) {
      {
      {
      p = tmp->fts_parent;
      sp->fts_cur = p;
      *(sp->fts_path + p->fts_pathlen) = (char )'\000';
      p = fts_build(sp, 3);
      }
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        {
        if (sp->fts_options & 8192) {
          {
          return ((FTSENT *)((void *)0));
          }
        }
        goto cd_dot_dot;
        }
      }
      {
      free((void *)tmp);
      }
      goto name;
      }
    }
    }
  }
  {
  p = p->fts_link;
  }
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
    {
    sp->fts_cur = p;
    free((void *)tmp);
    }
    if (p->fts_level == 0L) {
      {
      {
      fd_ring_clear(& sp->fts_fd_ring);
      }
      if (! (sp->fts_options & 4)) {
        {
        if (sp->fts_options & 512) {
          {
          if (sp->fts_options & 512) {
            {
            {
            tmp___5 = -100;
            }
            }
          } else {
            {
            {
            tmp___5 = sp->fts_rfd;
            }
            }
          }
          {
          cwd_advance_fd(sp, tmp___5, (_Bool)1);
          tmp___8 = 0;
          }
          }
        } else {
          {
          if (sp->fts_options & 512) {
            {
            {
            tmp___6 = -100;
            }
            }
          } else {
            {
            {
            tmp___6 = sp->fts_rfd;
            }
            }
          }
          {
          tmp___7 = fchdir(tmp___6);
          tmp___8 = tmp___7;
          }
          }
        }
        if (tmp___8) {
          {
          {
          tmp___9 = 1;
          }
          }
        } else {
          {
          {
          tmp___9 = 0;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___9 = 0;
        }
        }
      }
      if (tmp___9) {
        {
        {
        sp->fts_options |= 8192;
        }
        return ((FTSENT *)((void *)0));
        }
      }
      {
      free_dir(sp);
      fts_load(sp, p);
      setup_dir(sp);
      }
      goto check_for_dir;
      }
    }
    if ((int )p->fts_instr == 4) {
      {
      goto next;
      }
    }
    if ((int )p->fts_instr == 2) {
      {
      {
      p->fts_info = fts_stat(sp, p, (_Bool)1);
      }
      if ((int )p->fts_info == 1) {
        {
        if (! (sp->fts_options & 4)) {
          {
          {
          tmp___11 = diropen((FTS const *)sp, (char const *)".");
          p->fts_symfd = tmp___11;
          }
          if (tmp___11 < 0) {
            {
            {
            tmp___10 = __errno_location();
            p->fts_errno = *tmp___10;
            p->fts_info = (unsigned short)7;
            }
            }
          } else {
            {
            {
            p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
            }
            }
          }
          }
        }
        }
      }
      {
      p->fts_instr = (unsigned short)3;
      }
      }
    }
    name:
    if ((int )*((p->fts_parent)->fts_path + ((p->fts_parent)->fts_pathlen - 1UL)) == 47) {
      {
      {
      tmp___12 = (p->fts_parent)->fts_pathlen - 1UL;
      }
      }
    } else {
      {
      {
      tmp___12 = (p->fts_parent)->fts_pathlen;
      }
      }
    }
    {
    t = sp->fts_path + tmp___12;
    tmp___13 = t;
    t ++;
    *tmp___13 = (char )'/';
    memmove((void *)t, (void const *)(p->fts_name), p->fts_namelen + 1UL);
    }
    check_for_dir:
    {
    sp->fts_cur = p;
    }
    if ((int )p->fts_info == 11) {
      {
      if (p->fts_statp[0].st_size == 2L) {
        {
        {
        parent = p->fts_parent;
        }
        if (0L < p->fts_level) {
          {
          if (parent->fts_n_dirs_remaining == 0UL) {
            {
            if (sp->fts_options & 8) {
              {
              if (sp->fts_options & 16) {
                {
                {
                tmp___14 = link_count_optimize_ok((FTSENT const *)parent);
                }
                if (! tmp___14) {
                  {
                  goto _L___4;
                  }
                }
                }
              } else {
                {
                goto _L___4;
                }
              }
              }
            } else {
              {
              goto _L___4;
              }
            }
            }
          } else {
            {
            goto _L___4;
            }
          }
          }
        } else {
          {
          _L___4:
          {
          p->fts_info = fts_stat(sp, p, (_Bool)0);
          }
          if ((p->fts_statp[0].st_mode & 61440U) == 16384U) {
            {
            if (p->fts_level != 0L) {
              {
              if (parent->fts_n_dirs_remaining) {
                {
                {
                (parent->fts_n_dirs_remaining) --;
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      } else {
        {
        {
        while (1) {
          while_continue___2: ;
          if (! 1) {
            {
            goto while_break___2;
            }
          }
          if (! (p->fts_statp[0].st_size == 1L)) {
            {
            {
            abort();
            }
            }
          }
          goto while_break___2;
        }
        while_break___2: ;
        }
        }
      }
      }
    }
    if ((int )p->fts_info == 1) {
      {
      if (p->fts_level == 0L) {
        {
        {
        sp->fts_dev = p->fts_statp[0].st_dev;
        }
        }
      }
      {
      tmp___16 = enter_dir(sp, p);
      }
      if (! tmp___16) {
        {
        {
        tmp___15 = __errno_location();
        *tmp___15 = 12;
        }
        return ((FTSENT *)((void *)0));
        }
      }
      }
    }
    return (p);
    }
  }
  cd_dot_dot:
  {
  p = tmp->fts_parent;
  sp->fts_cur = p;
  free((void *)tmp);
  }
  if (p->fts_level == -1L) {
    {
    {
    free((void *)p);
    tmp___17 = __errno_location();
    *tmp___17 = 0;
    tmp___18 = (struct _ftsent *)((void *)0);
    sp->fts_cur = tmp___18;
    }
    return (tmp___18);
    }
  }
  {
  while (1) {
    while_continue___3: ;
    if (! 1) {
      {
      goto while_break___3;
      }
    }
    if (! ((int )p->fts_info != 11)) {
      {
      {
      abort();
      }
      }
    }
    goto while_break___3;
  }
  while_break___3: ;
  }
  {
  *(sp->fts_path + p->fts_pathlen) = (char )'\000';
  }
  if (p->fts_level == 0L) {
    {
    {
    fd_ring_clear(& sp->fts_fd_ring);
    }
    if (! (sp->fts_options & 4)) {
      {
      if (sp->fts_options & 512) {
        {
        if (sp->fts_options & 512) {
          {
          {
          tmp___20 = -100;
          }
          }
        } else {
          {
          {
          tmp___20 = sp->fts_rfd;
          }
          }
        }
        {
        cwd_advance_fd(sp, tmp___20, (_Bool)1);
        tmp___23 = 0;
        }
        }
      } else {
        {
        if (sp->fts_options & 512) {
          {
          {
          tmp___21 = -100;
          }
          }
        } else {
          {
          {
          tmp___21 = sp->fts_rfd;
          }
          }
        }
        {
        tmp___22 = fchdir(tmp___21);
        tmp___23 = tmp___22;
        }
        }
      }
      if (tmp___23) {
        {
        {
        tmp___24 = 1;
        }
        }
      } else {
        {
        {
        tmp___24 = 0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___24 = 0;
      }
      }
    }
    if (tmp___24) {
      {
      {
      tmp___19 = __errno_location();
      p->fts_errno = *tmp___19;
      sp->fts_options |= 8192;
      }
      }
    }
    }
  } else {
    {
    if ((int )p->fts_flags & 2) {
      {
      if (! (sp->fts_options & 4)) {
        {
        if (sp->fts_options & 512) {
          {
          {
          cwd_advance_fd(sp, p->fts_symfd, (_Bool)1);
          tmp___29 = 0;
          }
          }
        } else {
          {
          {
          tmp___28 = fchdir(p->fts_symfd);
          tmp___29 = tmp___28;
          }
          }
        }
        if (tmp___29) {
          {
          {
          tmp___25 = __errno_location();
          saved_errno = *tmp___25;
          close(p->fts_symfd);
          tmp___26 = __errno_location();
          *tmp___26 = saved_errno;
          tmp___27 = __errno_location();
          p->fts_errno = *tmp___27;
          sp->fts_options |= 8192;
          }
          }
        }
        }
      }
      {
      close(p->fts_symfd);
      }
      }
    } else {
      {
      if (! ((int )p->fts_flags & 1)) {
        {
        {
        tmp___31 = fts_safe_changedir(sp, p->fts_parent, -1, (char const *)"..");
        }
        if (tmp___31) {
          {
          {
          tmp___30 = __errno_location();
          p->fts_errno = *tmp___30;
          sp->fts_options |= 8192;
          }
          }
        }
        }
      }
      }
    }
    }
  }
  if (p->fts_errno) {
    {
    {
    p->fts_info = (unsigned short)7;
    }
    }
  } else {
    {
    {
    p->fts_info = (unsigned short)6;
    }
    }
  }
  if (p->fts_errno == 0) {
    {
    {
    while (1) {
      while_continue___4: ;
      if (! 1) {
        {
        goto while_break___4;
        }
      }
      {
      leave_dir(sp, p);
      }
      goto while_break___4;
    }
    while_break___4: ;
    }
    }
  }
  if (sp->fts_options & 8192) {
    {
    {
    tmp___32 = (FTSENT *)((void *)0);
    }
    }
  } else {
    {
    {
    tmp___32 = p;
    }
    }
  }
  return (tmp___32);
}
}
int fts_set(FTS *sp __attribute__((__unused__)) , FTSENT *p , int instr ) __attribute__((__nothrow__)) ;
int fts_set(FTS *sp __attribute__((__unused__)) , FTSENT *p , int instr )
{
  int *tmp ;
  {
  if (instr != 0) {
    {
    if (instr != 1) {
      {
      if (instr != 2) {
        {
        if (instr != 3) {
          {
          if (instr != 4) {
            {
            {
            tmp = __errno_location();
            *tmp = 22;
            }
            return (1);
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  {
  p->fts_instr = (unsigned short )instr;
  }
  return (0);
}
}
FTSENT *( __attribute__((__warn_unused_result__)) fts_children)(FTS *sp , int instr ) __attribute__((__nothrow__)) ;
FTSENT *( __attribute__((__warn_unused_result__)) fts_children)(FTS *sp , int instr )
{
  register FTSENT *p ;
  int fd ;
  int *tmp ;
  int *tmp___0 ;
  struct _ftsent *tmp___1 ;
  struct _ftsent *tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  {
  if (instr != 0) {
    {
    if (instr != 4096) {
      {
      {
      tmp = __errno_location();
      *tmp = 22;
      }
      return ((FTSENT *)((void *)0));
      }
    }
    }
  }
  {
  p = sp->fts_cur;
  tmp___0 = __errno_location();
  *tmp___0 = 0;
  }
  if (sp->fts_options & 8192) {
    {
    return ((FTSENT *)((void *)0));
    }
  }
  if ((int )p->fts_info == 9) {
    {
    return (p->fts_link);
    }
  }
  if ((int )p->fts_info != 1) {
    {
    return ((FTSENT *)((void *)0));
    }
  }
  if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
    {
    {
    fts_lfree(sp->fts_child);
    }
    }
  }
  if (instr == 4096) {
    {
    {
    sp->fts_options |= 4096;
    instr = 2;
    }
    }
  } else {
    {
    {
    instr = 1;
    }
    }
  }
  if (p->fts_level != 0L) {
    {
    {
    tmp___1 = fts_build(sp, instr);
    sp->fts_child = tmp___1;
    }
    return (tmp___1);
    }
  } else {
    {
    if ((int )*(p->fts_accpath + 0) == 47) {
      {
      {
      tmp___1 = fts_build(sp, instr);
      sp->fts_child = tmp___1;
      }
      return (tmp___1);
      }
    } else {
      {
      if (sp->fts_options & 4) {
        {
        {
        tmp___1 = fts_build(sp, instr);
        sp->fts_child = tmp___1;
        }
        return (tmp___1);
        }
      }
      }
    }
    }
  }
  {
  fd = diropen((FTS const *)sp, (char const *)".");
  }
  if (fd < 0) {
    {
    {
    tmp___2 = (struct _ftsent *)((void *)0);
    sp->fts_child = tmp___2;
    }
    return (tmp___2);
    }
  }
  {
  sp->fts_child = fts_build(sp, instr);
  }
  if (sp->fts_options & 512) {
    {
    {
    cwd_advance_fd(sp, fd, (_Bool)1);
    }
    }
  } else {
    {
    {
    tmp___5 = fchdir(fd);
    }
    if (tmp___5) {
      {
      {
      tmp___3 = __errno_location();
      saved_errno = *tmp___3;
      close(fd);
      tmp___4 = __errno_location();
      *tmp___4 = saved_errno;
      }
      return ((FTSENT *)((void *)0));
      }
    }
    {
    close(fd);
    }
    }
  }
  return (sp->fts_child);
}
}
static int fts_compare_ino(struct _ftsent const **a , struct _ftsent const **b )
{
  int tmp ;
  int tmp___0 ;
  {
  if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
    {
    {
    tmp___0 = -1;
    }
    }
  } else {
    {
    if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    {
    tmp___0 = tmp;
    }
    }
  }
  return (tmp___0);
}
}
static void set_stat_type(struct stat *st , unsigned int dtype )
{
  mode_t type ;
  {
  {
  if ((int )dtype == 6) {
    {
    goto case_6;
    }
  }
  if ((int )dtype == 2) {
    {
    goto case_2;
    }
  }
  if ((int )dtype == 4) {
    {
    goto case_4;
    }
  }
  if ((int )dtype == 1) {
    {
    goto case_1;
    }
  }
  if ((int )dtype == 10) {
    {
    goto case_10;
    }
  }
  if ((int )dtype == 8) {
    {
    goto case_8;
    }
  }
  if ((int )dtype == 12) {
    {
    goto case_12;
    }
  }
  goto switch_default;
  case_6:
  {
  type = (mode_t )24576;
  }
  goto switch_break;
  case_2:
  {
  type = (mode_t )8192;
  }
  goto switch_break;
  case_4:
  {
  type = (mode_t )16384;
  }
  goto switch_break;
  case_1:
  {
  type = (mode_t )4096;
  }
  goto switch_break;
  case_10:
  {
  type = (mode_t )40960;
  }
  goto switch_break;
  case_8:
  {
  type = (mode_t )32768;
  }
  goto switch_break;
  case_12:
  {
  type = (mode_t )49152;
  }
  goto switch_break;
  switch_default:
  {
  type = (mode_t )0;
  }
  switch_break: ;
  }
  {
  st->st_mode = type;
  }
  return;
}
}
static FTSENT *fts_build(FTS *sp , int type )
{
  register FTSENT *p ;
  register FTSENT *head ;
  register size_t nitems ;
  FTSENT *tail ;
  void *oldaddr ;
  int saved_errno ;
  _Bool descend ;
  _Bool doadjust ;
  ptrdiff_t level ;
  nlink_t nlinks ;
  _Bool nostat ;
  size_t len ;
  size_t maxlen ;
  size_t new_len ;
  char *cp ;
  int dir_fd ;
  FTSENT *cur ;
  _Bool continue_readdir ;
  DIR *dp ;
  int *tmp ;
  int *tmp___0 ;
  DIR *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  _Bool tmp___6 ;
  size_t max_entries ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  _Bool is_dir ;
  struct dirent *dp___0 ;
  struct dirent *tmp___12 ;
  size_t tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  size_t tmp___16 ;
  _Bool tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  int *tmp___20 ;
  _Bool skip_stat ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  _Bool tmp___31 ;
  {
  {
  cur = sp->fts_cur;
  continue_readdir = (_Bool )(! (! cur->fts_dirp));
  }
  if (continue_readdir) {
    {
    {
    dp = cur->fts_dirp;
    dir_fd = dirfd(dp);
    }
    if (dir_fd < 0) {
      {
      {
      while (1) {
        while_continue: ;
        if (! 1) {
          {
          goto while_break;
          }
        }
        {
        closedir(cur->fts_dirp);
        cur->fts_dirp = (DIR *)((void *)0);
        }
        goto while_break;
      }
      while_break: ;
      }
      if (type == 3) {
        {
        {
        cur->fts_info = (unsigned short)4;
        tmp = __errno_location();
        cur->fts_errno = *tmp;
        }
        }
      }
      return ((FTSENT *)((void *)0));
      }
    }
    }
  } else {
    {
    if (sp->fts_options & 16) {
      {
      if (sp->fts_options & 1) {
        {
        if (cur->fts_level == 0L) {
          {
          {
          tmp___2 = 0;
          }
          }
        } else {
          {
          {
          tmp___2 = 131072;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___2 = 131072;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___2 = 0;
      }
      }
    }
    if (sp->fts_options & 2048) {
      {
      {
      tmp___3 = 262144;
      }
      }
    } else {
      {
      {
      tmp___3 = 0;
      }
      }
    }
    if (! (sp->fts_options & 4)) {
      {
      if (sp->fts_options & 512) {
        {
        {
        tmp___4 = sp->fts_cwd_fd;
        }
        }
      } else {
        {
        {
        tmp___4 = -100;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___4 = -100;
      }
      }
    }
    {
    tmp___1 = opendirat(tmp___4, (char const *)cur->fts_accpath, tmp___2 | tmp___3,
                        & dir_fd);
    cur->fts_dirp = tmp___1;
    }
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
      if (type == 3) {
        {
        {
        cur->fts_info = (unsigned short)4;
        tmp___0 = __errno_location();
        cur->fts_errno = *tmp___0;
        }
        }
      }
      return ((FTSENT *)((void *)0));
      }
    }
    if ((int )cur->fts_info == 11) {
      {
      {
      cur->fts_info = fts_stat(sp, cur, (_Bool)0);
      }
      }
    } else {
      {
      if (sp->fts_options & 256) {
        {
        {
        while (1) {
          while_continue___0: ;
          if (! 1) {
            {
            goto while_break___0;
            }
          }
          {
          leave_dir(sp, cur);
          }
          goto while_break___0;
        }
        while_break___0: ;
        }
        {
        fts_stat(sp, cur, (_Bool)0);
        tmp___6 = enter_dir(sp, cur);
        }
        if (! tmp___6) {
          {
          {
          tmp___5 = __errno_location();
          *tmp___5 = 12;
          }
          return ((FTSENT *)((void *)0));
          }
        }
        }
      }
      }
    }
    }
  }
  if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
    {
    {
    tmp___7 = 100000UL;
    }
    }
  } else {
    {
    {
    tmp___7 = 0xffffffffffffffffUL;
    }
    }
  }
  {
  max_entries = tmp___7;
  }
  if (type == 2) {
    {
    {
    nlinks = (nlink_t )0;
    nostat = (_Bool)0;
    }
    }
  } else {
    {
    if (sp->fts_options & 8) {
      {
      if (sp->fts_options & 16) {
        {
        if (sp->fts_options & 32) {
          {
          {
          tmp___8 = 0;
          }
          }
        } else {
          {
          {
          tmp___8 = 2;
          }
          }
        }
        {
        nlinks = cur->fts_statp[0].st_nlink - (__nlink_t )tmp___8;
        nostat = (_Bool)1;
        }
        }
      } else {
        {
        {
        nlinks = (nlink_t )-1;
        nostat = (_Bool)0;
        }
        }
      }
      }
    } else {
      {
      {
      nlinks = (nlink_t )-1;
      nostat = (_Bool)0;
      }
      }
    }
    }
  }
  if (continue_readdir) {
    {
    {
    descend = (_Bool)1;
    }
    }
  } else {
    {
    if (nlinks) {
      {
      goto _L___0;
      }
    } else {
      {
      if (type == 3) {
        {
        _L___0:
        if (sp->fts_options & 512) {
          {
          {
          dir_fd = dup_safer(dir_fd);
          }
          if (0 <= dir_fd) {
            {
            {
            set_cloexec_flag(dir_fd, (_Bool)1);
            }
            }
          }
          }
        }
        if (dir_fd < 0) {
          {
          goto _L;
          }
        } else {
          {
          {
          tmp___10 = fts_safe_changedir(sp, cur, dir_fd, (char const *)((void *)0));
          }
          if (tmp___10) {
            {
            _L:
            if (nlinks) {
              {
              if (type == 3) {
                {
                {
                tmp___9 = __errno_location();
                cur->fts_errno = *tmp___9;
                }
                }
              }
              }
            }
            {
            cur->fts_flags = (unsigned short )((int )cur->fts_flags | 1);
            descend = (_Bool)0;
            }
            {
            while (1) {
              while_continue___1: ;
              if (! 1) {
                {
                goto while_break___1;
                }
              }
              {
              closedir(cur->fts_dirp);
              cur->fts_dirp = (DIR *)((void *)0);
              }
              goto while_break___1;
            }
            while_break___1: ;
            }
            if (sp->fts_options & 512) {
              {
              if (0 <= dir_fd) {
                {
                {
                close(dir_fd);
                }
                }
              }
              }
            }
            {
            cur->fts_dirp = (DIR *)((void *)0);
            }
            }
          } else {
            {
            {
            descend = (_Bool)1;
            }
            }
          }
          }
        }
        }
      } else {
        {
        {
        descend = (_Bool)0;
        }
        }
      }
      }
    }
    }
  }
  if ((int )*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
    {
    {
    len = cur->fts_pathlen - 1UL;
    }
    }
  } else {
    {
    {
    len = cur->fts_pathlen;
    }
    }
  }
  if (sp->fts_options & 4) {
    {
    {
    cp = sp->fts_path + len;
    tmp___11 = cp;
    cp ++;
    *tmp___11 = (char )'/';
    }
    }
  } else {
    {
    {
    cp = (char *)((void *)0);
    }
    }
  }
  {
  len ++;
  maxlen = sp->fts_pathlen - len;
  level = cur->fts_level + 1L;
  doadjust = (_Bool)0;
  head = (FTSENT *)((void *)0);
  tail = (FTSENT *)((void *)0);
  nitems = (size_t )0;
  }
  {
  while (1) {
    while_continue___2: ;
    if (! cur->fts_dirp) {
      {
      goto while_break___2;
      }
    }
    {
    tmp___12 = readdir(cur->fts_dirp);
    dp___0 = tmp___12;
    }
    if ((unsigned long )dp___0 == (unsigned long )((void *)0)) {
      {
      goto while_break___2;
      }
    }
    if (! (sp->fts_options & 32)) {
      {
      if ((int )dp___0->d_name[0] == 46) {
        {
        if (! dp___0->d_name[1]) {
          {
          goto while_continue___2;
          }
        } else {
          {
          if ((int )dp___0->d_name[1] == 46) {
            {
            if (! dp___0->d_name[2]) {
              {
              goto while_continue___2;
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    {
    tmp___13 = strlen((char const *)(dp___0->d_name));
    p = fts_alloc(sp, (char const *)(dp___0->d_name), tmp___13);
    }
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
      goto mem1;
      }
    }
    {
    tmp___18 = strlen((char const *)(dp___0->d_name));
    }
    if (tmp___18 >= maxlen) {
      {
      {
      oldaddr = (void *)sp->fts_path;
      tmp___16 = strlen((char const *)(dp___0->d_name));
      tmp___17 = fts_palloc(sp, (tmp___16 + len) + 1UL);
      }
      if (! tmp___17) {
        {
        mem1:
        {
        tmp___14 = __errno_location();
        saved_errno = *tmp___14;
        free((void *)p);
        fts_lfree(head);
        }
        {
        while (1) {
          while_continue___3: ;
          if (! 1) {
            {
            goto while_break___3;
            }
          }
          {
          closedir(cur->fts_dirp);
          cur->fts_dirp = (DIR *)((void *)0);
          }
          goto while_break___3;
        }
        while_break___3: ;
        }
        {
        cur->fts_info = (unsigned short)7;
        sp->fts_options |= 8192;
        tmp___15 = __errno_location();
        *tmp___15 = saved_errno;
        }
        return ((FTSENT *)((void *)0));
        }
      }
      if ((unsigned long )oldaddr != (unsigned long )sp->fts_path) {
        {
        {
        doadjust = (_Bool)1;
        }
        if (sp->fts_options & 4) {
          {
          {
          cp = sp->fts_path + len;
          }
          }
        }
        }
      }
      {
      maxlen = sp->fts_pathlen - len;
      }
      }
    }
    {
    tmp___19 = strlen((char const *)(dp___0->d_name));
    new_len = len + tmp___19;
    }
    if (new_len < len) {
      {
      {
      free((void *)p);
      fts_lfree(head);
      }
      {
      while (1) {
        while_continue___4: ;
        if (! 1) {
          {
          goto while_break___4;
          }
        }
        {
        closedir(cur->fts_dirp);
        cur->fts_dirp = (DIR *)((void *)0);
        }
        goto while_break___4;
      }
      while_break___4: ;
      }
      {
      cur->fts_info = (unsigned short)7;
      sp->fts_options |= 8192;
      tmp___20 = __errno_location();
      *tmp___20 = 36;
      }
      return ((FTSENT *)((void *)0));
      }
    }
    {
    p->fts_level = level;
    p->fts_parent = sp->fts_cur;
    p->fts_pathlen = new_len;
    p->fts_statp[0].st_ino = dp___0->d_ino;
    }
    if (sp->fts_options & 4) {
      {
      {
      p->fts_accpath = p->fts_path;
      memmove((void *)cp, (void const *)(p->fts_name), p->fts_namelen + 1UL);
      }
      }
    } else {
      {
      {
      p->fts_accpath = p->fts_name;
      }
      }
    }
    if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
      {
      goto _L___1;
      }
    } else {
      {
      if (sp->fts_options & 1024) {
        {
        _L___1:
        if (sp->fts_options & 16) {
          {
          if (sp->fts_options & 8) {
            {
            if ((int )dp___0->d_type != 0) {
              {
              if (! ((int )dp___0->d_type == 4)) {
                {
                {
                tmp___21 = 1;
                }
                }
              } else {
                {
                {
                tmp___21 = 0;
                }
                }
              }
              }
            } else {
              {
              {
              tmp___21 = 0;
              }
              }
            }
            }
          } else {
            {
            {
            tmp___21 = 0;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___21 = 0;
          }
          }
        }
        {
        skip_stat = (_Bool )tmp___21;
        p->fts_info = (unsigned short)11;
        set_stat_type(p->fts_statp, (unsigned int )dp___0->d_type);
        fts_set_stat_required(p, (_Bool )(! skip_stat));
        }
        if (sp->fts_options & 16) {
          {
          if ((int )dp___0->d_type == 4) {
            {
            {
            tmp___22 = 1;
            }
            }
          } else {
            {
            {
            tmp___22 = 0;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___22 = 0;
          }
          }
        }
        {
        is_dir = (_Bool )tmp___22;
        }
        }
      } else {
        {
        {
        p->fts_info = fts_stat(sp, p, (_Bool)0);
        }
        if ((int )p->fts_info == 1) {
          {
          {
          tmp___23 = 1;
          }
          }
        } else {
          {
          if ((int )p->fts_info == 2) {
            {
            {
            tmp___23 = 1;
            }
            }
          } else {
            {
            if ((int )p->fts_info == 5) {
              {
              {
              tmp___23 = 1;
              }
              }
            } else {
              {
              {
              tmp___23 = 0;
              }
              }
            }
            }
          }
          }
        }
        {
        is_dir = (_Bool )tmp___23;
        }
        }
      }
      }
    }
    if (nlinks > 0UL) {
      {
      if (is_dir) {
        {
        {
        nlinks -= (nlink_t )nostat;
        }
        }
      }
      }
    }
    {
    p->fts_link = (struct _ftsent *)((void *)0);
    }
    if ((unsigned long )head == (unsigned long )((void *)0)) {
      {
      {
      tail = p;
      head = tail;
      }
      }
    } else {
      {
      {
      tail->fts_link = p;
      tail = p;
      }
      }
    }
    {
    nitems ++;
    }
    if (max_entries <= nitems) {
      {
      goto break_without_closedir;
      }
    }
  }
  while_break___2: ;
  }
  if (cur->fts_dirp) {
    {
    {
    while (1) {
      while_continue___5: ;
      if (! 1) {
        {
        goto while_break___5;
        }
      }
      {
      closedir(cur->fts_dirp);
      cur->fts_dirp = (DIR *)((void *)0);
      }
      goto while_break___5;
    }
    while_break___5: ;
    }
    }
  }
  break_without_closedir:
  if (doadjust) {
    {
    {
    fts_padjust(sp, head);
    }
    }
  }
  if (sp->fts_options & 4) {
    {
    if (len == sp->fts_pathlen) {
      {
      {
      cp --;
      }
      }
    } else {
      {
      if (nitems == 0UL) {
        {
        {
        cp --;
        }
        }
      }
      }
    }
    {
    *cp = (char )'\000';
    }
    }
  }
  if (! continue_readdir) {
    {
    if (descend) {
      {
      if (type == 1) {
        {
        goto _L___2;
        }
      } else {
        {
        if (! nitems) {
          {
          _L___2:
          if (cur->fts_level == 0L) {
            {
            {
            fd_ring_clear(& sp->fts_fd_ring);
            }
            if (! (sp->fts_options & 4)) {
              {
              if (sp->fts_options & 512) {
                {
                if (sp->fts_options & 512) {
                  {
                  {
                  tmp___24 = -100;
                  }
                  }
                } else {
                  {
                  {
                  tmp___24 = sp->fts_rfd;
                  }
                  }
                }
                {
                cwd_advance_fd(sp, tmp___24, (_Bool)1);
                tmp___27 = 0;
                }
                }
              } else {
                {
                if (sp->fts_options & 512) {
                  {
                  {
                  tmp___25 = -100;
                  }
                  }
                } else {
                  {
                  {
                  tmp___25 = sp->fts_rfd;
                  }
                  }
                }
                {
                tmp___26 = fchdir(tmp___25);
                tmp___27 = tmp___26;
                }
                }
              }
              if (tmp___27) {
                {
                {
                tmp___28 = 1;
                }
                }
              } else {
                {
                {
                tmp___28 = 0;
                }
                }
              }
              }
            } else {
              {
              {
              tmp___28 = 0;
              }
              }
            }
            {
            tmp___30 = tmp___28;
            }
            }
          } else {
            {
            {
            tmp___29 = fts_safe_changedir(sp, cur->fts_parent, -1, (char const *)"..");
            tmp___30 = tmp___29;
            }
            }
          }
          if (tmp___30) {
            {
            {
            cur->fts_info = (unsigned short)7;
            sp->fts_options |= 8192;
            fts_lfree(head);
            }
            return ((FTSENT *)((void *)0));
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  if (! nitems) {
    {
    if (type == 3) {
      {
      {
      cur->fts_info = (unsigned short)6;
      }
      }
    }
    {
    fts_lfree(head);
    }
    return ((FTSENT *)((void *)0));
    }
  }
  if (nitems > 10000UL) {
    {
    if (! sp->fts_compar) {
      {
      if (sp->fts_options & 512) {
        {
        {
        tmp___31 = dirent_inode_sort_may_be_useful(sp->fts_cwd_fd);
        }
        if (tmp___31) {
          {
          {
          sp->fts_compar = & fts_compare_ino;
          head = fts_sort(sp, head, nitems);
          sp->fts_compar = (int (*)(struct _ftsent const ** , struct _ftsent const ** ))((void *)0);
          }
          }
        }
        }
      }
      }
    }
    }
  }
  if (sp->fts_compar) {
    {
    if (nitems > 1UL) {
      {
      {
      head = fts_sort(sp, head, nitems);
      }
      }
    }
    }
  }
  return (head);
}
}
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow )
{
  struct stat *sbp ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  {
  {
  sbp = p->fts_statp;
  }
  if (p->fts_level == 0L) {
    {
    if (sp->fts_options & 1) {
      {
      {
      follow = (_Bool)1;
      }
      }
    }
    }
  }
  if (sp->fts_options & 2) {
    {
    goto _L;
    }
  } else {
    {
    if (follow) {
      {
      _L:
      {
      tmp___3 = stat((char const *)((char const * __restrict )p->fts_accpath),
                     (struct stat *)((struct stat * __restrict )sbp));
      }
      if (tmp___3) {
        {
        {
        tmp = __errno_location();
        saved_errno = *tmp;
        tmp___1 = __errno_location();
        }
        if (*tmp___1 == 2) {
          {
          {
          tmp___2 = lstat((char const *)((char const * __restrict )p->fts_accpath),
                          (struct stat *)((struct stat * __restrict )sbp));
          }
          if (tmp___2 == 0) {
            {
            {
            tmp___0 = __errno_location();
            *tmp___0 = 0;
            }
            return ((unsigned short)13);
            }
          }
          }
        }
        {
        p->fts_errno = saved_errno;
        }
        goto err;
        }
      }
      }
    } else {
      {
      {
      tmp___5 = fstatat(sp->fts_cwd_fd, (char const *)((char const * __restrict )p->fts_accpath),
                        (struct stat *)((struct stat * __restrict )sbp), 256);
      }
      if (tmp___5) {
        {
        {
        tmp___4 = __errno_location();
        p->fts_errno = *tmp___4;
        }
        err:
        {
        memset((void *)sbp, 0, sizeof(struct stat ));
        }
        return ((unsigned short)10);
        }
      }
      }
    }
    }
  }
  if ((sbp->st_mode & 61440U) == 16384U) {
    {
    if (sp->fts_options & 32) {
      {
      {
      tmp___6 = 0;
      }
      }
    } else {
      {
      {
      tmp___6 = 2;
      }
      }
    }
    {
    p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t )tmp___6;
    }
    if ((int )p->fts_name[0] == 46) {
      {
      if (! p->fts_name[1]) {
        {
        goto _L___0;
        }
      } else {
        {
        if ((int )p->fts_name[1] == 46) {
          {
          if (! p->fts_name[2]) {
            {
            _L___0:
            if (p->fts_level == 0L) {
              {
              {
              tmp___7 = 1;
              }
              }
            } else {
              {
              {
              tmp___7 = 5;
              }
              }
            }
            return ((unsigned short )tmp___7);
            }
          }
          }
        }
        }
      }
      }
    }
    return ((unsigned short)1);
    }
  }
  if ((sbp->st_mode & 61440U) == 40960U) {
    {
    return ((unsigned short)12);
    }
  }
  if ((sbp->st_mode & 61440U) == 32768U) {
    {
    return ((unsigned short)8);
    }
  }
  return ((unsigned short)3);
}
}
static int fts_compar(void const *a , void const *b )
{
  FTSENT const **pa ;
  FTSENT const **pb ;
  int tmp ;
  {
  {
  pa = (FTSENT const **)a;
  pb = (FTSENT const **)b;
  tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
  }
  return (tmp);
}
}
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems )
{
  register FTSENT **ap ;
  register FTSENT *p ;
  FTSENT *dummy ;
  int (*compare)(void const * , void const * ) ;
  int (*tmp)(void const * , void const * ) ;
  FTSENT **a ;
  void *tmp___0 ;
  FTSENT **tmp___1 ;
  {
  if (sizeof(& dummy) == sizeof(void *)) {
    {
    if ((long )(& dummy) == (long )((void *)(& dummy))) {
      {
      {
      tmp = (int (*)(void const * , void const * ))sp->fts_compar;
      }
      }
    } else {
      {
      {
      tmp = & fts_compar;
      }
      }
    }
    }
  } else {
    {
    {
    tmp = & fts_compar;
    }
    }
  }
  {
  compare = tmp;
  }
  if (nitems > sp->fts_nitems) {
    {
    {
    sp->fts_nitems = nitems + 40UL;
    }
    if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
      {
      {
      free((void *)sp->fts_array);
      sp->fts_array = (struct _ftsent **)((void *)0);
      sp->fts_nitems = (size_t )0;
      }
      return (head);
      }
    } else {
      {
      {
      tmp___0 = realloc((void *)sp->fts_array, sp->fts_nitems * sizeof(*a));
      a = (FTSENT **)tmp___0;
      }
      if (! a) {
        {
        {
        free((void *)sp->fts_array);
        sp->fts_array = (struct _ftsent **)((void *)0);
        sp->fts_nitems = (size_t )0;
        }
        return (head);
        }
      }
      }
    }
    {
    sp->fts_array = a;
    }
    }
  }
  {
  ap = sp->fts_array;
  p = head;
  }
  {
  while (1) {
    while_continue: ;
    if (! p) {
      {
      goto while_break;
      }
    }
    {
    tmp___1 = ap;
    ap ++;
    *tmp___1 = p;
    p = p->fts_link;
    }
  }
  while_break: ;
  }
  {
  qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
  ap = sp->fts_array;
  head = *ap;
  }
  {
  while (1) {
    while_continue___0: ;
    if (! 1) {
      {
      goto while_break___0;
      }
    }
    {
    nitems --;
    }
    if (! nitems) {
      {
      goto while_break___0;
      }
    }
    {
    (*(ap + 0))->fts_link = *(ap + 1);
    ap ++;
    }
  }
  while_break___0: ;
  }
  {
  (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
  }
  return (head);
}
}
static FTSENT *fts_alloc(FTS *sp , char const *name , size_t namelen )
{
  register FTSENT *p ;
  size_t len ;
  void *tmp ;
  {
  {
  len = sizeof(FTSENT ) + namelen;
  tmp = malloc(len);
  p = (FTSENT *)tmp;
  }
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
    return ((FTSENT *)((void *)0));
    }
  }
  {
  memmove((void *)(p->fts_name), (void const *)name, namelen);
  p->fts_name[namelen] = (char )'\000';
  p->fts_namelen = namelen;
  p->fts_fts = sp;
  p->fts_path = sp->fts_path;
  p->fts_errno = 0;
  p->fts_dirp = (DIR *)((void *)0);
  p->fts_flags = (unsigned short)0;
  p->fts_instr = (unsigned short)3;
  p->fts_number = 0L;
  p->fts_pointer = (void *)0;
  }
  return (p);
}
}
static void fts_lfree(FTSENT *head )
{
  register FTSENT *p ;
  {
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    p = head;
    }
    if (! p) {
      {
      goto while_break;
      }
    }
    {
    head = head->fts_link;
    }
    if (p->fts_dirp) {
      {
      {
      closedir(p->fts_dirp);
      }
      }
    }
    {
    free((void *)p);
    }
  }
  while_break: ;
  }
  return;
}
}
static _Bool fts_palloc(FTS *sp , size_t more )
{
  char *p ;
  size_t new_len ;
  int *tmp ;
  void *tmp___0 ;
  {
  {
  new_len = (sp->fts_pathlen + more) + 256UL;
  }
  if (new_len < sp->fts_pathlen) {
    {
    {
    free((void *)sp->fts_path);
    sp->fts_path = (char *)((void *)0);
    tmp = __errno_location();
    *tmp = 36;
    }
    return ((_Bool)0);
    }
  }
  {
  sp->fts_pathlen = new_len;
  tmp___0 = realloc((void *)sp->fts_path, sp->fts_pathlen);
  p = (char *)tmp___0;
  }
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
    {
    free((void *)sp->fts_path);
    sp->fts_path = (char *)((void *)0);
    }
    return ((_Bool)0);
    }
  }
  {
  sp->fts_path = p;
  }
  return ((_Bool)1);
}
}
static void fts_padjust(FTS *sp , FTSENT *head )
{
  FTSENT *p ;
  char *addr ;
  {
  {
  addr = sp->fts_path;
  p = sp->fts_child;
  }
  {
  while (1) {
    while_continue: ;
    if (! p) {
      {
      goto while_break;
      }
    }
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
        {
        {
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
        }
        }
      }
      {
      p->fts_path = addr;
      }
      goto while_break___0;
    }
    while_break___0: ;
    }
    {
    p = p->fts_link;
    }
  }
  while_break: ;
  }
  {
  p = head;
  }
  {
  while (1) {
    while_continue___1: ;
    if (! (p->fts_level >= 0L)) {
      {
      goto while_break___1;
      }
    }
    {
    while (1) {
      while_continue___2: ;
      if (! 1) {
        {
        goto while_break___2;
        }
      }
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
        {
        {
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
        }
        }
      }
      {
      p->fts_path = addr;
      }
      goto while_break___2;
    }
    while_break___2: ;
    }
    if (p->fts_link) {
      {
      {
      p = p->fts_link;
      }
      }
    } else {
      {
      {
      p = p->fts_parent;
      }
      }
    }
  }
  while_break___1: ;
  }
  return;
}
}
static size_t fts_maxarglen(char **argv )
{
  size_t len ;
  size_t max ;
  {
  {
  max = (size_t )0;
  }
  {
  while (1) {
    while_continue: ;
    if (! *argv) {
      {
      goto while_break;
      }
    }
    {
    len = strlen((char const *)*argv);
    }
    if (len > max) {
      {
      {
      max = len;
      }
      }
    }
    {
    argv ++;
    }
  }
  while_break: ;
  }
  return (max + 1UL);
}
}
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const *dir )
{
  int ret ;
  _Bool is_dotdot ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int newfd ;
  int parent_fd ;
  _Bool tmp___7 ;
  struct stat sb ;
  int tmp___8 ;
  int *tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int oerrno ;
  int *tmp___17 ;
  int *tmp___18 ;
  {
  if (dir) {
    {
    if (0) {
      {
      {
      __s1_len = __builtin_strlen(dir);
      __s2_len = __builtin_strlen((char const *)"..");
      }
      if (! ((size_t )((void const *)(dir + 1)) - (size_t )((void const *)dir) == 1UL)) {
        {
        goto _L___0;
        }
      } else {
        {
        if (__s1_len >= 4UL) {
          {
          _L___0:
          if (! ((size_t )((void const *)(".." + 1)) - (size_t )((void const *)"..") == 1UL)) {
            {
            {
            tmp___5 = 1;
            }
            }
          } else {
            {
            if (__s2_len >= 4UL) {
              {
              {
              tmp___5 = 1;
              }
              }
            } else {
              {
              {
              tmp___5 = 0;
              }
              }
            }
            }
          }
          }
        } else {
          {
          {
          tmp___5 = 0;
          }
          }
        }
        }
      }
      if (tmp___5) {
        {
        {
        tmp___0 = __builtin_strcmp(dir, (char const *)"..");
        tmp___4 = tmp___0;
        }
        }
      } else {
        {
        {
        tmp___3 = __builtin_strcmp(dir, (char const *)"..");
        tmp___4 = tmp___3;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___3 = __builtin_strcmp(dir, (char const *)"..");
      tmp___4 = tmp___3;
      }
      }
    }
    if (tmp___4 == 0) {
      {
      {
      tmp___6 = 1;
      }
      }
    } else {
      {
      {
      tmp___6 = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___6 = 0;
    }
    }
  }
  {
  is_dotdot = (_Bool )tmp___6;
  }
  if (sp->fts_options & 4) {
    {
    if (sp->fts_options & 512) {
      {
      if (0 <= fd) {
        {
        {
        close(fd);
        }
        }
      }
      }
    }
    return (0);
    }
  }
  if (fd < 0) {
    {
    if (is_dotdot) {
      {
      if (sp->fts_options & 512) {
        {
        {
        tmp___7 = i_ring_empty((I_ring const *)(& sp->fts_fd_ring));
        }
        if (! tmp___7) {
          {
          {
          parent_fd = i_ring_pop(& sp->fts_fd_ring);
          is_dotdot = (_Bool)1;
          }
          if (0 <= parent_fd) {
            {
            {
            fd = parent_fd;
            dir = (char const *)((void *)0);
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  {
  newfd = fd;
  }
  if (fd < 0) {
    {
    {
    newfd = diropen((FTS const *)sp, dir);
    }
    if (newfd < 0) {
      {
      return (-1);
      }
    }
    }
  }
  if (sp->fts_options & 2) {
    {
    goto _L___3;
    }
  } else {
    {
    if (dir) {
      {
      if (0) {
        {
        {
        __s1_len___0 = __builtin_strlen(dir);
        __s2_len___0 = __builtin_strlen((char const *)"..");
        }
        if (! ((size_t )((void const *)(dir + 1)) - (size_t )((void const *)dir) == 1UL)) {
          {
          goto _L___2;
          }
        } else {
          {
          if (__s1_len___0 >= 4UL) {
            {
            _L___2:
            if (! ((size_t )((void const *)(".." + 1)) - (size_t )((void const *)"..") == 1UL)) {
              {
              {
              tmp___16 = 1;
              }
              }
            } else {
              {
              if (__s2_len___0 >= 4UL) {
                {
                {
                tmp___16 = 1;
                }
                }
              } else {
                {
                {
                tmp___16 = 0;
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            tmp___16 = 0;
            }
            }
          }
          }
        }
        if (tmp___16) {
          {
          {
          tmp___11 = __builtin_strcmp(dir, (char const *)"..");
          tmp___15 = tmp___11;
          }
          }
        } else {
          {
          {
          tmp___14 = __builtin_strcmp(dir, (char const *)"..");
          tmp___15 = tmp___14;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___14 = __builtin_strcmp(dir, (char const *)"..");
        tmp___15 = tmp___14;
        }
        }
      }
      if (tmp___15 == 0) {
        {
        _L___3:
        {
        tmp___8 = fstat(newfd, & sb);
        }
        if (tmp___8) {
          {
          {
          ret = -1;
          }
          goto bail;
          }
        }
        if (p->fts_statp[0].st_dev != sb.st_dev) {
          {
          {
          tmp___9 = __errno_location();
          *tmp___9 = 2;
          ret = -1;
          }
          goto bail;
          }
        } else {
          {
          if (p->fts_statp[0].st_ino != sb.st_ino) {
            {
            {
            tmp___9 = __errno_location();
            *tmp___9 = 2;
            ret = -1;
            }
            goto bail;
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  if (sp->fts_options & 512) {
    {
    {
    cwd_advance_fd(sp, newfd, (_Bool )(! is_dotdot));
    }
    return (0);
    }
  }
  {
  ret = fchdir(newfd);
  }
  bail:
  if (fd < 0) {
    {
    {
    tmp___17 = __errno_location();
    oerrno = *tmp___17;
    close(newfd);
    tmp___18 = __errno_location();
    *tmp___18 = oerrno;
    }
    }
  }
  return (ret);
}
}
int rpl_futimens(int fd , struct timespec const *times )
{
  int tmp ;
  {
  {
  tmp = fdutimens(fd, (char const *)((void *)0), times);
  }
  return (tmp);
}
}
char *rpl_getcwd(char *buf___1 , size_t size )
{
  int fd ;
  _Bool fd_needs_closing ;
  DIR *dirstream ;
  dev_t rootdev ;
  dev_t thisdev ;
  ino_t rootino ;
  ino_t thisino ;
  char *dir ;
  register char *dirp ;
  struct stat st ;
  size_t allocated ;
  size_t used ;
  char *tmp ;
  int *tmp___0 ;
  char big_buffer[4096] ;
  char *tmp___1 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  struct dirent *d ;
  dev_t dotdev ;
  ino_t dotino ;
  _Bool mount_point ;
  int parent_status ;
  size_t dirroom ;
  size_t namlen ;
  _Bool use_d_ino ;
  int tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  int *tmp___20 ;
  int *tmp___21 ;
  _Bool match ;
  int tmp___22 ;
  int entry_status ;
  int *tmp___23 ;
  char *tmp___24 ;
  size_t oldsize ;
  size_t tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  int tmp___28 ;
  void *tmp___29 ;
  int *tmp___30 ;
  int save ;
  int *tmp___31 ;
  int *tmp___32 ;
  {
  {
  fd = -100;
  fd_needs_closing = (_Bool)0;
  dirstream = (DIR *)((void *)0);
  allocated = size;
  tmp = getcwd(buf___1, size);
  dir = tmp;
  }
  if (dir) {
    {
    return (dir);
    }
  } else {
    {
    if (size) {
      {
      {
      tmp___0 = __errno_location();
      }
      if (*tmp___0 == 34) {
        {
        return (dir);
        }
      }
      }
    }
    }
  }
  {
  tmp___8 = __errno_location();
  }
  if (*tmp___8 == 22) {
    {
    if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
      {
      if (size == 0UL) {
        {
        {
        tmp___1 = getcwd(big_buffer, sizeof(big_buffer));
        dir = tmp___1;
        }
        if (dir) {
          {
          {
          tmp___7 = __strdup((char const *)dir);
          }
          return (tmp___7);
          }
        }
        }
      }
      }
    }
    }
  }
  {
  tmp___9 = __errno_location();
  }
  if (*tmp___9 != 34) {
    {
    {
    tmp___10 = __errno_location();
    }
    if (*tmp___10 != 36) {
      {
      {
      tmp___11 = __errno_location();
      }
      if (*tmp___11 != 2) {
        {
        return ((char *)((void *)0));
        }
      }
      }
    }
    }
  }
  if (size == 0UL) {
    {
    if ((unsigned long )buf___1 != (unsigned long )((void *)0)) {
      {
      {
      tmp___12 = __errno_location();
      *tmp___12 = 22;
      }
      return ((char *)((void *)0));
      }
    }
    {
    allocated = (size_t )4096;
    }
    }
  }
  if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
    {
    {
    tmp___13 = malloc(allocated);
    dir = (char *)tmp___13;
    }
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
      {
      return ((char *)((void *)0));
      }
    }
    }
  } else {
    {
    {
    dir = buf___1;
    }
    }
  }
  {
  dirp = dir + allocated;
  dirp --;
  *dirp = (char )'\000';
  tmp___14 = lstat((char const *)((char const * __restrict )"."), (struct stat *)((struct stat * __restrict )(& st)));
  }
  if (tmp___14 < 0) {
    {
    goto lose;
    }
  }
  {
  thisdev = st.st_dev;
  thisino = st.st_ino;
  tmp___15 = lstat((char const *)((char const * __restrict )"/"), (struct stat *)((struct stat * __restrict )(& st)));
  }
  if (tmp___15 < 0) {
    {
    goto lose;
    }
  }
  {
  rootdev = st.st_dev;
  rootino = st.st_ino;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (thisdev == rootdev) {
      {
      if (thisino == rootino) {
        {
        goto while_break;
        }
      }
      }
    }
    {
    use_d_ino = (_Bool)1;
    tmp___16 = openat(fd, (char const *)"..", 0);
    fd = tmp___16;
    }
    if (fd < 0) {
      {
      goto lose;
      }
    }
    {
    fd_needs_closing = (_Bool)1;
    parent_status = fstat(fd, & st);
    }
    if (parent_status != 0) {
      {
      goto lose;
      }
    }
    if (dirstream) {
      {
      {
      tmp___17 = closedir(dirstream);
      }
      if (tmp___17 != 0) {
        {
        {
        dirstream = (DIR *)((void *)0);
        }
        goto lose;
        }
      }
      }
    }
    {
    dotdev = st.st_dev;
    dotino = st.st_ino;
    mount_point = (_Bool )(dotdev != thisdev);
    dirstream = fdopendir(fd);
    }
    if ((unsigned long )dirstream == (unsigned long )((void *)0)) {
      {
      goto lose;
      }
    }
    {
    fd_needs_closing = (_Bool)0;
    }
    {
    while (1) {
      while_continue___0: ;
      if (! 1) {
        {
        goto while_break___0;
        }
      }
      {
      tmp___18 = __errno_location();
      *tmp___18 = 0;
      d = readdir(dirstream);
      }
      if ((unsigned long )d == (unsigned long )((void *)0)) {
        {
        {
        tmp___19 = __errno_location();
        }
        if (*tmp___19 == 0) {
          {
          if (use_d_ino) {
            {
            {
            use_d_ino = (_Bool)0;
            rewinddir(dirstream);
            d = readdir(dirstream);
            }
            }
          }
          }
        }
        }
      }
      if ((unsigned long )d == (unsigned long )((void *)0)) {
        {
        {
        tmp___21 = __errno_location();
        }
        if (*tmp___21 == 0) {
          {
          {
          tmp___20 = __errno_location();
          *tmp___20 = 2;
          }
          }
        }
        goto lose;
        }
      }
      if ((int )d->d_name[0] == 46) {
        {
        if ((int )d->d_name[1] == 0) {
          {
          goto __Cont;
          }
        } else {
          {
          if ((int )d->d_name[1] == 46) {
            {
            if ((int )d->d_name[2] == 0) {
              {
              goto __Cont;
              }
            }
            }
          }
          }
        }
        }
      }
      if (use_d_ino) {
        {
        if (d->d_ino == thisino) {
          {
          {
          tmp___22 = 1;
          }
          }
        } else {
          {
          if (mount_point) {
            {
            {
            tmp___22 = 1;
            }
            }
          } else {
            {
            {
            tmp___22 = 0;
            }
            }
          }
          }
        }
        {
        match = (_Bool )tmp___22;
        }
        if (! match) {
          {
          goto __Cont;
          }
        }
        }
      }
      {
      entry_status = fstatat(fd, (char const *)((char const * __restrict )(d->d_name)),
                             (struct stat *)((struct stat * __restrict )(& st)),
                             256);
      }
      if (entry_status == 0) {
        {
        if ((st.st_mode & 61440U) == 16384U) {
          {
          if (st.st_dev == thisdev) {
            {
            if (st.st_ino == thisino) {
              {
              goto while_break___0;
              }
            }
            }
          }
          }
        }
        }
      }
      __Cont:
      {
      }
    }
    while_break___0: ;
    }
    {
    dirroom = (size_t )(dirp - dir);
    namlen = strlen((char const *)(d->d_name));
    }
    if (dirroom <= namlen) {
      {
      if (size != 0UL) {
        {
        {
        tmp___23 = __errno_location();
        *tmp___23 = 34;
        }
        goto lose;
        }
      } else {
        {
        {
        oldsize = allocated;
        }
        if (allocated < namlen) {
          {
          {
          tmp___25 = namlen;
          }
          }
        } else {
          {
          {
          tmp___25 = allocated;
          }
          }
        }
        {
        allocated += tmp___25;
        }
        if (allocated < oldsize) {
          {
          goto memory_exhausted;
          }
        } else {
          {
          {
          tmp___26 = realloc((void *)dir, allocated);
          tmp___24 = (char *)tmp___26;
          }
          if (! tmp___24) {
            {
            goto memory_exhausted;
            }
          }
          }
        }
        {
        tmp___27 = memcpy((void *)((void * __restrict )((tmp___24 + allocated) - (oldsize - dirroom))),
                          (void const *)((void const * __restrict )(tmp___24 + dirroom)),
                          oldsize - dirroom);
        dirp = (char *)tmp___27;
        dir = tmp___24;
        }
        }
      }
      }
    }
    {
    dirp -= namlen;
    memcpy((void *)((void * __restrict )dirp), (void const *)((void const * __restrict )(d->d_name)),
           namlen);
    dirp --;
    *dirp = (char )'/';
    thisdev = dotdev;
    thisino = dotino;
    }
  }
  while_break: ;
  }
  if (dirstream) {
    {
    {
    tmp___28 = closedir(dirstream);
    }
    if (tmp___28 != 0) {
      {
      {
      dirstream = (DIR *)((void *)0);
      }
      goto lose;
      }
    }
    }
  }
  if ((unsigned long )dirp == (unsigned long )(dir + (allocated - 1UL))) {
    {
    {
    dirp --;
    *dirp = (char )'/';
    }
    }
  }
  {
  used = (size_t )((dir + allocated) - dirp);
  memmove((void *)dir, (void const *)dirp, used);
  }
  if (size == 0UL) {
    {
    {
    tmp___29 = realloc((void *)dir, used);
    buf___1 = (char *)tmp___29;
    }
    }
  }
  if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
    {
    {
    buf___1 = dir;
    }
    }
  }
  return (buf___1);
  memory_exhausted:
  {
  tmp___30 = __errno_location();
  *tmp___30 = 12;
  }
  lose:
  {
  tmp___31 = __errno_location();
  save = *tmp___31;
  }
  if (dirstream) {
    {
    {
    closedir(dirstream);
    }
    }
  }
  if (fd_needs_closing) {
    {
    {
    close(fd);
    }
    }
  }
  if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
    {
    {
    free((void *)dir);
    }
    }
  }
  {
  tmp___32 = __errno_location();
  *tmp___32 = save;
  }
  return ((char *)((void *)0));
}
}
__inline static xtime_t xtime_make(xtime_t s , long ns )
{
  {
  return (1000000000LL * s + (xtime_t )ns);
}
}
xtime_t gethrxtime(void)
{
  struct timespec ts ;
  xtime_t tmp ;
  int tmp___0 ;
  struct timespec ts___0 ;
  xtime_t tmp___1 ;
  {
  {
  tmp___0 = clock_gettime(1, & ts);
  }
  if (tmp___0 == 0) {
    {
    {
    tmp = xtime_make((xtime_t )ts.tv_sec, ts.tv_nsec);
    }
    return (tmp);
    }
  }
  {
  gettime(& ts___0);
  tmp___1 = xtime_make((xtime_t )ts___0.tv_sec, ts___0.tv_nsec);
  }
  return (tmp___1);
}
}
static void exchange(char **argv , struct _getopt_data *d )
{
  int bottom ;
  int middle ;
  int top ;
  char *tem ;
  int len ;
  register int i ;
  int len___0 ;
  register int i___0 ;
  {
  {
  bottom = d->__first_nonopt;
  middle = d->__last_nonopt;
  top = d->rpl_optind;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if (top > middle) {
      {
      if (! (middle > bottom)) {
        {
        goto while_break;
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
    if (top - middle > middle - bottom) {
      {
      {
      len = middle - bottom;
      i = 0;
      }
      {
      while (1) {
        while_continue___0: ;
        if (! (i < len)) {
          {
          goto while_break___0;
          }
        }
        {
        tem = *(argv + (bottom + i));
        *(argv + (bottom + i)) = *(argv + ((top - (middle - bottom)) + i));
        *(argv + ((top - (middle - bottom)) + i)) = tem;
        i ++;
        }
      }
      while_break___0: ;
      }
      {
      top -= len;
      }
      }
    } else {
      {
      {
      len___0 = top - middle;
      i___0 = 0;
      }
      {
      while (1) {
        while_continue___1: ;
        if (! (i___0 < len___0)) {
          {
          goto while_break___1;
          }
        }
        {
        tem = *(argv + (bottom + i___0));
        *(argv + (bottom + i___0)) = *(argv + (middle + i___0));
        *(argv + (middle + i___0)) = tem;
        i___0 ++;
        }
      }
      while_break___1: ;
      }
      {
      bottom += len___0;
      }
      }
    }
  }
  while_break: ;
  }
  {
  d->__first_nonopt += d->rpl_optind - d->__last_nonopt;
  d->__last_nonopt = d->rpl_optind;
  }
  return;
}
}
static char const *_getopt_initialize(int argc __attribute__((__unused__)) , char **argv __attribute__((__unused__)) ,
                                        char const *optstring , struct _getopt_data *d ,
                                        int posixly_correct )
{
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  {
  {
  tmp = d->rpl_optind;
  d->__last_nonopt = tmp;
  d->__first_nonopt = tmp;
  d->__nextchar = (char *)((void *)0);
  }
  if (posixly_correct) {
    {
    {
    tmp___1 = 1;
    }
    }
  } else {
    {
    { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
    {
    tmp___0 = getenv((char const *)"POSIXLY_CORRECT");
    }
    if (tmp___0) {
      {
      {
      tmp___1 = 1;
      }
      }
    } else {
      {
      { if(!(tmp___0 == 0)) { reach_error(); abort(); } };
      {
      tmp___1 = 0;
      }
      }
    }
    }
  }
  {
  d->__posixly_correct = tmp___1;
  }
  if ((int const )*(optstring + 0) == 45) {
    {
    {
    d->__ordering = (enum __ord )2;
    optstring ++;
    }
    }
  } else {
    {
    if ((int const )*(optstring + 0) == 43) {
      {
      {
      d->__ordering = (enum __ord )0;
      optstring ++;
      }
      }
    } else {
      {
      if (d->__posixly_correct) {
        {
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        {
        d->__ordering = (enum __ord )0;
        }
        }
      } else {
        {
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        {
        d->__ordering = (enum __ord )1;
        }
        }
      }
      }
    }
    }
  }
  return (optstring);
}
}
int _getopt_internal_r(int argc , char **argv , char const *optstring , struct rpl_option const *longopts ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct )
{
  int print_errors ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *nameend ;
  unsigned int namelen ;
  struct rpl_option const *p ;
  struct rpl_option const *pfound ;
  struct option_list *ambig_list ;
  int exact ;
  int indfound ;
  int option_index ;
  struct option_list *newp ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___13 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  struct option_list first ;
  char *tmp___23 ;
  size_t tmp___24 ;
  struct option_list *pn ;
  char *tmp___25 ;
  char *tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  size_t tmp___30 ;
  int tmp___31 ;
  size_t tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___36 ;
  char *tmp___38 ;
  char c ;
  char *tmp___39 ;
  char const *temp ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *nameend___0 ;
  struct rpl_option const *p___0 ;
  struct rpl_option const *pfound___0 ;
  int exact___0 ;
  int ambig ;
  int indfound___0 ;
  int option_index___0 ;
  char *tmp___43 ;
  int tmp___44 ;
  size_t tmp___45 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___49 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  char *tmp___59 ;
  size_t tmp___60 ;
  char *tmp___61 ;
  size_t tmp___62 ;
  int tmp___63 ;
  char *tmp___64 ;
  size_t tmp___65 ;
  int tmp___66 ;
  size_t tmp___67 ;
  char *tmp___68 ;
  int tmp___69 ;
  {
  {
  print_errors = d->rpl_opterr;
  }
  if (argc < 1) {
    {
    return (-1);
    }
  }
  {
  d->rpl_optarg = (char *)((void *)0);
  }
  if (d->rpl_optind == 0) {
    {
    goto _L;
    }
  } else {
    {
    { if(!(d == & getopt_data)) { reach_error(); abort(); } };
    if (! d->__initialized) {
      {
      _L:
      {
      { if(!(longind == 0)) { reach_error(); abort(); } };
      { if(!(long_only == 0)) { reach_error(); abort(); } };
      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
      { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
      { if(!(argc != 0)) { reach_error(); abort(); } };
      { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
      if (d->rpl_optind == 0) {
        {
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        {
        d->rpl_optind = 1;
        }
        }
      }
      }
      {
      { if(!(longind == 0)) { reach_error(); abort(); } };
      { if(!(long_only == 0)) { reach_error(); abort(); } };
      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
      { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
      { if(!(argc != 0)) { reach_error(); abort(); } };
      { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
      {
      optstring = _getopt_initialize(argc, argv, optstring, d, posixly_correct);
      d->__initialized = 1;
      }
      }
      }
    } else {
      {
      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
      if ((int const )*(optstring + 0) == 45) {
        {
        {
        optstring ++;
        }
        }
      } else {
        {
        if ((int const )*(optstring + 0) == 43) {
          {
          {
          optstring ++;
          }
          }
        }
        }
      }
      }
    }
    }
  }
  if ((int const )*(optstring + 0) == 58) {
    {
    {
    print_errors = 0;
    }
    }
  }
  {
  { if(!(longind == 0)) { reach_error(); abort(); } };
  { if(!(long_only == 0)) { reach_error(); abort(); } };
  { if(!(d == & getopt_data)) { reach_error(); abort(); } };
  { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
  { if(!(argc != 0)) { reach_error(); abort(); } };
  { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
  if ((unsigned long )d->__nextchar == (unsigned long )((void *)0)) {
    {
    goto _L___5;
    }
  } else {
    {
    { if(!(d == & getopt_data)) { reach_error(); abort(); } };
    if ((int )*(d->__nextchar) == 0) {
      {
      _L___5:
      {
      { if(!(longind == 0)) { reach_error(); abort(); } };
      { if(!(long_only == 0)) { reach_error(); abort(); } };
      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
      { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
      { if(!(argc != 0)) { reach_error(); abort(); } };
      { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
      if (d->__last_nonopt > d->rpl_optind) {
        {
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        {
        d->__last_nonopt = d->rpl_optind;
        }
        }
      }
      }
      {
      { if(!(longind == 0)) { reach_error(); abort(); } };
      { if(!(long_only == 0)) { reach_error(); abort(); } };
      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
      { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
      { if(!(argc != 0)) { reach_error(); abort(); } };
      { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
      if (d->__first_nonopt > d->rpl_optind) {
        {
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        {
        d->__first_nonopt = d->rpl_optind;
        }
        }
      }
      }
      {
      { if(!(longind == 0)) { reach_error(); abort(); } };
      { if(!(long_only == 0)) { reach_error(); abort(); } };
      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
      { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
      { if(!(argc != 0)) { reach_error(); abort(); } };
      { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
      if ((unsigned int )d->__ordering == 1U) {
        {
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        if (d->__first_nonopt != d->__last_nonopt) {
          {
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          if (d->__last_nonopt != d->rpl_optind) {
            {
            { if(!(d == & getopt_data)) { reach_error(); abort(); } };
            { if(!(d == & getopt_data)) { reach_error(); abort(); } };
            {
            exchange(argv, d);
            { if(!(longind == 0)) { reach_error(); abort(); } };
            { if(!(long_only == 0)) { reach_error(); abort(); } };
            { if(!(d == & getopt_data)) { reach_error(); abort(); } };
            { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
            { if(!(argc != 0)) { reach_error(); abort(); } };
            { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
            }
            }
          } else {
            {
            goto _L___0;
            }
          }
          }
        } else {
          {
          _L___0:
          {
          { if(!(longind == 0)) { reach_error(); abort(); } };
          { if(!(long_only == 0)) { reach_error(); abort(); } };
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
          { if(!(argc != 0)) { reach_error(); abort(); } };
          { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
          if (d->__last_nonopt != d->rpl_optind) {
            {
            { if(!(d == & getopt_data)) { reach_error(); abort(); } };
            { if(!(d == & getopt_data)) { reach_error(); abort(); } };
            {
            d->__first_nonopt = d->rpl_optind;
            }
            }
          }
          }
          }
        }
        {
        while (1) {
          while_continue: ;
          if (! 1) {
            {
            goto while_break;
            }
          }
          if (d->rpl_optind < argc) {
            {
            { if(!(d == & getopt_data)) { reach_error(); abort(); } };
            { if(!(argc != 0)) { reach_error(); abort(); } };
            if (! ((int )*(*(argv + d->rpl_optind) + 0) != 45)) {
              {
              { if(!(d == & getopt_data)) { reach_error(); abort(); } };
              if (! ((int )*(*(argv + d->rpl_optind) + 1) == 0)) {
                {
                goto while_break;
                }
              }
              }
            }
            }
          } else {
            {
            goto while_break;
            }
          }
          {
          { if(!(longind == 0)) { reach_error(); abort(); } };
          { if(!(long_only == 0)) { reach_error(); abort(); } };
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
          { if(!(argc != 0)) { reach_error(); abort(); } };
          { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
          {
          (d->rpl_optind) ++;
          }
          }
        }
        while_break: ;
        }
        {
        d->__last_nonopt = d->rpl_optind;
        }
        }
      }
      }
      {
      { if(!(longind == 0)) { reach_error(); abort(); } };
      { if(!(long_only == 0)) { reach_error(); abort(); } };
      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
      { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
      { if(!(argc != 0)) { reach_error(); abort(); } };
      { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
      if (d->rpl_optind != argc) {
        {
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        { if(!(argc != 0)) { reach_error(); abort(); } };
        if (0) {
          {
          {
          __s1_len = __builtin_strlen((char const *)*(argv + d->rpl_optind));
          __s2_len = __builtin_strlen((char const *)"--");
          }
          if (! ((size_t )((void const *)(*(argv + d->rpl_optind) + 1)) - (size_t )((void const *)*(argv + d->rpl_optind)) == 1UL)) {
            {
            goto _L___3;
            }
          } else {
            {
            if (__s1_len >= 4UL) {
              {
              _L___3:
              if (! ((size_t )((void const *)("--" + 1)) - (size_t )((void const *)"--") == 1UL)) {
                {
                {
                tmp___5 = 1;
                }
                }
              } else {
                {
                if (__s2_len >= 4UL) {
                  {
                  {
                  tmp___5 = 1;
                  }
                  }
                } else {
                  {
                  {
                  tmp___5 = 0;
                  }
                  }
                }
                }
              }
              }
            } else {
              {
              {
              tmp___5 = 0;
              }
              }
            }
            }
          }
          if (tmp___5) {
            {
            {
            tmp___0 = __builtin_strcmp((char const *)*(argv + d->rpl_optind), (char const *)"--");
            tmp___4 = tmp___0;
            }
            }
          } else {
            {
            {
            tmp___3 = __builtin_strcmp((char const *)*(argv + d->rpl_optind), (char const *)"--");
            tmp___4 = tmp___3;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___3 = __builtin_strcmp((char const *)*(argv + d->rpl_optind), (char const *)"--");
          tmp___4 = tmp___3;
          }
          }
        }
        if (! tmp___4) {
          {
          { if(!(tmp___4 == 0)) { reach_error(); abort(); } };
          {
          (d->rpl_optind) ++;
          }
          if (d->__first_nonopt != d->__last_nonopt) {
            {
            { if(!(d == & getopt_data)) { reach_error(); abort(); } };
            { if(!(d == & getopt_data)) { reach_error(); abort(); } };
            if (d->__last_nonopt != d->rpl_optind) {
              {
              { if(!(d == & getopt_data)) { reach_error(); abort(); } };
              { if(!(d == & getopt_data)) { reach_error(); abort(); } };
              {
              exchange(argv, d);
              { if(!(longind == 0)) { reach_error(); abort(); } };
              { if(!(long_only == 0)) { reach_error(); abort(); } };
              { if(!(d == & getopt_data)) { reach_error(); abort(); } };
              { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
              { if(!(tmp___4 == 0)) { reach_error(); abort(); } };
              { if(!(argc != 0)) { reach_error(); abort(); } };
              { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
              }
              }
            } else {
              {
              goto _L___1;
              }
            }
            }
          } else {
            {
            _L___1:
            {
            { if(!(longind == 0)) { reach_error(); abort(); } };
            { if(!(long_only == 0)) { reach_error(); abort(); } };
            { if(!(d == & getopt_data)) { reach_error(); abort(); } };
            { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
            { if(!(tmp___4 == 0)) { reach_error(); abort(); } };
            { if(!(argc != 0)) { reach_error(); abort(); } };
            { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
            if (d->__first_nonopt == d->__last_nonopt) {
              {
              { if(!(d == & getopt_data)) { reach_error(); abort(); } };
              { if(!(d == & getopt_data)) { reach_error(); abort(); } };
              {
              d->__first_nonopt = d->rpl_optind;
              }
              }
            }
            }
            }
          }
          {
          d->__last_nonopt = argc;
          d->rpl_optind = argc;
          }
          }
        }
        }
      }
      }
      if (d->rpl_optind == argc) {
        {
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        { if(!(argc != 0)) { reach_error(); abort(); } };
        if (d->__first_nonopt != d->__last_nonopt) {
          {
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          {
          d->rpl_optind = d->__first_nonopt;
          }
          }
        }
        {
        { if(!(longind == 0)) { reach_error(); abort(); } };
        { if(!(long_only == 0)) { reach_error(); abort(); } };
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
        { if(!(argc != 0)) { reach_error(); abort(); } };
        { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
        return (-1);
        }
        }
      }
      if ((int )*(*(argv + d->rpl_optind) + 0) != 45) {
        {
        goto _L___4;
        }
      } else {
        {
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        if ((int )*(*(argv + d->rpl_optind) + 1) == 0) {
          {
          _L___4:
          {
          { if(!(longind == 0)) { reach_error(); abort(); } };
          { if(!(long_only == 0)) { reach_error(); abort(); } };
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
          { if(!(argc != 0)) { reach_error(); abort(); } };
          { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
          if ((unsigned int )d->__ordering == 0U) {
            {
            { if(!(d == & getopt_data)) { reach_error(); abort(); } };
            return (-1);
            }
          }
          }
          {
          tmp___6 = d->rpl_optind;
          (d->rpl_optind) ++;
          d->rpl_optarg = *(argv + tmp___6);
          }
          return (1);
          }
        }
        }
      }
      if ((unsigned long )longopts != (unsigned long )((void *)0)) {
        {
        { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
        if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
          {
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          {
          tmp___7 = 1;
          }
          }
        } else {
          {
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          {
          tmp___7 = 0;
          }
          }
        }
        }
      } else {
        {
        { if(!(longopts == 0)) { reach_error(); abort(); } };
        {
        tmp___7 = 0;
        }
        }
      }
      {
      d->__nextchar = (*(argv + d->rpl_optind) + 1) + tmp___7;
      }
      }
    }
    }
  }
  }
  {
  { if(!(longind == 0)) { reach_error(); abort(); } };
  { if(!(long_only == 0)) { reach_error(); abort(); } };
  { if(!(d == & getopt_data)) { reach_error(); abort(); } };
  { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
  { if(!(argc != 0)) { reach_error(); abort(); } };
  { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
  if ((unsigned long )longopts != (unsigned long )((void *)0)) {
    {
    { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
    if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
      {
      goto _L___10;
      }
    } else {
      {
      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
      if (long_only) {
        {
        if (*(*(argv + d->rpl_optind) + 2)) {
          {
          goto _L___10;
          }
        } else {
          {
          {
          tmp___38 = __builtin_strchr((char *)optstring, (int )*(*(argv + d->rpl_optind) + 1));
          }
          if (! tmp___38) {
            {
            _L___10:
            {
            pfound = (struct rpl_option const *)((void *)0);
            { if(!(pfound == 0)) { reach_error(); abort(); } };
            ambig_list = (struct option_list *)((void *)0);
            { if(!(ambig_list == 0)) { reach_error(); abort(); } };
            exact = 0;
            { if(!(exact == 0)) { reach_error(); abort(); } };
            indfound = -1;
            { if(!(indfound == -1)) { reach_error(); abort(); } };
            nameend = d->__nextchar;
            }
            {
            while (1) {
              while_continue___0: ;
              if (! 1) {
                {
                goto while_break___0;
                }
              }
              if (*nameend) {
                {
                if (! ((int )*nameend != 61)) {
                  {
                  goto while_break___0;
                  }
                }
                }
              } else {
                {
                goto while_break___0;
                }
              }
              {
              nameend ++;
              }
            }
            while_break___0: ;
            }
            {
            namelen = (unsigned int )(nameend - d->__nextchar);
            p = longopts;
            { if(!(p == & long_options[0LL])) { reach_error(); abort(); } };
            option_index = 0;
            }
            {
            while (1) {
              while_continue___1: ;
              if (! p->name) {
                {
                goto while_break___1;
                }
              }
              if (0) {
                {
                if (0) {
                  {
                  {
                  __s1_len___0 = __builtin_strlen((char const *)p->name);
                  __s2_len___0 = __builtin_strlen((char const *)d->__nextchar);
                  }
                  if (! ((size_t )((void const *)(p->name + 1)) - (size_t )((void const *)p->name) == 1UL)) {
                    {
                    goto _L___7;
                    }
                  } else {
                    {
                    if (__s1_len___0 >= 4UL) {
                      {
                      _L___7:
                      if (! ((size_t )((void const *)(d->__nextchar + 1)) - (size_t )((void const *)d->__nextchar) == 1UL)) {
                        {
                        {
                        tmp___18 = 1;
                        }
                        }
                      } else {
                        {
                        if (__s2_len___0 >= 4UL) {
                          {
                          {
                          tmp___18 = 1;
                          }
                          }
                        } else {
                          {
                          {
                          tmp___18 = 0;
                          }
                          }
                        }
                        }
                      }
                      }
                    } else {
                      {
                      {
                      tmp___18 = 0;
                      }
                      }
                    }
                    }
                  }
                  if (tmp___18) {
                    {
                    {
                    tmp___13 = __builtin_strcmp((char const *)p->name, (char const *)d->__nextchar);
                    tmp___17 = tmp___13;
                    }
                    }
                  } else {
                    {
                    {
                    tmp___16 = __builtin_strcmp((char const *)p->name, (char const *)d->__nextchar);
                    tmp___17 = tmp___16;
                    }
                    }
                  }
                  }
                } else {
                  {
                  {
                  tmp___16 = __builtin_strcmp((char const *)p->name, (char const *)d->__nextchar);
                  tmp___17 = tmp___16;
                  }
                  }
                }
                {
                tmp___20 = tmp___17;
                }
                }
              } else {
                {
                {
                tmp___19 = strncmp((char const *)p->name, (char const *)d->__nextchar,
                                   (size_t )namelen);
                tmp___20 = tmp___19;
                }
                }
              }
              {
              { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
              { if(!(longind == 0)) { reach_error(); abort(); } };
              { if(!(long_only == 0)) { reach_error(); abort(); } };
              { if(!(d == & getopt_data)) { reach_error(); abort(); } };
              { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
              { if(!(exact == 0)) { reach_error(); abort(); } };
              { if(!(argc != 0)) { reach_error(); abort(); } };
              if (! tmp___20) {
                {
                { if(!(tmp___20 == 0)) { reach_error(); abort(); } };
                {
                tmp___9 = strlen((char const *)p->name);
                }
                if (namelen == (unsigned int )tmp___9) {
                  {
                  {
                  pfound = p;
                  indfound = option_index;
                  exact = 1;
                  }
                  goto while_break___1;
                  }
                } else {
                  {
                  if ((unsigned long )pfound == (unsigned long )((void *)0)) {
                    {
                    { if(!(pfound == 0)) { reach_error(); abort(); } };
                    {
                    pfound = p;
                    indfound = option_index;
                    }
                    }
                  } else {
                    {
                    if (long_only) {
                      {
                      {
                      tmp___8 = malloc(sizeof(*newp));
                      newp = (struct option_list *)tmp___8;
                      newp->p = p;
                      newp->next = ambig_list;
                      ambig_list = newp;
                      }
                      }
                    } else {
                      {
                      { if(!(long_only == 0)) { reach_error(); abort(); } };
                      if (pfound->has_arg != p->has_arg) {
                        {
                        {
                        tmp___8 = malloc(sizeof(*newp));
                        newp = (struct option_list *)tmp___8;
                        newp->p = p;
                        newp->next = ambig_list;
                        ambig_list = newp;
                        }
                        }
                      } else {
                        {
                        if ((unsigned long )pfound->flag != (unsigned long )p->flag) {
                          {
                          {
                          tmp___8 = malloc(sizeof(*newp));
                          newp = (struct option_list *)tmp___8;
                          newp->p = p;
                          newp->next = ambig_list;
                          ambig_list = newp;
                          }
                          }
                        } else {
                          {
                          if (pfound->val != p->val) {
                            {
                            {
                            tmp___8 = malloc(sizeof(*newp));
                            newp = (struct option_list *)tmp___8;
                            newp->p = p;
                            newp->next = ambig_list;
                            ambig_list = newp;
                            }
                            }
                          }
                          }
                        }
                        }
                      }
                      }
                    }
                    }
                  }
                  }
                }
                }
              }
              }
              {
              p ++;
              option_index ++;
              }
            }
            while_break___1: ;
            }
            if ((unsigned long )ambig_list != (unsigned long )((void *)0)) {
              {
              if (! exact) {
                {
                { if(!(exact == 0)) { reach_error(); abort(); } };
                if (print_errors) {
                  {
                  { if(!(print_errors != 0)) { reach_error(); abort(); } };
                  {
                  first.p = pfound;
                  first.next = ambig_list;
                  ambig_list = & first;
                  { if(!(ambig_list == & first)) { reach_error(); abort(); } };
                  tmp___23 = dcgettext((char const *)((void *)0), (char const *)"%s: option \'%s\' is ambiguous; possibilities:",
                                       5);
                  fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )tmp___23),
                          *(argv + 0), *(argv + d->rpl_optind));
                  { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
                  { if(!(longind == 0)) { reach_error(); abort(); } };
                  { if(!(long_only == 0)) { reach_error(); abort(); } };
                  { if(!(d == & getopt_data)) { reach_error(); abort(); } };
                  { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
                  { if(!(exact == 0)) { reach_error(); abort(); } };
                  { if(!(argc != 0)) { reach_error(); abort(); } };
                  { if(!(print_errors != 0)) { reach_error(); abort(); } };
                  }
                  {
                  while (1) {
                    while_continue___2: ;
                    if (! 1) {
                      {
                      goto while_break___2;
                      }
                    }
                    {
                    fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )" \'--%s\'"),
                            (ambig_list->p)->name);
                    { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
                    { if(!(longind == 0)) { reach_error(); abort(); } };
                    { if(!(long_only == 0)) { reach_error(); abort(); } };
                    { if(!(d == & getopt_data)) { reach_error(); abort(); } };
                    { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
                    { if(!(exact == 0)) { reach_error(); abort(); } };
                    { if(!(argc != 0)) { reach_error(); abort(); } };
                    { if(!(print_errors != 0)) { reach_error(); abort(); } };
                    ambig_list = ambig_list->next;
                    }
                    if (! ((unsigned long )ambig_list != (unsigned long )((void *)0))) {
                      {
                      goto while_break___2;
                      }
                    }
                  }
                  while_break___2: ;
                  }
                  {
                  fputc('\n', stderr);
                  { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
                  { if(!(longind == 0)) { reach_error(); abort(); } };
                  { if(!(long_only == 0)) { reach_error(); abort(); } };
                  { if(!(d == & getopt_data)) { reach_error(); abort(); } };
                  { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
                  { if(!(exact == 0)) { reach_error(); abort(); } };
                  { if(!(argc != 0)) { reach_error(); abort(); } };
                  }
                  }
                }
                {
                { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
                { if(!(longind == 0)) { reach_error(); abort(); } };
                { if(!(long_only == 0)) { reach_error(); abort(); } };
                { if(!(d == & getopt_data)) { reach_error(); abort(); } };
                { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
                { if(!(exact == 0)) { reach_error(); abort(); } };
                { if(!(argc != 0)) { reach_error(); abort(); } };
                {
                tmp___24 = strlen((char const *)d->__nextchar);
                d->__nextchar += tmp___24;
                (d->rpl_optind) ++;
                d->rpl_optopt = 0;
                }
                }
                return ('?');
                }
              }
              }
            }
            {
            { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
            { if(!(longind == 0)) { reach_error(); abort(); } };
            { if(!(long_only == 0)) { reach_error(); abort(); } };
            { if(!(d == & getopt_data)) { reach_error(); abort(); } };
            { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
            { if(!(argc != 0)) { reach_error(); abort(); } };
            {
            while (1) {
              while_continue___3: ;
              if (! ((unsigned long )ambig_list != (unsigned long )((void *)0))) {
                {
                goto while_break___3;
                }
              }
              {
              pn = ambig_list->next;
              free((void *)ambig_list);
              { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
              { if(!(longind == 0)) { reach_error(); abort(); } };
              { if(!(long_only == 0)) { reach_error(); abort(); } };
              { if(!(d == & getopt_data)) { reach_error(); abort(); } };
              { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
              { if(!(argc != 0)) { reach_error(); abort(); } };
              ambig_list = pn;
              }
            }
            while_break___3: ;
            }
            }
            if ((unsigned long )pfound != (unsigned long )((void *)0)) {
              {
              {
              option_index = indfound;
              (d->rpl_optind) ++;
              }
              if (*nameend) {
                {
                if (pfound->has_arg) {
                  {
                  {
                  d->rpl_optarg = nameend + 1;
                  }
                  }
                } else {
                  {
                  if (print_errors) {
                    {
                    { if(!(print_errors != 0)) { reach_error(); abort(); } };
                    if ((int )*(*(argv + (d->rpl_optind - 1)) + 1) == 45) {
                      {
                      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
                      {
                      tmp___25 = dcgettext((char const *)((void *)0), (char const *)"%s: option \'--%s\' doesn\'t allow an argument\n",
                                           5);
                      fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )tmp___25),
                              *(argv + 0), pfound->name);
                      { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
                      { if(!(longind == 0)) { reach_error(); abort(); } };
                      { if(!(long_only == 0)) { reach_error(); abort(); } };
                      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
                      { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
                      { if(!(ambig_list == 0)) { reach_error(); abort(); } };
                      { if(!(argc != 0)) { reach_error(); abort(); } };
                      }
                      }
                    } else {
                      {
                      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
                      {
                      tmp___26 = dcgettext((char const *)((void *)0), (char const *)"%s: option \'%c%s\' doesn\'t allow an argument\n",
                                           5);
                      fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )tmp___26),
                              *(argv + 0), (int )*(*(argv + (d->rpl_optind - 1)) + 0),
                              pfound->name);
                      { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
                      { if(!(longind == 0)) { reach_error(); abort(); } };
                      { if(!(long_only == 0)) { reach_error(); abort(); } };
                      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
                      { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
                      { if(!(ambig_list == 0)) { reach_error(); abort(); } };
                      { if(!(argc != 0)) { reach_error(); abort(); } };
                      }
                      }
                    }
                    }
                  }
                  {
                  tmp___27 = strlen((char const *)d->__nextchar);
                  d->__nextchar += tmp___27;
                  d->rpl_optopt = (int )pfound->val;
                  }
                  return ('?');
                  }
                }
                }
              } else {
                {
                if (pfound->has_arg == 1) {
                  {
                  if (d->rpl_optind < argc) {
                    {
                    {
                    tmp___28 = d->rpl_optind;
                    (d->rpl_optind) ++;
                    d->rpl_optarg = *(argv + tmp___28);
                    }
                    }
                  } else {
                    {
                    if (print_errors) {
                      {
                      {
                      tmp___29 = dcgettext((char const *)((void *)0), (char const *)"%s: option \'--%s\' requires an argument\n",
                                           5);
                      fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )tmp___29),
                              *(argv + 0), pfound->name);
                      }
                      }
                    }
                    {
                    tmp___30 = strlen((char const *)d->__nextchar);
                    d->__nextchar += tmp___30;
                    d->rpl_optopt = (int )pfound->val;
                    }
                    if ((int const )*(optstring + 0) == 58) {
                      {
                      {
                      tmp___31 = ':';
                      }
                      }
                    } else {
                      {
                      {
                      tmp___31 = '?';
                      }
                      }
                    }
                    return (tmp___31);
                    }
                  }
                  }
                }
                }
              }
              {
              tmp___32 = strlen((char const *)d->__nextchar);
              d->__nextchar += tmp___32;
              }
              if ((unsigned long )longind != (unsigned long )((void *)0)) {
                {
                {
                *longind = option_index;
                }
                }
              }
              {
              { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
              { if(!(longind == 0)) { reach_error(); abort(); } };
              { if(!(long_only == 0)) { reach_error(); abort(); } };
              { if(!(d == & getopt_data)) { reach_error(); abort(); } };
              { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
              { if(!(ambig_list == 0)) { reach_error(); abort(); } };
              { if(!(argc != 0)) { reach_error(); abort(); } };
              if (pfound->flag) {
                {
                {
                *(pfound->flag) = (int )pfound->val;
                }
                return (0);
                }
              }
              }
              return ((int )pfound->val);
              }
            }
            if (! long_only) {
              {
              goto _L___8;
              }
            } else {
              {
              if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
                {
                goto _L___8;
                }
              } else {
                {
                {
                tmp___36 = __builtin_strchr((char *)optstring, (int )*(d->__nextchar));
                }
                if ((unsigned long )tmp___36 == (unsigned long )((void *)0)) {
                  {
                  _L___8:
                  if (print_errors) {
                    {
                    { if(!(print_errors != 0)) { reach_error(); abort(); } };
                    if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
                      {
                      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
                      {
                      tmp___33 = dcgettext((char const *)((void *)0), (char const *)"%s: unrecognized option \'--%s\'\n",
                                           5);
                      fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )tmp___33),
                              *(argv + 0), d->__nextchar);
                      { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
                      { if(!(longind == 0)) { reach_error(); abort(); } };
                      { if(!(long_only == 0)) { reach_error(); abort(); } };
                      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
                      { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
                      { if(!(pfound == 0)) { reach_error(); abort(); } };
                      { if(!(ambig_list == 0)) { reach_error(); abort(); } };
                      { if(!(argc != 0)) { reach_error(); abort(); } };
                      }
                      }
                    } else {
                      {
                      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
                      {
                      tmp___34 = dcgettext((char const *)((void *)0), (char const *)"%s: unrecognized option \'%c%s\'\n",
                                           5);
                      fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )tmp___34),
                              *(argv + 0), (int )*(*(argv + d->rpl_optind) + 0), d->__nextchar);
                      { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
                      { if(!(longind == 0)) { reach_error(); abort(); } };
                      { if(!(long_only == 0)) { reach_error(); abort(); } };
                      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
                      { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
                      { if(!(pfound == 0)) { reach_error(); abort(); } };
                      { if(!(ambig_list == 0)) { reach_error(); abort(); } };
                      { if(!(argc != 0)) { reach_error(); abort(); } };
                      }
                      }
                    }
                    }
                  }
                  {
                  d->__nextchar = "";
                  (d->rpl_optind) ++;
                  d->rpl_optopt = 0;
                  }
                  return ('?');
                  }
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  }
  {
  int t = argc * argc * ((int) (__VERIFIER_nondet_uint() % 4));
  tmp___39 = d->__nextchar;
  (d->__nextchar) ++;
  c = *tmp___39;
  tmp___41 = __builtin_strchr((char *)optstring, (int )c);
  temp = (char const *)tmp___41;
  }
  if ((int )*(d->__nextchar) == 0) {
    {
    { if(!(d == & getopt_data)) { reach_error(); abort(); } };
    {
    (d->rpl_optind) ++;
    }
    }
  }
  {
  { if(!(longind == 0)) { reach_error(); abort(); } };
  { if(!(long_only == 0)) { reach_error(); abort(); } };
  { if(!(d == & getopt_data)) { reach_error(); abort(); } };
  { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
  { if(!(argc != 0)) { reach_error(); abort(); } };
  { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    {
    goto _L___11;
    }
  } else {
    {
    if ((int )c == 58) {
      {
      goto _L___11;
      }
    } else {
      {
      { if(!(c != (char)58)) { reach_error(); abort(); } };
      if ((int )c == 59) {
        {
        _L___11:
        if (print_errors) {
          {
          { if(!(print_errors != 0)) { reach_error(); abort(); } };
          {
          tmp___42 = dcgettext((char const *)((void *)0), (char const *)"%s: invalid option -- \'%c\'\n",
                               5);
          fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )tmp___42),
                  *(argv + 0), (int )c);
          { if(!(longind == 0)) { reach_error(); abort(); } };
          { if(!(long_only == 0)) { reach_error(); abort(); } };
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
          { if(!(argc != 0)) { reach_error(); abort(); } };
          { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
          }
          }
        }
        {
        { if(!(longind == 0)) { reach_error(); abort(); } };
        { if(!(long_only == 0)) { reach_error(); abort(); } };
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
        { if(!(argc != 0)) { reach_error(); abort(); } };
        { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
        {
        d->rpl_optopt = (int )c;
        }
        }
        return ('?');
        }
      }
      }
    }
    }
  }
  }
  if ((int const )*(temp + 0) == 87) {
    {
    if ((int const )*(temp + 1) == 59) {
      {
      {
      pfound___0 = (struct rpl_option const *)((void *)0);
      { if(!(pfound___0 == 0)) { reach_error(); abort(); } };
      exact___0 = 0;
      { if(!(exact___0 == 0)) { reach_error(); abort(); } };
      ambig = 0;
      { if(!(ambig == 0)) { reach_error(); abort(); } };
      indfound___0 = 0;
      { if(!(indfound___0 == 0)) { reach_error(); abort(); } };
      }
      if ((unsigned long )longopts == (unsigned long )((void *)0)) {
        {
        goto no_longs;
        }
      }
      if ((int )*(d->__nextchar) != 0) {
        {
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        {
        d->rpl_optarg = d->__nextchar;
        (d->rpl_optind) ++;
        }
        }
      } else {
        {
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        if (d->rpl_optind == argc) {
          {
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          { if(!(argc != 0)) { reach_error(); abort(); } };
          if (print_errors) {
            {
            { if(!(print_errors != 0)) { reach_error(); abort(); } };
            {
            tmp___43 = dcgettext((char const *)((void *)0), (char const *)"%s: option requires an argument -- \'%c\'\n",
                                 5);
            fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )tmp___43),
                    *(argv + 0), (int )c);
            { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
            { if(!(longind == 0)) { reach_error(); abort(); } };
            { if(!(long_only == 0)) { reach_error(); abort(); } };
            { if(!(d == & getopt_data)) { reach_error(); abort(); } };
            { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
            { if(!(pfound___0 == 0)) { reach_error(); abort(); } };
            { if(!(exact___0 == 0)) { reach_error(); abort(); } };
            { if(!(ambig == 0)) { reach_error(); abort(); } };
            { if(!(indfound___0 == 0)) { reach_error(); abort(); } };
            { if(!(argc != 0)) { reach_error(); abort(); } };
            { if(!(c != (char)58)) { reach_error(); abort(); } };
            { if(!(c != (char)59)) { reach_error(); abort(); } };
            }
            }
          }
          {
          { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
          { if(!(longind == 0)) { reach_error(); abort(); } };
          { if(!(long_only == 0)) { reach_error(); abort(); } };
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
          { if(!(pfound___0 == 0)) { reach_error(); abort(); } };
          { if(!(exact___0 == 0)) { reach_error(); abort(); } };
          { if(!(ambig == 0)) { reach_error(); abort(); } };
          { if(!(indfound___0 == 0)) { reach_error(); abort(); } };
          { if(!(argc != 0)) { reach_error(); abort(); } };
          { if(!(c != (char)58)) { reach_error(); abort(); } };
          { if(!(c != (char)59)) { reach_error(); abort(); } };
          {
          d->rpl_optopt = (int )c;
          }
          }
          if ((int const )*(optstring + 0) == 58) {
            {
            {
            c = (char )':';
            { if(!(c != (char)0)) { reach_error(); abort(); } };
            }
            }
          } else {
            {
            {
            c = (char )'?';
            { if(!(c != (char)0)) { reach_error(); abort(); } };
            }
            }
          }
          {
          { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
          { if(!(longind == 0)) { reach_error(); abort(); } };
          { if(!(long_only == 0)) { reach_error(); abort(); } };
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
          { if(!(pfound___0 == 0)) { reach_error(); abort(); } };
          { if(!(exact___0 == 0)) { reach_error(); abort(); } };
          { if(!(ambig == 0)) { reach_error(); abort(); } };
          { if(!(indfound___0 == 0)) { reach_error(); abort(); } };
          { if(!(argc != 0)) { reach_error(); abort(); } };
          { if(!(c != (char)0)) { reach_error(); abort(); } };
          return ((int )c);
          }
          }
        } else {
          {
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          { if(!(argc != 0)) { reach_error(); abort(); } };
          {
          tmp___44 = d->rpl_optind;
          (d->rpl_optind) ++;
          d->rpl_optarg = *(argv + tmp___44);
          }
          }
        }
        }
      }
      {
      { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
      { if(!(longind == 0)) { reach_error(); abort(); } };
      { if(!(long_only == 0)) { reach_error(); abort(); } };
      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
      { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
      { if(!(pfound___0 == 0)) { reach_error(); abort(); } };
      { if(!(exact___0 == 0)) { reach_error(); abort(); } };
      { if(!(ambig == 0)) { reach_error(); abort(); } };
      { if(!(indfound___0 == 0)) { reach_error(); abort(); } };
      { if(!(argc != 0)) { reach_error(); abort(); } };
      { if(!(c != (char)58)) { reach_error(); abort(); } };
      { if(!(c != (char)59)) { reach_error(); abort(); } };
      {
      nameend___0 = d->rpl_optarg;
      d->__nextchar = nameend___0;
      }
      }
      {
      while (1) {
        while_continue___4: ;
        if (! 1) {
          {
          goto while_break___4;
          }
        }
        if (*nameend___0) {
          {
          if (! ((int )*nameend___0 != 61)) {
            {
            goto while_break___4;
            }
          }
          }
        } else {
          {
          goto while_break___4;
          }
        }
        {
        nameend___0 ++;
        }
      }
      while_break___4: ;
      }
      {
      p___0 = longopts;
      { if(!(p___0 == & long_options[0LL])) { reach_error(); abort(); } };
      option_index___0 = 0;
      }
      {
      while (1) {
        while_continue___5: ;
        if (! p___0->name) {
          {
          goto while_break___5;
          }
        }
        if (0) {
          {
          if (0) {
            {
            {
            __s1_len___1 = __builtin_strlen((char const *)p___0->name);
            __s2_len___1 = __builtin_strlen((char const *)d->__nextchar);
            }
            if (! ((size_t )((void const *)(p___0->name + 1)) - (size_t )((void const *)p___0->name) == 1UL)) {
              {
              goto _L___13;
              }
            } else {
              {
              if (__s1_len___1 >= 4UL) {
                {
                _L___13:
                if (! ((size_t )((void const *)(d->__nextchar + 1)) - (size_t )((void const *)d->__nextchar) == 1UL)) {
                  {
                  {
                  tmp___54 = 1;
                  }
                  }
                } else {
                  {
                  if (__s2_len___1 >= 4UL) {
                    {
                    {
                    tmp___54 = 1;
                    }
                    }
                  } else {
                    {
                    {
                    tmp___54 = 0;
                    }
                    }
                  }
                  }
                }
                }
              } else {
                {
                {
                tmp___54 = 0;
                }
                }
              }
              }
            }
            if (tmp___54) {
              {
              {
              tmp___49 = __builtin_strcmp((char const *)p___0->name, (char const *)d->__nextchar);
              tmp___53 = tmp___49;
              }
              }
            } else {
              {
              {
              tmp___52 = __builtin_strcmp((char const *)p___0->name, (char const *)d->__nextchar);
              tmp___53 = tmp___52;
              }
              }
            }
            }
          } else {
            {
            {
            tmp___52 = __builtin_strcmp((char const *)p___0->name, (char const *)d->__nextchar);
            tmp___53 = tmp___52;
            }
            }
          }
          {
          tmp___56 = tmp___53;
          }
          }
        } else {
          {
          {
          tmp___55 = strncmp((char const *)p___0->name, (char const *)d->__nextchar,
                             (size_t )(nameend___0 - d->__nextchar));
          tmp___56 = tmp___55;
          }
          }
        }
        {
        { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
        { if(!(longind == 0)) { reach_error(); abort(); } };
        { if(!(long_only == 0)) { reach_error(); abort(); } };
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
        { if(!(exact___0 == 0)) { reach_error(); abort(); } };
        { if(!(argc != 0)) { reach_error(); abort(); } };
        { if(!(c != (char)58)) { reach_error(); abort(); } };
        { if(!(c != (char)59)) { reach_error(); abort(); } };
        if (! tmp___56) {
          {
          { if(!(tmp___56 == 0)) { reach_error(); abort(); } };
          {
          tmp___45 = strlen((char const *)p___0->name);
          }
          if ((size_t )((unsigned int )(nameend___0 - d->__nextchar)) == tmp___45) {
            {
            { if(!(d == & getopt_data)) { reach_error(); abort(); } };
            {
            pfound___0 = p___0;
            indfound___0 = option_index___0;
            exact___0 = 1;
            }
            goto while_break___5;
            }
          } else {
            {
            { if(!(d == & getopt_data)) { reach_error(); abort(); } };
            if ((unsigned long )pfound___0 == (unsigned long )((void *)0)) {
              {
              { if(!(pfound___0 == 0)) { reach_error(); abort(); } };
              {
              pfound___0 = p___0;
              indfound___0 = option_index___0;
              }
              }
            } else {
              {
              if (long_only) {
                {
                {
                ambig = 1;
                }
                }
              } else {
                {
                { if(!(long_only == 0)) { reach_error(); abort(); } };
                if (pfound___0->has_arg != p___0->has_arg) {
                  {
                  {
                  ambig = 1;
                  }
                  }
                } else {
                  {
                  if ((unsigned long )pfound___0->flag != (unsigned long )p___0->flag) {
                    {
                    {
                    ambig = 1;
                    }
                    }
                  } else {
                    {
                    if (pfound___0->val != p___0->val) {
                      {
                      {
                      ambig = 1;
                      }
                      }
                    }
                    }
                  }
                  }
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
        {
        p___0 ++;
        option_index___0 ++;
        }
      }
      while_break___5: ;
      }
      if (ambig) {
        {
        { if(!(ambig != 0)) { reach_error(); abort(); } };
        if (! exact___0) {
          {
          { if(!(exact___0 == 0)) { reach_error(); abort(); } };
          if (print_errors) {
            {
            { if(!(print_errors != 0)) { reach_error(); abort(); } };
            {
            tmp___59 = dcgettext((char const *)((void *)0), (char const *)"%s: option \'-W %s\' is ambiguous\n",
                                 5);
            fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )tmp___59),
                    *(argv + 0), d->rpl_optarg);
            { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
            { if(!(longind == 0)) { reach_error(); abort(); } };
            { if(!(long_only == 0)) { reach_error(); abort(); } };
            { if(!(d == & getopt_data)) { reach_error(); abort(); } };
            { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
            { if(!(exact___0 == 0)) { reach_error(); abort(); } };
            { if(!(argc != 0)) { reach_error(); abort(); } };
            { if(!(c != (char)58)) { reach_error(); abort(); } };
            { if(!(c != (char)59)) { reach_error(); abort(); } };
            { if(!(ambig != 0)) { reach_error(); abort(); } };
            }
            }
          }
          {
          { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
          { if(!(longind == 0)) { reach_error(); abort(); } };
          { if(!(long_only == 0)) { reach_error(); abort(); } };
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
          { if(!(exact___0 == 0)) { reach_error(); abort(); } };
          { if(!(argc != 0)) { reach_error(); abort(); } };
          { if(!(c != (char)58)) { reach_error(); abort(); } };
          { if(!(c != (char)59)) { reach_error(); abort(); } };
          { if(!(ambig != 0)) { reach_error(); abort(); } };
          {
          tmp___60 = strlen((char const *)d->__nextchar);
          d->__nextchar += tmp___60;
          (d->rpl_optind) ++;
          }
          }
          return ('?');
          }
        }
        }
      }
      {
      { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
      { if(!(longind == 0)) { reach_error(); abort(); } };
      { if(!(long_only == 0)) { reach_error(); abort(); } };
      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
      { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
      { if(!(argc != 0)) { reach_error(); abort(); } };
      { if(!(c != (char)58)) { reach_error(); abort(); } };
      { if(!(c != (char)59)) { reach_error(); abort(); } };
      if ((unsigned long )pfound___0 != (unsigned long )((void *)0)) {
        {
        {
        option_index___0 = indfound___0;
        }
        if (*nameend___0) {
          {
          if (pfound___0->has_arg) {
            {
            {
            d->rpl_optarg = nameend___0 + 1;
            }
            }
          } else {
            {
            if (print_errors) {
              {
              { if(!(print_errors != 0)) { reach_error(); abort(); } };
              {
              tmp___61 = dcgettext((char const *)((void *)0), (char const *)"%s: option \'-W %s\' doesn\'t allow an argument\n",
                                   5);
              fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )tmp___61),
                      *(argv + 0), pfound___0->name);
              { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
              { if(!(longind == 0)) { reach_error(); abort(); } };
              { if(!(long_only == 0)) { reach_error(); abort(); } };
              { if(!(d == & getopt_data)) { reach_error(); abort(); } };
              { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
              { if(!(argc != 0)) { reach_error(); abort(); } };
              { if(!(c != (char)58)) { reach_error(); abort(); } };
              { if(!(c != (char)59)) { reach_error(); abort(); } };
              }
              }
            }
            {
            { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
            { if(!(longind == 0)) { reach_error(); abort(); } };
            { if(!(long_only == 0)) { reach_error(); abort(); } };
            { if(!(d == & getopt_data)) { reach_error(); abort(); } };
            { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
            { if(!(argc != 0)) { reach_error(); abort(); } };
            { if(!(c != (char)58)) { reach_error(); abort(); } };
            { if(!(c != (char)59)) { reach_error(); abort(); } };
            {
            tmp___62 = strlen((char const *)d->__nextchar);
            d->__nextchar += tmp___62;
            }
            }
            return ('?');
            }
          }
          }
        } else {
          {
          if (pfound___0->has_arg == 1) {
            {
            if (d->rpl_optind < argc) {
              {
              {
              tmp___63 = d->rpl_optind;
              (d->rpl_optind) ++;
              d->rpl_optarg = *(argv + tmp___63);
              }
              }
            } else {
              {
              if (print_errors) {
                {
                {
                tmp___64 = dcgettext((char const *)((void *)0), (char const *)"%s: option \'-W %s\' requires an argument\n",
                                     5);
                fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )tmp___64),
                        *(argv + 0), pfound___0->name);
                }
                }
              }
              {
              tmp___65 = strlen((char const *)d->__nextchar);
              d->__nextchar += tmp___65;
              }
              if ((int const )*(optstring + 0) == 58) {
                {
                {
                tmp___66 = ':';
                }
                }
              } else {
                {
                {
                tmp___66 = '?';
                }
                }
              }
              return (tmp___66);
              }
            }
            }
          } else {
            {
            {
            d->rpl_optarg = (char *)((void *)0);
            }
            }
          }
          }
        }
        {
        tmp___67 = strlen((char const *)d->__nextchar);
        d->__nextchar += tmp___67;
        }
        if ((unsigned long )longind != (unsigned long )((void *)0)) {
          {
          {
          *longind = option_index___0;
          }
          }
        }
        {
        { if(!(longopts == & long_options[0LL])) { reach_error(); abort(); } };
        { if(!(longind == 0)) { reach_error(); abort(); } };
        { if(!(long_only == 0)) { reach_error(); abort(); } };
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
        { if(!(argc != 0)) { reach_error(); abort(); } };
        { if(!(c != (char)58)) { reach_error(); abort(); } };
        { if(!(c != (char)59)) { reach_error(); abort(); } };
        if (pfound___0->flag) {
          {
          {
          *(pfound___0->flag) = (int )pfound___0->val;
          }
          return (0);
          }
        }
        }
        return ((int )pfound___0->val);
        }
      }
      }
      no_longs:
      {
      { if(!(longind == 0)) { reach_error(); abort(); } };
      { if(!(long_only == 0)) { reach_error(); abort(); } };
      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
      { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
      { if(!(pfound___0 == 0)) { reach_error(); abort(); } };
      { if(!(argc != 0)) { reach_error(); abort(); } };
      { if(!(c != (char)58)) { reach_error(); abort(); } };
      { if(!(c != (char)59)) { reach_error(); abort(); } };
      { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
      {
      d->__nextchar = (char *)((void *)0);
      }
      }
      return ('W');
      }
    }
    }
  }
  {
  { if(!(longind == 0)) { reach_error(); abort(); } };
  { if(!(long_only == 0)) { reach_error(); abort(); } };
  { if(!(d == & getopt_data)) { reach_error(); abort(); } };
  { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
  { if(!(argc != 0)) { reach_error(); abort(); } };
  { if(!(c != (char)58)) { reach_error(); abort(); } };
  { if(!(c != (char)59)) { reach_error(); abort(); } };
  { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
  if ((int const )*(temp + 1) == 58) {
    {
    if ((int const )*(temp + 2) == 58) {
      {
      if ((int )*(d->__nextchar) != 0) {
        {
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        {
        d->rpl_optarg = d->__nextchar;
        (d->rpl_optind) ++;
        }
        }
      } else {
        {
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        {
        d->rpl_optarg = (char *)((void *)0);
        }
        }
      }
      {
      { if(!(longind == 0)) { reach_error(); abort(); } };
      { if(!(long_only == 0)) { reach_error(); abort(); } };
      { if(!(d == & getopt_data)) { reach_error(); abort(); } };
      { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
      { if(!(argc != 0)) { reach_error(); abort(); } };
      { if(!(c != (char)58)) { reach_error(); abort(); } };
      { if(!(c != (char)59)) { reach_error(); abort(); } };
      { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
      {
      d->__nextchar = (char *)((void *)0);
      }
      }
      }
    } else {
      {
      if ((int )*(d->__nextchar) != 0) {
        {
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        {
        d->rpl_optarg = d->__nextchar;
        (d->rpl_optind) ++;
        }
        }
      } else {
        {
        { if(!(d == & getopt_data)) { reach_error(); abort(); } };
        if (d->rpl_optind == argc) {
          {
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          { if(!(argc != 0)) { reach_error(); abort(); } };
          if (print_errors) {
            {
            { if(!(print_errors != 0)) { reach_error(); abort(); } };
            {
            tmp___68 = dcgettext((char const *)((void *)0), (char const *)"%s: option requires an argument -- \'%c\'\n",
                                 5);
            fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )tmp___68),
                    *(argv + 0), (int )c);
            { if(!(longind == 0)) { reach_error(); abort(); } };
            { if(!(long_only == 0)) { reach_error(); abort(); } };
            { if(!(d == & getopt_data)) { reach_error(); abort(); } };
            { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
            { if(!(argc != 0)) { reach_error(); abort(); } };
            { if(!(c != (char)58)) { reach_error(); abort(); } };
            { if(!(c != (char)59)) { reach_error(); abort(); } };
            { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
            }
            }
          }
          {
          { if(!(longind == 0)) { reach_error(); abort(); } };
          { if(!(long_only == 0)) { reach_error(); abort(); } };
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          { if(!(posixly_correct == 0)) { reach_error(); abort(); } };
          { if(!(argc != 0)) { reach_error(); abort(); } };
          { if(!(c != (char)58)) { reach_error(); abort(); } };
          { if(!(c != (char)59)) { reach_error(); abort(); } };
          { if(!(longopts == & long_options[0LL] || longopts == 0)) { reach_error(); abort(); } };
          {
          d->rpl_optopt = (int )c;
          }
          }
          if ((int const )*(optstring + 0) == 58) {
            {
            {
            c = (char )':';
            { if(!(c != (char)59)) { reach_error(); abort(); } };
            }
            }
          } else {
            {
            {
            c = (char )'?';
            { if(!(c != (char)59)) { reach_error(); abort(); } };
            }
            }
          }
          }
        } else {
          {
          { if(!(d == & getopt_data)) { reach_error(); abort(); } };
          { if(!(argc != 0)) { reach_error(); abort(); } };
          {
          tmp___69 = d->rpl_optind;
          (d->rpl_optind) ++;
          d->rpl_optarg = *(argv + tmp___69);
          }
          }
        }
        }
      }
      {
      d->__nextchar = (char *)((void *)0);
      }
      }
    }
    }
  }
  }
  return ((int )c);
}
}
int rpl_getopt_internal(int argc , char **argv , char const *optstring , struct rpl_option const *longopts ,
                        int *longind , int long_only , int posixly_correct )
{
  int result ;
  {
  {
  getopt_data.rpl_optind = rpl_optind;
  getopt_data.rpl_opterr = rpl_opterr;
  result = _getopt_internal_r(argc, argv, optstring, longopts, longind, long_only,
                              & getopt_data, posixly_correct);
  rpl_optind = getopt_data.rpl_optind;
  rpl_optarg = getopt_data.rpl_optarg;
  rpl_optopt = getopt_data.rpl_optopt;
  }
  return (result);
}
}
int ( __attribute__((__nonnull__(2,3))) rpl_getopt)(int argc , char **argv , char const *optstring ) __attribute__((__nothrow__)) ;
int ( __attribute__((__nonnull__(2,3))) rpl_getopt)(int argc , char **argv , char const *optstring )
{
  int tmp ;
  {
  {
  tmp = rpl_getopt_internal(argc, (char **)argv, optstring, (struct rpl_option const *)0,
                            (int *)0, 0, 1);
  }
  return (tmp);
}
}
int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long)(int argc , char **argv ,
                                                         char const *options , struct rpl_option const *long_options___0 ,
                                                         int *opt_index ) __attribute__((__nothrow__)) ;
int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long)(int argc , char **argv ,
                                                         char const *options , struct rpl_option const *long_options___0 ,
                                                         int *opt_index )
{
  int tmp ;
  {
  {
  tmp = rpl_getopt_internal(argc, argv, options, long_options___0, opt_index, 0, 0);
  }
  return (tmp);
}
}
int _getopt_long_r(int argc , char **argv , char const *options , struct rpl_option const *long_options___0 ,
                   int *opt_index , struct _getopt_data *d )
{
  int tmp ;
  {
  {
  tmp = _getopt_internal_r(argc, argv, options, long_options___0, opt_index, 0, d,
                           0);
  }
  return (tmp);
}
}
int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long_only)(int argc , char **argv ,
                                                              char const *options ,
                                                              struct rpl_option const *long_options___0 ,
                                                              int *opt_index ) __attribute__((__nothrow__)) ;
int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long_only)(int argc , char **argv ,
                                                              char const *options ,
                                                              struct rpl_option const *long_options___0 ,
                                                              int *opt_index )
{
  int tmp ;
  {
  {
  tmp = rpl_getopt_internal(argc, argv, options, long_options___0, opt_index, 1, 0);
  }
  return (tmp);
}
}
int _getopt_long_only_r(int argc , char **argv , char const *options , struct rpl_option const *long_options___0 ,
                        int *opt_index , struct _getopt_data *d )
{
  int tmp ;
  {
  {
  tmp = _getopt_internal_r(argc, argv, options, long_options___0, opt_index, 1, d,
                           0);
  }
  return (tmp);
}
}
static void call_fclose(void *arg )
{
  {
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
    {
    {
    rpl_fclose((FILE *)arg);
    }
    }
  }
  return;
}
}
char *( __attribute__((__nonnull__(1))) gnu_getpass)(char const *prompt )
{
  FILE *tty ;
  FILE *in ;
  FILE *out ;
  struct termios s ;
  struct termios t ;
  _Bool tty_changed ;
  ssize_t nread ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  {
  tty_changed = (_Bool)0;
  tty = fopen((char const * __restrict )"/dev/tty", (char const * __restrict )"w+");
  }
  if ((unsigned long )tty == (unsigned long )((void *)0)) {
    {
    {
    in = stdin;
    out = stderr;
    }
    }
  } else {
    {
    {
    __fsetlocking(tty, 2);
    in = tty;
    out = in;
    }
    }
  }
  {
  tmp___1 = fileno(in);
  tmp___2 = tcgetattr(tmp___1, & t);
  }
  if (tmp___2 == 0) {
    {
    {
    s = t;
    t.c_lflag &= 4294967286U;
    tmp = fileno(in);
    tmp___0 = tcsetattr(tmp, 2, (struct termios const *)(& t));
    tty_changed = (_Bool )(tmp___0 == 0);
    }
    }
  }
  {
  fputs_unlocked((char const * __restrict )prompt, (FILE * __restrict )out);
  fflush_unlocked(out);
  nread = getline((char **)((char ** __restrict )(& buf)), (size_t *)((size_t * __restrict )(& bufsize)),
                  (FILE *)((FILE * __restrict )in));
  rpl_fseeko(out, (off_t )0, 1);
  }
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
    {
    if (nread < 0L) {
      {
      {
      *(buf + 0) = (char )'\000';
      }
      }
    } else {
      {
      if ((int )*(buf + (nread - 1L)) == 10) {
        {
        {
        *(buf + (nread - 1L)) = (char )'\000';
        }
        if (tty_changed) {
          {
          {
          fputc_unlocked('\n', out);
          }
          }
        }
        }
      }
      }
    }
    }
  }
  if (tty_changed) {
    {
    {
    tmp___3 = fileno(in);
    tcsetattr(tmp___3, 2, (struct termios const *)(& s));
    }
    }
  }
  {
  call_fclose((void *)tty);
  }
  return (buf);
}
}
int isapipe(int fd )
{
  nlink_t pipe_link_count_max ;
  _Bool check_for_fifo ;
  struct stat st ;
  int fstat_result ;
  int tmp ;
  int tmp___4 ;
  int tmp___5 ;
  {
  {
  pipe_link_count_max = (nlink_t )1;
  check_for_fifo = (_Bool)1;
  tmp = fstat(fd, & st);
  fstat_result = tmp;
  }
  if (fstat_result != 0) {
    {
    return (fstat_result);
    }
  }
  if (st.st_nlink <= pipe_link_count_max) {
    {
    if (check_for_fifo) {
      {
      {
      tmp___4 = (st.st_mode & 61440U) == 4096U;
      }
      }
    } else {
      {
      {
      tmp___4 = (st.st_mode & 61440U) == 49152U;
      }
      }
    }
    if (tmp___4) {
      {
      {
      tmp___5 = 1;
      }
      }
    } else {
      {
      {
      tmp___5 = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp___5 = 0;
    }
    }
  }
  return (tmp___5);
}
}
int rpl_isnanl(long double x )
{
  memory_double m ;
  unsigned int exponent ;
  {
  {
  m.value = x;
  exponent = m.word[2] & 32767U;
  }
  if (exponent == 0U) {
    {
    return ((int )(m.word[1] >> 31));
    }
  } else {
    {
    if (exponent == 32767U) {
      {
      return (((m.word[1] ^ 2147483648U) | m.word[0]) != 0U);
      }
    } else {
      {
      return ((int )((m.word[1] >> 31) ^ 1U));
      }
    }
    }
  }
}
}
static int linkat_follow(int fd1 , char const *file1 , int fd2 , char const *file2 )
{
  char *name ;
  char *target ;
  int result ;
  int i ;
  char *dir ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int saved_errno ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int saved_errno___0 ;
  int *tmp___7 ;
  int *tmp___8 ;
  {
  {
  name = (char *)file1;
  i = 20;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    tmp___2 = i;
    i --;
    }
    if (tmp___2) {
      {
      {
      target = areadlinkat(fd1, (char const *)name);
      }
      if (! target) {
        {
        goto while_break;
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
    if ((int )*(target + 0) == 47) {
      {
      goto _L;
      }
    } else {
      {
      if (0) {
        {
        _L:
        if ((unsigned long )name != (unsigned long )file1) {
          {
          {
          free((void *)name);
          }
          }
        }
        {
        name = target;
        }
        }
      } else {
        {
        {
        tmp = mdir_name((char const *)name);
        dir = tmp;
        }
        if ((unsigned long )name != (unsigned long )file1) {
          {
          {
          free((void *)name);
          }
          }
        }
        if (! dir) {
          {
          {
          free((void *)target);
          tmp___0 = __errno_location();
          *tmp___0 = 12;
          }
          return (-1);
          }
        }
        {
        name = mfile_name_concat((char const *)dir, (char const *)target, (char **)((void *)0));
        free((void *)dir);
        free((void *)target);
        }
        if (! name) {
          {
          {
          tmp___1 = __errno_location();
          *tmp___1 = 12;
          }
          return (-1);
          }
        }
        }
      }
      }
    }
  }
  while_break: ;
  }
  if (i < 0) {
    {
    {
    target = (char *)((void *)0);
    tmp___3 = __errno_location();
    *tmp___3 = 40;
    }
    }
  }
  if (! target) {
    {
    {
    tmp___6 = __errno_location();
    }
    if (*tmp___6 != 22) {
      {
      if ((unsigned long )name != (unsigned long )file1) {
        {
        {
        tmp___4 = __errno_location();
        saved_errno = *tmp___4;
        free((void *)name);
        tmp___5 = __errno_location();
        *tmp___5 = saved_errno;
        }
        }
      }
      return (-1);
      }
    }
    }
  }
  {
  result = linkat(fd1, (char const *)name, fd2, file2, 0);
  }
  if ((unsigned long )name != (unsigned long )file1) {
    {
    {
    tmp___7 = __errno_location();
    saved_errno___0 = *tmp___7;
    free((void *)name);
    tmp___8 = __errno_location();
    *tmp___8 = saved_errno___0;
    }
    }
  }
  return (result);
}
}
int ( __attribute__((__nonnull__(2,4))) rpl_linkat)(int fd1 , char const *file1 ,
                                                    int fd2 , char const *file2 ,
                                                    int flag )
{
  int *tmp ;
  int tmp___0 ;
  int result ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  {
  if (flag & -1025) {
    {
    {
    tmp = __errno_location();
    *tmp = 22;
    }
    return (-1);
    }
  }
  if (! flag) {
    {
    {
    tmp___0 = linkat(fd1, file1, fd2, file2, flag);
    }
    return (tmp___0);
    }
  }
  if (0 <= have_follow_really) {
    {
    {
    tmp___1 = linkat(fd1, file1, fd2, file2, flag);
    result = tmp___1;
    }
    if (result == -1) {
      {
      {
      tmp___2 = __errno_location();
      }
      if (! (*tmp___2 == 22)) {
        {
        {
        have_follow_really = 1;
        }
        return (result);
        }
      }
      }
    } else {
      {
      {
      have_follow_really = 1;
      }
      return (result);
      }
    }
    {
    have_follow_really = -1;
    }
    }
  }
  {
  tmp___3 = linkat_follow(fd1, file1, fd2, file2);
  }
  return (tmp___3);
}
}
static dev_t dev_from_mount_options(char const *mount_options )
{
  {
  return ((dev_t )-1);
}
}
struct mount_entry *read_file_system_list(_Bool need_fs_type )
{
  struct mount_entry *mount_list ;
  struct mount_entry *me ;
  struct mount_entry **mtail ;
  struct mntent *mnt ;
  char const *table___0 ;
  FILE *fp ;
  void *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___29 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___36 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  char *tmp___44 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___46 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___53 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int saved_errno ;
  int *tmp___61 ;
  int *tmp___62 ;
  {
  {
  mtail = & mount_list;
  table___0 = (char const *)"/etc/mtab";
  fp = setmntent(table___0, (char const *)"r");
  }
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
    return ((struct mount_entry *)((void *)0));
    }
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    mnt = getmntent(fp);
    }
    if (! mnt) {
      {
      goto while_break;
      }
    }
    {
    tmp = xmalloc(sizeof(*me));
    me = (struct mount_entry *)tmp;
    me->me_devname = xstrdup((char const *)mnt->mnt_fsname);
    me->me_mountdir = xstrdup((char const *)mnt->mnt_dir);
    me->me_type = xstrdup((char const *)mnt->mnt_type);
    me->me_type_malloced = 1U;
    }
    if (0) {
      {
      {
      __s1_len = __builtin_strlen((char const *)me->me_type);
      __s2_len = __builtin_strlen((char const *)"autofs");
      }
      if (! ((size_t )((void const *)(me->me_type + 1)) - (size_t )((void const *)me->me_type) == 1UL)) {
        {
        goto _L___0;
        }
      } else {
        {
        if (__s1_len >= 4UL) {
          {
          _L___0:
          if (! ((size_t )((void const *)("autofs" + 1)) - (size_t )((void const *)"autofs") == 1UL)) {
            {
            {
            tmp___6 = 1;
            }
            }
          } else {
            {
            if (__s2_len >= 4UL) {
              {
              {
              tmp___6 = 1;
              }
              }
            } else {
              {
              {
              tmp___6 = 0;
              }
              }
            }
            }
          }
          }
        } else {
          {
          {
          tmp___6 = 0;
          }
          }
        }
        }
      }
      if (tmp___6) {
        {
        {
        tmp___1 = __builtin_strcmp((char const *)me->me_type, (char const *)"autofs");
        tmp___5 = tmp___1;
        }
        }
      } else {
        {
        {
        tmp___4 = __builtin_strcmp((char const *)me->me_type, (char const *)"autofs");
        tmp___5 = tmp___4;
        }
        }
      }
      }
    } else {
      {
      {
      tmp___4 = __builtin_strcmp((char const *)me->me_type, (char const *)"autofs");
      tmp___5 = tmp___4;
      }
      }
    }
    if (tmp___5 == 0) {
      {
      {
      tmp___42 = 1;
      }
      }
    } else {
      {
      if (0) {
        {
        {
        __s1_len___0 = __builtin_strlen((char const *)me->me_type);
        __s2_len___0 = __builtin_strlen((char const *)"none");
        }
        if (! ((size_t )((void const *)(me->me_type + 1)) - (size_t )((void const *)me->me_type) == 1UL)) {
          {
          goto _L___2;
          }
        } else {
          {
          if (__s1_len___0 >= 4UL) {
            {
            _L___2:
            if (! ((size_t )((void const *)("none" + 1)) - (size_t )((void const *)"none") == 1UL)) {
              {
              {
              tmp___13 = 1;
              }
              }
            } else {
              {
              if (__s2_len___0 >= 4UL) {
                {
                {
                tmp___13 = 1;
                }
                }
              } else {
                {
                {
                tmp___13 = 0;
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            tmp___13 = 0;
            }
            }
          }
          }
        }
        if (tmp___13) {
          {
          {
          tmp___8 = __builtin_strcmp((char const *)me->me_type, (char const *)"none");
          tmp___12 = tmp___8;
          }
          }
        } else {
          {
          {
          tmp___11 = __builtin_strcmp((char const *)me->me_type, (char const *)"none");
          tmp___12 = tmp___11;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___11 = __builtin_strcmp((char const *)me->me_type, (char const *)"none");
        tmp___12 = tmp___11;
        }
        }
      }
      if (tmp___12 == 0) {
        {
        {
        tmp___42 = 1;
        }
        }
      } else {
        {
        if (0) {
          {
          {
          __s1_len___1 = __builtin_strlen((char const *)me->me_type);
          __s2_len___1 = __builtin_strlen((char const *)"proc");
          }
          if (! ((size_t )((void const *)(me->me_type + 1)) - (size_t )((void const *)me->me_type) == 1UL)) {
            {
            goto _L___4;
            }
          } else {
            {
            if (__s1_len___1 >= 4UL) {
              {
              _L___4:
              if (! ((size_t )((void const *)("proc" + 1)) - (size_t )((void const *)"proc") == 1UL)) {
                {
                {
                tmp___20 = 1;
                }
                }
              } else {
                {
                if (__s2_len___1 >= 4UL) {
                  {
                  {
                  tmp___20 = 1;
                  }
                  }
                } else {
                  {
                  {
                  tmp___20 = 0;
                  }
                  }
                }
                }
              }
              }
            } else {
              {
              {
              tmp___20 = 0;
              }
              }
            }
            }
          }
          if (tmp___20) {
            {
            {
            tmp___15 = __builtin_strcmp((char const *)me->me_type, (char const *)"proc");
            tmp___19 = tmp___15;
            }
            }
          } else {
            {
            {
            tmp___18 = __builtin_strcmp((char const *)me->me_type, (char const *)"proc");
            tmp___19 = tmp___18;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___18 = __builtin_strcmp((char const *)me->me_type, (char const *)"proc");
          tmp___19 = tmp___18;
          }
          }
        }
        if (tmp___19 == 0) {
          {
          {
          tmp___42 = 1;
          }
          }
        } else {
          {
          if (0) {
            {
            {
            __s1_len___2 = __builtin_strlen((char const *)me->me_type);
            __s2_len___2 = __builtin_strlen((char const *)"subfs");
            }
            if (! ((size_t )((void const *)(me->me_type + 1)) - (size_t )((void const *)me->me_type) == 1UL)) {
              {
              goto _L___6;
              }
            } else {
              {
              if (__s1_len___2 >= 4UL) {
                {
                _L___6:
                if (! ((size_t )((void const *)("subfs" + 1)) - (size_t )((void const *)"subfs") == 1UL)) {
                  {
                  {
                  tmp___27 = 1;
                  }
                  }
                } else {
                  {
                  if (__s2_len___2 >= 4UL) {
                    {
                    {
                    tmp___27 = 1;
                    }
                    }
                  } else {
                    {
                    {
                    tmp___27 = 0;
                    }
                    }
                  }
                  }
                }
                }
              } else {
                {
                {
                tmp___27 = 0;
                }
                }
              }
              }
            }
            if (tmp___27) {
              {
              {
              tmp___22 = __builtin_strcmp((char const *)me->me_type, (char const *)"subfs");
              tmp___26 = tmp___22;
              }
              }
            } else {
              {
              {
              tmp___25 = __builtin_strcmp((char const *)me->me_type, (char const *)"subfs");
              tmp___26 = tmp___25;
              }
              }
            }
            }
          } else {
            {
            {
            tmp___25 = __builtin_strcmp((char const *)me->me_type, (char const *)"subfs");
            tmp___26 = tmp___25;
            }
            }
          }
          if (tmp___26 == 0) {
            {
            {
            tmp___42 = 1;
            }
            }
          } else {
            {
            if (0) {
              {
              {
              __s1_len___3 = __builtin_strlen((char const *)me->me_type);
              __s2_len___3 = __builtin_strlen((char const *)"kernfs");
              }
              if (! ((size_t )((void const *)(me->me_type + 1)) - (size_t )((void const *)me->me_type) == 1UL)) {
                {
                goto _L___8;
                }
              } else {
                {
                if (__s1_len___3 >= 4UL) {
                  {
                  _L___8:
                  if (! ((size_t )((void const *)("kernfs" + 1)) - (size_t )((void const *)"kernfs") == 1UL)) {
                    {
                    {
                    tmp___34 = 1;
                    }
                    }
                  } else {
                    {
                    if (__s2_len___3 >= 4UL) {
                      {
                      {
                      tmp___34 = 1;
                      }
                      }
                    } else {
                      {
                      {
                      tmp___34 = 0;
                      }
                      }
                    }
                    }
                  }
                  }
                } else {
                  {
                  {
                  tmp___34 = 0;
                  }
                  }
                }
                }
              }
              if (tmp___34) {
                {
                {
                tmp___29 = __builtin_strcmp((char const *)me->me_type, (char const *)"kernfs");
                tmp___33 = tmp___29;
                }
                }
              } else {
                {
                {
                tmp___32 = __builtin_strcmp((char const *)me->me_type, (char const *)"kernfs");
                tmp___33 = tmp___32;
                }
                }
              }
              }
            } else {
              {
              {
              tmp___32 = __builtin_strcmp((char const *)me->me_type, (char const *)"kernfs");
              tmp___33 = tmp___32;
              }
              }
            }
            if (tmp___33 == 0) {
              {
              {
              tmp___42 = 1;
              }
              }
            } else {
              {
              if (0) {
                {
                {
                __s1_len___4 = __builtin_strlen((char const *)me->me_type);
                __s2_len___4 = __builtin_strlen((char const *)"ignore");
                }
                if (! ((size_t )((void const *)(me->me_type + 1)) - (size_t )((void const *)me->me_type) == 1UL)) {
                  {
                  goto _L___10;
                  }
                } else {
                  {
                  if (__s1_len___4 >= 4UL) {
                    {
                    _L___10:
                    if (! ((size_t )((void const *)("ignore" + 1)) - (size_t )((void const *)"ignore") == 1UL)) {
                      {
                      {
                      tmp___41 = 1;
                      }
                      }
                    } else {
                      {
                      if (__s2_len___4 >= 4UL) {
                        {
                        {
                        tmp___41 = 1;
                        }
                        }
                      } else {
                        {
                        {
                        tmp___41 = 0;
                        }
                        }
                      }
                      }
                    }
                    }
                  } else {
                    {
                    {
                    tmp___41 = 0;
                    }
                    }
                  }
                  }
                }
                if (tmp___41) {
                  {
                  {
                  tmp___36 = __builtin_strcmp((char const *)me->me_type, (char const *)"ignore");
                  tmp___40 = tmp___36;
                  }
                  }
                } else {
                  {
                  {
                  tmp___39 = __builtin_strcmp((char const *)me->me_type, (char const *)"ignore");
                  tmp___40 = tmp___39;
                  }
                  }
                }
                }
              } else {
                {
                {
                tmp___39 = __builtin_strcmp((char const *)me->me_type, (char const *)"ignore");
                tmp___40 = tmp___39;
                }
                }
              }
              if (tmp___40 == 0) {
                {
                {
                tmp___42 = 1;
                }
                }
              } else {
                {
                {
                tmp___42 = 0;
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    {
    me->me_dummy = (unsigned int )tmp___42;
    tmp___44 = __builtin_strchr(me->me_devname, ':');
    }
    if ((unsigned long )tmp___44 != (unsigned long )((void *)0)) {
      {
      {
      tmp___59 = 1;
      }
      }
    } else {
      {
      if ((int )*(me->me_devname + 0) == 47) {
        {
        if ((int )*(me->me_devname + 1) == 47) {
          {
          if (0) {
            {
            {
            __s1_len___5 = __builtin_strlen((char const *)me->me_type);
            __s2_len___5 = __builtin_strlen((char const *)"smbfs");
            }
            if (! ((size_t )((void const *)(me->me_type + 1)) - (size_t )((void const *)me->me_type) == 1UL)) {
              {
              goto _L___12;
              }
            } else {
              {
              if (__s1_len___5 >= 4UL) {
                {
                _L___12:
                if (! ((size_t )((void const *)("smbfs" + 1)) - (size_t )((void const *)"smbfs") == 1UL)) {
                  {
                  {
                  tmp___51 = 1;
                  }
                  }
                } else {
                  {
                  if (__s2_len___5 >= 4UL) {
                    {
                    {
                    tmp___51 = 1;
                    }
                    }
                  } else {
                    {
                    {
                    tmp___51 = 0;
                    }
                    }
                  }
                  }
                }
                }
              } else {
                {
                {
                tmp___51 = 0;
                }
                }
              }
              }
            }
            if (tmp___51) {
              {
              {
              tmp___46 = __builtin_strcmp((char const *)me->me_type, (char const *)"smbfs");
              tmp___50 = tmp___46;
              }
              }
            } else {
              {
              {
              tmp___49 = __builtin_strcmp((char const *)me->me_type, (char const *)"smbfs");
              tmp___50 = tmp___49;
              }
              }
            }
            }
          } else {
            {
            {
            tmp___49 = __builtin_strcmp((char const *)me->me_type, (char const *)"smbfs");
            tmp___50 = tmp___49;
            }
            }
          }
          if (tmp___50 == 0) {
            {
            {
            tmp___59 = 1;
            }
            }
          } else {
            {
            if (0) {
              {
              {
              __s1_len___6 = __builtin_strlen((char const *)me->me_type);
              __s2_len___6 = __builtin_strlen((char const *)"cifs");
              }
              if (! ((size_t )((void const *)(me->me_type + 1)) - (size_t )((void const *)me->me_type) == 1UL)) {
                {
                goto _L___14;
                }
              } else {
                {
                if (__s1_len___6 >= 4UL) {
                  {
                  _L___14:
                  if (! ((size_t )((void const *)("cifs" + 1)) - (size_t )((void const *)"cifs") == 1UL)) {
                    {
                    {
                    tmp___58 = 1;
                    }
                    }
                  } else {
                    {
                    if (__s2_len___6 >= 4UL) {
                      {
                      {
                      tmp___58 = 1;
                      }
                      }
                    } else {
                      {
                      {
                      tmp___58 = 0;
                      }
                      }
                    }
                    }
                  }
                  }
                } else {
                  {
                  {
                  tmp___58 = 0;
                  }
                  }
                }
                }
              }
              if (tmp___58) {
                {
                {
                tmp___53 = __builtin_strcmp((char const *)me->me_type, (char const *)"cifs");
                tmp___57 = tmp___53;
                }
                }
              } else {
                {
                {
                tmp___56 = __builtin_strcmp((char const *)me->me_type, (char const *)"cifs");
                tmp___57 = tmp___56;
                }
                }
              }
              }
            } else {
              {
              {
              tmp___56 = __builtin_strcmp((char const *)me->me_type, (char const *)"cifs");
              tmp___57 = tmp___56;
              }
              }
            }
            if (tmp___57 == 0) {
              {
              {
              tmp___59 = 1;
              }
              }
            } else {
              {
              {
              tmp___59 = 0;
              }
              }
            }
            }
          }
          }
        } else {
          {
          {
          tmp___59 = 0;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___59 = 0;
        }
        }
      }
      }
    }
    {
    me->me_remote = (unsigned int )tmp___59;
    me->me_dev = dev_from_mount_options((char const *)mnt->mnt_opts);
    *mtail = me;
    mtail = & me->me_next;
    }
  }
  while_break: ;
  }
  {
  tmp___60 = endmntent(fp);
  }
  if (tmp___60 == 0) {
    {
    goto free_then_fail;
    }
  }
  {
  *mtail = (struct mount_entry *)((void *)0);
  }
  return (mount_list);
  free_then_fail:
  {
  tmp___61 = __errno_location();
  saved_errno = *tmp___61;
  *mtail = (struct mount_entry *)((void *)0);
  }
  {
  while (1) {
    while_continue___0: ;
    if (! mount_list) {
      {
      goto while_break___0;
      }
    }
    {
    me = mount_list->me_next;
    free((void *)mount_list->me_devname);
    free((void *)mount_list->me_mountdir);
    }
    if (mount_list->me_type_malloced) {
      {
      {
      free((void *)mount_list->me_type);
      }
      }
    }
    {
    free((void *)mount_list);
    mount_list = me;
    }
  }
  while_break___0: ;
  }
  {
  tmp___62 = __errno_location();
  *tmp___62 = saved_errno;
  }
  return ((struct mount_entry *)((void *)0));
}
}
int ( __attribute__((__nonnull__(1))) rpl_nanosleep)(struct timespec const *requested_delay ,
                                                     struct timespec *remaining_delay )
{
  int *tmp ;
  time_t limit ;
  time_t seconds ;
  struct timespec intermediate ;
  int result ;
  int tmp___0 ;
  {
  if (requested_delay->tv_nsec < 0L) {
    {
    {
    tmp = __errno_location();
    *tmp = 22;
    }
    return (-1);
    }
  } else {
    {
    if (1000000000L <= (long )requested_delay->tv_nsec) {
      {
      {
      tmp = __errno_location();
      *tmp = 22;
      }
      return (-1);
      }
    }
    }
  }
  {
  limit = (time_t )2073600;
  seconds = (time_t )requested_delay->tv_sec;
  intermediate.tv_nsec = (long )requested_delay->tv_nsec;
  }
  {
  while (1) {
    while_continue: ;
    if (! (limit < seconds)) {
      {
      goto while_break;
      }
    }
    {
    intermediate.tv_sec = limit;
    result = nanosleep((struct timespec const *)(& intermediate), remaining_delay);
    seconds -= limit;
    }
    if (result) {
      {
      if (remaining_delay) {
        {
        {
        remaining_delay->tv_sec += seconds;
        }
        }
      }
      return (result);
      }
    }
    {
    intermediate.tv_nsec = 0L;
    }
  }
  while_break: ;
  }
  {
  intermediate.tv_sec = seconds;
  tmp___0 = nanosleep((struct timespec const *)(& intermediate), remaining_delay);
  }
  return (tmp___0);
}
}
char *openat_proc_name(char *buf___1 , int fd , char const *file )
{
  int proc_self_fd ;
  int tmp ;
  char dotdot_buf[(((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL)) + (sizeof("../fd") - 1UL)) + 1UL] ;
  int tmp___1 ;
  size_t bufsize___0 ;
  size_t tmp___2 ;
  char *result ;
  void *tmp___3 ;
  {
  if (! *file) {
    {
    {
    *(buf___1 + 0) = (char )'\000';
    }
    return (buf___1);
    }
  }
  if (! proc_status) {
    {
    {
    tmp = open((char const *)"/proc/self/fd", 67840);
    proc_self_fd = tmp;
    }
    if (proc_self_fd < 0) {
      {
      {
      proc_status = -1;
      }
      }
    } else {
      {
      {
      sprintf((char *)((char * __restrict )(dotdot_buf)), (char const *)((char const * __restrict )"/proc/self/fd/%d/%s"),
              proc_self_fd, "../fd");
      tmp___1 = access((char const *)(dotdot_buf), 0);
      }
      if (tmp___1) {
        {
        {
        proc_status = -1;
        }
        }
      } else {
        {
        {
        proc_status = 1;
        }
        }
      }
      {
      close(proc_self_fd);
      }
      }
    }
    }
  }
  if (proc_status < 0) {
    {
    return ((char *)((void *)0));
    }
  } else {
    {
    {
    tmp___2 = strlen(file);
    bufsize___0 = (((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL)) + tmp___2) + 1UL;
    result = buf___1;
    }
    if (4032UL < bufsize___0) {
      {
      {
      tmp___3 = malloc(bufsize___0);
      result = (char *)tmp___3;
      }
      if (! result) {
        {
        return ((char *)((void *)0));
        }
      }
      }
    }
    {
    sprintf((char *)((char * __restrict )result), (char const *)((char const * __restrict )"/proc/self/fd/%d/%s"),
            fd, file);
    }
    return (result);
    }
  }
}
}
int printf_fetchargs(va_list args , arguments *a )
{
  size_t i ;
  argument *ap ;
  int tmp ;
  wint_t tmp___0 ;
  signed char tmp___1 ;
  unsigned char tmp___2 ;
  short tmp___3 ;
  unsigned short tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  long tmp___7 ;
  unsigned long tmp___8 ;
  long long tmp___9 ;
  unsigned long long tmp___10 ;
  double tmp___11 ;
  long double tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  wint_t tmp___15 ;
  char const *tmp___16 ;
  wchar_t const *tmp___17 ;
  void *tmp___18 ;
  signed char *tmp___19 ;
  short *tmp___20 ;
  int *tmp___21 ;
  long *tmp___22 ;
  long long *tmp___23 ;
  {
  {
  i = (size_t )0;
  ap = a->arg + 0;
  }
  {
  while (1) {
    while_continue: ;
    if (! (i < a->count)) {
      {
      goto while_break;
      }
    }
    {
    if ((int )ap->type == 1) {
      {
      goto case_1;
      }
    }
    if ((int )ap->type == 2) {
      {
      goto case_2;
      }
    }
    if ((int )ap->type == 3) {
      {
      goto case_3;
      }
    }
    if ((int )ap->type == 4) {
      {
      goto case_4;
      }
    }
    if ((int )ap->type == 5) {
      {
      goto case_5;
      }
    }
    if ((int )ap->type == 6) {
      {
      goto case_6;
      }
    }
    if ((int )ap->type == 7) {
      {
      goto case_7;
      }
    }
    if ((int )ap->type == 8) {
      {
      goto case_8;
      }
    }
    if ((int )ap->type == 9) {
      {
      goto case_9;
      }
    }
    if ((int )ap->type == 10) {
      {
      goto case_10;
      }
    }
    if ((int )ap->type == 11) {
      {
      goto case_11;
      }
    }
    if ((int )ap->type == 12) {
      {
      goto case_12;
      }
    }
    if ((int )ap->type == 13) {
      {
      goto case_13;
      }
    }
    if ((int )ap->type == 14) {
      {
      goto case_14;
      }
    }
    if ((int )ap->type == 15) {
      {
      goto case_15;
      }
    }
    if ((int )ap->type == 16) {
      {
      goto case_16;
      }
    }
    if ((int )ap->type == 17) {
      {
      goto case_17;
      }
    }
    if ((int )ap->type == 18) {
      {
      goto case_18;
      }
    }
    if ((int )ap->type == 19) {
      {
      goto case_19;
      }
    }
    if ((int )ap->type == 20) {
      {
      goto case_20;
      }
    }
    if ((int )ap->type == 21) {
      {
      goto case_21;
      }
    }
    if ((int )ap->type == 22) {
      {
      goto case_22;
      }
    }
    goto switch_default;
    case_1:
    {
    tmp___1 = __builtin_va_arg(args, int );
    ap->a.a_schar = tmp___1;
    }
    goto switch_break;
    case_2:
    {
    tmp___2 = __builtin_va_arg(args, int );
    ap->a.a_uchar = tmp___2;
    }
    goto switch_break;
    case_3:
    {
    tmp___3 = __builtin_va_arg(args, int );
    ap->a.a_short = tmp___3;
    }
    goto switch_break;
    case_4:
    {
    tmp___4 = __builtin_va_arg(args, int );
    ap->a.a_ushort = tmp___4;
    }
    goto switch_break;
    case_5:
    {
    tmp___5 = __builtin_va_arg(args, int );
    ap->a.a_int = tmp___5;
    }
    goto switch_break;
    case_6:
    {
    tmp___6 = __builtin_va_arg(args, unsigned int );
    ap->a.a_uint = tmp___6;
    }
    goto switch_break;
    case_7:
    {
    tmp___7 = __builtin_va_arg(args, long );
    ap->a.a_longint = tmp___7;
    }
    goto switch_break;
    case_8:
    {
    tmp___8 = __builtin_va_arg(args, unsigned long );
    ap->a.a_ulongint = tmp___8;
    }
    goto switch_break;
    case_9:
    {
    tmp___9 = __builtin_va_arg(args, long long );
    ap->a.a_longlongint = tmp___9;
    }
    goto switch_break;
    case_10:
    {
    tmp___10 = __builtin_va_arg(args, unsigned long long );
    ap->a.a_ulonglongint = tmp___10;
    }
    goto switch_break;
    case_11:
    {
    tmp___11 = __builtin_va_arg(args, double );
    ap->a.a_double = tmp___11;
    }
    goto switch_break;
    case_12:
    {
    tmp___12 = __builtin_va_arg(args, long double );
    ap->a.a_longdouble = tmp___12;
    }
    goto switch_break;
    case_13:
    {
    tmp___13 = __builtin_va_arg(args, int );
    ap->a.a_char = tmp___13;
    }
    goto switch_break;
    case_14:
    if (sizeof(wint_t ) < sizeof(int )) {
      {
      {
      tmp___14 = __builtin_va_arg(args, int );
      tmp = tmp___14;
      ap->a.a_wide_char = (wint_t )tmp;
      }
      }
    } else {
      {
      {
      tmp___15 = __builtin_va_arg(args, wint_t );
      tmp___0 = tmp___15;
      ap->a.a_wide_char = tmp___0;
      }
      }
    }
    goto switch_break;
    case_15:
    {
    tmp___16 = __builtin_va_arg(args, char const *);
    ap->a.a_string = tmp___16;
    }
    if ((unsigned long )ap->a.a_string == (unsigned long )((void *)0)) {
      {
      {
      ap->a.a_string = (char const *)"(NULL)";
      }
      }
    }
    goto switch_break;
    case_16:
    {
    tmp___17 = __builtin_va_arg(args, wchar_t const *);
    ap->a.a_wide_string = tmp___17;
    }
    if ((unsigned long )ap->a.a_wide_string == (unsigned long )((void *)0)) {
      {
      {
      ap->a.a_wide_string = wide_null_string;
      }
      }
    }
    goto switch_break;
    case_17:
    {
    tmp___18 = __builtin_va_arg(args, void *);
    ap->a.a_pointer = tmp___18;
    }
    goto switch_break;
    case_18:
    {
    tmp___19 = __builtin_va_arg(args, signed char *);
    ap->a.a_count_schar_pointer = tmp___19;
    }
    goto switch_break;
    case_19:
    {
    tmp___20 = __builtin_va_arg(args, short *);
    ap->a.a_count_short_pointer = tmp___20;
    }
    goto switch_break;
    case_20:
    {
    tmp___21 = __builtin_va_arg(args, int *);
    ap->a.a_count_int_pointer = tmp___21;
    }
    goto switch_break;
    case_21:
    {
    tmp___22 = __builtin_va_arg(args, long *);
    ap->a.a_count_longint_pointer = tmp___22;
    }
    goto switch_break;
    case_22:
    {
    tmp___23 = __builtin_va_arg(args, long long *);
    ap->a.a_count_longlongint_pointer = tmp___23;
    }
    goto switch_break;
    switch_default:
    return (-1);
    switch_break: ;
    }
    {
    i ++;
    ap ++;
    }
  }
  while_break: ;
  }
  return (0);
}
}
int printf_parse(char const *format , char_directives *d , arguments *a )
{
  char const *cp ;
  size_t arg_posn ;
  size_t d_allocated ;
  size_t a_allocated ;
  size_t max_width_length ;
  size_t max_precision_length ;
  char c ;
  char const *tmp ;
  size_t arg_index ;
  char_directive *dp ;
  char const *np ;
  size_t n ;
  size_t tmp___0 ;
  size_t __attribute__((__pure__)) tmp___1 ;
  char const *np___0 ;
  size_t n___0 ;
  size_t tmp___2 ;
  size_t __attribute__((__pure__)) tmp___3 ;
  size_t tmp___4 ;
  size_t n___1 ;
  size_t memory_size ;
  argument *memory ;
  size_t __attribute__((__pure__)) tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t width_length ;
  char const *np___1 ;
  size_t n___2 ;
  size_t tmp___10 ;
  size_t __attribute__((__pure__)) tmp___11 ;
  size_t tmp___12 ;
  size_t n___3 ;
  size_t memory_size___0 ;
  argument *memory___0 ;
  size_t __attribute__((__pure__)) tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  size_t tmp___17 ;
  size_t precision_length ;
  arg_type type ;
  int flags ;
  char const *tmp___18 ;
  size_t tmp___19 ;
  size_t n___4 ;
  size_t memory_size___1 ;
  argument *memory___1 ;
  size_t __attribute__((__pure__)) tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  size_t tmp___24 ;
  size_t memory_size___2 ;
  char_directive *memory___2 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  int *tmp___28 ;
  int *tmp___29 ;
  {
  {
  cp = format;
  arg_posn = (size_t )0;
  max_width_length = (size_t )0;
  max_precision_length = (size_t )0;
  d->count = (size_t )0;
  d_allocated = (size_t )7;
  d->dir = d->direct_alloc_dir;
  a->count = (size_t )0;
  a_allocated = (size_t )7;
  a->arg = a->direct_alloc_arg;
  }
  {
  while (1) {
    while_continue: ;
    if (! ((int const )*cp != 0)) {
      {
      goto while_break;
      }
    }
    {
    tmp = cp;
    cp ++;
    c = (char )*tmp;
    }
    if ((int )c == 37) {
      {
      {
      arg_index = ~ ((size_t )0);
      dp = d->dir + d->count;
      dp->dir_start = cp - 1;
      dp->flags = 0;
      dp->width_start = (char const *)((void *)0);
      dp->width_end = (char const *)((void *)0);
      dp->width_arg_index = ~ ((size_t )0);
      dp->precision_start = (char const *)((void *)0);
      dp->precision_end = (char const *)((void *)0);
      dp->precision_arg_index = ~ ((size_t )0);
      dp->arg_index = ~ ((size_t )0);
      }
      if ((int const )*cp >= 48) {
        {
        if ((int const )*cp <= 57) {
          {
          {
          np = cp;
          }
          {
          while (1) {
            while_continue___0: ;
            if (! 1) {
              {
              goto while_break___0;
              }
            }
            if ((int const )*np >= 48) {
              {
              if (! ((int const )*np <= 57)) {
                {
                goto while_break___0;
                }
              }
              }
            } else {
              {
              goto while_break___0;
              }
            }
            {
            np ++;
            }
          }
          while_break___0: ;
          }
          if ((int const )*np == 36) {
            {
            {
            n = (size_t )0;
            np = cp;
            }
            {
            while (1) {
              while_continue___1: ;
              if (! 1) {
                {
                goto while_break___1;
                }
              }
              if ((int const )*np >= 48) {
                {
                if (! ((int const )*np <= 57)) {
                  {
                  goto while_break___1;
                  }
                }
                }
              } else {
                {
                goto while_break___1;
                }
              }
              if (n <= 1844674407370955161UL) {
                {
                {
                tmp___0 = n * 10UL;
                }
                }
              } else {
                {
                {
                tmp___0 = 0xffffffffffffffffUL;
                }
                }
              }
              {
              tmp___1 = xsum(tmp___0, (size_t )((int const )*np - 48));
              n = (size_t )tmp___1;
              np ++;
              }
            }
            while_break___1: ;
            }
            if (n == 0UL) {
              {
              goto error;
              }
            }
            if (n == 0xffffffffffffffffUL) {
              {
              goto error;
              }
            }
            {
            arg_index = n - 1UL;
            cp = np + 1;
            }
            }
          }
          }
        }
        }
      }
      {
      while (1) {
        while_continue___2: ;
        if (! 1) {
          {
          goto while_break___2;
          }
        }
        if ((int const )*cp == 39) {
          {
          {
          dp->flags |= 1;
          cp ++;
          }
          }
        } else {
          {
          if ((int const )*cp == 45) {
            {
            {
            dp->flags |= 2;
            cp ++;
            }
            }
          } else {
            {
            if ((int const )*cp == 43) {
              {
              {
              dp->flags |= 4;
              cp ++;
              }
              }
            } else {
              {
              if ((int const )*cp == 32) {
                {
                {
                dp->flags |= 8;
                cp ++;
                }
                }
              } else {
                {
                if ((int const )*cp == 35) {
                  {
                  {
                  dp->flags |= 16;
                  cp ++;
                  }
                  }
                } else {
                  {
                  if ((int const )*cp == 48) {
                    {
                    {
                    dp->flags |= 32;
                    cp ++;
                    }
                    }
                  } else {
                    {
                    if ((int const )*cp == 73) {
                      {
                      {
                      dp->flags |= 64;
                      cp ++;
                      }
                      }
                    } else {
                      {
                      goto while_break___2;
                      }
                    }
                    }
                  }
                  }
                }
                }
              }
              }
            }
            }
          }
          }
        }
      }
      while_break___2: ;
      }
      if ((int const )*cp == 42) {
        {
        {
        dp->width_start = cp;
        cp ++;
        dp->width_end = cp;
        }
        if (max_width_length < 1UL) {
          {
          {
          max_width_length = (size_t )1;
          }
          }
        }
        if ((int const )*cp >= 48) {
          {
          if ((int const )*cp <= 57) {
            {
            {
            np___0 = cp;
            }
            {
            while (1) {
              while_continue___3: ;
              if (! 1) {
                {
                goto while_break___3;
                }
              }
              if ((int const )*np___0 >= 48) {
                {
                if (! ((int const )*np___0 <= 57)) {
                  {
                  goto while_break___3;
                  }
                }
                }
              } else {
                {
                goto while_break___3;
                }
              }
              {
              np___0 ++;
              }
            }
            while_break___3: ;
            }
            if ((int const )*np___0 == 36) {
              {
              {
              n___0 = (size_t )0;
              np___0 = cp;
              }
              {
              while (1) {
                while_continue___4: ;
                if (! 1) {
                  {
                  goto while_break___4;
                  }
                }
                if ((int const )*np___0 >= 48) {
                  {
                  if (! ((int const )*np___0 <= 57)) {
                    {
                    goto while_break___4;
                    }
                  }
                  }
                } else {
                  {
                  goto while_break___4;
                  }
                }
                if (n___0 <= 1844674407370955161UL) {
                  {
                  {
                  tmp___2 = n___0 * 10UL;
                  }
                  }
                } else {
                  {
                  {
                  tmp___2 = 0xffffffffffffffffUL;
                  }
                  }
                }
                {
                tmp___3 = xsum(tmp___2, (size_t )((int const )*np___0 - 48));
                n___0 = (size_t )tmp___3;
                np___0 ++;
                }
              }
              while_break___4: ;
              }
              if (n___0 == 0UL) {
                {
                goto error;
                }
              }
              if (n___0 == 0xffffffffffffffffUL) {
                {
                goto error;
                }
              }
              {
              dp->width_arg_index = n___0 - 1UL;
              cp = np___0 + 1;
              }
              }
            }
            }
          }
          }
        }
        if (dp->width_arg_index == 0xffffffffffffffffUL) {
          {
          {
          tmp___4 = arg_posn;
          arg_posn ++;
          dp->width_arg_index = tmp___4;
          }
          if (dp->width_arg_index == 0xffffffffffffffffUL) {
            {
            goto error;
            }
          }
          }
        }
        {
        n___1 = dp->width_arg_index;
        }
        if (n___1 >= a_allocated) {
          {
          if (a_allocated <= 9223372036854775807UL) {
            {
            {
            a_allocated *= 2UL;
            }
            }
          } else {
            {
            {
            a_allocated = 0xffffffffffffffffUL;
            }
            }
          }
          if (a_allocated <= n___1) {
            {
            {
            tmp___5 = xsum(n___1, (size_t )1);
            a_allocated = (size_t )tmp___5;
            }
            }
          }
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
            {
            {
            memory_size = a_allocated * sizeof(argument );
            }
            }
          } else {
            {
            {
            memory_size = 0xffffffffffffffffUL;
            }
            }
          }
          if (memory_size == 0xffffffffffffffffUL) {
            {
            goto out_of_memory;
            }
          }
          if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
            {
            {
            tmp___6 = realloc((void *)a->arg, memory_size);
            tmp___8 = tmp___6;
            }
            }
          } else {
            {
            {
            tmp___7 = malloc(memory_size);
            tmp___8 = tmp___7;
            }
            }
          }
          {
          memory = (argument *)tmp___8;
          }
          if ((unsigned long )memory == (unsigned long )((void *)0)) {
            {
            goto out_of_memory;
            }
          }
          if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
            {
            {
            memcpy((void *)((void * __restrict )memory), (void const *)((void const * __restrict )a->arg),
                   a->count * sizeof(argument ));
            }
            }
          }
          {
          a->arg = memory;
          }
          }
        }
        {
        while (1) {
          while_continue___5: ;
          if (! (a->count <= n___1)) {
            {
            goto while_break___5;
            }
          }
          {
          tmp___9 = a->count;
          (a->count) ++;
          (a->arg + tmp___9)->type = (arg_type )0;
          }
        }
        while_break___5: ;
        }
        if ((unsigned int )(a->arg + n___1)->type == 0U) {
          {
          {
          (a->arg + n___1)->type = (arg_type )5;
          }
          }
        } else {
          {
          if ((unsigned int )(a->arg + n___1)->type != 5U) {
            {
            goto error;
            }
          }
          }
        }
        }
      } else {
        {
        if ((int const )*cp >= 48) {
          {
          if ((int const )*cp <= 57) {
            {
            {
            dp->width_start = cp;
            }
            {
            while (1) {
              while_continue___6: ;
              if (! 1) {
                {
                goto while_break___6;
                }
              }
              if ((int const )*cp >= 48) {
                {
                if (! ((int const )*cp <= 57)) {
                  {
                  goto while_break___6;
                  }
                }
                }
              } else {
                {
                goto while_break___6;
                }
              }
              {
              cp ++;
              }
            }
            while_break___6: ;
            }
            {
            dp->width_end = cp;
            width_length = (size_t )(dp->width_end - dp->width_start);
            }
            if (max_width_length < width_length) {
              {
              {
              max_width_length = width_length;
              }
              }
            }
            }
          }
          }
        }
        }
      }
      if ((int const )*cp == 46) {
        {
        {
        cp ++;
        }
        if ((int const )*cp == 42) {
          {
          {
          dp->precision_start = cp - 1;
          cp ++;
          dp->precision_end = cp;
          }
          if (max_precision_length < 2UL) {
            {
            {
            max_precision_length = (size_t )2;
            }
            }
          }
          if ((int const )*cp >= 48) {
            {
            if ((int const )*cp <= 57) {
              {
              {
              np___1 = cp;
              }
              {
              while (1) {
                while_continue___7: ;
                if (! 1) {
                  {
                  goto while_break___7;
                  }
                }
                if ((int const )*np___1 >= 48) {
                  {
                  if (! ((int const )*np___1 <= 57)) {
                    {
                    goto while_break___7;
                    }
                  }
                  }
                } else {
                  {
                  goto while_break___7;
                  }
                }
                {
                np___1 ++;
                }
              }
              while_break___7: ;
              }
              if ((int const )*np___1 == 36) {
                {
                {
                n___2 = (size_t )0;
                np___1 = cp;
                }
                {
                while (1) {
                  while_continue___8: ;
                  if (! 1) {
                    {
                    goto while_break___8;
                    }
                  }
                  if ((int const )*np___1 >= 48) {
                    {
                    if (! ((int const )*np___1 <= 57)) {
                      {
                      goto while_break___8;
                      }
                    }
                    }
                  } else {
                    {
                    goto while_break___8;
                    }
                  }
                  if (n___2 <= 1844674407370955161UL) {
                    {
                    {
                    tmp___10 = n___2 * 10UL;
                    }
                    }
                  } else {
                    {
                    {
                    tmp___10 = 0xffffffffffffffffUL;
                    }
                    }
                  }
                  {
                  tmp___11 = xsum(tmp___10, (size_t )((int const )*np___1 - 48));
                  n___2 = (size_t )tmp___11;
                  np___1 ++;
                  }
                }
                while_break___8: ;
                }
                if (n___2 == 0UL) {
                  {
                  goto error;
                  }
                }
                if (n___2 == 0xffffffffffffffffUL) {
                  {
                  goto error;
                  }
                }
                {
                dp->precision_arg_index = n___2 - 1UL;
                cp = np___1 + 1;
                }
                }
              }
              }
            }
            }
          }
          if (dp->precision_arg_index == 0xffffffffffffffffUL) {
            {
            {
            tmp___12 = arg_posn;
            arg_posn ++;
            dp->precision_arg_index = tmp___12;
            }
            if (dp->precision_arg_index == 0xffffffffffffffffUL) {
              {
              goto error;
              }
            }
            }
          }
          {
          n___3 = dp->precision_arg_index;
          }
          if (n___3 >= a_allocated) {
            {
            if (a_allocated <= 9223372036854775807UL) {
              {
              {
              a_allocated *= 2UL;
              }
              }
            } else {
              {
              {
              a_allocated = 0xffffffffffffffffUL;
              }
              }
            }
            if (a_allocated <= n___3) {
              {
              {
              tmp___13 = xsum(n___3, (size_t )1);
              a_allocated = (size_t )tmp___13;
              }
              }
            }
            if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
              {
              {
              memory_size___0 = a_allocated * sizeof(argument );
              }
              }
            } else {
              {
              {
              memory_size___0 = 0xffffffffffffffffUL;
              }
              }
            }
            if (memory_size___0 == 0xffffffffffffffffUL) {
              {
              goto out_of_memory;
              }
            }
            if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
              {
              {
              tmp___14 = realloc((void *)a->arg, memory_size___0);
              tmp___16 = tmp___14;
              }
              }
            } else {
              {
              {
              tmp___15 = malloc(memory_size___0);
              tmp___16 = tmp___15;
              }
              }
            }
            {
            memory___0 = (argument *)tmp___16;
            }
            if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
              {
              goto out_of_memory;
              }
            }
            if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
              {
              {
              memcpy((void *)((void * __restrict )memory___0), (void const *)((void const * __restrict )a->arg),
                     a->count * sizeof(argument ));
              }
              }
            }
            {
            a->arg = memory___0;
            }
            }
          }
          {
          while (1) {
            while_continue___9: ;
            if (! (a->count <= n___3)) {
              {
              goto while_break___9;
              }
            }
            {
            tmp___17 = a->count;
            (a->count) ++;
            (a->arg + tmp___17)->type = (arg_type )0;
            }
          }
          while_break___9: ;
          }
          if ((unsigned int )(a->arg + n___3)->type == 0U) {
            {
            {
            (a->arg + n___3)->type = (arg_type )5;
            }
            }
          } else {
            {
            if ((unsigned int )(a->arg + n___3)->type != 5U) {
              {
              goto error;
              }
            }
            }
          }
          }
        } else {
          {
          {
          dp->precision_start = cp - 1;
          }
          {
          while (1) {
            while_continue___10: ;
            if (! 1) {
              {
              goto while_break___10;
              }
            }
            if ((int const )*cp >= 48) {
              {
              if (! ((int const )*cp <= 57)) {
                {
                goto while_break___10;
                }
              }
              }
            } else {
              {
              goto while_break___10;
              }
            }
            {
            cp ++;
            }
          }
          while_break___10: ;
          }
          {
          dp->precision_end = cp;
          precision_length = (size_t )(dp->precision_end - dp->precision_start);
          }
          if (max_precision_length < precision_length) {
            {
            {
            max_precision_length = precision_length;
            }
            }
          }
          }
        }
        }
      }
      {
      flags = 0;
      }
      {
      while (1) {
        while_continue___11: ;
        if (! 1) {
          {
          goto while_break___11;
          }
        }
        if ((int const )*cp == 104) {
          {
          {
          flags |= 1 << (flags & 1);
          cp ++;
          }
          }
        } else {
          {
          if ((int const )*cp == 76) {
            {
            {
            flags |= 4;
            cp ++;
            }
            }
          } else {
            {
            if ((int const )*cp == 108) {
              {
              {
              flags += 8;
              cp ++;
              }
              }
            } else {
              {
              if ((int const )*cp == 106) {
                {
                if (sizeof(intmax_t ) > sizeof(long )) {
                  {
                  {
                  flags += 16;
                  }
                  }
                } else {
                  {
                  if (sizeof(intmax_t ) > sizeof(int )) {
                    {
                    {
                    flags += 8;
                    }
                    }
                  }
                  }
                }
                {
                cp ++;
                }
                }
              } else {
                {
                if ((int const )*cp == 122) {
                  {
                  goto _L;
                  }
                } else {
                  {
                  if ((int const )*cp == 90) {
                    {
                    _L:
                    if (sizeof(size_t ) > sizeof(long )) {
                      {
                      {
                      flags += 16;
                      }
                      }
                    } else {
                      {
                      if (sizeof(size_t ) > sizeof(int )) {
                        {
                        {
                        flags += 8;
                        }
                        }
                      }
                      }
                    }
                    {
                    cp ++;
                    }
                    }
                  } else {
                    {
                    if ((int const )*cp == 116) {
                      {
                      if (sizeof(ptrdiff_t ) > sizeof(long )) {
                        {
                        {
                        flags += 16;
                        }
                        }
                      } else {
                        {
                        if (sizeof(ptrdiff_t ) > sizeof(int )) {
                          {
                          {
                          flags += 8;
                          }
                          }
                        }
                        }
                      }
                      {
                      cp ++;
                      }
                      }
                    } else {
                      {
                      goto while_break___11;
                      }
                    }
                    }
                  }
                  }
                }
                }
              }
              }
            }
            }
          }
          }
        }
      }
      while_break___11: ;
      }
      {
      tmp___18 = cp;
      cp ++;
      c = (char )*tmp___18;
      }
      {
      if ((int )c == 105) {
        {
        goto case_105;
        }
      }
      if ((int )c == 100) {
        {
        goto case_105;
        }
      }
      if ((int )c == 88) {
        {
        goto case_88;
        }
      }
      if ((int )c == 120) {
        {
        goto case_88;
        }
      }
      if ((int )c == 117) {
        {
        goto case_88;
        }
      }
      if ((int )c == 111) {
        {
        goto case_88;
        }
      }
      if ((int )c == 65) {
        {
        goto case_65;
        }
      }
      if ((int )c == 97) {
        {
        goto case_65;
        }
      }
      if ((int )c == 71) {
        {
        goto case_65;
        }
      }
      if ((int )c == 103) {
        {
        goto case_65;
        }
      }
      if ((int )c == 69) {
        {
        goto case_65;
        }
      }
      if ((int )c == 101) {
        {
        goto case_65;
        }
      }
      if ((int )c == 70) {
        {
        goto case_65;
        }
      }
      if ((int )c == 102) {
        {
        goto case_65;
        }
      }
      if ((int )c == 99) {
        {
        goto case_99;
        }
      }
      if ((int )c == 67) {
        {
        goto case_67;
        }
      }
      if ((int )c == 115) {
        {
        goto case_115;
        }
      }
      if ((int )c == 83) {
        {
        goto case_83;
        }
      }
      if ((int )c == 112) {
        {
        goto case_112;
        }
      }
      if ((int )c == 110) {
        {
        goto case_110;
        }
      }
      if ((int )c == 37) {
        {
        goto case_37;
        }
      }
      goto switch_default;
      case_105:
      case_100:
      if (flags >= 16) {
        {
        {
        type = (arg_type )9;
        }
        }
      } else {
        {
        if (flags & 4) {
          {
          {
          type = (arg_type )9;
          }
          }
        } else {
          {
          if (flags >= 8) {
            {
            {
            type = (arg_type )7;
            }
            }
          } else {
            {
            if (flags & 2) {
              {
              {
              type = (arg_type )1;
              }
              }
            } else {
              {
              if (flags & 1) {
                {
                {
                type = (arg_type )3;
                }
                }
              } else {
                {
                {
                type = (arg_type )5;
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      goto switch_break;
      case_88:
      case_120:
      case_117:
      case_111:
      if (flags >= 16) {
        {
        {
        type = (arg_type )10;
        }
        }
      } else {
        {
        if (flags & 4) {
          {
          {
          type = (arg_type )10;
          }
          }
        } else {
          {
          if (flags >= 8) {
            {
            {
            type = (arg_type )8;
            }
            }
          } else {
            {
            if (flags & 2) {
              {
              {
              type = (arg_type )2;
              }
              }
            } else {
              {
              if (flags & 1) {
                {
                {
                type = (arg_type )4;
                }
                }
              } else {
                {
                {
                type = (arg_type )6;
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      goto switch_break;
      case_65:
      case_97:
      case_71:
      case_103:
      case_69:
      case_101:
      case_70:
      case_102:
      if (flags >= 16) {
        {
        {
        type = (arg_type )12;
        }
        }
      } else {
        {
        if (flags & 4) {
          {
          {
          type = (arg_type )12;
          }
          }
        } else {
          {
          {
          type = (arg_type )11;
          }
          }
        }
        }
      }
      goto switch_break;
      case_99:
      if (flags >= 8) {
        {
        {
        type = (arg_type )14;
        }
        }
      } else {
        {
        {
        type = (arg_type )13;
        }
        }
      }
      goto switch_break;
      case_67:
      {
      type = (arg_type )14;
      c = (char )'c';
      }
      goto switch_break;
      case_115:
      if (flags >= 8) {
        {
        {
        type = (arg_type )16;
        }
        }
      } else {
        {
        {
        type = (arg_type )15;
        }
        }
      }
      goto switch_break;
      case_83:
      {
      type = (arg_type )16;
      c = (char )'s';
      }
      goto switch_break;
      case_112:
      {
      type = (arg_type )17;
      }
      goto switch_break;
      case_110:
      if (flags >= 16) {
        {
        {
        type = (arg_type )22;
        }
        }
      } else {
        {
        if (flags & 4) {
          {
          {
          type = (arg_type )22;
          }
          }
        } else {
          {
          if (flags >= 8) {
            {
            {
            type = (arg_type )21;
            }
            }
          } else {
            {
            if (flags & 2) {
              {
              {
              type = (arg_type )18;
              }
              }
            } else {
              {
              if (flags & 1) {
                {
                {
                type = (arg_type )19;
                }
                }
              } else {
                {
                {
                type = (arg_type )20;
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      goto switch_break;
      case_37:
      {
      type = (arg_type )0;
      }
      goto switch_break;
      switch_default:
      goto error;
      switch_break: ;
      }
      if ((unsigned int )type != 0U) {
        {
        {
        dp->arg_index = arg_index;
        }
        if (dp->arg_index == 0xffffffffffffffffUL) {
          {
          {
          tmp___19 = arg_posn;
          arg_posn ++;
          dp->arg_index = tmp___19;
          }
          if (dp->arg_index == 0xffffffffffffffffUL) {
            {
            goto error;
            }
          }
          }
        }
        {
        n___4 = dp->arg_index;
        }
        if (n___4 >= a_allocated) {
          {
          if (a_allocated <= 9223372036854775807UL) {
            {
            {
            a_allocated *= 2UL;
            }
            }
          } else {
            {
            {
            a_allocated = 0xffffffffffffffffUL;
            }
            }
          }
          if (a_allocated <= n___4) {
            {
            {
            tmp___20 = xsum(n___4, (size_t )1);
            a_allocated = (size_t )tmp___20;
            }
            }
          }
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
            {
            {
            memory_size___1 = a_allocated * sizeof(argument );
            }
            }
          } else {
            {
            {
            memory_size___1 = 0xffffffffffffffffUL;
            }
            }
          }
          if (memory_size___1 == 0xffffffffffffffffUL) {
            {
            goto out_of_memory;
            }
          }
          if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
            {
            {
            tmp___21 = realloc((void *)a->arg, memory_size___1);
            tmp___23 = tmp___21;
            }
            }
          } else {
            {
            {
            tmp___22 = malloc(memory_size___1);
            tmp___23 = tmp___22;
            }
            }
          }
          {
          memory___1 = (argument *)tmp___23;
          }
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
            {
            goto out_of_memory;
            }
          }
          if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
            {
            {
            memcpy((void *)((void * __restrict )memory___1), (void const *)((void const * __restrict )a->arg),
                   a->count * sizeof(argument ));
            }
            }
          }
          {
          a->arg = memory___1;
          }
          }
        }
        {
        while (1) {
          while_continue___12: ;
          if (! (a->count <= n___4)) {
            {
            goto while_break___12;
            }
          }
          {
          tmp___24 = a->count;
          (a->count) ++;
          (a->arg + tmp___24)->type = (arg_type )0;
          }
        }
        while_break___12: ;
        }
        if ((unsigned int )(a->arg + n___4)->type == 0U) {
          {
          {
          (a->arg + n___4)->type = type;
          }
          }
        } else {
          {
          if ((unsigned int )(a->arg + n___4)->type != (unsigned int )type) {
            {
            goto error;
            }
          }
          }
        }
        }
      }
      {
      dp->conversion = c;
      dp->dir_end = cp;
      (d->count) ++;
      }
      if (d->count >= d_allocated) {
        {
        if (d_allocated <= 9223372036854775807UL) {
          {
          {
          d_allocated *= 2UL;
          }
          }
        } else {
          {
          {
          d_allocated = 0xffffffffffffffffUL;
          }
          }
        }
        if (d_allocated <= 0xffffffffffffffffUL / sizeof(char_directive )) {
          {
          {
          memory_size___2 = d_allocated * sizeof(char_directive );
          }
          }
        } else {
          {
          {
          memory_size___2 = 0xffffffffffffffffUL;
          }
          }
        }
        if (memory_size___2 == 0xffffffffffffffffUL) {
          {
          goto out_of_memory;
          }
        }
        if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
          {
          {
          tmp___25 = realloc((void *)d->dir, memory_size___2);
          tmp___27 = tmp___25;
          }
          }
        } else {
          {
          {
          tmp___26 = malloc(memory_size___2);
          tmp___27 = tmp___26;
          }
          }
        }
        {
        memory___2 = (char_directive *)tmp___27;
        }
        if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
          {
          goto out_of_memory;
          }
        }
        if ((unsigned long )d->dir == (unsigned long )(d->direct_alloc_dir)) {
          {
          {
          memcpy((void *)((void * __restrict )memory___2), (void const *)((void const * __restrict )d->dir),
                 d->count * sizeof(char_directive ));
          }
          }
        }
        {
        d->dir = memory___2;
        }
        }
      }
      }
    }
  }
  while_break: ;
  }
  {
  (d->dir + d->count)->dir_start = cp;
  d->max_width_length = max_width_length;
  d->max_precision_length = max_precision_length;
  }
  return (0);
  error:
  if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
    {
    {
    free((void *)a->arg);
    }
    }
  }
  if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
    {
    {
    free((void *)d->dir);
    }
    }
  }
  {
  tmp___28 = __errno_location();
  *tmp___28 = 22;
  }
  return (-1);
  out_of_memory:
  if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
    {
    {
    free((void *)a->arg);
    }
    }
  }
  if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
    {
    {
    free((void *)d->dir);
    }
    }
  }
  {
  tmp___29 = __errno_location();
  *tmp___29 = 12;
  }
  return (-1);
}
}
char *extract_trimmed_name(STRUCT_UTMP const *ut )
{
  char *p ;
  char *trimmed_name ;
  void *tmp ;
  size_t tmp___0 ;
  {
  {
  tmp = xmalloc(sizeof(ut->ut_user) + 1UL);
  trimmed_name = (char *)tmp;
  strncpy((char *)((char * __restrict )trimmed_name), (char const *)((char const * __restrict )(ut->ut_user)),
          sizeof(ut->ut_user));
  *(trimmed_name + sizeof(ut->ut_user)) = (char )'\000';
  tmp___0 = strlen((char const *)trimmed_name);
  p = trimmed_name + tmp___0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if ((unsigned long )trimmed_name < (unsigned long )p) {
      {
      if (! ((int )*(p + -1) == 32)) {
        {
        goto while_break;
        }
      }
      }
    } else {
      {
      goto while_break;
      }
    }
    goto __Cont;
    __Cont:
    {
    p --;
    *p = (char )'\000';
    }
  }
  while_break: ;
  }
  return (trimmed_name);
}
}
__inline static _Bool desirable_utmp_entry(STRUCT_UTMP const *u , int options )
{
  _Bool user_proc ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  {
  if (u->ut_user[0]) {
    {
    if ((int const )u->ut_type == 7) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  {
  user_proc = (_Bool )tmp;
  }
  if (options & 2) {
    {
    if (! user_proc) {
      {
      return ((_Bool)0);
      }
    }
    }
  }
  if (options & 1) {
    {
    if (user_proc) {
      {
      if (u->ut_pid <= 0) {
        {
        return ((_Bool)0);
        }
      } else {
        {
        {
        tmp___0 = kill((__pid_t )u->ut_pid, 0);
        }
        if (tmp___0 < 0) {
          {
          {
          tmp___1 = __errno_location();
          }
          if (*tmp___1 == 3) {
            {
            return ((_Bool)0);
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  return ((_Bool)1);
}
}
int read_utmp(char const *file , size_t *n_entries , STRUCT_UTMP **utmp_buf , int options )
{
  size_t n_read ;
  size_t n_alloc ;
  STRUCT_UTMP *utmp ;
  STRUCT_UTMP *u ;
  void *tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;
  {
  {
  n_read = (size_t )0;
  n_alloc = (size_t )0;
  utmp = (STRUCT_UTMP *)((void *)0);
  utmpxname(file);
  setutxent();
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    {
    u = getutxent();
    }
    if (! ((unsigned long )u != (unsigned long )((void *)0))) {
      {
      goto while_break;
      }
    }
    {
    tmp___1 = desirable_utmp_entry((STRUCT_UTMP const *)u, options);
    }
    if (tmp___1) {
      {
      if (n_read == n_alloc) {
        {
        {
        tmp = x2nrealloc((void *)utmp, & n_alloc, sizeof(*utmp));
        utmp = (STRUCT_UTMP *)tmp;
        }
        }
      }
      {
      tmp___0 = n_read;
      n_read ++;
      *(utmp + tmp___0) = *u;
      }
      }
    }
  }
  while_break: ;
  }
  {
  endutxent();
  *n_entries = n_read;
  *utmp_buf = utmp;
  }
  return (0);
}
}
int ( __attribute__((__nonnull__(1))) rpl_remove)(char const *name )
{
  int result ;
  int tmp ;
  int *tmp___0 ;
  {
  {
  tmp = rmdir(name);
  result = tmp;
  }
  if (result) {
    {
    {
    tmp___0 = __errno_location();
    }
    if (*tmp___0 == 20) {
      {
      {
      result = unlink(name);
      }
      }
    }
    }
  }
  return (result);
}
}
struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i )
{
  struct stat statbuf ;
  int tmp ;
  {
  {
  tmp = lstat((char const *)((char const * __restrict )"/"), (struct stat *)((struct stat * __restrict )(& statbuf)));
  }
  if (tmp) {
    {
    return ((struct dev_ino *)((void *)0));
    }
  }
  {
  root_d_i->st_ino = statbuf.st_ino;
  root_d_i->st_dev = statbuf.st_dev;
  }
  return (root_d_i);
}
}
__inline static int getfilecon(char const *file __attribute__((__unused__)) , char **con __attribute__((__unused__)) )
{
  int *tmp ;
  {
  {
  tmp = __errno_location();
  *tmp = 95;
  }
  return (-1);
}
}
__inline static int setfilecon(char const *file __attribute__((__unused__)) , char *con __attribute__((__unused__)) )
{
  int *tmp ;
  {
  {
  tmp = __errno_location();
  *tmp = 95;
  }
  return (-1);
}
}
int getfileconat(int fd , char const *file , char **con )
{
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  {
  if (fd == -100) {
    {
    {
    tmp = getfilecon(file, con);
    }
    return (tmp);
    }
  } else {
    {
    if ((int const )*(file + 0) == 47) {
      {
      {
      tmp = getfilecon(file, con);
      }
      return (tmp);
      }
    }
    }
  }
  {
  tmp___0 = openat_proc_name(proc_buf, fd, file);
  proc_file = tmp___0;
  }
  if (proc_file) {
    {
    {
    tmp___1 = getfilecon((char const *)proc_file, con);
    proc_result = tmp___1;
    tmp___2 = __errno_location();
    proc_errno = *tmp___2;
    }
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      {
      {
      free((void *)proc_file);
      }
      }
    }
    if (-1 != proc_result) {
      {
      return (proc_result);
      }
    }
    if (! (proc_errno == 20)) {
      {
      if (! (proc_errno == 2)) {
        {
        if (! (proc_errno == 1)) {
          {
          if (! (proc_errno == 13)) {
            {
            if (! (proc_errno == 38)) {
              {
              if (! (proc_errno == 95)) {
                {
                {
                tmp___3 = __errno_location();
                *tmp___3 = proc_errno;
                }
                return (proc_result);
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  {
  tmp___5 = save_cwd(& saved_cwd);
  }
  if (tmp___5 != 0) {
    {
    {
    tmp___4 = __errno_location();
    openat_save_fail(*tmp___4);
    }
    }
  }
  if (0 <= fd) {
    {
    if (fd == saved_cwd.desc) {
      {
      {
      free_cwd(& saved_cwd);
      tmp___6 = __errno_location();
      *tmp___6 = 9;
      }
      return (-1);
      }
    }
    }
  }
  {
  tmp___9 = fchdir(fd);
  }
  if (tmp___9 != 0) {
    {
    {
    tmp___7 = __errno_location();
    saved_errno = *tmp___7;
    free_cwd(& saved_cwd);
    tmp___8 = __errno_location();
    *tmp___8 = saved_errno;
    }
    return (-1);
    }
  }
  {
  err = getfilecon(file, con);
  }
  if (err == -1) {
    {
    {
    tmp___10 = __errno_location();
    saved_errno = *tmp___10;
    }
    }
  } else {
    {
    {
    saved_errno = 0;
    }
    }
  }
  {
  tmp___12 = restore_cwd((struct saved_cwd const *)(& saved_cwd));
  }
  if (tmp___12 != 0) {
    {
    {
    tmp___11 = __errno_location();
    openat_restore_fail(*tmp___11);
    }
    }
  }
  {
  free_cwd(& saved_cwd);
  }
  if (saved_errno) {
    {
    {
    tmp___13 = __errno_location();
    *tmp___13 = saved_errno;
    }
    }
  }
  return (err);
}
}
int lgetfileconat(int fd , char const *file , char **con )
{
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  {
  if (fd == -100) {
    {
    {
    tmp = getfilecon(file, con);
    }
    return (tmp);
    }
  } else {
    {
    if ((int const )*(file + 0) == 47) {
      {
      {
      tmp = getfilecon(file, con);
      }
      return (tmp);
      }
    }
    }
  }
  {
  tmp___0 = openat_proc_name(proc_buf, fd, file);
  proc_file = tmp___0;
  }
  if (proc_file) {
    {
    {
    tmp___1 = getfilecon((char const *)proc_file, con);
    proc_result = tmp___1;
    tmp___2 = __errno_location();
    proc_errno = *tmp___2;
    }
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      {
      {
      free((void *)proc_file);
      }
      }
    }
    if (-1 != proc_result) {
      {
      return (proc_result);
      }
    }
    if (! (proc_errno == 20)) {
      {
      if (! (proc_errno == 2)) {
        {
        if (! (proc_errno == 1)) {
          {
          if (! (proc_errno == 13)) {
            {
            if (! (proc_errno == 38)) {
              {
              if (! (proc_errno == 95)) {
                {
                {
                tmp___3 = __errno_location();
                *tmp___3 = proc_errno;
                }
                return (proc_result);
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  {
  tmp___5 = save_cwd(& saved_cwd);
  }
  if (tmp___5 != 0) {
    {
    {
    tmp___4 = __errno_location();
    openat_save_fail(*tmp___4);
    }
    }
  }
  if (0 <= fd) {
    {
    if (fd == saved_cwd.desc) {
      {
      {
      free_cwd(& saved_cwd);
      tmp___6 = __errno_location();
      *tmp___6 = 9;
      }
      return (-1);
      }
    }
    }
  }
  {
  tmp___9 = fchdir(fd);
  }
  if (tmp___9 != 0) {
    {
    {
    tmp___7 = __errno_location();
    saved_errno = *tmp___7;
    free_cwd(& saved_cwd);
    tmp___8 = __errno_location();
    *tmp___8 = saved_errno;
    }
    return (-1);
    }
  }
  {
  err = getfilecon(file, con);
  }
  if (err == -1) {
    {
    {
    tmp___10 = __errno_location();
    saved_errno = *tmp___10;
    }
    }
  } else {
    {
    {
    saved_errno = 0;
    }
    }
  }
  {
  tmp___12 = restore_cwd((struct saved_cwd const *)(& saved_cwd));
  }
  if (tmp___12 != 0) {
    {
    {
    tmp___11 = __errno_location();
    openat_restore_fail(*tmp___11);
    }
    }
  }
  {
  free_cwd(& saved_cwd);
  }
  if (saved_errno) {
    {
    {
    tmp___13 = __errno_location();
    *tmp___13 = saved_errno;
    }
    }
  }
  return (err);
}
}
int setfileconat(int fd , char const *file , char *con )
{
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  {
  if (fd == -100) {
    {
    {
    tmp = setfilecon(file, con);
    }
    return (tmp);
    }
  } else {
    {
    if ((int const )*(file + 0) == 47) {
      {
      {
      tmp = setfilecon(file, con);
      }
      return (tmp);
      }
    }
    }
  }
  {
  tmp___0 = openat_proc_name(proc_buf, fd, file);
  proc_file = tmp___0;
  }
  if (proc_file) {
    {
    {
    tmp___1 = setfilecon((char const *)proc_file, con);
    proc_result = tmp___1;
    tmp___2 = __errno_location();
    proc_errno = *tmp___2;
    }
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      {
      {
      free((void *)proc_file);
      }
      }
    }
    if (-1 != proc_result) {
      {
      return (proc_result);
      }
    }
    if (! (proc_errno == 20)) {
      {
      if (! (proc_errno == 2)) {
        {
        if (! (proc_errno == 1)) {
          {
          if (! (proc_errno == 13)) {
            {
            if (! (proc_errno == 38)) {
              {
              if (! (proc_errno == 95)) {
                {
                {
                tmp___3 = __errno_location();
                *tmp___3 = proc_errno;
                }
                return (proc_result);
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  {
  tmp___5 = save_cwd(& saved_cwd);
  }
  if (tmp___5 != 0) {
    {
    {
    tmp___4 = __errno_location();
    openat_save_fail(*tmp___4);
    }
    }
  }
  if (0 <= fd) {
    {
    if (fd == saved_cwd.desc) {
      {
      {
      free_cwd(& saved_cwd);
      tmp___6 = __errno_location();
      *tmp___6 = 9;
      }
      return (-1);
      }
    }
    }
  }
  {
  tmp___9 = fchdir(fd);
  }
  if (tmp___9 != 0) {
    {
    {
    tmp___7 = __errno_location();
    saved_errno = *tmp___7;
    free_cwd(& saved_cwd);
    tmp___8 = __errno_location();
    *tmp___8 = saved_errno;
    }
    return (-1);
    }
  }
  {
  err = setfilecon(file, con);
  }
  if (err == -1) {
    {
    {
    tmp___10 = __errno_location();
    saved_errno = *tmp___10;
    }
    }
  } else {
    {
    {
    saved_errno = 0;
    }
    }
  }
  {
  tmp___12 = restore_cwd((struct saved_cwd const *)(& saved_cwd));
  }
  if (tmp___12 != 0) {
    {
    {
    tmp___11 = __errno_location();
    openat_restore_fail(*tmp___11);
    }
    }
  }
  {
  free_cwd(& saved_cwd);
  }
  if (saved_errno) {
    {
    {
    tmp___13 = __errno_location();
    *tmp___13 = saved_errno;
    }
    }
  }
  return (err);
}
}
int lsetfileconat(int fd , char const *file , char *con )
{
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  {
  if (fd == -100) {
    {
    {
    tmp = setfilecon(file, con);
    }
    return (tmp);
    }
  } else {
    {
    if ((int const )*(file + 0) == 47) {
      {
      {
      tmp = setfilecon(file, con);
      }
      return (tmp);
      }
    }
    }
  }
  {
  tmp___0 = openat_proc_name(proc_buf, fd, file);
  proc_file = tmp___0;
  }
  if (proc_file) {
    {
    {
    tmp___1 = setfilecon((char const *)proc_file, con);
    proc_result = tmp___1;
    tmp___2 = __errno_location();
    proc_errno = *tmp___2;
    }
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      {
      {
      free((void *)proc_file);
      }
      }
    }
    if (-1 != proc_result) {
      {
      return (proc_result);
      }
    }
    if (! (proc_errno == 20)) {
      {
      if (! (proc_errno == 2)) {
        {
        if (! (proc_errno == 1)) {
          {
          if (! (proc_errno == 13)) {
            {
            if (! (proc_errno == 38)) {
              {
              if (! (proc_errno == 95)) {
                {
                {
                tmp___3 = __errno_location();
                *tmp___3 = proc_errno;
                }
                return (proc_result);
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  {
  tmp___5 = save_cwd(& saved_cwd);
  }
  if (tmp___5 != 0) {
    {
    {
    tmp___4 = __errno_location();
    openat_save_fail(*tmp___4);
    }
    }
  }
  if (0 <= fd) {
    {
    if (fd == saved_cwd.desc) {
      {
      {
      free_cwd(& saved_cwd);
      tmp___6 = __errno_location();
      *tmp___6 = 9;
      }
      return (-1);
      }
    }
    }
  }
  {
  tmp___9 = fchdir(fd);
  }
  if (tmp___9 != 0) {
    {
    {
    tmp___7 = __errno_location();
    saved_errno = *tmp___7;
    free_cwd(& saved_cwd);
    tmp___8 = __errno_location();
    *tmp___8 = saved_errno;
    }
    return (-1);
    }
  }
  {
  err = setfilecon(file, con);
  }
  if (err == -1) {
    {
    {
    tmp___10 = __errno_location();
    saved_errno = *tmp___10;
    }
    }
  } else {
    {
    {
    saved_errno = 0;
    }
    }
  }
  {
  tmp___12 = restore_cwd((struct saved_cwd const *)(& saved_cwd));
  }
  if (tmp___12 != 0) {
    {
    {
    tmp___11 = __errno_location();
    openat_restore_fail(*tmp___11);
    }
    }
  }
  {
  free_cwd(& saved_cwd);
  }
  if (saved_errno) {
    {
    {
    tmp___13 = __errno_location();
    *tmp___13 = saved_errno;
    }
    }
  }
  return (err);
}
}
static int str2signum(char const *signame )
{
  char *endp ;
  long n ;
  long tmp ;
  unsigned int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *endp___0 ;
  int rtmin ;
  int tmp___7 ;
  int rtmax ;
  int tmp___8 ;
  long n___0 ;
  long tmp___9 ;
  long n___1 ;
  long tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___27 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  {
  if ((unsigned int )*signame - 48U <= 9U) {
    {
    {
    tmp = strtol((char const * __restrict )signame, (char ** __restrict )(& endp),
                 10);
    n = tmp;
    }
    if (! *endp) {
      {
      if (n <= 64L) {
        {
        return ((int )n);
        }
      }
      }
    }
    }
  } else {
    {
    {
    i = 0U;
    }
    {
    while (1) {
      while_continue: ;
      if (! ((unsigned long )i < sizeof(numname_table) / sizeof(numname_table[0]))) {
        {
        goto while_break;
        }
      }
      if (0) {
        {
        {
        __s1_len = __builtin_strlen(numname_table[i].name);
        __s2_len = __builtin_strlen(signame);
        }
        if (! ((size_t )((void const *)(numname_table[i].name + 1)) - (size_t )((void const *)(numname_table[i].name)) == 1UL)) {
          {
          goto _L___0;
          }
        } else {
          {
          if (__s1_len >= 4UL) {
            {
            _L___0:
            if (! ((size_t )((void const *)(signame + 1)) - (size_t )((void const *)signame) == 1UL)) {
              {
              {
              tmp___6 = 1;
              }
              }
            } else {
              {
              if (__s2_len >= 4UL) {
                {
                {
                tmp___6 = 1;
                }
                }
              } else {
                {
                {
                tmp___6 = 0;
                }
                }
              }
              }
            }
            }
          } else {
            {
            {
            tmp___6 = 0;
            }
            }
          }
          }
        }
        if (tmp___6) {
          {
          {
          tmp___1 = __builtin_strcmp(numname_table[i].name, signame);
          tmp___5 = tmp___1;
          }
          }
        } else {
          {
          {
          tmp___4 = __builtin_strcmp(numname_table[i].name, signame);
          tmp___5 = tmp___4;
          }
          }
        }
        }
      } else {
        {
        {
        tmp___4 = __builtin_strcmp(numname_table[i].name, signame);
        tmp___5 = tmp___4;
        }
        }
      }
      if (tmp___5 == 0) {
        {
        return (numname_table[i].num);
        }
      }
      {
      i ++;
      }
    }
    while_break: ;
    }
    {
    tmp___7 = __libc_current_sigrtmin();
    rtmin = tmp___7;
    tmp___8 = __libc_current_sigrtmax();
    rtmax = tmp___8;
    }
    if (0 < rtmin) {
      {
      if (0) {
        {
        if (0) {
          {
          {
          __s1_len___1 = __builtin_strlen(signame);
          __s2_len___1 = __builtin_strlen((char const *)"RTMIN");
          }
          if (! ((size_t )((void const *)(signame + 1)) - (size_t )((void const *)signame) == 1UL)) {
            {
            goto _L___4;
            }
          } else {
            {
            if (__s1_len___1 >= 4UL) {
              {
              _L___4:
              if (! ((size_t )((void const *)("RTMIN" + 1)) - (size_t )((void const *)"RTMIN") == 1UL)) {
                {
                {
                tmp___32 = 1;
                }
                }
              } else {
                {
                if (__s2_len___1 >= 4UL) {
                  {
                  {
                  tmp___32 = 1;
                  }
                  }
                } else {
                  {
                  {
                  tmp___32 = 0;
                  }
                  }
                }
                }
              }
              }
            } else {
              {
              {
              tmp___32 = 0;
              }
              }
            }
            }
          }
          if (tmp___32) {
            {
            {
            tmp___27 = __builtin_strcmp(signame, (char const *)"RTMIN");
            tmp___31 = tmp___27;
            }
            }
          } else {
            {
            {
            tmp___30 = __builtin_strcmp(signame, (char const *)"RTMIN");
            tmp___31 = tmp___30;
            }
            }
          }
          }
        } else {
          {
          {
          tmp___30 = __builtin_strcmp(signame, (char const *)"RTMIN");
          tmp___31 = tmp___30;
          }
          }
        }
        {
        tmp___34 = tmp___31;
        }
        }
      } else {
        {
        {
        tmp___33 = strncmp(signame, (char const *)"RTMIN", (size_t )5);
        tmp___34 = tmp___33;
        }
        }
      }
      if (tmp___34 == 0) {
        {
        {
        tmp___9 = strtol((char const * __restrict )(signame + 5), (char ** __restrict )(& endp___0),
                         10);
        n___0 = tmp___9;
        }
        if (! *endp___0) {
          {
          if (0L <= n___0) {
            {
            if (n___0 <= (long )(rtmax - rtmin)) {
              {
              return ((int )((long )rtmin + n___0));
              }
            }
            }
          }
          }
        }
        }
      } else {
        {
        goto _L___5;
        }
      }
      }
    } else {
      {
      _L___5:
      if (0 < rtmax) {
        {
        if (0) {
          {
          if (0) {
            {
            {
            __s1_len___0 = __builtin_strlen(signame);
            __s2_len___0 = __builtin_strlen((char const *)"RTMAX");
            }
            if (! ((size_t )((void const *)(signame + 1)) - (size_t )((void const *)signame) == 1UL)) {
              {
              goto _L___2;
              }
            } else {
              {
              if (__s1_len___0 >= 4UL) {
                {
                _L___2:
                if (! ((size_t )((void const *)("RTMAX" + 1)) - (size_t )((void const *)"RTMAX") == 1UL)) {
                  {
                  {
                  tmp___19 = 1;
                  }
                  }
                } else {
                  {
                  if (__s2_len___0 >= 4UL) {
                    {
                    {
                    tmp___19 = 1;
                    }
                    }
                  } else {
                    {
                    {
                    tmp___19 = 0;
                    }
                    }
                  }
                  }
                }
                }
              } else {
                {
                {
                tmp___19 = 0;
                }
                }
              }
              }
            }
            if (tmp___19) {
              {
              {
              tmp___14 = __builtin_strcmp(signame, (char const *)"RTMAX");
              tmp___18 = tmp___14;
              }
              }
            } else {
              {
              {
              tmp___17 = __builtin_strcmp(signame, (char const *)"RTMAX");
              tmp___18 = tmp___17;
              }
              }
            }
            }
          } else {
            {
            {
            tmp___17 = __builtin_strcmp(signame, (char const *)"RTMAX");
            tmp___18 = tmp___17;
            }
            }
          }
          {
          tmp___21 = tmp___18;
          }
          }
        } else {
          {
          {
          tmp___20 = strncmp(signame, (char const *)"RTMAX", (size_t )5);
          tmp___21 = tmp___20;
          }
          }
        }
        if (tmp___21 == 0) {
          {
          {
          tmp___10 = strtol((char const * __restrict )(signame + 5), (char ** __restrict )(& endp___0),
                            10);
          n___1 = tmp___10;
          }
          if (! *endp___0) {
            {
            if ((long )(rtmin - rtmax) <= n___1) {
              {
              if (n___1 <= 0L) {
                {
                return ((int )((long )rtmax + n___1));
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  return (-1);
}
}
int str2sig(char const *signame , int *signum )
{
  int tmp ;
  {
  {
  *signum = str2signum(signame);
  }
  if (*signum < 0) {
    {
    {
    tmp = -1;
    }
    }
  } else {
    {
    {
    tmp = 0;
    }
    }
  }
  return (tmp);
}
}
int sig2str(int signum , char *signame )
{
  unsigned int i ;
  int rtmin ;
  int tmp ;
  int rtmax ;
  int tmp___0 ;
  int delta ;
  char const *tmp___1 ;
  int delta___0 ;
  char const *tmp___2 ;
  {
  {
  i = 0U;
  }
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )i < sizeof(numname_table) / sizeof(numname_table[0]))) {
      {
      goto while_break;
      }
    }
    if (numname_table[i].num == signum) {
      {
      {
      strcpy((char *)((char * __restrict )signame), (char const *)((char const * __restrict )(numname_table[i].name)));
      }
      return (0);
      }
    }
    {
    i ++;
    }
  }
  while_break: ;
  }
  {
  tmp = __libc_current_sigrtmin();
  rtmin = tmp;
  tmp___0 = __libc_current_sigrtmax();
  rtmax = tmp___0;
  }
  if (rtmin <= signum) {
    {
    if (! (signum <= rtmax)) {
      {
      return (-1);
      }
    }
    }
  } else {
    {
    return (-1);
    }
  }
  if (signum <= rtmin + (rtmax - rtmin) / 2) {
    {
    {
    delta = signum - rtmin;
    }
    if (delta) {
      {
      {
      tmp___1 = (char const *)"RTMIN+%d";
      }
      }
    } else {
      {
      {
      tmp___1 = (char const *)"RTMIN";
      }
      }
    }
    {
    sprintf((char *)((char * __restrict )signame), (char const *)((char const * __restrict )tmp___1),
            delta);
    }
    }
  } else {
    {
    {
    delta___0 = rtmax - signum;
    }
    if (delta___0) {
      {
      {
      tmp___2 = (char const *)"RTMAX-%d";
      }
      }
    } else {
      {
      {
      tmp___2 = (char const *)"RTMAX";
      }
      }
    }
    {
    sprintf((char *)((char * __restrict )signame), (char const *)((char const * __restrict )tmp___2),
            delta___0);
    }
    }
  }
  return (0);
}
}
char *rpl_strerror(int n )
{
  size_t len ;
  char const *msg ;
  char *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  {
  {
  msg = (char const *)((void *)0);
  }
  if (msg) {
    {
    return ((char *)msg);
    }
  }
  {
  tmp = strerror(n);
  msg = (char const *)tmp;
  }
  if (! msg) {
    {
    {
    sprintf((char *)((char * __restrict )(buf___0)), (char const *)((char const * __restrict )(fmt)),
            n);
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    }
    return (buf___0);
    }
  } else {
    {
    if (! *msg) {
      {
      {
      sprintf((char *)((char * __restrict )(buf___0)), (char const *)((char const * __restrict )(fmt)),
              n);
      tmp___0 = __errno_location();
      *tmp___0 = 22;
      }
      return (buf___0);
      }
    }
    }
  }
  {
  len = strlen(msg);
  }
  if (sizeof(buf___0) <= len) {
    {
    {
    abort();
    }
    }
  }
  {
  tmp___1 = memcpy((void *)((void * __restrict )(buf___0)), (void const *)((void const * __restrict )msg),
                   len + 1UL);
  }
  return ((char *)tmp___1);
}
}
int ( __attribute__((__nonnull__(2))) rpl_utimensat)(int fd , char const *file ,
                                                     struct timespec const *times ,
                                                     int flag )
{
  struct timespec ts[2] ;
  int result ;
  struct stat st ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  {
  if (0 <= utimensat_works_really___0) {
    {
    if (times) {
      {
      if ((times + 0)->tv_nsec == (long )((long const )((1L << 30) - 2L))) {
        {
        goto _L;
        }
      } else {
        {
        if ((times + 1)->tv_nsec == (long )((long const )((1L << 30) - 2L))) {
          {
          _L:
          {
          tmp = fstatat(fd, (char const *)((char const * __restrict )file), (struct stat *)((struct stat * __restrict )(& st)),
                        flag);
          }
          if (tmp) {
            {
            return (-1);
            }
          }
          if ((times + 0)->tv_nsec == (long )((long const )((1L << 30) - 2L))) {
            {
            if ((times + 1)->tv_nsec == (long )((long const )((1L << 30) - 2L))) {
              {
              return (0);
              }
            }
            }
          }
          if ((times + 0)->tv_nsec == (long )((long const )((1L << 30) - 2L))) {
            {
            {
            ts[0] = get_stat_atime((struct stat const *)(& st));
            }
            }
          } else {
            {
            {
            ts[0] = (struct timespec )*(times + 0);
            }
            }
          }
          if ((times + 1)->tv_nsec == (long )((long const )((1L << 30) - 2L))) {
            {
            {
            ts[1] = get_stat_mtime((struct stat const *)(& st));
            }
            }
          } else {
            {
            {
            ts[1] = (struct timespec )*(times + 1);
            }
            }
          }
          {
          times = (struct timespec const *)(ts);
          }
          }
        }
        }
      }
      }
    }
    {
    result = utimensat(fd, file, times, flag);
    }
    if (result == -1) {
      {
      {
      tmp___0 = __errno_location();
      }
      if (*tmp___0 == 22) {
        {
        if (flag & -257) {
          {
          return (result);
          }
        }
        }
      }
      }
    }
    if (result == 0) {
      {
      {
      utimensat_works_really___0 = 1;
      }
      return (result);
      }
    } else {
      {
      {
      tmp___1 = __errno_location();
      }
      if (*tmp___1 != 38) {
        {
        {
        tmp___2 = __errno_location();
        }
        if (*tmp___2 != 22) {
          {
          {
          utimensat_works_really___0 = 1;
          }
          return (result);
          }
        }
        }
      }
      }
    }
    }
  }
  if (0 <= utimensat_works_really___0) {
    {
    {
    tmp___3 = __errno_location();
    }
    if (*tmp___3 == 38) {
      {
      {
      utimensat_works_really___0 = -1;
      }
      }
    }
    }
  }
  {
  tmp___4 = local_utimensat(fd, file, times, flag);
  }
  return (tmp___4);
}
}
static int local_utimensat(int fd , char const *file , struct timespec const *ts ,
                           int flag )
{
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___3 ;
  int proc_result ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int proc_errno ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  {
  if (flag & -257) {
    {
    {
    tmp = __errno_location();
    *tmp = 22;
    }
    return (-1);
    }
  }
  if (fd == -100) {
    {
    goto _L___0;
    }
  } else {
    {
    if ((int const )*(file + 0) == 47) {
      {
      goto _L___0;
      }
    } else {
      {
      if (0) {
        {
        _L___0:
        if (flag == 256) {
          {
          {
          tmp___0 = lutimens(file, ts);
          tmp___2 = tmp___0;
          }
          }
        } else {
          {
          {
          tmp___1 = utimens(file, ts);
          tmp___2 = tmp___1;
          }
          }
        }
        return (tmp___2);
        }
      }
      }
    }
    }
  }
  {
  tmp___3 = openat_proc_name(proc_buf, fd, file);
  proc_file = tmp___3;
  }
  if (proc_file) {
    {
    if (flag == 256) {
      {
      {
      tmp___4 = lutimens((char const *)proc_file, ts);
      tmp___6 = tmp___4;
      }
      }
    } else {
      {
      {
      tmp___5 = utimens((char const *)proc_file, ts);
      tmp___6 = tmp___5;
      }
      }
    }
    {
    proc_result = tmp___6;
    tmp___7 = __errno_location();
    proc_errno = *tmp___7;
    }
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      {
      {
      free((void *)proc_file);
      }
      }
    }
    if (-1 != proc_result) {
      {
      return (proc_result);
      }
    }
    if (! (proc_errno == 20)) {
      {
      if (! (proc_errno == 2)) {
        {
        if (! (proc_errno == 1)) {
          {
          if (! (proc_errno == 13)) {
            {
            if (! (proc_errno == 38)) {
              {
              if (! (proc_errno == 95)) {
                {
                {
                tmp___8 = __errno_location();
                *tmp___8 = proc_errno;
                }
                return (proc_result);
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  {
  tmp___10 = save_cwd(& saved_cwd);
  }
  if (tmp___10 != 0) {
    {
    {
    tmp___9 = __errno_location();
    openat_save_fail(*tmp___9);
    }
    }
  }
  if (0 <= fd) {
    {
    if (fd == saved_cwd.desc) {
      {
      {
      free_cwd(& saved_cwd);
      tmp___11 = __errno_location();
      *tmp___11 = 9;
      }
      return (-1);
      }
    }
    }
  }
  {
  tmp___14 = fchdir(fd);
  }
  if (tmp___14 != 0) {
    {
    {
    tmp___12 = __errno_location();
    saved_errno = *tmp___12;
    free_cwd(& saved_cwd);
    tmp___13 = __errno_location();
    *tmp___13 = saved_errno;
    }
    return (-1);
    }
  }
  if (flag == 256) {
    {
    {
    tmp___15 = lutimens(file, ts);
    err = tmp___15;
    }
    }
  } else {
    {
    {
    tmp___16 = utimens(file, ts);
    err = tmp___16;
    }
    }
  }
  if (err == -1) {
    {
    {
    tmp___17 = __errno_location();
    saved_errno = *tmp___17;
    }
    }
  } else {
    {
    {
    saved_errno = 0;
    }
    }
  }
  {
  tmp___19 = restore_cwd((struct saved_cwd const *)(& saved_cwd));
  }
  if (tmp___19 != 0) {
    {
    {
    tmp___18 = __errno_location();
    openat_restore_fail(*tmp___18);
    }
    }
  }
  {
  free_cwd(& saved_cwd);
  }
  if (saved_errno) {
    {
    {
    tmp___20 = __errno_location();
    *tmp___20 = saved_errno;
    }
    }
  }
  return (err);
}
}
__inline static size_t __attribute__((__pure__)) xsum4(size_t size1 , size_t size2 ,
                                                        size_t size3 , size_t size4 )
{
  size_t __attribute__((__pure__)) tmp ;
  size_t __attribute__((__pure__)) tmp___0 ;
  size_t __attribute__((__pure__)) tmp___1 ;
  {
  {
  tmp = xsum(size1, size2);
  tmp___0 = xsum((size_t )tmp, size3);
  tmp___1 = xsum((size_t )tmp___0, size4);
  }
  return (tmp___1);
}
}
__inline static size_t __attribute__((__pure__)) xmax(size_t size1 , size_t size2 )
{
  size_t tmp ;
  {
  if (size1 >= size2) {
    {
    {
    tmp = size1;
    }
    }
  } else {
    {
    {
    tmp = size2;
    }
    }
  }
  return ((size_t __attribute__((__pure__)) )tmp);
}
}
__inline extern int __signbitl(long double __x ) __attribute__((__nothrow__, __const__)) ;
__inline extern int __signbitl(long double __x )
{
  union __anonunion___u_36 __u ;
  {
  {
  __u.__l = __x;
  }
  return ((__u.__i[2] & 32768) != 0);
}
}
static char decimal_point_char(void)
{
  char const *point ;
  char *tmp ;
  int tmp___0 ;
  {
  {
  tmp = nl_langinfo(65536);
  point = (char const *)tmp;
  }
  if ((int const )*(point + 0) != 0) {
    {
    {
    tmp___0 = (int )((int const )*(point + 0));
    }
    }
  } else {
    {
    {
    tmp___0 = (int )((int const )'.');
    }
    }
  }
  return ((char )tmp___0);
}
}
static int is_infinite_or_zerol(long double x )
{
  int tmp ;
  int tmp___0 ;
  {
  {
  tmp = rpl_isnanl(x);
  }
  if (tmp) {
    {
    {
    tmp___0 = 1;
    }
    }
  } else {
    {
    if (x + x == x) {
      {
      {
      tmp___0 = 1;
      }
      }
    } else {
      {
      {
      tmp___0 = 0;
      }
      }
    }
    }
  }
  return (tmp___0);
}
}
char *vasnprintf(char *resultbuf , size_t *lengthp , char const *format , va_list args )
{
  char_directives d ;
  arguments a ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t buf_neededlength ;
  char *buf___1 ;
  char *buf_malloced ;
  char const *cp ;
  size_t i ;
  char_directive *dp ;
  char *result ;
  size_t allocated ;
  size_t length ;
  size_t __attribute__((__pure__)) tmp___2 ;
  void *tmp___3 ;
  size_t buf_memsize ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t n ;
  size_t augmented_length ;
  size_t __attribute__((__pure__)) tmp___6 ;
  size_t memory_size ;
  char *memory ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  char const *tmp___11 ;
  size_t augmented_length___0 ;
  size_t __attribute__((__pure__)) tmp___12 ;
  size_t memory_size___0 ;
  char *memory___0 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  int flags ;
  int has_width ;
  size_t width ;
  int has_precision ;
  size_t precision ;
  size_t tmp_length ;
  char tmpbuf[700] ;
  char *tmp___16 ;
  char *pad_ptr ;
  char *p ;
  int arg ;
  char const *digitp ;
  char const *tmp___17 ;
  size_t tmp___18 ;
  size_t __attribute__((__pure__)) tmp___19 ;
  int arg___0 ;
  char const *digitp___0 ;
  char const *tmp___20 ;
  size_t tmp___21 ;
  size_t __attribute__((__pure__)) tmp___22 ;
  size_t __attribute__((__pure__)) tmp___23 ;
  size_t __attribute__((__pure__)) tmp___24 ;
  size_t tmp_memsize ;
  size_t tmp___25 ;
  void *tmp___26 ;
  long double arg___1 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  int sign ;
  fpucw_t oldcw ;
  fpucw_t _cw ;
  fpucw_t _ncw ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  size_t ndigits ;
  size_t tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  fpucw_t _ncw___0 ;
  int tmp___69 ;
  size_t pad ;
  char *end ;
  char *tmp___70 ;
  char *q ;
  char *tmp___71 ;
  char *q___0 ;
  char *tmp___72 ;
  size_t count ;
  size_t n___0 ;
  size_t __attribute__((__pure__)) tmp___73 ;
  size_t memory_size___1 ;
  char *memory___1 ;
  size_t tmp___74 ;
  void *tmp___75 ;
  void *tmp___76 ;
  arg_type type ;
  int flags___0 ;
  char *fbp ;
  unsigned int prefix_count ;
  int prefixes[2] ;
  int orig_errno ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  size_t n___1 ;
  char const *mp ;
  char *tmp___85 ;
  char const *tmp___86 ;
  size_t n___2 ;
  char const *mp___0 ;
  char *tmp___87 ;
  char const *tmp___88 ;
  char *tmp___89 ;
  char *tmp___90 ;
  char *tmp___91 ;
  unsigned int tmp___92 ;
  unsigned int tmp___93 ;
  size_t memory_size___2 ;
  char *memory___2 ;
  size_t tmp___94 ;
  size_t __attribute__((__pure__)) tmp___95 ;
  size_t __attribute__((__pure__)) tmp___96 ;
  void *tmp___97 ;
  void *tmp___98 ;
  size_t __attribute__((__pure__)) tmp___99 ;
  int *tmp___100 ;
  int count___0 ;
  int retcount ;
  size_t maxlen ;
  int *tmp___101 ;
  int arg___2 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  unsigned int arg___3 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int arg___4 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  unsigned int arg___5 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int arg___6 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  unsigned int arg___7 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  long arg___8 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  unsigned long arg___9 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  long long arg___10 ;
  int tmp___126 ;
  int tmp___127 ;
  int tmp___128 ;
  unsigned long long arg___11 ;
  int tmp___129 ;
  int tmp___130 ;
  int tmp___131 ;
  double arg___12 ;
  int tmp___132 ;
  int tmp___133 ;
  int tmp___134 ;
  long double arg___13 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int arg___14 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  wint_t arg___15 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  char const *arg___16 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  wchar_t const *arg___17 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  void *arg___18 ;
  int tmp___150 ;
  int tmp___151 ;
  int tmp___152 ;
  int saved_errno ;
  int *tmp___153 ;
  int *tmp___154 ;
  int tmp___155 ;
  size_t n___3 ;
  size_t tmp___156 ;
  size_t __attribute__((__pure__)) tmp___157 ;
  size_t __attribute__((__pure__)) tmp___158 ;
  size_t memory_size___3 ;
  char *memory___3 ;
  size_t tmp___159 ;
  void *tmp___160 ;
  void *tmp___161 ;
  int *tmp___162 ;
  int tmp___163 ;
  size_t memory_size___4 ;
  char *memory___4 ;
  size_t tmp___164 ;
  size_t __attribute__((__pure__)) tmp___165 ;
  size_t __attribute__((__pure__)) tmp___166 ;
  void *tmp___167 ;
  void *tmp___168 ;
  size_t __attribute__((__pure__)) tmp___169 ;
  char *memory___5 ;
  void *tmp___170 ;
  int *tmp___171 ;
  int *tmp___172 ;
  {
  {
  tmp = printf_parse(format, & d, & a);
  }
  if (tmp < 0) {
    {
    return ((char *)((void *)0));
    }
  }
  {
  tmp___1 = printf_fetchargs(args, & a);
  }
  if (tmp___1 < 0) {
    {
    if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
      {
      {
      free((void *)d.dir);
      }
      }
    }
    if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
      {
      {
      free((void *)a.arg);
      }
      }
    }
    {
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    }
    return ((char *)((void *)0));
    }
  }
  {
  tmp___2 = xsum4((size_t )7, d.max_width_length, d.max_precision_length, (size_t )6);
  buf_neededlength = (size_t )tmp___2;
  }
  if (buf_neededlength < 4000UL / sizeof(char )) {
    {
    {
    tmp___3 = __builtin_alloca(buf_neededlength * sizeof(char ));
    buf___1 = (char *)tmp___3;
    buf_malloced = (char *)((void *)0);
    }
    }
  } else {
    {
    if (buf_neededlength <= 0xffffffffffffffffUL / sizeof(char )) {
      {
      {
      tmp___4 = buf_neededlength * sizeof(char );
      }
      }
    } else {
      {
      {
      tmp___4 = 0xffffffffffffffffUL;
      }
      }
    }
    {
    buf_memsize = tmp___4;
    }
    if (buf_memsize == 0xffffffffffffffffUL) {
      {
      goto out_of_memory_1;
      }
    }
    {
    tmp___5 = malloc(buf_memsize);
    buf___1 = (char *)tmp___5;
    }
    if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
      {
      goto out_of_memory_1;
      }
    }
    {
    buf_malloced = buf___1;
    }
    }
  }
  if ((unsigned long )resultbuf != (unsigned long )((void *)0)) {
    {
    {
    result = resultbuf;
    allocated = *lengthp;
    }
    }
  } else {
    {
    {
    result = (char *)((void *)0);
    allocated = (size_t )0;
    }
    }
  }
  {
  length = (size_t )0;
  cp = format;
  i = (size_t )0;
  dp = d.dir + 0;
  }
  {
  while (1) {
    while_continue: ;
    if (! 1) {
      {
      goto while_break;
      }
    }
    if ((unsigned long )cp != (unsigned long )dp->dir_start) {
      {
      {
      n = (size_t )(dp->dir_start - cp);
      tmp___6 = xsum(length, n);
      augmented_length = (size_t )tmp___6;
      }
      if (augmented_length > allocated) {
        {
        if (allocated > 0UL) {
          {
          if (allocated <= 9223372036854775807UL) {
            {
            {
            tmp___7 = allocated * 2UL;
            }
            }
          } else {
            {
            {
            tmp___7 = 0xffffffffffffffffUL;
            }
            }
          }
          {
          allocated = tmp___7;
          }
          }
        } else {
          {
          {
          allocated = (size_t )12;
          }
          }
        }
        if (augmented_length > allocated) {
          {
          {
          allocated = augmented_length;
          }
          }
        }
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
          {
          {
          memory_size = allocated * sizeof(char );
          }
          }
        } else {
          {
          {
          memory_size = 0xffffffffffffffffUL;
          }
          }
        }
        if (memory_size == 0xffffffffffffffffUL) {
          {
          goto out_of_memory;
          }
        }
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
          {
          tmp___8 = malloc(memory_size);
          memory = (char *)tmp___8;
          }
          }
        } else {
          {
          if ((unsigned long )result == (unsigned long )((void *)0)) {
            {
            {
            tmp___8 = malloc(memory_size);
            memory = (char *)tmp___8;
            }
            }
          } else {
            {
            {
            tmp___9 = realloc((void *)result, memory_size);
            memory = (char *)tmp___9;
            }
            }
          }
          }
        }
        if ((unsigned long )memory == (unsigned long )((void *)0)) {
          {
          goto out_of_memory;
          }
        }
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
          if (length > 0UL) {
            {
            {
            memcpy((void *)((void * __restrict )memory), (void const *)((void const * __restrict )result),
                   length);
            }
            }
          }
          }
        }
        {
        result = memory;
        }
        }
      }
      if (sizeof(char ) == sizeof(char )) {
        {
        {
        memcpy((void *)((void * __restrict )(result + length)), (void const *)((void const * __restrict )cp),
               n);
        length = augmented_length;
        }
        }
      } else {
        {
        {
        while (1) {
          while_continue___0: ;
          if (! 1) {
            {
            goto while_break___0;
            }
          }
          {
          tmp___10 = length;
          length ++;
          tmp___11 = cp;
          cp ++;
          *(result + tmp___10) = (char )((unsigned char )*tmp___11);
          n --;
          }
          if (! (n > 0UL)) {
            {
            goto while_break___0;
            }
          }
        }
        while_break___0: ;
        }
        }
      }
      }
    }
    if (i == d.count) {
      {
      goto while_break;
      }
    }
    if ((int )dp->conversion == 37) {
      {
      if (! (dp->arg_index == 0xffffffffffffffffUL)) {
        {
        {
        abort();
        }
        }
      }
      {
      tmp___12 = xsum(length, (size_t )1);
      augmented_length___0 = (size_t )tmp___12;
      }
      if (augmented_length___0 > allocated) {
        {
        if (allocated > 0UL) {
          {
          if (allocated <= 9223372036854775807UL) {
            {
            {
            tmp___13 = allocated * 2UL;
            }
            }
          } else {
            {
            {
            tmp___13 = 0xffffffffffffffffUL;
            }
            }
          }
          {
          allocated = tmp___13;
          }
          }
        } else {
          {
          {
          allocated = (size_t )12;
          }
          }
        }
        if (augmented_length___0 > allocated) {
          {
          {
          allocated = augmented_length___0;
          }
          }
        }
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
          {
          {
          memory_size___0 = allocated * sizeof(char );
          }
          }
        } else {
          {
          {
          memory_size___0 = 0xffffffffffffffffUL;
          }
          }
        }
        if (memory_size___0 == 0xffffffffffffffffUL) {
          {
          goto out_of_memory;
          }
        }
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
          {
          tmp___14 = malloc(memory_size___0);
          memory___0 = (char *)tmp___14;
          }
          }
        } else {
          {
          if ((unsigned long )result == (unsigned long )((void *)0)) {
            {
            {
            tmp___14 = malloc(memory_size___0);
            memory___0 = (char *)tmp___14;
            }
            }
          } else {
            {
            {
            tmp___15 = realloc((void *)result, memory_size___0);
            memory___0 = (char *)tmp___15;
            }
            }
          }
          }
        }
        if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
          {
          goto out_of_memory;
          }
        }
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
          if (length > 0UL) {
            {
            {
            memcpy((void *)((void * __restrict )memory___0), (void const *)((void const * __restrict )result),
                   length);
            }
            }
          }
          }
        }
        {
        result = memory___0;
        }
        }
      }
      {
      *(result + length) = (char )'%';
      length = augmented_length___0;
      }
      }
    } else {
      {
      if (! (dp->arg_index != 0xffffffffffffffffUL)) {
        {
        {
        abort();
        }
        }
      }
      if ((int )dp->conversion == 110) {
        {
        {
        if ((int )(a.arg + dp->arg_index)->type == 18) {
          {
          goto case_18;
          }
        }
        if ((int )(a.arg + dp->arg_index)->type == 19) {
          {
          goto case_19;
          }
        }
        if ((int )(a.arg + dp->arg_index)->type == 20) {
          {
          goto case_20;
          }
        }
        if ((int )(a.arg + dp->arg_index)->type == 21) {
          {
          goto case_21;
          }
        }
        if ((int )(a.arg + dp->arg_index)->type == 22) {
          {
          goto case_22;
          }
        }
        goto switch_default;
        case_18:
        {
        *((a.arg + dp->arg_index)->a.a_count_schar_pointer) = (signed char )length;
        }
        goto switch_break;
        case_19:
        {
        *((a.arg + dp->arg_index)->a.a_count_short_pointer) = (short )length;
        }
        goto switch_break;
        case_20:
        {
        *((a.arg + dp->arg_index)->a.a_count_int_pointer) = (int )length;
        }
        goto switch_break;
        case_21:
        {
        *((a.arg + dp->arg_index)->a.a_count_longint_pointer) = (long )length;
        }
        goto switch_break;
        case_22:
        {
        *((a.arg + dp->arg_index)->a.a_count_longlongint_pointer) = (long long )length;
        }
        goto switch_break;
        switch_default:
        {
        abort();
        }
        switch_break: ;
        }
        }
      } else {
        {
        if ((int )dp->conversion == 102) {
          {
          goto _L___11;
          }
        } else {
          {
          if ((int )dp->conversion == 70) {
            {
            goto _L___11;
            }
          } else {
            {
            if ((int )dp->conversion == 101) {
              {
              goto _L___11;
              }
            } else {
              {
              if ((int )dp->conversion == 69) {
                {
                goto _L___11;
                }
              } else {
                {
                if ((int )dp->conversion == 103) {
                  {
                  goto _L___11;
                  }
                } else {
                  {
                  if ((int )dp->conversion == 71) {
                    {
                    goto _L___11;
                    }
                  } else {
                    {
                    if ((int )dp->conversion == 97) {
                      {
                      goto _L___11;
                      }
                    } else {
                      {
                      if ((int )dp->conversion == 65) {
                        {
                        _L___11:
                        if ((unsigned int )(a.arg + dp->arg_index)->type == 12U) {
                          {
                          {
                          tmp___163 = is_infinite_or_zerol((a.arg + dp->arg_index)->a.a_longdouble);
                          }
                          if (tmp___163) {
                            {
                            {
                            flags = dp->flags;
                            has_width = 0;
                            width = (size_t )0;
                            }
                            if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
                              {
                              if (dp->width_arg_index != 0xffffffffffffffffUL) {
                                {
                                if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
                                  {
                                  {
                                  abort();
                                  }
                                  }
                                }
                                {
                                arg = (a.arg + dp->width_arg_index)->a.a_int;
                                }
                                if (arg < 0) {
                                  {
                                  {
                                  flags |= 2;
                                  width = (size_t )((unsigned int )(- arg));
                                  }
                                  }
                                } else {
                                  {
                                  {
                                  width = (size_t )arg;
                                  }
                                  }
                                }
                                }
                              } else {
                                {
                                {
                                digitp = dp->width_start;
                                }
                                {
                                while (1) {
                                  while_continue___1: ;
                                  if (! 1) {
                                    {
                                    goto while_break___1;
                                    }
                                  }
                                  {
                                  tmp___17 = digitp;
                                  digitp ++;
                                  }
                                  if (width <= 1844674407370955161UL) {
                                    {
                                    {
                                    tmp___18 = width * 10UL;
                                    }
                                    }
                                  } else {
                                    {
                                    {
                                    tmp___18 = 0xffffffffffffffffUL;
                                    }
                                    }
                                  }
                                  {
                                  tmp___19 = xsum(tmp___18, (size_t )((int const )*tmp___17 - 48));
                                  width = (size_t )tmp___19;
                                  }
                                  if (! ((unsigned long )digitp != (unsigned long )dp->width_end)) {
                                    {
                                    goto while_break___1;
                                    }
                                  }
                                }
                                while_break___1: ;
                                }
                                }
                              }
                              {
                              has_width = 1;
                              }
                              }
                            }
                            {
                            has_precision = 0;
                            precision = (size_t )0;
                            }
                            if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
                              {
                              if (dp->precision_arg_index != 0xffffffffffffffffUL) {
                                {
                                if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
                                  {
                                  {
                                  abort();
                                  }
                                  }
                                }
                                {
                                arg___0 = (a.arg + dp->precision_arg_index)->a.a_int;
                                }
                                if (arg___0 >= 0) {
                                  {
                                  {
                                  precision = (size_t )arg___0;
                                  has_precision = 1;
                                  }
                                  }
                                }
                                }
                              } else {
                                {
                                {
                                digitp___0 = dp->precision_start + 1;
                                precision = (size_t )0;
                                }
                                {
                                while (1) {
                                  while_continue___2: ;
                                  if (! ((unsigned long )digitp___0 != (unsigned long )dp->precision_end)) {
                                    {
                                    goto while_break___2;
                                    }
                                  }
                                  {
                                  tmp___20 = digitp___0;
                                  digitp___0 ++;
                                  }
                                  if (precision <= 1844674407370955161UL) {
                                    {
                                    {
                                    tmp___21 = precision * 10UL;
                                    }
                                    }
                                  } else {
                                    {
                                    {
                                    tmp___21 = 0xffffffffffffffffUL;
                                    }
                                    }
                                  }
                                  {
                                  tmp___22 = xsum(tmp___21, (size_t )((int const )*tmp___20 - 48));
                                  precision = (size_t )tmp___22;
                                  }
                                }
                                while_break___2: ;
                                }
                                {
                                has_precision = 1;
                                }
                                }
                              }
                              }
                            }
                            if (! has_precision) {
                              {
                              if (! ((int )dp->conversion == 97)) {
                                {
                                if (! ((int )dp->conversion == 65)) {
                                  {
                                  {
                                  precision = (size_t )6;
                                  }
                                  }
                                }
                                }
                              }
                              }
                            }
                            {
                            tmp_length = (size_t )0;
                            }
                            if (tmp_length < precision) {
                              {
                              {
                              tmp_length = precision;
                              }
                              }
                            }
                            {
                            tmp___23 = xsum(tmp_length, (size_t )12);
                            tmp_length = (size_t )tmp___23;
                            }
                            if (tmp_length < width) {
                              {
                              {
                              tmp_length = width;
                              }
                              }
                            }
                            {
                            tmp___24 = xsum(tmp_length, (size_t )1);
                            tmp_length = (size_t )tmp___24;
                            }
                            if (tmp_length <= sizeof(tmpbuf) / sizeof(char )) {
                              {
                              {
                              tmp___16 = tmpbuf;
                              }
                              }
                            } else {
                              {
                              if (tmp_length <= 0xffffffffffffffffUL / sizeof(char )) {
                                {
                                {
                                tmp___25 = tmp_length * sizeof(char );
                                }
                                }
                              } else {
                                {
                                {
                                tmp___25 = 0xffffffffffffffffUL;
                                }
                                }
                              }
                              {
                              tmp_memsize = tmp___25;
                              }
                              if (tmp_memsize == 0xffffffffffffffffUL) {
                                {
                                goto out_of_memory;
                                }
                              }
                              {
                              tmp___26 = malloc(tmp_memsize);
                              tmp___16 = (char *)tmp___26;
                              }
                              if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
                                {
                                goto out_of_memory;
                                }
                              }
                              }
                            }
                            {
                            pad_ptr = (char *)((void *)0);
                            p = tmp___16;
                            arg___1 = (a.arg + dp->arg_index)->a.a_longdouble;
                            tmp___69 = rpl_isnanl(arg___1);
                            }
                            if (tmp___69) {
                              {
                              if ((int )dp->conversion >= 65) {
                                {
                                if ((int )dp->conversion <= 90) {
                                  {
                                  {
                                  tmp___27 = p;
                                  p ++;
                                  *tmp___27 = (char )'N';
                                  tmp___28 = p;
                                  p ++;
                                  *tmp___28 = (char )'A';
                                  tmp___29 = p;
                                  p ++;
                                  *tmp___29 = (char )'N';
                                  }
                                  }
                                } else {
                                  {
                                  goto _L;
                                  }
                                }
                                }
                              } else {
                                {
                                _L:
                                {
                                tmp___30 = p;
                                p ++;
                                *tmp___30 = (char )'n';
                                tmp___31 = p;
                                p ++;
                                *tmp___31 = (char )'a';
                                tmp___32 = p;
                                p ++;
                                *tmp___32 = (char )'n';
                                }
                                }
                              }
                              }
                            } else {
                              {
                              {
                              sign = 0;
                              __asm__ volatile ("fnstcw %0": "=m" (_cw));
                              oldcw = _cw;
                              _ncw = (fpucw_t )(((int )oldcw & -769) | 768);
                              __asm__ volatile ("fldcw %0": : "m" (_ncw));
                              }
                              if (sizeof(arg___1) == sizeof(long double )) {
                                {
                                {
                                tmp___33 = __builtin_signbitl(arg___1);
                                tmp___37 = tmp___33;
                                }
                                }
                              } else {
                                {
                                if (sizeof(arg___1) == sizeof(double )) {
                                  {
                                  {
                                  tmp___34 = __builtin_signbit(arg___1);
                                  tmp___36 = tmp___34;
                                  }
                                  }
                                } else {
                                  {
                                  {
                                  tmp___35 = __builtin_signbitf(arg___1);
                                  tmp___36 = tmp___35;
                                  }
                                  }
                                }
                                {
                                tmp___37 = tmp___36;
                                }
                                }
                              }
                              if (tmp___37) {
                                {
                                {
                                sign = -1;
                                arg___1 = - arg___1;
                                }
                                }
                              }
                              if (sign < 0) {
                                {
                                {
                                tmp___38 = p;
                                p ++;
                                *tmp___38 = (char )'-';
                                }
                                }
                              } else {
                                {
                                if (flags & 4) {
                                  {
                                  {
                                  tmp___39 = p;
                                  p ++;
                                  *tmp___39 = (char )'+';
                                  }
                                  }
                                } else {
                                  {
                                  if (flags & 8) {
                                    {
                                    {
                                    tmp___40 = p;
                                    p ++;
                                    *tmp___40 = (char )' ';
                                    }
                                    }
                                  }
                                  }
                                }
                                }
                              }
                              if (arg___1 > 0.0L) {
                                {
                                if (arg___1 + arg___1 == arg___1) {
                                  {
                                  if ((int )dp->conversion >= 65) {
                                    {
                                    if ((int )dp->conversion <= 90) {
                                      {
                                      {
                                      tmp___41 = p;
                                      p ++;
                                      *tmp___41 = (char )'I';
                                      tmp___42 = p;
                                      p ++;
                                      *tmp___42 = (char )'N';
                                      tmp___43 = p;
                                      p ++;
                                      *tmp___43 = (char )'F';
                                      }
                                      }
                                    } else {
                                      {
                                      goto _L___0;
                                      }
                                    }
                                    }
                                  } else {
                                    {
                                    _L___0:
                                    {
                                    tmp___44 = p;
                                    p ++;
                                    *tmp___44 = (char )'i';
                                    tmp___45 = p;
                                    p ++;
                                    *tmp___45 = (char )'n';
                                    tmp___46 = p;
                                    p ++;
                                    *tmp___46 = (char )'f';
                                    }
                                    }
                                  }
                                  }
                                } else {
                                  {
                                  goto _L___8;
                                  }
                                }
                                }
                              } else {
                                {
                                _L___8:
                                if (! (arg___1 == 0.0L)) {
                                  {
                                  {
                                  abort();
                                  }
                                  }
                                }
                                {
                                pad_ptr = p;
                                }
                                if ((int )dp->conversion == 102) {
                                  {
                                  goto _L___7;
                                  }
                                } else {
                                  {
                                  if ((int )dp->conversion == 70) {
                                    {
                                    _L___7:
                                    {
                                    tmp___47 = p;
                                    p ++;
                                    *tmp___47 = (char )'0';
                                    }
                                    if (flags & 16) {
                                      {
                                      goto _L___1;
                                      }
                                    } else {
                                      {
                                      if (precision > 0UL) {
                                        {
                                        _L___1:
                                        {
                                        tmp___48 = p;
                                        p ++;
                                        *tmp___48 = decimal_point_char();
                                        }
                                        {
                                        while (1) {
                                          while_continue___3: ;
                                          if (! (precision > 0UL)) {
                                            {
                                            goto while_break___3;
                                            }
                                          }
                                          {
                                          tmp___49 = p;
                                          p ++;
                                          *tmp___49 = (char )'0';
                                          precision --;
                                          }
                                        }
                                        while_break___3: ;
                                        }
                                        }
                                      }
                                      }
                                    }
                                    }
                                  } else {
                                    {
                                    if ((int )dp->conversion == 101) {
                                      {
                                      goto _L___6;
                                      }
                                    } else {
                                      {
                                      if ((int )dp->conversion == 69) {
                                        {
                                        _L___6:
                                        {
                                        tmp___50 = p;
                                        p ++;
                                        *tmp___50 = (char )'0';
                                        }
                                        if (flags & 16) {
                                          {
                                          goto _L___2;
                                          }
                                        } else {
                                          {
                                          if (precision > 0UL) {
                                            {
                                            _L___2:
                                            {
                                            tmp___51 = p;
                                            p ++;
                                            *tmp___51 = decimal_point_char();
                                            }
                                            {
                                            while (1) {
                                              while_continue___4: ;
                                              if (! (precision > 0UL)) {
                                                {
                                                goto while_break___4;
                                                }
                                              }
                                              {
                                              tmp___52 = p;
                                              p ++;
                                              *tmp___52 = (char )'0';
                                              precision --;
                                              }
                                            }
                                            while_break___4: ;
                                            }
                                            }
                                          }
                                          }
                                        }
                                        {
                                        tmp___53 = p;
                                        p ++;
                                        *tmp___53 = dp->conversion;
                                        tmp___54 = p;
                                        p ++;
                                        *tmp___54 = (char )'+';
                                        tmp___55 = p;
                                        p ++;
                                        *tmp___55 = (char )'0';
                                        tmp___56 = p;
                                        p ++;
                                        *tmp___56 = (char )'0';
                                        }
                                        }
                                      } else {
                                        {
                                        if ((int )dp->conversion == 103) {
                                          {
                                          goto _L___5;
                                          }
                                        } else {
                                          {
                                          if ((int )dp->conversion == 71) {
                                            {
                                            _L___5:
                                            {
                                            tmp___57 = p;
                                            p ++;
                                            *tmp___57 = (char )'0';
                                            }
                                            if (flags & 16) {
                                              {
                                              if (precision > 0UL) {
                                                {
                                                {
                                                tmp___58 = precision - 1UL;
                                                }
                                                }
                                              } else {
                                                {
                                                {
                                                tmp___58 = (size_t )0;
                                                }
                                                }
                                              }
                                              {
                                              ndigits = tmp___58;
                                              tmp___59 = p;
                                              p ++;
                                              *tmp___59 = decimal_point_char();
                                              }
                                              {
                                              while (1) {
                                                while_continue___5: ;
                                                if (! (ndigits > 0UL)) {
                                                  {
                                                  goto while_break___5;
                                                  }
                                                }
                                                {
                                                tmp___60 = p;
                                                p ++;
                                                *tmp___60 = (char )'0';
                                                ndigits --;
                                                }
                                              }
                                              while_break___5: ;
                                              }
                                              }
                                            }
                                            }
                                          } else {
                                            {
                                            if ((int )dp->conversion == 97) {
                                              {
                                              goto _L___4;
                                              }
                                            } else {
                                              {
                                              if ((int )dp->conversion == 65) {
                                                {
                                                _L___4:
                                                {
                                                tmp___61 = p;
                                                p ++;
                                                *tmp___61 = (char )'0';
                                                tmp___62 = p;
                                                p ++;
                                                *tmp___62 = (char )(((int )dp->conversion - 65) + 88);
                                                pad_ptr = p;
                                                tmp___63 = p;
                                                p ++;
                                                *tmp___63 = (char )'0';
                                                }
                                                if (flags & 16) {
                                                  {
                                                  goto _L___3;
                                                  }
                                                } else {
                                                  {
                                                  if (precision > 0UL) {
                                                    {
                                                    _L___3:
                                                    {
                                                    tmp___64 = p;
                                                    p ++;
                                                    *tmp___64 = decimal_point_char();
                                                    }
                                                    {
                                                    while (1) {
                                                      while_continue___6: ;
                                                      if (! (precision > 0UL)) {
                                                        {
                                                        goto while_break___6;
                                                        }
                                                      }
                                                      {
                                                      tmp___65 = p;
                                                      p ++;
                                                      *tmp___65 = (char )'0';
                                                      precision --;
                                                      }
                                                    }
                                                    while_break___6: ;
                                                    }
                                                    }
                                                  }
                                                  }
                                                }
                                                {
                                                tmp___66 = p;
                                                p ++;
                                                *tmp___66 = (char )(((int )dp->conversion - 65) + 80);
                                                tmp___67 = p;
                                                p ++;
                                                *tmp___67 = (char )'+';
                                                tmp___68 = p;
                                                p ++;
                                                *tmp___68 = (char )'0';
                                                }
                                                }
                                              } else {
                                                {
                                                {
                                                abort();
                                                }
                                                }
                                              }
                                              }
                                            }
                                            }
                                          }
                                          }
                                        }
                                        }
                                      }
                                      }
                                    }
                                    }
                                  }
                                  }
                                }
                                }
                              }
                              {
                              _ncw___0 = oldcw;
                              __asm__ volatile ("fldcw %0": : "m" (_ncw___0));
                              }
                              }
                            }
                            if (has_width) {
                              {
                              if ((size_t )(p - tmp___16) < width) {
                                {
                                {
                                pad = width - (size_t )(p - tmp___16);
                                end = p + pad;
                                }
                                if (flags & 2) {
                                  {
                                  {
                                  while (1) {
                                    while_continue___7: ;
                                    if (! (pad > 0UL)) {
                                      {
                                      goto while_break___7;
                                      }
                                    }
                                    {
                                    tmp___70 = p;
                                    p ++;
                                    *tmp___70 = (char )' ';
                                    pad --;
                                    }
                                  }
                                  while_break___7: ;
                                  }
                                  }
                                } else {
                                  {
                                  if (flags & 32) {
                                    {
                                    if ((unsigned long )pad_ptr != (unsigned long )((void *)0)) {
                                      {
                                      {
                                      q = end;
                                      }
                                      {
                                      while (1) {
                                        while_continue___8: ;
                                        if (! ((unsigned long )p > (unsigned long )pad_ptr)) {
                                          {
                                          goto while_break___8;
                                          }
                                        }
                                        {
                                        q --;
                                        p --;
                                        *q = *p;
                                        }
                                      }
                                      while_break___8: ;
                                      }
                                      {
                                      while (1) {
                                        while_continue___9: ;
                                        if (! (pad > 0UL)) {
                                          {
                                          goto while_break___9;
                                          }
                                        }
                                        {
                                        tmp___71 = p;
                                        p ++;
                                        *tmp___71 = (char )'0';
                                        pad --;
                                        }
                                      }
                                      while_break___9: ;
                                      }
                                      }
                                    } else {
                                      {
                                      goto _L___9;
                                      }
                                    }
                                    }
                                  } else {
                                    {
                                    _L___9:
                                    {
                                    q___0 = end;
                                    }
                                    {
                                    while (1) {
                                      while_continue___10: ;
                                      if (! ((unsigned long )p > (unsigned long )tmp___16)) {
                                        {
                                        goto while_break___10;
                                        }
                                      }
                                      {
                                      q___0 --;
                                      p --;
                                      *q___0 = *p;
                                      }
                                    }
                                    while_break___10: ;
                                    }
                                    {
                                    while (1) {
                                      while_continue___11: ;
                                      if (! (pad > 0UL)) {
                                        {
                                        goto while_break___11;
                                        }
                                      }
                                      {
                                      tmp___72 = p;
                                      p ++;
                                      *tmp___72 = (char )' ';
                                      pad --;
                                      }
                                    }
                                    while_break___11: ;
                                    }
                                    }
                                  }
                                  }
                                }
                                {
                                p = end;
                                }
                                }
                              }
                              }
                            }
                            {
                            count = (size_t )(p - tmp___16);
                            }
                            if (count >= tmp_length) {
                              {
                              {
                              abort();
                              }
                              }
                            }
                            if (count >= allocated - length) {
                              {
                              {
                              tmp___73 = xsum(length, count);
                              n___0 = (size_t )tmp___73;
                              }
                              if (n___0 > allocated) {
                                {
                                if (allocated > 0UL) {
                                  {
                                  if (allocated <= 9223372036854775807UL) {
                                    {
                                    {
                                    tmp___74 = allocated * 2UL;
                                    }
                                    }
                                  } else {
                                    {
                                    {
                                    tmp___74 = 0xffffffffffffffffUL;
                                    }
                                    }
                                  }
                                  {
                                  allocated = tmp___74;
                                  }
                                  }
                                } else {
                                  {
                                  {
                                  allocated = (size_t )12;
                                  }
                                  }
                                }
                                if (n___0 > allocated) {
                                  {
                                  {
                                  allocated = n___0;
                                  }
                                  }
                                }
                                if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
                                  {
                                  {
                                  memory_size___1 = allocated * sizeof(char );
                                  }
                                  }
                                } else {
                                  {
                                  {
                                  memory_size___1 = 0xffffffffffffffffUL;
                                  }
                                  }
                                }
                                if (memory_size___1 == 0xffffffffffffffffUL) {
                                  {
                                  goto out_of_memory;
                                  }
                                }
                                if ((unsigned long )result == (unsigned long )resultbuf) {
                                  {
                                  {
                                  tmp___75 = malloc(memory_size___1);
                                  memory___1 = (char *)tmp___75;
                                  }
                                  }
                                } else {
                                  {
                                  if ((unsigned long )result == (unsigned long )((void *)0)) {
                                    {
                                    {
                                    tmp___75 = malloc(memory_size___1);
                                    memory___1 = (char *)tmp___75;
                                    }
                                    }
                                  } else {
                                    {
                                    {
                                    tmp___76 = realloc((void *)result, memory_size___1);
                                    memory___1 = (char *)tmp___76;
                                    }
                                    }
                                  }
                                  }
                                }
                                if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
                                  {
                                  goto out_of_memory;
                                  }
                                }
                                if ((unsigned long )result == (unsigned long )resultbuf) {
                                  {
                                  if (length > 0UL) {
                                    {
                                    {
                                    memcpy((void *)((void * __restrict )memory___1),
                                           (void const *)((void const * __restrict )result),
                                           length);
                                    }
                                    }
                                  }
                                  }
                                }
                                {
                                result = memory___1;
                                }
                                }
                              }
                              }
                            }
                            {
                            memcpy((void *)((void * __restrict )(result + length)),
                                   (void const *)((void const * __restrict )tmp___16),
                                   count * sizeof(char ));
                            }
                            if ((unsigned long )tmp___16 != (unsigned long )(tmpbuf)) {
                              {
                              {
                              free((void *)tmp___16);
                              }
                              }
                            }
                            {
                            length += count;
                            }
                            }
                          } else {
                            {
                            goto _L___10;
                            }
                          }
                          }
                        } else {
                          {
                          goto _L___10;
                          }
                        }
                        }
                      } else {
                        {
                        _L___10:
                        {
                        type = (a.arg + dp->arg_index)->type;
                        flags___0 = dp->flags;
                        fbp = buf___1;
                        tmp___77 = fbp;
                        fbp ++;
                        *tmp___77 = (char )'%';
                        }
                        if (flags___0 & 1) {
                          {
                          {
                          tmp___78 = fbp;
                          fbp ++;
                          *tmp___78 = (char )'\'';
                          }
                          }
                        }
                        if (flags___0 & 2) {
                          {
                          {
                          tmp___79 = fbp;
                          fbp ++;
                          *tmp___79 = (char )'-';
                          }
                          }
                        }
                        if (flags___0 & 4) {
                          {
                          {
                          tmp___80 = fbp;
                          fbp ++;
                          *tmp___80 = (char )'+';
                          }
                          }
                        }
                        if (flags___0 & 8) {
                          {
                          {
                          tmp___81 = fbp;
                          fbp ++;
                          *tmp___81 = (char )' ';
                          }
                          }
                        }
                        if (flags___0 & 16) {
                          {
                          {
                          tmp___82 = fbp;
                          fbp ++;
                          *tmp___82 = (char )'#';
                          }
                          }
                        }
                        if (flags___0 & 64) {
                          {
                          {
                          tmp___83 = fbp;
                          fbp ++;
                          *tmp___83 = (char )'I';
                          }
                          }
                        }
                        if (flags___0 & 32) {
                          {
                          {
                          tmp___84 = fbp;
                          fbp ++;
                          *tmp___84 = (char )'0';
                          }
                          }
                        }
                        if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
                          {
                          {
                          n___1 = (size_t )(dp->width_end - dp->width_start);
                          }
                          if (sizeof(char ) == sizeof(char )) {
                            {
                            {
                            memcpy((void *)((void * __restrict )fbp), (void const *)((void const * __restrict )dp->width_start),
                                   n___1 * sizeof(char ));
                            fbp += n___1;
                            }
                            }
                          } else {
                            {
                            {
                            mp = dp->width_start;
                            }
                            {
                            while (1) {
                              while_continue___12: ;
                              if (! 1) {
                                {
                                goto while_break___12;
                                }
                              }
                              {
                              tmp___85 = fbp;
                              fbp ++;
                              tmp___86 = mp;
                              mp ++;
                              *tmp___85 = (char )((unsigned char )*tmp___86);
                              n___1 --;
                              }
                              if (! (n___1 > 0UL)) {
                                {
                                goto while_break___12;
                                }
                              }
                            }
                            while_break___12: ;
                            }
                            }
                          }
                          }
                        }
                        if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
                          {
                          {
                          n___2 = (size_t )(dp->precision_end - dp->precision_start);
                          }
                          if (sizeof(char ) == sizeof(char )) {
                            {
                            {
                            memcpy((void *)((void * __restrict )fbp), (void const *)((void const * __restrict )dp->precision_start),
                                   n___2 * sizeof(char ));
                            fbp += n___2;
                            }
                            }
                          } else {
                            {
                            {
                            mp___0 = dp->precision_start;
                            }
                            {
                            while (1) {
                              while_continue___13: ;
                              if (! 1) {
                                {
                                goto while_break___13;
                                }
                              }
                              {
                              tmp___87 = fbp;
                              fbp ++;
                              tmp___88 = mp___0;
                              mp___0 ++;
                              *tmp___87 = (char )((unsigned char )*tmp___88);
                              n___2 --;
                              }
                              if (! (n___2 > 0UL)) {
                                {
                                goto while_break___13;
                                }
                              }
                            }
                            while_break___13: ;
                            }
                            }
                          }
                          }
                        }
                        {
                        if ((int )type == 10) {
                          {
                          goto case_10;
                          }
                        }
                        if ((int )type == 9) {
                          {
                          goto case_10;
                          }
                        }
                        if ((int )type == 16) {
                          {
                          goto case_16;
                          }
                        }
                        if ((int )type == 14) {
                          {
                          goto case_16;
                          }
                        }
                        if ((int )type == 8) {
                          {
                          goto case_16;
                          }
                        }
                        if ((int )type == 7) {
                          {
                          goto case_16;
                          }
                        }
                        if ((int )type == 12) {
                          {
                          goto case_12;
                          }
                        }
                        goto switch_default___0;
                        case_10:
                        case_9:
                        {
                        tmp___89 = fbp;
                        fbp ++;
                        *tmp___89 = (char )'l';
                        }
                        case_16:
                        case_14:
                        case_8:
                        case_7:
                        {
                        tmp___90 = fbp;
                        fbp ++;
                        *tmp___90 = (char )'l';
                        }
                        goto switch_break___0;
                        case_12:
                        {
                        tmp___91 = fbp;
                        fbp ++;
                        *tmp___91 = (char )'L';
                        }
                        goto switch_break___0;
                        switch_default___0:
                        goto switch_break___0;
                        switch_break___0: ;
                        }
                        {
                        *fbp = dp->conversion;
                        *(fbp + 1) = (char )'\000';
                        prefix_count = 0U;
                        }
                        if (dp->width_arg_index != 0xffffffffffffffffUL) {
                          {
                          if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
                            {
                            {
                            abort();
                            }
                            }
                          }
                          {
                          tmp___92 = prefix_count;
                          prefix_count ++;
                          prefixes[tmp___92] = (a.arg + dp->width_arg_index)->a.a_int;
                          }
                          }
                        }
                        if (dp->precision_arg_index != 0xffffffffffffffffUL) {
                          {
                          if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
                            {
                            {
                            abort();
                            }
                            }
                          }
                          {
                          tmp___93 = prefix_count;
                          prefix_count ++;
                          prefixes[tmp___93] = (a.arg + dp->precision_arg_index)->a.a_int;
                          }
                          }
                        }
                        {
                        tmp___99 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
                        }
                        if (tmp___99 > (size_t __attribute__((__pure__)) )allocated) {
                          {
                          if (allocated > 0UL) {
                            {
                            if (allocated <= 9223372036854775807UL) {
                              {
                              {
                              tmp___94 = allocated * 2UL;
                              }
                              }
                            } else {
                              {
                              {
                              tmp___94 = 0xffffffffffffffffUL;
                              }
                              }
                            }
                            {
                            allocated = tmp___94;
                            }
                            }
                          } else {
                            {
                            {
                            allocated = (size_t )12;
                            }
                            }
                          }
                          {
                          tmp___96 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
                          }
                          if (tmp___96 > (size_t __attribute__((__pure__)) )allocated) {
                            {
                            {
                            tmp___95 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
                            allocated = (size_t )tmp___95;
                            }
                            }
                          }
                          if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
                            {
                            {
                            memory_size___2 = allocated * sizeof(char );
                            }
                            }
                          } else {
                            {
                            {
                            memory_size___2 = 0xffffffffffffffffUL;
                            }
                            }
                          }
                          if (memory_size___2 == 0xffffffffffffffffUL) {
                            {
                            goto out_of_memory;
                            }
                          }
                          if ((unsigned long )result == (unsigned long )resultbuf) {
                            {
                            {
                            tmp___97 = malloc(memory_size___2);
                            memory___2 = (char *)tmp___97;
                            }
                            }
                          } else {
                            {
                            if ((unsigned long )result == (unsigned long )((void *)0)) {
                              {
                              {
                              tmp___97 = malloc(memory_size___2);
                              memory___2 = (char *)tmp___97;
                              }
                              }
                            } else {
                              {
                              {
                              tmp___98 = realloc((void *)result, memory_size___2);
                              memory___2 = (char *)tmp___98;
                              }
                              }
                            }
                            }
                          }
                          if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
                            {
                            goto out_of_memory;
                            }
                          }
                          if ((unsigned long )result == (unsigned long )resultbuf) {
                            {
                            if (length > 0UL) {
                              {
                              {
                              memcpy((void *)((void * __restrict )memory___2), (void const *)((void const * __restrict )result),
                                     length);
                              }
                              }
                            }
                            }
                          }
                          {
                          result = memory___2;
                          }
                          }
                        }
                        {
                        *(result + length) = (char )'\000';
                        tmp___100 = __errno_location();
                        orig_errno = *tmp___100;
                        }
                        {
                        while (1) {
                          while_continue___14: ;
                          if (! 1) {
                            {
                            goto while_break___14;
                            }
                          }
                          {
                          count___0 = -1;
                          retcount = 0;
                          maxlen = allocated - length;
                          }
                          if (maxlen > 2147483647UL / (sizeof(char ) / sizeof(char ))) {
                            {
                            {
                            maxlen = 2147483647UL / (sizeof(char ) / sizeof(char ));
                            }
                            }
                          }
                          {
                          maxlen *= sizeof(char ) / sizeof(char );
                          tmp___101 = __errno_location();
                          *tmp___101 = 0;
                          }
                          {
                          if ((int )type == 1) {
                            {
                            goto case_1;
                            }
                          }
                          if ((int )type == 2) {
                            {
                            goto case_2___0;
                            }
                          }
                          if ((int )type == 3) {
                            {
                            goto case_3;
                            }
                          }
                          if ((int )type == 4) {
                            {
                            goto case_4;
                            }
                          }
                          if ((int )type == 5) {
                            {
                            goto case_5;
                            }
                          }
                          if ((int )type == 6) {
                            {
                            goto case_6;
                            }
                          }
                          if ((int )type == 7) {
                            {
                            goto case_7___0;
                            }
                          }
                          if ((int )type == 8) {
                            {
                            goto case_8___0;
                            }
                          }
                          if ((int )type == 9) {
                            {
                            goto case_9___0;
                            }
                          }
                          if ((int )type == 10) {
                            {
                            goto case_10___0;
                            }
                          }
                          if ((int )type == 11) {
                            {
                            goto case_11;
                            }
                          }
                          if ((int )type == 12) {
                            {
                            goto case_12___0;
                            }
                          }
                          if ((int )type == 13) {
                            {
                            goto case_13;
                            }
                          }
                          if ((int )type == 14) {
                            {
                            goto case_14___0;
                            }
                          }
                          if ((int )type == 15) {
                            {
                            goto case_15;
                            }
                          }
                          if ((int )type == 16) {
                            {
                            goto case_16___0;
                            }
                          }
                          if ((int )type == 17) {
                            {
                            goto case_17;
                            }
                          }
                          goto switch_default___18;
                          case_1:
                          {
                          arg___2 = (int )(a.arg + dp->arg_index)->a.a_schar;
                          }
                          {
                          if ((int )prefix_count == 0) {
                            {
                            goto case_0;
                            }
                          }
                          if ((int )prefix_count == 1) {
                            {
                            goto case_1___0;
                            }
                          }
                          if ((int )prefix_count == 2) {
                            {
                            goto case_2;
                            }
                          }
                          goto switch_default___1;
                          case_0:
                          {
                          tmp___102 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               arg___2, & count___0);
                          retcount = tmp___102;
                          }
                          goto switch_break___2;
                          case_1___0:
                          {
                          tmp___103 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], arg___2, & count___0);
                          retcount = tmp___103;
                          }
                          goto switch_break___2;
                          case_2:
                          {
                          tmp___104 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], prefixes[1], arg___2,
                                               & count___0);
                          retcount = tmp___104;
                          }
                          goto switch_break___2;
                          switch_default___1:
                          {
                          abort();
                          }
                          switch_break___2: ;
                          }
                          goto switch_break___1;
                          case_2___0:
                          {
                          arg___3 = (unsigned int )(a.arg + dp->arg_index)->a.a_uchar;
                          }
                          {
                          if ((int )prefix_count == 0) {
                            {
                            goto case_0___0;
                            }
                          }
                          if ((int )prefix_count == 1) {
                            {
                            goto case_1___1;
                            }
                          }
                          if ((int )prefix_count == 2) {
                            {
                            goto case_2___1;
                            }
                          }
                          goto switch_default___2;
                          case_0___0:
                          {
                          tmp___105 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               arg___3, & count___0);
                          retcount = tmp___105;
                          }
                          goto switch_break___3;
                          case_1___1:
                          {
                          tmp___106 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], arg___3, & count___0);
                          retcount = tmp___106;
                          }
                          goto switch_break___3;
                          case_2___1:
                          {
                          tmp___107 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], prefixes[1], arg___3,
                                               & count___0);
                          retcount = tmp___107;
                          }
                          goto switch_break___3;
                          switch_default___2:
                          {
                          abort();
                          }
                          switch_break___3: ;
                          }
                          goto switch_break___1;
                          case_3:
                          {
                          arg___4 = (int )(a.arg + dp->arg_index)->a.a_short;
                          }
                          {
                          if ((int )prefix_count == 0) {
                            {
                            goto case_0___1;
                            }
                          }
                          if ((int )prefix_count == 1) {
                            {
                            goto case_1___2;
                            }
                          }
                          if ((int )prefix_count == 2) {
                            {
                            goto case_2___2;
                            }
                          }
                          goto switch_default___3;
                          case_0___1:
                          {
                          tmp___108 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               arg___4, & count___0);
                          retcount = tmp___108;
                          }
                          goto switch_break___4;
                          case_1___2:
                          {
                          tmp___109 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], arg___4, & count___0);
                          retcount = tmp___109;
                          }
                          goto switch_break___4;
                          case_2___2:
                          {
                          tmp___110 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], prefixes[1], arg___4,
                                               & count___0);
                          retcount = tmp___110;
                          }
                          goto switch_break___4;
                          switch_default___3:
                          {
                          abort();
                          }
                          switch_break___4: ;
                          }
                          goto switch_break___1;
                          case_4:
                          {
                          arg___5 = (unsigned int )(a.arg + dp->arg_index)->a.a_ushort;
                          }
                          {
                          if ((int )prefix_count == 0) {
                            {
                            goto case_0___2;
                            }
                          }
                          if ((int )prefix_count == 1) {
                            {
                            goto case_1___3;
                            }
                          }
                          if ((int )prefix_count == 2) {
                            {
                            goto case_2___3;
                            }
                          }
                          goto switch_default___4;
                          case_0___2:
                          {
                          tmp___111 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               arg___5, & count___0);
                          retcount = tmp___111;
                          }
                          goto switch_break___5;
                          case_1___3:
                          {
                          tmp___112 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], arg___5, & count___0);
                          retcount = tmp___112;
                          }
                          goto switch_break___5;
                          case_2___3:
                          {
                          tmp___113 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], prefixes[1], arg___5,
                                               & count___0);
                          retcount = tmp___113;
                          }
                          goto switch_break___5;
                          switch_default___4:
                          {
                          abort();
                          }
                          switch_break___5: ;
                          }
                          goto switch_break___1;
                          case_5:
                          {
                          arg___6 = (a.arg + dp->arg_index)->a.a_int;
                          }
                          {
                          if ((int )prefix_count == 0) {
                            {
                            goto case_0___3;
                            }
                          }
                          if ((int )prefix_count == 1) {
                            {
                            goto case_1___4;
                            }
                          }
                          if ((int )prefix_count == 2) {
                            {
                            goto case_2___4;
                            }
                          }
                          goto switch_default___5;
                          case_0___3:
                          {
                          tmp___114 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               arg___6, & count___0);
                          retcount = tmp___114;
                          }
                          goto switch_break___6;
                          case_1___4:
                          {
                          tmp___115 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], arg___6, & count___0);
                          retcount = tmp___115;
                          }
                          goto switch_break___6;
                          case_2___4:
                          {
                          tmp___116 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], prefixes[1], arg___6,
                                               & count___0);
                          retcount = tmp___116;
                          }
                          goto switch_break___6;
                          switch_default___5:
                          {
                          abort();
                          }
                          switch_break___6: ;
                          }
                          goto switch_break___1;
                          case_6:
                          {
                          arg___7 = (a.arg + dp->arg_index)->a.a_uint;
                          }
                          {
                          if ((int )prefix_count == 0) {
                            {
                            goto case_0___4;
                            }
                          }
                          if ((int )prefix_count == 1) {
                            {
                            goto case_1___5;
                            }
                          }
                          if ((int )prefix_count == 2) {
                            {
                            goto case_2___5;
                            }
                          }
                          goto switch_default___6;
                          case_0___4:
                          {
                          tmp___117 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               arg___7, & count___0);
                          retcount = tmp___117;
                          }
                          goto switch_break___7;
                          case_1___5:
                          {
                          tmp___118 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], arg___7, & count___0);
                          retcount = tmp___118;
                          }
                          goto switch_break___7;
                          case_2___5:
                          {
                          tmp___119 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], prefixes[1], arg___7,
                                               & count___0);
                          retcount = tmp___119;
                          }
                          goto switch_break___7;
                          switch_default___6:
                          {
                          abort();
                          }
                          switch_break___7: ;
                          }
                          goto switch_break___1;
                          case_7___0:
                          {
                          arg___8 = (a.arg + dp->arg_index)->a.a_longint;
                          }
                          {
                          if ((int )prefix_count == 0) {
                            {
                            goto case_0___5;
                            }
                          }
                          if ((int )prefix_count == 1) {
                            {
                            goto case_1___6;
                            }
                          }
                          if ((int )prefix_count == 2) {
                            {
                            goto case_2___6;
                            }
                          }
                          goto switch_default___7;
                          case_0___5:
                          {
                          tmp___120 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               arg___8, & count___0);
                          retcount = tmp___120;
                          }
                          goto switch_break___8;
                          case_1___6:
                          {
                          tmp___121 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], arg___8, & count___0);
                          retcount = tmp___121;
                          }
                          goto switch_break___8;
                          case_2___6:
                          {
                          tmp___122 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], prefixes[1], arg___8,
                                               & count___0);
                          retcount = tmp___122;
                          }
                          goto switch_break___8;
                          switch_default___7:
                          {
                          abort();
                          }
                          switch_break___8: ;
                          }
                          goto switch_break___1;
                          case_8___0:
                          {
                          arg___9 = (a.arg + dp->arg_index)->a.a_ulongint;
                          }
                          {
                          if ((int )prefix_count == 0) {
                            {
                            goto case_0___6;
                            }
                          }
                          if ((int )prefix_count == 1) {
                            {
                            goto case_1___7;
                            }
                          }
                          if ((int )prefix_count == 2) {
                            {
                            goto case_2___7;
                            }
                          }
                          goto switch_default___8;
                          case_0___6:
                          {
                          tmp___123 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               arg___9, & count___0);
                          retcount = tmp___123;
                          }
                          goto switch_break___9;
                          case_1___7:
                          {
                          tmp___124 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], arg___9, & count___0);
                          retcount = tmp___124;
                          }
                          goto switch_break___9;
                          case_2___7:
                          {
                          tmp___125 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], prefixes[1], arg___9,
                                               & count___0);
                          retcount = tmp___125;
                          }
                          goto switch_break___9;
                          switch_default___8:
                          {
                          abort();
                          }
                          switch_break___9: ;
                          }
                          goto switch_break___1;
                          case_9___0:
                          {
                          arg___10 = (a.arg + dp->arg_index)->a.a_longlongint;
                          }
                          {
                          if ((int )prefix_count == 0) {
                            {
                            goto case_0___7;
                            }
                          }
                          if ((int )prefix_count == 1) {
                            {
                            goto case_1___8;
                            }
                          }
                          if ((int )prefix_count == 2) {
                            {
                            goto case_2___8;
                            }
                          }
                          goto switch_default___9;
                          case_0___7:
                          {
                          tmp___126 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               arg___10, & count___0);
                          retcount = tmp___126;
                          }
                          goto switch_break___10;
                          case_1___8:
                          {
                          tmp___127 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], arg___10, & count___0);
                          retcount = tmp___127;
                          }
                          goto switch_break___10;
                          case_2___8:
                          {
                          tmp___128 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], prefixes[1], arg___10,
                                               & count___0);
                          retcount = tmp___128;
                          }
                          goto switch_break___10;
                          switch_default___9:
                          {
                          abort();
                          }
                          switch_break___10: ;
                          }
                          goto switch_break___1;
                          case_10___0:
                          {
                          arg___11 = (a.arg + dp->arg_index)->a.a_ulonglongint;
                          }
                          {
                          if ((int )prefix_count == 0) {
                            {
                            goto case_0___8;
                            }
                          }
                          if ((int )prefix_count == 1) {
                            {
                            goto case_1___9;
                            }
                          }
                          if ((int )prefix_count == 2) {
                            {
                            goto case_2___9;
                            }
                          }
                          goto switch_default___10;
                          case_0___8:
                          {
                          tmp___129 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               arg___11, & count___0);
                          retcount = tmp___129;
                          }
                          goto switch_break___11;
                          case_1___9:
                          {
                          tmp___130 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], arg___11, & count___0);
                          retcount = tmp___130;
                          }
                          goto switch_break___11;
                          case_2___9:
                          {
                          tmp___131 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], prefixes[1], arg___11,
                                               & count___0);
                          retcount = tmp___131;
                          }
                          goto switch_break___11;
                          switch_default___10:
                          {
                          abort();
                          }
                          switch_break___11: ;
                          }
                          goto switch_break___1;
                          case_11:
                          {
                          arg___12 = (a.arg + dp->arg_index)->a.a_double;
                          }
                          {
                          if ((int )prefix_count == 0) {
                            {
                            goto case_0___9;
                            }
                          }
                          if ((int )prefix_count == 1) {
                            {
                            goto case_1___10;
                            }
                          }
                          if ((int )prefix_count == 2) {
                            {
                            goto case_2___10;
                            }
                          }
                          goto switch_default___11;
                          case_0___9:
                          {
                          tmp___132 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               arg___12, & count___0);
                          retcount = tmp___132;
                          }
                          goto switch_break___12;
                          case_1___10:
                          {
                          tmp___133 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], arg___12, & count___0);
                          retcount = tmp___133;
                          }
                          goto switch_break___12;
                          case_2___10:
                          {
                          tmp___134 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], prefixes[1], arg___12,
                                               & count___0);
                          retcount = tmp___134;
                          }
                          goto switch_break___12;
                          switch_default___11:
                          {
                          abort();
                          }
                          switch_break___12: ;
                          }
                          goto switch_break___1;
                          case_12___0:
                          {
                          arg___13 = (a.arg + dp->arg_index)->a.a_longdouble;
                          }
                          {
                          if ((int )prefix_count == 0) {
                            {
                            goto case_0___10;
                            }
                          }
                          if ((int )prefix_count == 1) {
                            {
                            goto case_1___11;
                            }
                          }
                          if ((int )prefix_count == 2) {
                            {
                            goto case_2___11;
                            }
                          }
                          goto switch_default___12;
                          case_0___10:
                          {
                          tmp___135 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               arg___13, & count___0);
                          retcount = tmp___135;
                          }
                          goto switch_break___13;
                          case_1___11:
                          {
                          tmp___136 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], arg___13, & count___0);
                          retcount = tmp___136;
                          }
                          goto switch_break___13;
                          case_2___11:
                          {
                          tmp___137 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], prefixes[1], arg___13,
                                               & count___0);
                          retcount = tmp___137;
                          }
                          goto switch_break___13;
                          switch_default___12:
                          {
                          abort();
                          }
                          switch_break___13: ;
                          }
                          goto switch_break___1;
                          case_13:
                          {
                          arg___14 = (a.arg + dp->arg_index)->a.a_char;
                          }
                          {
                          if ((int )prefix_count == 0) {
                            {
                            goto case_0___11;
                            }
                          }
                          if ((int )prefix_count == 1) {
                            {
                            goto case_1___12;
                            }
                          }
                          if ((int )prefix_count == 2) {
                            {
                            goto case_2___12;
                            }
                          }
                          goto switch_default___13;
                          case_0___11:
                          {
                          tmp___138 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               arg___14, & count___0);
                          retcount = tmp___138;
                          }
                          goto switch_break___14;
                          case_1___12:
                          {
                          tmp___139 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], arg___14, & count___0);
                          retcount = tmp___139;
                          }
                          goto switch_break___14;
                          case_2___12:
                          {
                          tmp___140 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], prefixes[1], arg___14,
                                               & count___0);
                          retcount = tmp___140;
                          }
                          goto switch_break___14;
                          switch_default___13:
                          {
                          abort();
                          }
                          switch_break___14: ;
                          }
                          goto switch_break___1;
                          case_14___0:
                          {
                          arg___15 = (a.arg + dp->arg_index)->a.a_wide_char;
                          }
                          {
                          if ((int )prefix_count == 0) {
                            {
                            goto case_0___12;
                            }
                          }
                          if ((int )prefix_count == 1) {
                            {
                            goto case_1___13;
                            }
                          }
                          if ((int )prefix_count == 2) {
                            {
                            goto case_2___13;
                            }
                          }
                          goto switch_default___14;
                          case_0___12:
                          {
                          tmp___141 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               arg___15, & count___0);
                          retcount = tmp___141;
                          }
                          goto switch_break___15;
                          case_1___13:
                          {
                          tmp___142 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], arg___15, & count___0);
                          retcount = tmp___142;
                          }
                          goto switch_break___15;
                          case_2___13:
                          {
                          tmp___143 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], prefixes[1], arg___15,
                                               & count___0);
                          retcount = tmp___143;
                          }
                          goto switch_break___15;
                          switch_default___14:
                          {
                          abort();
                          }
                          switch_break___15: ;
                          }
                          goto switch_break___1;
                          case_15:
                          {
                          arg___16 = (a.arg + dp->arg_index)->a.a_string;
                          }
                          {
                          if ((int )prefix_count == 0) {
                            {
                            goto case_0___13;
                            }
                          }
                          if ((int )prefix_count == 1) {
                            {
                            goto case_1___14;
                            }
                          }
                          if ((int )prefix_count == 2) {
                            {
                            goto case_2___14;
                            }
                          }
                          goto switch_default___15;
                          case_0___13:
                          {
                          tmp___144 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               arg___16, & count___0);
                          retcount = tmp___144;
                          }
                          goto switch_break___16;
                          case_1___14:
                          {
                          tmp___145 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], arg___16, & count___0);
                          retcount = tmp___145;
                          }
                          goto switch_break___16;
                          case_2___14:
                          {
                          tmp___146 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], prefixes[1], arg___16,
                                               & count___0);
                          retcount = tmp___146;
                          }
                          goto switch_break___16;
                          switch_default___15:
                          {
                          abort();
                          }
                          switch_break___16: ;
                          }
                          goto switch_break___1;
                          case_16___0:
                          {
                          arg___17 = (a.arg + dp->arg_index)->a.a_wide_string;
                          }
                          {
                          if ((int )prefix_count == 0) {
                            {
                            goto case_0___14;
                            }
                          }
                          if ((int )prefix_count == 1) {
                            {
                            goto case_1___15;
                            }
                          }
                          if ((int )prefix_count == 2) {
                            {
                            goto case_2___15;
                            }
                          }
                          goto switch_default___16;
                          case_0___14:
                          {
                          tmp___147 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               arg___17, & count___0);
                          retcount = tmp___147;
                          }
                          goto switch_break___17;
                          case_1___15:
                          {
                          tmp___148 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], arg___17, & count___0);
                          retcount = tmp___148;
                          }
                          goto switch_break___17;
                          case_2___15:
                          {
                          tmp___149 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], prefixes[1], arg___17,
                                               & count___0);
                          retcount = tmp___149;
                          }
                          goto switch_break___17;
                          switch_default___16:
                          {
                          abort();
                          }
                          switch_break___17: ;
                          }
                          goto switch_break___1;
                          case_17:
                          {
                          arg___18 = (a.arg + dp->arg_index)->a.a_pointer;
                          }
                          {
                          if ((int )prefix_count == 0) {
                            {
                            goto case_0___15;
                            }
                          }
                          if ((int )prefix_count == 1) {
                            {
                            goto case_1___16;
                            }
                          }
                          if ((int )prefix_count == 2) {
                            {
                            goto case_2___16;
                            }
                          }
                          goto switch_default___17;
                          case_0___15:
                          {
                          tmp___150 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               arg___18, & count___0);
                          retcount = tmp___150;
                          }
                          goto switch_break___18;
                          case_1___16:
                          {
                          tmp___151 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], arg___18, & count___0);
                          retcount = tmp___151;
                          }
                          goto switch_break___18;
                          case_2___16:
                          {
                          tmp___152 = snprintf((char *)((char * __restrict )(result + length)),
                                               maxlen, (char const *)((char const * __restrict )buf___1),
                                               prefixes[0], prefixes[1], arg___18,
                                               & count___0);
                          retcount = tmp___152;
                          }
                          goto switch_break___18;
                          switch_default___17:
                          {
                          abort();
                          }
                          switch_break___18: ;
                          }
                          goto switch_break___1;
                          switch_default___18:
                          {
                          abort();
                          }
                          switch_break___1: ;
                          }
                          if (count___0 >= 0) {
                            {
                            if ((size_t )count___0 < maxlen) {
                              {
                              if ((int )*((result + length) + count___0) != 0) {
                                {
                                {
                                abort();
                                }
                                }
                              }
                              }
                            }
                            if (retcount > count___0) {
                              {
                              {
                              count___0 = retcount;
                              }
                              }
                            }
                            }
                          } else {
                            {
                            if ((int )*(fbp + 1) != 0) {
                              {
                              {
                              *(fbp + 1) = (char )'\000';
                              }
                              goto __Cont;
                              }
                            } else {
                              {
                              if (! (retcount < 0)) {
                                {
                                {
                                count___0 = retcount;
                                }
                                }
                              }
                              }
                            }
                            }
                          }
                          if (count___0 < 0) {
                            {
                            {
                            tmp___153 = __errno_location();
                            saved_errno = *tmp___153;
                            }
                            if (! ((unsigned long )result == (unsigned long )resultbuf)) {
                              {
                              if (! ((unsigned long )result == (unsigned long )((void *)0))) {
                                {
                                {
                                free((void *)result);
                                }
                                }
                              }
                              }
                            }
                            if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
                              {
                              {
                              free((void *)buf_malloced);
                              }
                              }
                            }
                            if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
                              {
                              {
                              free((void *)d.dir);
                              }
                              }
                            }
                            if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
                              {
                              {
                              free((void *)a.arg);
                              }
                              }
                            }
                            {
                            tmp___154 = __errno_location();
                            }
                            if (saved_errno != 0) {
                              {
                              {
                              *tmp___154 = saved_errno;
                              }
                              }
                            } else {
                              {
                              if ((int )dp->conversion == 99) {
                                {
                                {
                                tmp___155 = 84;
                                }
                                }
                              } else {
                                {
                                if ((int )dp->conversion == 115) {
                                  {
                                  {
                                  tmp___155 = 84;
                                  }
                                  }
                                } else {
                                  {
                                  {
                                  tmp___155 = 22;
                                  }
                                  }
                                }
                                }
                              }
                              {
                              *tmp___154 = tmp___155;
                              }
                              }
                            }
                            return ((char *)((void *)0));
                            }
                          }
                          if ((size_t )((unsigned int )count___0 + 1U) >= maxlen) {
                            {
                            if (maxlen == 2147483647UL / (sizeof(char ) / sizeof(char ))) {
                              {
                              goto overflow;
                              }
                            } else {
                              {
                              if (allocated <= 9223372036854775807UL) {
                                {
                                {
                                tmp___156 = allocated * 2UL;
                                }
                                }
                              } else {
                                {
                                {
                                tmp___156 = 0xffffffffffffffffUL;
                                }
                                }
                              }
                              {
                              tmp___157 = xsum(length, (((unsigned long )((unsigned int )count___0 + 2U) + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
                              tmp___158 = xmax((size_t )tmp___157, tmp___156);
                              n___3 = (size_t )tmp___158;
                              }
                              if (n___3 > allocated) {
                                {
                                if (allocated > 0UL) {
                                  {
                                  if (allocated <= 9223372036854775807UL) {
                                    {
                                    {
                                    tmp___159 = allocated * 2UL;
                                    }
                                    }
                                  } else {
                                    {
                                    {
                                    tmp___159 = 0xffffffffffffffffUL;
                                    }
                                    }
                                  }
                                  {
                                  allocated = tmp___159;
                                  }
                                  }
                                } else {
                                  {
                                  {
                                  allocated = (size_t )12;
                                  }
                                  }
                                }
                                if (n___3 > allocated) {
                                  {
                                  {
                                  allocated = n___3;
                                  }
                                  }
                                }
                                if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
                                  {
                                  {
                                  memory_size___3 = allocated * sizeof(char );
                                  }
                                  }
                                } else {
                                  {
                                  {
                                  memory_size___3 = 0xffffffffffffffffUL;
                                  }
                                  }
                                }
                                if (memory_size___3 == 0xffffffffffffffffUL) {
                                  {
                                  goto out_of_memory;
                                  }
                                }
                                if ((unsigned long )result == (unsigned long )resultbuf) {
                                  {
                                  {
                                  tmp___160 = malloc(memory_size___3);
                                  memory___3 = (char *)tmp___160;
                                  }
                                  }
                                } else {
                                  {
                                  if ((unsigned long )result == (unsigned long )((void *)0)) {
                                    {
                                    {
                                    tmp___160 = malloc(memory_size___3);
                                    memory___3 = (char *)tmp___160;
                                    }
                                    }
                                  } else {
                                    {
                                    {
                                    tmp___161 = realloc((void *)result, memory_size___3);
                                    memory___3 = (char *)tmp___161;
                                    }
                                    }
                                  }
                                  }
                                }
                                if ((unsigned long )memory___3 == (unsigned long )((void *)0)) {
                                  {
                                  goto out_of_memory;
                                  }
                                }
                                if ((unsigned long )result == (unsigned long )resultbuf) {
                                  {
                                  if (length > 0UL) {
                                    {
                                    {
                                    memcpy((void *)((void * __restrict )memory___3),
                                           (void const *)((void const * __restrict )result),
                                           length);
                                    }
                                    }
                                  }
                                  }
                                }
                                {
                                result = memory___3;
                                }
                                }
                              }
                              goto __Cont;
                              }
                            }
                            }
                          }
                          {
                          length += (size_t )count___0;
                          }
                          goto while_break___14;
                          __Cont:
                          {
                          }
                        }
                        while_break___14: ;
                        }
                        {
                        tmp___162 = __errno_location();
                        *tmp___162 = orig_errno;
                        }
                        }
                      }
                      }
                    }
                    }
                  }
                  }
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    {
    cp = dp->dir_end;
    i ++;
    dp ++;
    }
  }
  while_break: ;
  }
  {
  tmp___169 = xsum(length, (size_t )1);
  }
  if (tmp___169 > (size_t __attribute__((__pure__)) )allocated) {
    {
    if (allocated > 0UL) {
      {
      if (allocated <= 9223372036854775807UL) {
        {
        {
        tmp___164 = allocated * 2UL;
        }
        }
      } else {
        {
        {
        tmp___164 = 0xffffffffffffffffUL;
        }
        }
      }
      {
      allocated = tmp___164;
      }
      }
    } else {
      {
      {
      allocated = (size_t )12;
      }
      }
    }
    {
    tmp___166 = xsum(length, (size_t )1);
    }
    if (tmp___166 > (size_t __attribute__((__pure__)) )allocated) {
      {
      {
      tmp___165 = xsum(length, (size_t )1);
      allocated = (size_t )tmp___165;
      }
      }
    }
    if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
      {
      {
      memory_size___4 = allocated * sizeof(char );
      }
      }
    } else {
      {
      {
      memory_size___4 = 0xffffffffffffffffUL;
      }
      }
    }
    if (memory_size___4 == 0xffffffffffffffffUL) {
      {
      goto out_of_memory;
      }
    }
    if ((unsigned long )result == (unsigned long )resultbuf) {
      {
      {
      tmp___167 = malloc(memory_size___4);
      memory___4 = (char *)tmp___167;
      }
      }
    } else {
      {
      if ((unsigned long )result == (unsigned long )((void *)0)) {
        {
        {
        tmp___167 = malloc(memory_size___4);
        memory___4 = (char *)tmp___167;
        }
        }
      } else {
        {
        {
        tmp___168 = realloc((void *)result, memory_size___4);
        memory___4 = (char *)tmp___168;
        }
        }
      }
      }
    }
    if ((unsigned long )memory___4 == (unsigned long )((void *)0)) {
      {
      goto out_of_memory;
      }
    }
    if ((unsigned long )result == (unsigned long )resultbuf) {
      {
      if (length > 0UL) {
        {
        {
        memcpy((void *)((void * __restrict )memory___4), (void const *)((void const * __restrict )result),
               length);
        }
        }
      }
      }
    }
    {
    result = memory___4;
    }
    }
  }
  {
  *(result + length) = (char )'\000';
  }
  if ((unsigned long )result != (unsigned long )resultbuf) {
    {
    if (length + 1UL < allocated) {
      {
      {
      tmp___170 = realloc((void *)result, (length + 1UL) * sizeof(char ));
      memory___5 = (char *)tmp___170;
      }
      if ((unsigned long )memory___5 != (unsigned long )((void *)0)) {
        {
        {
        result = memory___5;
        }
        }
      }
      }
    }
    }
  }
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
    {
    free((void *)buf_malloced);
    }
    }
  }
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    {
    {
    free((void *)d.dir);
    }
    }
  }
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    {
    {
    free((void *)a.arg);
    }
    }
  }
  {
  *lengthp = length;
  }
  return (result);
  overflow:
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
    {
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
      {
      free((void *)result);
      }
      }
    }
    }
  }
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
    {
    free((void *)buf_malloced);
    }
    }
  }
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    {
    {
    free((void *)d.dir);
    }
    }
  }
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    {
    {
    free((void *)a.arg);
    }
    }
  }
  {
  tmp___171 = __errno_location();
  *tmp___171 = 75;
  }
  return ((char *)((void *)0));
  out_of_memory:
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
    {
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
      {
      free((void *)result);
      }
      }
    }
    }
  }
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
    {
    free((void *)buf_malloced);
    }
    }
  }
  out_of_memory_1:
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    {
    {
    free((void *)d.dir);
    }
    }
  }
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    {
    {
    free((void *)a.arg);
    }
    }
  }
  {
  tmp___172 = __errno_location();
  *tmp___172 = 12;
  }
  return ((char *)((void *)0));
}
}
int ( __attribute__((__nonnull__(1,2))) rpl_vasprintf)(char **resultp , char const *format ,
                                                       va_list args )
{
  size_t length ;
  char *result ;
  char *tmp ;
  int *tmp___0 ;
  {
  {
  tmp = vasnprintf((char *)((void *)0), & length, format, args);
  result = tmp;
  }
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
    return (-1);
    }
  }
  if (length > 2147483647UL) {
    {
    {
    free((void *)result);
    tmp___0 = __errno_location();
    *tmp___0 = 75;
    }
    return (-1);
    }
  }
  {
  *resultp = result;
  }
  return ((int )length);
}
}
int ( __attribute__((__nonnull__(1,2))) rpl_vfprintf)(FILE *fp , char const *format ,
                                                      va_list args )
{
  char buf___1[2000] ;
  char *output ;
  size_t len ;
  size_t lenbuf ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  {
  {
  lenbuf = sizeof(buf___1);
  output = vasnprintf(buf___1, & lenbuf, format, args);
  len = lenbuf;
  }
  if (! output) {
    {
    {
    fseterr(fp);
    }
    return (-1);
    }
  }
  {
  tmp___1 = rpl_fwrite((void const *)output, (size_t )1, len, fp);
  }
  if (tmp___1 < len) {
    {
    if ((unsigned long )output != (unsigned long )(buf___1)) {
      {
      {
      tmp = __errno_location();
      saved_errno = *tmp;
      free((void *)output);
      tmp___0 = __errno_location();
      *tmp___0 = saved_errno;
      }
      }
    }
    return (-1);
    }
  }
  if ((unsigned long )output != (unsigned long )(buf___1)) {
    {
    {
    free((void *)output);
    }
    }
  }
  if (len > 2147483647UL) {
    {
    {
    tmp___2 = __errno_location();
    *tmp___2 = 75;
    fseterr(fp);
    }
    return (-1);
    }
  }
  return ((int )len);
}
}
int ( __attribute__((__nonnull__(1))) rpl_vprintf)(char const *format , va_list args )
{
  int tmp ;
  {
  {
  tmp = rpl_vfprintf(stdout, format, args);
  }
  return (tmp);
}
}
_Bool euidaccess_stat(struct stat const *st , int mode )
{
  uid_t euid ;
  unsigned int granted ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  gid_t egid ;
  __gid_t tmp___11 ;
  int tmp___12 ;
  {
  {
  mode &= 7;
  }
  if (mode == 0) {
    {
    return ((_Bool)1);
    }
  }
  {
  euid = geteuid();
  }
  if (euid == 0U) {
    {
    if ((mode & 1) == 0) {
      {
      return ((_Bool)1);
      }
    } else {
      {
      if (st->st_mode & (unsigned int )((unsigned int const )((64 | (64 >> 3)) | ((64 >> 3) >> 3)))) {
        {
        return ((_Bool)1);
        }
      }
      }
    }
    }
  }
  if (256 == 4 << 6) {
    {
    if (128 == 2 << 6) {
      {
      if (64 == 1 << 6) {
        {
        if (256 >> 3 == 4 << 3) {
          {
          if (128 >> 3 == 2 << 3) {
            {
            if (64 >> 3 == 1 << 3) {
              {
              if ((256 >> 3) >> 3 == 4) {
                {
                if ((128 >> 3) >> 3 == 2) {
                  {
                  if ((64 >> 3) >> 3 == 1) {
                    {
                    {
                    granted = (unsigned int )st->st_mode;
                    }
                    }
                  } else {
                    {
                    goto _L___6;
                    }
                  }
                  }
                } else {
                  {
                  goto _L___6;
                  }
                }
                }
              } else {
                {
                goto _L___6;
                }
              }
              }
            } else {
              {
              goto _L___6;
              }
            }
            }
          } else {
            {
            goto _L___6;
            }
          }
          }
        } else {
          {
          goto _L___6;
          }
        }
        }
      } else {
        {
        goto _L___6;
        }
      }
      }
    } else {
      {
      goto _L___6;
      }
    }
    }
  } else {
    {
    _L___6:
    if (st->st_mode & 256U) {
      {
      {
      tmp___2 = 4 << 6;
      }
      }
    } else {
      {
      {
      tmp___2 = 0;
      }
      }
    }
    if (st->st_mode & 128U) {
      {
      {
      tmp___3 = 2 << 6;
      }
      }
    } else {
      {
      {
      tmp___3 = 0;
      }
      }
    }
    if (st->st_mode & 64U) {
      {
      {
      tmp___4 = 1 << 6;
      }
      }
    } else {
      {
      {
      tmp___4 = 0;
      }
      }
    }
    if (st->st_mode & (unsigned int )((unsigned int const )(256 >> 3))) {
      {
      {
      tmp___5 = 4 << 3;
      }
      }
    } else {
      {
      {
      tmp___5 = 0;
      }
      }
    }
    if (st->st_mode & (unsigned int )((unsigned int const )(128 >> 3))) {
      {
      {
      tmp___6 = 2 << 3;
      }
      }
    } else {
      {
      {
      tmp___6 = 0;
      }
      }
    }
    if (st->st_mode & (unsigned int )((unsigned int const )(64 >> 3))) {
      {
      {
      tmp___7 = 1 << 3;
      }
      }
    } else {
      {
      {
      tmp___7 = 0;
      }
      }
    }
    if (st->st_mode & (unsigned int )((unsigned int const )((256 >> 3) >> 3))) {
      {
      {
      tmp___8 = 4;
      }
      }
    } else {
      {
      {
      tmp___8 = 0;
      }
      }
    }
    if (st->st_mode & (unsigned int )((unsigned int const )((128 >> 3) >> 3))) {
      {
      {
      tmp___9 = 2;
      }
      }
    } else {
      {
      {
      tmp___9 = 0;
      }
      }
    }
    if (st->st_mode & (unsigned int )((unsigned int const )((64 >> 3) >> 3))) {
      {
      {
      tmp___10 = 1;
      }
      }
    } else {
      {
      {
      tmp___10 = 0;
      }
      }
    }
    {
    granted = (unsigned int )((((((((tmp___2 + tmp___3) + tmp___4) + tmp___5) + tmp___6) + tmp___7) + tmp___8) + tmp___9) + tmp___10);
    }
    }
  }
  if (euid == (uid_t )st->st_uid) {
    {
    {
    granted >>= 6;
    }
    }
  } else {
    {
    {
    tmp___11 = getegid();
    egid = tmp___11;
    }
    if (egid == (gid_t )st->st_gid) {
      {
      {
      granted >>= 3;
      }
      }
    } else {
      {
      {
      tmp___12 = group_member((__gid_t )st->st_gid);
      }
      if (tmp___12) {
        {
        {
        granted >>= 3;
        }
        }
      }
      }
    }
    }
  }
  if (((unsigned int )mode & ~ granted) == 0U) {
    {
    return ((_Bool)1);
    }
  }
  return ((_Bool)0);
}
}
int fd_reopen(int desired_fd , char const *file , int flags , mode_t mode )
{
  int fd ;
  int tmp ;
  int fd2 ;
  int tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  {
  {
  tmp = open(file, flags, mode);
  fd = tmp;
  }
  if (fd == desired_fd) {
    {
    return (fd);
    }
  } else {
    {
    if (fd < 0) {
      {
      { if(!(fd != 0)) { reach_error(); abort(); } };
      return (fd);
      }
    } else {
      {
      {
      tmp___0 = dup2(fd, desired_fd);
      fd2 = tmp___0;
      tmp___1 = __errno_location();
      saved_errno = *tmp___1;
      close(fd);
      { if(!(flags != 0)) { reach_error(); abort(); } };
      tmp___2 = __errno_location();
      *tmp___2 = saved_errno;
      }
      return (fd2);
      }
    }
    }
  }
}
}
FTS *xfts_open(char **argv , int options , int (*compar)(FTSENT const ** , FTSENT const ** ) )
{
  FTS *fts ;
  FTS *tmp ;
  int *tmp___0 ;
  {
  {
  tmp = fts_open(argv, options | 512, compar);
  fts = tmp;
  }
  if ((unsigned long )fts == (unsigned long )((void *)0)) {
    {
    {
    tmp___0 = __errno_location();
    }
    if (! (*tmp___0 != 22)) {
      {
      {
      __assert_fail((char const *)"(*__errno_location ()) != 22", (char const *)"xfts.c",
                    41U, (char const *)"xfts_open");
      }
      }
    }
    {
    xalloc_die();
    }
    }
  }
  return (fts);
}
}
_Bool cycle_warning_required(FTS const *fts , FTSENT const *ent ) __attribute__((__pure__)) ;
_Bool cycle_warning_required(FTS const *fts , FTSENT const *ent )
{
  int tmp ;
  {
  if (fts->fts_options & 16) {
    {
    if (! (fts->fts_options & 1)) {
      {
      {
      tmp = 1;
      }
      }
    } else {
      {
      goto _L;
      }
    }
    }
  } else {
    {
    _L:
    if (fts->fts_options & 16) {
      {
      if (fts->fts_options & 1) {
        {
        if (ent->fts_level != 0L) {
          {
          {
          tmp = 1;
          }
          }
        } else {
          {
          {
          tmp = 0;
          }
          }
        }
        }
      } else {
        {
        {
        tmp = 0;
        }
        }
      }
      }
    } else {
      {
      {
      tmp = 0;
      }
      }
    }
    }
  }
  return ((_Bool )tmp);
}
}
__inline static int __attribute__((__pure__)) fraccompare(char const *a , char const *b ,
                                                           char decimal_point )
{
  char const *tmp ;
  char const *tmp___0 ;
  {
  if ((int const )*a == (int const )decimal_point) {
    {
    if ((int const )*b == (int const )decimal_point) {
      {
      {
      while (1) {
        while_continue: ;
        if (! 1) {
          {
          goto while_break;
          }
        }
        {
        a ++;
        b ++;
        }
        if (! ((int const )*a == (int const )*b)) {
          {
          goto while_break;
          }
        }
        if (! ((unsigned int )*a - 48U <= 9U)) {
          {
          return ((int __attribute__((__pure__)) )0);
          }
        }
      }
      while_break: ;
      }
      if ((unsigned int )*a - 48U <= 9U) {
        {
        if ((unsigned int )*b - 48U <= 9U) {
          {
          return ((int __attribute__((__pure__)) )((int const )*a - (int const )*b));
          }
        }
        }
      }
      if ((unsigned int )*a - 48U <= 9U) {
        {
        goto a_trailing_nonzero;
        }
      }
      if ((unsigned int )*b - 48U <= 9U) {
        {
        goto b_trailing_nonzero;
        }
      }
      return ((int __attribute__((__pure__)) )0);
      }
    } else {
      {
      goto _L;
      }
    }
    }
  } else {
    {
    _L:
    {
    tmp___0 = a;
    a ++;
    }
    if ((int const )*tmp___0 == (int const )decimal_point) {
      {
      a_trailing_nonzero:
      {
      while (1) {
        while_continue___0: ;
        if (! ((int const )*a == 48)) {
          {
          goto while_break___0;
          }
        }
        {
        a ++;
        }
      }
      while_break___0: ;
      }
      return ((int __attribute__((__pure__)) )((unsigned int )*a - 48U <= 9U));
      }
    } else {
      {
      {
      tmp = b;
      b ++;
      }
      if ((int const )*tmp == (int const )decimal_point) {
        {
        b_trailing_nonzero:
        {
        while (1) {
          while_continue___1: ;
          if (! ((int const )*b == 48)) {
            {
            goto while_break___1;
            }
          }
          {
          b ++;
          }
        }
        while_break___1: ;
        }
        return ((int __attribute__((__pure__)) )(- ((unsigned int )*b - 48U <= 9U)));
        }
      }
      }
    }
    }
  }
  return ((int __attribute__((__pure__)) )0);
}
}
__inline static int __attribute__((__pure__)) numcompare(char const *a , char const *b ,
                                                          int decimal_point , int thousands_sep )
{
  unsigned char tmpa ;
  unsigned char tmpb ;
  int tmp ;
  size_t log_a ;
  size_t log_b ;
  int __attribute__((__pure__)) tmp___0 ;
  int tmp___1 ;
  int __attribute__((__pure__)) tmp___2 ;
  int tmp___3 ;
  {
  {
  tmpa = (unsigned char )*a;
  tmpb = (unsigned char )*b;
  }
  if ((int )tmpa == 45) {
    {
    {
    while (1) {
      while_continue: ;
      if (! 1) {
        {
        goto while_break;
        }
      }
      {
      a ++;
      tmpa = (unsigned char )*a;
      }
      if (! ((int )tmpa == 48)) {
        {
        if (! ((int )tmpa == thousands_sep)) {
          {
          goto while_break;
          }
        }
        }
      }
    }
    while_break: ;
    }
    if ((int )tmpb != 45) {
      {
      if ((int )tmpa == decimal_point) {
        {
        {
        while (1) {
          while_continue___0: ;
          if (! 1) {
            {
            goto while_break___0;
            }
          }
          {
          a ++;
          tmpa = (unsigned char )*a;
          }
          if (! ((int )tmpa == 48)) {
            {
            goto while_break___0;
            }
          }
        }
        while_break___0: ;
        }
        }
      }
      if ((unsigned int )tmpa - 48U <= 9U) {
        {
        return ((int __attribute__((__pure__)) )-1);
        }
      }
      {
      while (1) {
        while_continue___1: ;
        if (! 1) {
          {
          goto while_break___1;
          }
        }
        if (! ((int )tmpb == 48)) {
          {
          if (! ((int )tmpb == thousands_sep)) {
            {
            goto while_break___1;
            }
          }
          }
        }
        {
        b ++;
        tmpb = (unsigned char )*b;
        }
      }
      while_break___1: ;
      }
      if ((int )tmpb == decimal_point) {
        {
        {
        while (1) {
          while_continue___2: ;
          if (! 1) {
            {
            goto while_break___2;
            }
          }
          {
          b ++;
          tmpb = (unsigned char )*b;
          }
          if (! ((int )tmpb == 48)) {
            {
            goto while_break___2;
            }
          }
        }
        while_break___2: ;
        }
        }
      }
      return ((int __attribute__((__pure__)) )(- ((unsigned int )tmpb - 48U <= 9U)));
      }
    }
    {
    while (1) {
      while_continue___3: ;
      if (! 1) {
        {
        goto while_break___3;
        }
      }
      {
      b ++;
      tmpb = (unsigned char )*b;
      }
      if (! ((int )tmpb == 48)) {
        {
        if (! ((int )tmpb == thousands_sep)) {
          {
          goto while_break___3;
          }
        }
        }
      }
    }
    while_break___3: ;
    }
    {
    while (1) {
      while_continue___4: ;
      if (! 1) {
        {
        goto while_break___4;
        }
      }
      if ((int )tmpa == (int )tmpb) {
        {
        if (! ((unsigned int )tmpa - 48U <= 9U)) {
          {
          goto while_break___4;
          }
        }
        }
      } else {
        {
        goto while_break___4;
        }
      }
      {
      while (1) {
        while_continue___5: ;
        if (! 1) {
          {
          goto while_break___5;
          }
        }
        {
        a ++;
        tmpa = (unsigned char )*a;
        }
        if (! ((int )tmpa == thousands_sep)) {
          {
          goto while_break___5;
          }
        }
      }
      while_break___5: ;
      }
      {
      while (1) {
        while_continue___6: ;
        if (! 1) {
          {
          goto while_break___6;
          }
        }
        {
        b ++;
        tmpb = (unsigned char )*b;
        }
        if (! ((int )tmpb == thousands_sep)) {
          {
          goto while_break___6;
          }
        }
      }
      while_break___6: ;
      }
    }
    while_break___4: ;
    }
    if ((int )tmpa == decimal_point) {
      {
      if (! ((unsigned int )tmpb - 48U <= 9U)) {
        {
        {
        tmp___0 = fraccompare(b, a, (char )decimal_point);
        }
        return (tmp___0);
        }
      } else {
        {
        goto _L;
        }
      }
      }
    } else {
      {
      _L:
      if ((int )tmpb == decimal_point) {
        {
        if (! ((unsigned int )tmpa - 48U <= 9U)) {
          {
          {
          tmp___0 = fraccompare(b, a, (char )decimal_point);
          }
          return (tmp___0);
          }
        }
        }
      }
      }
    }
    {
    tmp = (int )tmpb - (int )tmpa;
    log_a = (size_t )0;
    }
    {
    while (1) {
      while_continue___7: ;
      if (! ((unsigned int )tmpa - 48U <= 9U)) {
        {
        goto while_break___7;
        }
      }
      {
      while (1) {
        while_continue___8: ;
        if (! 1) {
          {
          goto while_break___8;
          }
        }
        {
        a ++;
        tmpa = (unsigned char )*a;
        }
        if (! ((int )tmpa == thousands_sep)) {
          {
          goto while_break___8;
          }
        }
      }
      while_break___8: ;
      }
      {
      log_a ++;
      }
    }
    while_break___7: ;
    }
    {
    log_b = (size_t )0;
    }
    {
    while (1) {
      while_continue___9: ;
      if (! ((unsigned int )tmpb - 48U <= 9U)) {
        {
        goto while_break___9;
        }
      }
      {
      while (1) {
        while_continue___10: ;
        if (! 1) {
          {
          goto while_break___10;
          }
        }
        {
        b ++;
        tmpb = (unsigned char )*b;
        }
        if (! ((int )tmpb == thousands_sep)) {
          {
          goto while_break___10;
          }
        }
      }
      while_break___10: ;
      }
      {
      log_b ++;
      }
    }
    while_break___9: ;
    }
    if (log_a != log_b) {
      {
      if (log_a < log_b) {
        {
        {
        tmp___1 = 1;
        }
        }
      } else {
        {
        {
        tmp___1 = -1;
        }
        }
      }
      return ((int __attribute__((__pure__)) )tmp___1);
      }
    }
    if (! log_a) {
      {
      return ((int __attribute__((__pure__)) )0);
      }
    }
    return ((int __attribute__((__pure__)) )tmp);
    }
  } else {
    {
    if ((int )tmpb == 45) {
      {
      {
      while (1) {
        while_continue___11: ;
        if (! 1) {
          {
          goto while_break___11;
          }
        }
        {
        b ++;
        tmpb = (unsigned char )*b;
        }
        if (! ((int )tmpb == 48)) {
          {
          if (! ((int )tmpb == thousands_sep)) {
            {
            goto while_break___11;
            }
          }
          }
        }
      }
      while_break___11: ;
      }
      if ((int )tmpb == decimal_point) {
        {
        {
        while (1) {
          while_continue___12: ;
          if (! 1) {
            {
            goto while_break___12;
            }
          }
          {
          b ++;
          tmpb = (unsigned char )*b;
          }
          if (! ((int )tmpb == 48)) {
            {
            goto while_break___12;
            }
          }
        }
        while_break___12: ;
        }
        }
      }
      if ((unsigned int )tmpb - 48U <= 9U) {
        {
        return ((int __attribute__((__pure__)) )1);
        }
      }
      {
      while (1) {
        while_continue___13: ;
        if (! 1) {
          {
          goto while_break___13;
          }
        }
        if (! ((int )tmpa == 48)) {
          {
          if (! ((int )tmpa == thousands_sep)) {
            {
            goto while_break___13;
            }
          }
          }
        }
        {
        a ++;
        tmpa = (unsigned char )*a;
        }
      }
      while_break___13: ;
      }
      if ((int )tmpa == decimal_point) {
        {
        {
        while (1) {
          while_continue___14: ;
          if (! 1) {
            {
            goto while_break___14;
            }
          }
          {
          a ++;
          tmpa = (unsigned char )*a;
          }
          if (! ((int )tmpa == 48)) {
            {
            goto while_break___14;
            }
          }
        }
        while_break___14: ;
        }
        }
      }
      return ((int __attribute__((__pure__)) )((unsigned int )tmpa - 48U <= 9U));
      }
    } else {
      {
      {
      while (1) {
        while_continue___15: ;
        if (! 1) {
          {
          goto while_break___15;
          }
        }
        if (! ((int )tmpa == 48)) {
          {
          if (! ((int )tmpa == thousands_sep)) {
            {
            goto while_break___15;
            }
          }
          }
        }
        {
        a ++;
        tmpa = (unsigned char )*a;
        }
      }
      while_break___15: ;
      }
      {
      while (1) {
        while_continue___16: ;
        if (! 1) {
          {
          goto while_break___16;
          }
        }
        if (! ((int )tmpb == 48)) {
          {
          if (! ((int )tmpb == thousands_sep)) {
            {
            goto while_break___16;
            }
          }
          }
        }
        {
        b ++;
        tmpb = (unsigned char )*b;
        }
      }
      while_break___16: ;
      }
      {
      while (1) {
        while_continue___17: ;
        if (! 1) {
          {
          goto while_break___17;
          }
        }
        if ((int )tmpa == (int )tmpb) {
          {
          if (! ((unsigned int )tmpa - 48U <= 9U)) {
            {
            goto while_break___17;
            }
          }
          }
        } else {
          {
          goto while_break___17;
          }
        }
        {
        while (1) {
          while_continue___18: ;
          if (! 1) {
            {
            goto while_break___18;
            }
          }
          {
          a ++;
          tmpa = (unsigned char )*a;
          }
          if (! ((int )tmpa == thousands_sep)) {
            {
            goto while_break___18;
            }
          }
        }
        while_break___18: ;
        }
        {
        while (1) {
          while_continue___19: ;
          if (! 1) {
            {
            goto while_break___19;
            }
          }
          {
          b ++;
          tmpb = (unsigned char )*b;
          }
          if (! ((int )tmpb == thousands_sep)) {
            {
            goto while_break___19;
            }
          }
        }
        while_break___19: ;
        }
      }
      while_break___17: ;
      }
      if ((int )tmpa == decimal_point) {
        {
        if (! ((unsigned int )tmpb - 48U <= 9U)) {
          {
          {
          tmp___2 = fraccompare(a, b, (char )decimal_point);
          }
          return (tmp___2);
          }
        } else {
          {
          goto _L___0;
          }
        }
        }
      } else {
        {
        _L___0:
        if ((int )tmpb == decimal_point) {
          {
          if (! ((unsigned int )tmpa - 48U <= 9U)) {
            {
            {
            tmp___2 = fraccompare(a, b, (char )decimal_point);
            }
            return (tmp___2);
            }
          }
          }
        }
        }
      }
      {
      tmp = (int )tmpa - (int )tmpb;
      log_a = (size_t )0;
      }
      {
      while (1) {
        while_continue___20: ;
        if (! ((unsigned int )tmpa - 48U <= 9U)) {
          {
          goto while_break___20;
          }
        }
        {
        while (1) {
          while_continue___21: ;
          if (! 1) {
            {
            goto while_break___21;
            }
          }
          {
          a ++;
          tmpa = (unsigned char )*a;
          }
          if (! ((int )tmpa == thousands_sep)) {
            {
            goto while_break___21;
            }
          }
        }
        while_break___21: ;
        }
        {
        log_a ++;
        }
      }
      while_break___20: ;
      }
      {
      log_b = (size_t )0;
      }
      {
      while (1) {
        while_continue___22: ;
        if (! ((unsigned int )tmpb - 48U <= 9U)) {
          {
          goto while_break___22;
          }
        }
        {
        while (1) {
          while_continue___23: ;
          if (! 1) {
            {
            goto while_break___23;
            }
          }
          {
          b ++;
          tmpb = (unsigned char )*b;
          }
          if (! ((int )tmpb == thousands_sep)) {
            {
            goto while_break___23;
            }
          }
        }
        while_break___23: ;
        }
        {
        log_b ++;
        }
      }
      while_break___22: ;
      }
      if (log_a != log_b) {
        {
        if (log_a < log_b) {
          {
          {
          tmp___3 = -1;
          }
          }
        } else {
          {
          {
          tmp___3 = 1;
          }
          }
        }
        return ((int __attribute__((__pure__)) )tmp___3);
        }
      }
      if (! log_a) {
        {
        return ((int __attribute__((__pure__)) )0);
        }
      }
      return ((int __attribute__((__pure__)) )tmp);
      }
    }
    }
  }
}
}
int strintcmp(char const *a , char const *b ) __attribute__((__pure__)) ;
int strintcmp(char const *a , char const *b )
{
  int __attribute__((__pure__)) tmp ;
  {
  {
  tmp = numcompare(a, b, -1, -1);
  }
  return ((int )tmp);
}
}
int __attribute__((__pure__)) strnumcmp(char const *a , char const *b , int decimal_point ,
                                         int thousands_sep )
{
  int __attribute__((__pure__)) tmp ;
  {
  {
  tmp = numcompare(a, b, decimal_point, thousands_sep);
  }
  return (tmp);
}
}
__inline static void initialize_exit_failure(int status )
{
  {
  if (status != 1) {
    {
    { if(!(status != 0)) { reach_error(); abort(); } };
    { if(!(status != 1)) { reach_error(); abort(); } };
    {
    exit_failure = (int volatile )status;
    }
    }
  }
  {
  { if(!(stdlib_allocator.die == 0)) { reach_error(); abort(); } };
  { if(!(argmatch_die == & __argmatch_die)) { reach_error(); abort(); } };
  { if(!(rpl_optind == 1)) { reach_error(); abort(); } };
  { if(!(rpl_opterr == 1)) { reach_error(); abort(); } };
  { if(!(rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(rpl_optopt == 63)) { reach_error(); abort(); } };
  { if(!(last_cherror == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addr == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addrlen == 0U)) { reach_error(); abort(); } };
  { if(!(hints.ai_canonname == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_family == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_flags == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_next == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_protocol == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_socktype == 0)) { reach_error(); abort(); } };
  { if(!(file_name == 0)) { reach_error(); abort(); } };
  { if(!(file_name___0 == 0)) { reach_error(); abort(); } };
  { if(!(ignore_EPIPE == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(user_alist == 0)) { reach_error(); abort(); } };
  { if(!(nouser_alist == 0)) { reach_error(); abort(); } };
  { if(!(group_alist == 0)) { reach_error(); abort(); } };
  { if(!(nogroup_alist == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.flags == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.left_quote == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.right_quote == 0)) { reach_error(); abort(); } };
  { if(!(nslots == 1U)) { reach_error(); abort(); } };
  { if(!(slotvec0.size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec0.val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!(slotvec == & slotvec0)) { reach_error(); abort(); } };
  { if(!(saved_delim == 0)) { reach_error(); abort(); } };
  { if(!(initialized == 0)) { reach_error(); abort(); } };
  { if(!(is_utf8 == 0)) { reach_error(); abort(); } };
  { if(!(ht == 0)) { reach_error(); abort(); } };
  { if(!(new_dst_res == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(lutimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(initialized___0 == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(can_write == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(have_dupfd_cloexec == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__first_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__initialized == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__last_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__nextchar == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__posixly_correct == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_opterr == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optind == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optopt == 0)) { reach_error(); abort(); } };
  { if(!(buf == 0)) { reach_error(); abort(); } };
  { if(!(bufsize == 0UL)) { reach_error(); abort(); } };
  { if(!(have_follow_really == 0)) { reach_error(); abort(); } };
  { if(!(proc_status == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really___0 == 0)) { reach_error(); abort(); } };
  { if(!(slotvec->size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec->val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!((_Bool )default_tuning.is_n_buckets == (_Bool)0)) { reach_error(); abort(); } };
  { if(!((int )fresh_once == 0)) { reach_error(); abort(); } };
  { if(!((unsigned int )default_quoting_options.style == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned int )getopt_data.__ordering == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned long )utf8_to_local == 0UL)) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.allocate == (void *)(& malloc))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.free == (void *)(& free))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.reallocate == (void *)(& realloc))) { reach_error(); abort(); } };
  { if(!(status != 0)) { reach_error(); abort(); } };
  return;
  }
}
}
__inline static void emit_ancillary_info(void)
{
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const *lc_messages ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  {
  {
  tmp = last_component(program_name);
  tmp___0 = gettext((char const *)"\nReport %s bugs to %s\n");
  printf((char const *)((char const * __restrict )tmp___0), tmp, "bug-coreutils@gnu.org");
  tmp___1 = gettext((char const *)"%s home page: <%s>\n");
  printf((char const *)((char const * __restrict )tmp___1), "GNU coreutils",
         "http://www.gnu.org/software/coreutils/");
  tmp___2 = gettext((char const *)"General help using GNU software: <http://www.gnu.org/gethelp/>\n");
  fputs_unlocked((char const * __restrict )tmp___2, (FILE * __restrict )stdout);
  tmp___3 = setlocale(5, (char const *)((void *)0));
  lc_messages = (char const *)tmp___3;
  }
  if (lc_messages) {
    {
    {
    tmp___6 = strncmp(lc_messages, (char const *)"en_", sizeof("en_") - 1UL);
    }
    if (tmp___6) {
      {
      { if(!(tmp___6 != 0)) { reach_error(); abort(); } };
      {
      tmp___4 = last_component(program_name);
      tmp___5 = gettext((char const *)"Report %s translation bugs to <http://translationproject.org/team/>\n");
      printf((char const *)((char const * __restrict )tmp___5), tmp___4);
      }
      }
    }
    }
  }
  {
  tmp___7 = last_component(program_name);
  tmp___8 = gettext((char const *)"For complete documentation, run: info coreutils \'%s invocation\'\n");
  printf((char const *)((char const * __restrict )tmp___8), tmp___7);
  }
  return;
}
}
void usage(int status ) __attribute__((__noreturn__)) ;
void usage(int status )
{
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  {
  if (status != 0) {
    {
    { if(!(status != 0)) { reach_error(); abort(); } };
    {
    tmp = gettext((char const *)"Try `%s --help\' for more information.\n");
    fprintf((FILE *)((FILE * __restrict )stderr), (char const *)((char const * __restrict )tmp),
            program_name);
    }
    }
  } else {
    {
    { if(!(status == 0)) { reach_error(); abort(); } };
    {
    tmp___0 = gettext((char const *)"Usage: %s COMMAND [ARG]...\n  or:  %s OPTION\n");
    printf((char const *)((char const * __restrict )tmp___0), program_name, program_name);
    { if(!(status == 0)) { reach_error(); abort(); } };
    tmp___1 = gettext((char const *)"Run COMMAND, ignoring hangup signals.\n\n");
    fputs_unlocked((char const * __restrict )tmp___1, (FILE * __restrict )stdout);
    { if(!(status == 0)) { reach_error(); abort(); } };
    tmp___2 = gettext((char const *)"      --help     display this help and exit\n");
    fputs_unlocked((char const * __restrict )tmp___2, (FILE * __restrict )stdout);
    { if(!(status == 0)) { reach_error(); abort(); } };
    tmp___3 = gettext((char const *)"      --version  output version information and exit\n");
    fputs_unlocked((char const * __restrict )tmp___3, (FILE * __restrict )stdout);
    { if(!(status == 0)) { reach_error(); abort(); } };
    tmp___4 = gettext((char const *)"\nIf standard input is a terminal, redirect it from /dev/null.\nIf standard output is a terminal, append output to `nohup.out\' if possible,\n`$HOME/nohup.out\' otherwise.\nIf standard error is a terminal, redirect it to standard output.\nTo save output to FILE, use `%s COMMAND > FILE\'.\n");
    printf((char const *)((char const * __restrict )tmp___4), program_name);
    { if(!(status == 0)) { reach_error(); abort(); } };
    tmp___5 = gettext((char const *)"\nNOTE: your shell may have its own version of %s, which usually supersedes\nthe version described here.  Please refer to your shell\'s documentation\nfor details about the options it supports.\n");
    printf((char const *)((char const * __restrict )tmp___5), "nohup");
    { if(!(status == 0)) { reach_error(); abort(); } };
    emit_ancillary_info();
    }
    }
  }
  {
  exit(status);
  }
}
}
int main(int argc , char **argv )
{
  int out_fd ;
  int saved_stderr_fd ;
  _Bool ignoring_input ;
  _Bool redirecting_stdout ;
  _Bool stdout_is_closed ;
  _Bool redirecting_stderr ;
  int exit_internal_failure ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *in_home ;
  char const *file ;
  int flags ;
  mode_t mode ;
  mode_t umask_value ;
  __mode_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int saved_errno ;
  int *tmp___15 ;
  char const *home ;
  char *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int saved_errno2 ;
  int *tmp___19 ;
  char const *tmp___20 ;
  char *tmp___21 ;
  char const *tmp___22 ;
  char *tmp___23 ;
  char const *tmp___24 ;
  char const *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  int *tmp___28 ;
  int tmp___29 ;
  char const *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  int *tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int exit_status ;
  int saved_errno___0 ;
  char **cmd ;
  int *tmp___37 ;
  int *tmp___38 ;
  char const *tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;
  int tmp ;
  int tmp___42 ;
  {
  {
  out_fd = 1;
  { if(!(out_fd == 1)) { reach_error(); abort(); } };
  saved_stderr_fd = 2;
  { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
  set_program_name((char const *)*(argv + 0));
  { if(!(stdlib_allocator.die == 0)) { reach_error(); abort(); } };
  { if(!(argmatch_die == & __argmatch_die)) { reach_error(); abort(); } };
  { if(!(rpl_optind == 1)) { reach_error(); abort(); } };
  { if(!(rpl_opterr == 1)) { reach_error(); abort(); } };
  { if(!(rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(rpl_optopt == 63)) { reach_error(); abort(); } };
  { if(!(out_fd == 1)) { reach_error(); abort(); } };
  { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
  { if(!(last_cherror == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addr == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addrlen == 0U)) { reach_error(); abort(); } };
  { if(!(hints.ai_canonname == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_family == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_flags == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_next == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_protocol == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_socktype == 0)) { reach_error(); abort(); } };
  { if(!(file_name == 0)) { reach_error(); abort(); } };
  { if(!(file_name___0 == 0)) { reach_error(); abort(); } };
  { if(!(ignore_EPIPE == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(user_alist == 0)) { reach_error(); abort(); } };
  { if(!(nouser_alist == 0)) { reach_error(); abort(); } };
  { if(!(group_alist == 0)) { reach_error(); abort(); } };
  { if(!(nogroup_alist == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.flags == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.left_quote == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.right_quote == 0)) { reach_error(); abort(); } };
  { if(!(nslots == 1U)) { reach_error(); abort(); } };
  { if(!(slotvec0.size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec0.val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!(slotvec == & slotvec0)) { reach_error(); abort(); } };
  { if(!(saved_delim == 0)) { reach_error(); abort(); } };
  { if(!(initialized == 0)) { reach_error(); abort(); } };
  { if(!(is_utf8 == 0)) { reach_error(); abort(); } };
  { if(!(ht == 0)) { reach_error(); abort(); } };
  { if(!(new_dst_res == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(lutimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(initialized___0 == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(can_write == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(have_dupfd_cloexec == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__first_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__initialized == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__last_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__nextchar == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__posixly_correct == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_opterr == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optind == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optopt == 0)) { reach_error(); abort(); } };
  { if(!(buf == 0)) { reach_error(); abort(); } };
  { if(!(bufsize == 0UL)) { reach_error(); abort(); } };
  { if(!(have_follow_really == 0)) { reach_error(); abort(); } };
  { if(!(proc_status == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really___0 == 0)) { reach_error(); abort(); } };
  { if(!(slotvec->size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec->val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!((_Bool )default_tuning.is_n_buckets == (_Bool)0)) { reach_error(); abort(); } };
  { if(!((int )fresh_once == 0)) { reach_error(); abort(); } };
  { if(!((unsigned int )default_quoting_options.style == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned int )getopt_data.__ordering == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned long )utf8_to_local == 0UL)) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.allocate == (void *)(& malloc))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.free == (void *)(& free))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.reallocate == (void *)(& realloc))) { reach_error(); abort(); } };
  setlocale(6, (char const *)"");
  { if(!(stdlib_allocator.die == 0)) { reach_error(); abort(); } };
  { if(!(argmatch_die == & __argmatch_die)) { reach_error(); abort(); } };
  { if(!(rpl_optind == 1)) { reach_error(); abort(); } };
  { if(!(rpl_opterr == 1)) { reach_error(); abort(); } };
  { if(!(rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(rpl_optopt == 63)) { reach_error(); abort(); } };
  { if(!(out_fd == 1)) { reach_error(); abort(); } };
  { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
  { if(!(last_cherror == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addr == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addrlen == 0U)) { reach_error(); abort(); } };
  { if(!(hints.ai_canonname == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_family == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_flags == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_next == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_protocol == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_socktype == 0)) { reach_error(); abort(); } };
  { if(!(file_name == 0)) { reach_error(); abort(); } };
  { if(!(file_name___0 == 0)) { reach_error(); abort(); } };
  { if(!(ignore_EPIPE == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(user_alist == 0)) { reach_error(); abort(); } };
  { if(!(nouser_alist == 0)) { reach_error(); abort(); } };
  { if(!(group_alist == 0)) { reach_error(); abort(); } };
  { if(!(nogroup_alist == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.flags == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.left_quote == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.right_quote == 0)) { reach_error(); abort(); } };
  { if(!(nslots == 1U)) { reach_error(); abort(); } };
  { if(!(slotvec0.size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec0.val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!(slotvec == & slotvec0)) { reach_error(); abort(); } };
  { if(!(saved_delim == 0)) { reach_error(); abort(); } };
  { if(!(initialized == 0)) { reach_error(); abort(); } };
  { if(!(is_utf8 == 0)) { reach_error(); abort(); } };
  { if(!(ht == 0)) { reach_error(); abort(); } };
  { if(!(new_dst_res == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(lutimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(initialized___0 == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(can_write == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(have_dupfd_cloexec == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__first_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__initialized == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__last_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__nextchar == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__posixly_correct == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_opterr == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optind == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optopt == 0)) { reach_error(); abort(); } };
  { if(!(buf == 0)) { reach_error(); abort(); } };
  { if(!(bufsize == 0UL)) { reach_error(); abort(); } };
  { if(!(have_follow_really == 0)) { reach_error(); abort(); } };
  { if(!(proc_status == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really___0 == 0)) { reach_error(); abort(); } };
  { if(!(slotvec->size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec->val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!((_Bool )default_tuning.is_n_buckets == (_Bool)0)) { reach_error(); abort(); } };
  { if(!((int )fresh_once == 0)) { reach_error(); abort(); } };
  { if(!((unsigned int )default_quoting_options.style == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned int )getopt_data.__ordering == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned long )utf8_to_local == 0UL)) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.allocate == (void *)(& malloc))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.free == (void *)(& free))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.reallocate == (void *)(& realloc))) { reach_error(); abort(); } };
  bindtextdomain((char const *)"coreutils", (char const *)"/usr/local/share/locale");
  { if(!(stdlib_allocator.die == 0)) { reach_error(); abort(); } };
  { if(!(argmatch_die == & __argmatch_die)) { reach_error(); abort(); } };
  { if(!(rpl_optind == 1)) { reach_error(); abort(); } };
  { if(!(rpl_opterr == 1)) { reach_error(); abort(); } };
  { if(!(rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(rpl_optopt == 63)) { reach_error(); abort(); } };
  { if(!(out_fd == 1)) { reach_error(); abort(); } };
  { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
  { if(!(last_cherror == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addr == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addrlen == 0U)) { reach_error(); abort(); } };
  { if(!(hints.ai_canonname == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_family == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_flags == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_next == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_protocol == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_socktype == 0)) { reach_error(); abort(); } };
  { if(!(file_name == 0)) { reach_error(); abort(); } };
  { if(!(file_name___0 == 0)) { reach_error(); abort(); } };
  { if(!(ignore_EPIPE == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(user_alist == 0)) { reach_error(); abort(); } };
  { if(!(nouser_alist == 0)) { reach_error(); abort(); } };
  { if(!(group_alist == 0)) { reach_error(); abort(); } };
  { if(!(nogroup_alist == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.flags == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.left_quote == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.right_quote == 0)) { reach_error(); abort(); } };
  { if(!(nslots == 1U)) { reach_error(); abort(); } };
  { if(!(slotvec0.size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec0.val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!(slotvec == & slotvec0)) { reach_error(); abort(); } };
  { if(!(saved_delim == 0)) { reach_error(); abort(); } };
  { if(!(initialized == 0)) { reach_error(); abort(); } };
  { if(!(is_utf8 == 0)) { reach_error(); abort(); } };
  { if(!(ht == 0)) { reach_error(); abort(); } };
  { if(!(new_dst_res == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(lutimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(initialized___0 == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(can_write == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(have_dupfd_cloexec == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__first_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__initialized == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__last_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__nextchar == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__posixly_correct == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_opterr == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optind == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optopt == 0)) { reach_error(); abort(); } };
  { if(!(buf == 0)) { reach_error(); abort(); } };
  { if(!(bufsize == 0UL)) { reach_error(); abort(); } };
  { if(!(have_follow_really == 0)) { reach_error(); abort(); } };
  { if(!(proc_status == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really___0 == 0)) { reach_error(); abort(); } };
  { if(!(slotvec->size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec->val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!((_Bool )default_tuning.is_n_buckets == (_Bool)0)) { reach_error(); abort(); } };
  { if(!((int )fresh_once == 0)) { reach_error(); abort(); } };
  { if(!((unsigned int )default_quoting_options.style == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned int )getopt_data.__ordering == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned long )utf8_to_local == 0UL)) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.allocate == (void *)(& malloc))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.free == (void *)(& free))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.reallocate == (void *)(& realloc))) { reach_error(); abort(); } };
  textdomain((char const *)"coreutils");
  { if(!(stdlib_allocator.die == 0)) { reach_error(); abort(); } };
  { if(!(argmatch_die == & __argmatch_die)) { reach_error(); abort(); } };
  { if(!(rpl_optind == 1)) { reach_error(); abort(); } };
  { if(!(rpl_opterr == 1)) { reach_error(); abort(); } };
  { if(!(rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(rpl_optopt == 63)) { reach_error(); abort(); } };
  { if(!(out_fd == 1)) { reach_error(); abort(); } };
  { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
  { if(!(last_cherror == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addr == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addrlen == 0U)) { reach_error(); abort(); } };
  { if(!(hints.ai_canonname == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_family == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_flags == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_next == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_protocol == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_socktype == 0)) { reach_error(); abort(); } };
  { if(!(file_name == 0)) { reach_error(); abort(); } };
  { if(!(file_name___0 == 0)) { reach_error(); abort(); } };
  { if(!(ignore_EPIPE == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(user_alist == 0)) { reach_error(); abort(); } };
  { if(!(nouser_alist == 0)) { reach_error(); abort(); } };
  { if(!(group_alist == 0)) { reach_error(); abort(); } };
  { if(!(nogroup_alist == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.flags == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.left_quote == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.right_quote == 0)) { reach_error(); abort(); } };
  { if(!(nslots == 1U)) { reach_error(); abort(); } };
  { if(!(slotvec0.size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec0.val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!(slotvec == & slotvec0)) { reach_error(); abort(); } };
  { if(!(saved_delim == 0)) { reach_error(); abort(); } };
  { if(!(initialized == 0)) { reach_error(); abort(); } };
  { if(!(is_utf8 == 0)) { reach_error(); abort(); } };
  { if(!(ht == 0)) { reach_error(); abort(); } };
  { if(!(new_dst_res == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(lutimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(initialized___0 == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(can_write == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(have_dupfd_cloexec == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__first_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__initialized == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__last_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__nextchar == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__posixly_correct == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_opterr == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optind == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optopt == 0)) { reach_error(); abort(); } };
  { if(!(buf == 0)) { reach_error(); abort(); } };
  { if(!(bufsize == 0UL)) { reach_error(); abort(); } };
  { if(!(have_follow_really == 0)) { reach_error(); abort(); } };
  { if(!(proc_status == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really___0 == 0)) { reach_error(); abort(); } };
  { if(!(slotvec->size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec->val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!((_Bool )default_tuning.is_n_buckets == (_Bool)0)) { reach_error(); abort(); } };
  { if(!((int )fresh_once == 0)) { reach_error(); abort(); } };
  { if(!((unsigned int )default_quoting_options.style == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned int )getopt_data.__ordering == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned long )utf8_to_local == 0UL)) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.allocate == (void *)(& malloc))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.free == (void *)(& free))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.reallocate == (void *)(& realloc))) { reach_error(); abort(); } };
  tmp___0 = getenv((char const *)"POSIXLY_CORRECT");
  }
  if (tmp___0) {
    {
    {
    exit_internal_failure = 127;
    { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
    }
    }
  } else {
    {
    { if(!(tmp___0 == 0)) { reach_error(); abort(); } };
    {
    exit_internal_failure = 125;
    { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
    }
    }
  }
  {
  { if(!(stdlib_allocator.die == 0)) { reach_error(); abort(); } };
  { if(!(argmatch_die == & __argmatch_die)) { reach_error(); abort(); } };
  { if(!(rpl_optind == 1)) { reach_error(); abort(); } };
  { if(!(rpl_opterr == 1)) { reach_error(); abort(); } };
  { if(!(rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(rpl_optopt == 63)) { reach_error(); abort(); } };
  { if(!(out_fd == 1)) { reach_error(); abort(); } };
  { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
  { if(!(last_cherror == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addr == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addrlen == 0U)) { reach_error(); abort(); } };
  { if(!(hints.ai_canonname == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_family == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_flags == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_next == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_protocol == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_socktype == 0)) { reach_error(); abort(); } };
  { if(!(file_name == 0)) { reach_error(); abort(); } };
  { if(!(file_name___0 == 0)) { reach_error(); abort(); } };
  { if(!(ignore_EPIPE == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(user_alist == 0)) { reach_error(); abort(); } };
  { if(!(nouser_alist == 0)) { reach_error(); abort(); } };
  { if(!(group_alist == 0)) { reach_error(); abort(); } };
  { if(!(nogroup_alist == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.flags == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.left_quote == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.right_quote == 0)) { reach_error(); abort(); } };
  { if(!(nslots == 1U)) { reach_error(); abort(); } };
  { if(!(slotvec0.size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec0.val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!(slotvec == & slotvec0)) { reach_error(); abort(); } };
  { if(!(saved_delim == 0)) { reach_error(); abort(); } };
  { if(!(initialized == 0)) { reach_error(); abort(); } };
  { if(!(is_utf8 == 0)) { reach_error(); abort(); } };
  { if(!(ht == 0)) { reach_error(); abort(); } };
  { if(!(new_dst_res == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(lutimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(initialized___0 == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(can_write == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(have_dupfd_cloexec == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__first_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__initialized == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__last_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__nextchar == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__posixly_correct == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_opterr == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optind == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optopt == 0)) { reach_error(); abort(); } };
  { if(!(buf == 0)) { reach_error(); abort(); } };
  { if(!(bufsize == 0UL)) { reach_error(); abort(); } };
  { if(!(have_follow_really == 0)) { reach_error(); abort(); } };
  { if(!(proc_status == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really___0 == 0)) { reach_error(); abort(); } };
  { if(!(slotvec->size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec->val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!((_Bool )default_tuning.is_n_buckets == (_Bool)0)) { reach_error(); abort(); } };
  { if(!((int )fresh_once == 0)) { reach_error(); abort(); } };
  { if(!((unsigned int )default_quoting_options.style == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned int )getopt_data.__ordering == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned long )utf8_to_local == 0UL)) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.allocate == (void *)(& malloc))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.free == (void *)(& free))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.reallocate == (void *)(& realloc))) { reach_error(); abort(); } };
  { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
  {
  initialize_exit_failure(exit_internal_failure);
  { if(!(stdlib_allocator.die == 0)) { reach_error(); abort(); } };
  { if(!(argmatch_die == & __argmatch_die)) { reach_error(); abort(); } };
  { if(!(rpl_optind == 1)) { reach_error(); abort(); } };
  { if(!(rpl_opterr == 1)) { reach_error(); abort(); } };
  { if(!(rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(rpl_optopt == 63)) { reach_error(); abort(); } };
  { if(!(out_fd == 1)) { reach_error(); abort(); } };
  { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
  { if(!(last_cherror == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addr == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_addrlen == 0U)) { reach_error(); abort(); } };
  { if(!(hints.ai_canonname == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_family == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_flags == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_next == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_protocol == 0)) { reach_error(); abort(); } };
  { if(!(hints.ai_socktype == 0)) { reach_error(); abort(); } };
  { if(!(file_name == 0)) { reach_error(); abort(); } };
  { if(!(file_name___0 == 0)) { reach_error(); abort(); } };
  { if(!(ignore_EPIPE == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(user_alist == 0)) { reach_error(); abort(); } };
  { if(!(nouser_alist == 0)) { reach_error(); abort(); } };
  { if(!(group_alist == 0)) { reach_error(); abort(); } };
  { if(!(nogroup_alist == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.flags == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.left_quote == 0)) { reach_error(); abort(); } };
  { if(!(default_quoting_options.right_quote == 0)) { reach_error(); abort(); } };
  { if(!(nslots == 1U)) { reach_error(); abort(); } };
  { if(!(slotvec0.size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec0.val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!(slotvec == & slotvec0)) { reach_error(); abort(); } };
  { if(!(saved_delim == 0)) { reach_error(); abort(); } };
  { if(!(initialized == 0)) { reach_error(); abort(); } };
  { if(!(is_utf8 == 0)) { reach_error(); abort(); } };
  { if(!(ht == 0)) { reach_error(); abort(); } };
  { if(!(new_dst_res == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(lutimensat_works_really == 0)) { reach_error(); abort(); } };
  { if(!(initialized___0 == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(can_write == (_Bool)0)) { reach_error(); abort(); } };
  { if(!(have_dupfd_cloexec == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__first_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__initialized == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__last_nonopt == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__nextchar == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.__posixly_correct == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optarg == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_opterr == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optind == 0)) { reach_error(); abort(); } };
  { if(!(getopt_data.rpl_optopt == 0)) { reach_error(); abort(); } };
  { if(!(buf == 0)) { reach_error(); abort(); } };
  { if(!(bufsize == 0UL)) { reach_error(); abort(); } };
  { if(!(have_follow_really == 0)) { reach_error(); abort(); } };
  { if(!(proc_status == 0)) { reach_error(); abort(); } };
  { if(!(utimensat_works_really___0 == 0)) { reach_error(); abort(); } };
  { if(!(slotvec->size == 256UL)) { reach_error(); abort(); } };
  { if(!(slotvec->val == & slot0[0LL])) { reach_error(); abort(); } };
  { if(!((_Bool )default_tuning.is_n_buckets == (_Bool)0)) { reach_error(); abort(); } };
  { if(!((int )fresh_once == 0)) { reach_error(); abort(); } };
  { if(!((unsigned int )default_quoting_options.style == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned int )getopt_data.__ordering == 0U)) { reach_error(); abort(); } };
  { if(!((unsigned long )utf8_to_local == 0UL)) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.allocate == (void *)(& malloc))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.free == (void *)(& free))) { reach_error(); abort(); } };
  { if(!((void *)stdlib_allocator.reallocate == (void *)(& realloc))) { reach_error(); abort(); } };
  { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
  atexit(& close_stdout);
  { if(!(out_fd == 1)) { reach_error(); abort(); } };
  { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
  { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
  parse_long_options(argc, argv, (char const *)"nohup", (char const *)"GNU coreutils",
                     Version, & usage, "Jim Meyering", (char const *)((void *)0));
  { if(!(out_fd == 1)) { reach_error(); abort(); } };
  { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
  { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
  tmp___1 = rpl_getopt_long(argc, argv, (char const *)"+", (struct rpl_option const *)((void *)0),
                            (int *)((void *)0));
  }
  }
  if (tmp___1 != -1) {
    {
    { if(!(tmp___1 != -1)) { reach_error(); abort(); } };
    {
    usage(exit_internal_failure);
    { if(!(out_fd == 1)) { reach_error(); abort(); } };
    { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
    { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
    { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
    }
    }
  }
  {
  { if(!(out_fd == 1)) { reach_error(); abort(); } };
  { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
  { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
  { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
  if (argc <= rpl_optind) {
    {
    {
    tmp___2 = gettext((char const *)"missing operand");
    error(0, 0, (char const *)tmp___2);
    { if(!(out_fd == 1)) { reach_error(); abort(); } };
    { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
    { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
    { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
    usage(exit_internal_failure);
    { if(!(out_fd == 1)) { reach_error(); abort(); } };
    { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
    { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
    { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
    }
    }
  }
  }
  {
  { if(!(out_fd == 1)) { reach_error(); abort(); } };
  { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
  { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
  { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
  {
  tmp___3 = isatty(0);
  ignoring_input = (_Bool )tmp___3;
  tmp___4 = isatty(1);
  redirecting_stdout = (_Bool )tmp___4;
  }
  }
  if (! redirecting_stdout) {
    {
    { if(!(redirecting_stdout == (_Bool)0)) { reach_error(); abort(); } };
    {
    tmp___5 = __errno_location();
    }
    if (*tmp___5 == 9) {
      {
      {
      tmp___6 = 1;
      }
      }
    } else {
      {
      {
      tmp___6 = 0;
      }
      }
    }
    }
  } else {
    {
    { if(!(redirecting_stdout != (_Bool)0)) { reach_error(); abort(); } };
    {
    tmp___6 = 0;
    }
    }
  }
  {
  stdout_is_closed = (_Bool )tmp___6;
  tmp___7 = isatty(2);
  redirecting_stderr = (_Bool )tmp___7;
  }
  if (ignoring_input) {
    {
    { if(!(ignoring_input != (_Bool)0)) { reach_error(); abort(); } };
    {
    tmp___10 = fd_reopen(0, (char const *)"/dev/null", 1, (mode_t )0);
    }
    if (tmp___10 < 0) {
      {
      { if(!(tmp___10 != 0)) { reach_error(); abort(); } };
      {
      tmp___8 = gettext((char const *)"failed to render standard input unusable");
      tmp___9 = __errno_location();
      error(0, *tmp___9, (char const *)tmp___8);
      { if(!(out_fd == 1)) { reach_error(); abort(); } };
      { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
      { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
      { if(!(ignoring_input != (_Bool)0)) { reach_error(); abort(); } };
      { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
      { if(!(tmp___10 != 0)) { reach_error(); abort(); } };
      exit(exit_internal_failure);
      { if(!(out_fd == 1)) { reach_error(); abort(); } };
      { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
      { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
      { if(!(ignoring_input != (_Bool)0)) { reach_error(); abort(); } };
      { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
      }
      }
    }
    {
    { if(!(out_fd == 1)) { reach_error(); abort(); } };
    { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
    { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
    { if(!(ignoring_input != (_Bool)0)) { reach_error(); abort(); } };
    { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
    if (! redirecting_stdout) {
      {
      { if(!(redirecting_stdout == (_Bool)0)) { reach_error(); abort(); } };
      if (! redirecting_stderr) {
        {
        { if(!(redirecting_stderr == (_Bool)0)) { reach_error(); abort(); } };
        {
        tmp___11 = gettext((char const *)"ignoring input");
        error(0, 0, (char const *)tmp___11);
        { if(!(out_fd == 1)) { reach_error(); abort(); } };
        { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
        { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
        { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
        }
        }
      }
      }
    }
    }
    }
  }
  if (redirecting_stdout) {
    {
    goto _L;
    }
  } else {
    {
    { if(!(redirecting_stdout == (_Bool)0)) { reach_error(); abort(); } };
    if (redirecting_stderr) {
      {
      { if(!(redirecting_stderr != (_Bool)0)) { reach_error(); abort(); } };
      if (stdout_is_closed) {
        {
        _L:
        {
        { if(!(out_fd == 1)) { reach_error(); abort(); } };
        { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
        { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
        { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
        {
        in_home = (char *)((void *)0);
        { if(!(in_home == 0)) { reach_error(); abort(); } };
        file = (char const *)"nohup.out";
        flags = 1089;
        { if(!(flags == 1089)) { reach_error(); abort(); } };
        mode = (mode_t )384;
        { if(!(mode == 384U)) { reach_error(); abort(); } };
        tmp___12 = umask(~ mode);
        umask_value = tmp___12;
        }
        }
        if (redirecting_stdout) {
          {
          { if(!(redirecting_stdout != (_Bool)0)) { reach_error(); abort(); } };
          {
          tmp___13 = fd_reopen(1, file, flags, mode);
          out_fd = tmp___13;
          }
          }
        } else {
          {
          { if(!(redirecting_stdout == (_Bool)0)) { reach_error(); abort(); } };
          {
          tmp = open(file, flags, mode);
          tmp___14 = tmp;
          out_fd = tmp___14;
          }
          }
        }
        {
        { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
        { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
        { if(!(in_home == 0)) { reach_error(); abort(); } };
        { if(!(flags == 1089)) { reach_error(); abort(); } };
        { if(!(mode == 384U)) { reach_error(); abort(); } };
        { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
        if (out_fd < 0) {
          {
          { if(!(out_fd != 0)) { reach_error(); abort(); } };
          {
          tmp___15 = __errno_location();
          saved_errno = *tmp___15;
          tmp___16 = getenv((char const *)"HOME");
          home = (char const *)tmp___16;
          }
          if (home) {
            {
            {
            in_home = file_name_concat(home, file, (char **)((void *)0));
            }
            if (redirecting_stdout) {
              {
              { if(!(redirecting_stdout != (_Bool)0)) { reach_error(); abort(); } };
              {
              tmp___17 = fd_reopen(1, (char const *)in_home, flags, mode);
              out_fd = tmp___17;
              }
              }
            } else {
              {
              { if(!(redirecting_stdout == (_Bool)0)) { reach_error(); abort(); } };
              {
              tmp___42 = open((char const *)in_home, flags, mode);
              tmp___18 = tmp___42;
              out_fd = tmp___18;
              }
              }
            }
            }
          }
          if (out_fd < 0) {
            {
            { if(!(out_fd != 0)) { reach_error(); abort(); } };
            {
            tmp___19 = __errno_location();
            saved_errno2 = *tmp___19;
            tmp___20 = quote(file);
            tmp___21 = gettext((char const *)"failed to open %s");
            error(0, saved_errno, (char const *)tmp___21, tmp___20);
            { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
            { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
            { if(!(flags == 1089)) { reach_error(); abort(); } };
            { if(!(mode == 384U)) { reach_error(); abort(); } };
            { if(!(out_fd != 0)) { reach_error(); abort(); } };
            { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
            }
            if (in_home) {
              {
              {
              tmp___22 = quote((char const *)in_home);
              tmp___23 = gettext((char const *)"failed to open %s");
              error(0, saved_errno2, (char const *)tmp___23, tmp___22);
              { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
              { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
              { if(!(flags == 1089)) { reach_error(); abort(); } };
              { if(!(mode == 384U)) { reach_error(); abort(); } };
              { if(!(out_fd != 0)) { reach_error(); abort(); } };
              { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
              }
              }
            }
            {
            { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
            { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
            { if(!(flags == 1089)) { reach_error(); abort(); } };
            { if(!(mode == 384U)) { reach_error(); abort(); } };
            { if(!(out_fd != 0)) { reach_error(); abort(); } };
            { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
            {
            exit(exit_internal_failure);
            { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
            { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
            { if(!(flags == 1089)) { reach_error(); abort(); } };
            { if(!(mode == 384U)) { reach_error(); abort(); } };
            { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
            }
            }
            }
          }
          {
          { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
          { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
          { if(!(flags == 1089)) { reach_error(); abort(); } };
          { if(!(mode == 384U)) { reach_error(); abort(); } };
          { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
          {
          file = (char const *)in_home;
          }
          }
          }
        }
        }
        {
        { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
        { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
        { if(!(flags == 1089)) { reach_error(); abort(); } };
        { if(!(mode == 384U)) { reach_error(); abort(); } };
        { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
        {
        umask(umask_value);
        { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
        { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
        { if(!(flags == 1089)) { reach_error(); abort(); } };
        { if(!(mode == 384U)) { reach_error(); abort(); } };
        { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
        tmp___24 = quote(file);
        }
        }
        if (ignoring_input) {
          {
          { if(!(ignoring_input != (_Bool)0)) { reach_error(); abort(); } };
          {
          tmp___25 = (char const *)"ignoring input and appending output to %s";
          }
          }
        } else {
          {
          { if(!(ignoring_input == (_Bool)0)) { reach_error(); abort(); } };
          {
          tmp___25 = (char const *)"appending output to %s";
          }
          }
        }
        {
        { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
        { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
        { if(!(flags == 1089)) { reach_error(); abort(); } };
        { if(!(mode == 384U)) { reach_error(); abort(); } };
        { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
        {
        tmp___26 = gettext(tmp___25);
        error(0, 0, (char const *)tmp___26, tmp___24);
        { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
        { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
        { if(!(flags == 1089)) { reach_error(); abort(); } };
        { if(!(mode == 384U)) { reach_error(); abort(); } };
        { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
        free((void *)in_home);
        { if(!(saved_stderr_fd == 2)) { reach_error(); abort(); } };
        { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
        { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
        }
        }
        }
      }
      }
    }
    }
  }
  if (redirecting_stderr) {
    {
    { if(!(redirecting_stderr != (_Bool)0)) { reach_error(); abort(); } };
    {
    saved_stderr_fd = dup_safer(2);
    }
    if (0 <= saved_stderr_fd) {
      {
      {
      tmp___29 = set_cloexec_flag(saved_stderr_fd, (_Bool)1);
      }
      if (tmp___29 != 0) {
        {
        { if(!(tmp___29 != 0)) { reach_error(); abort(); } };
        {
        tmp___27 = gettext((char const *)"failed to set the copy of stderr to close on exec");
        tmp___28 = __errno_location();
        error(exit_internal_failure, *tmp___28, (char const *)tmp___27);
        { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
        { if(!(redirecting_stderr != (_Bool)0)) { reach_error(); abort(); } };
        { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
        }
        }
      }
      }
    }
    if (! redirecting_stdout) {
      {
      { if(!(redirecting_stdout == (_Bool)0)) { reach_error(); abort(); } };
      if (ignoring_input) {
        {
        { if(!(ignoring_input != (_Bool)0)) { reach_error(); abort(); } };
        {
        tmp___30 = (char const *)"ignoring input and redirecting stderr to stdout";
        }
        }
      } else {
        {
        { if(!(ignoring_input == (_Bool)0)) { reach_error(); abort(); } };
        {
        tmp___30 = (char const *)"redirecting stderr to stdout";
        }
        }
      }
      {
      { if(!(redirecting_stdout == (_Bool)0)) { reach_error(); abort(); } };
      { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
      { if(!(redirecting_stderr != (_Bool)0)) { reach_error(); abort(); } };
      { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
      {
      tmp___31 = gettext(tmp___30);
      error(0, 0, (char const *)tmp___31);
      { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
      { if(!(redirecting_stderr != (_Bool)0)) { reach_error(); abort(); } };
      { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
      }
      }
      }
    }
    {
    { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
    { if(!(redirecting_stderr != (_Bool)0)) { reach_error(); abort(); } };
    { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
    {
    tmp___34 = dup2(out_fd, 2);
    }
    }
    if (tmp___34 < 0) {
      {
      { if(!(tmp___34 != 0)) { reach_error(); abort(); } };
      {
      tmp___32 = gettext((char const *)"failed to redirect standard error");
      tmp___33 = __errno_location();
      error(exit_internal_failure, *tmp___33, (char const *)tmp___32);
      { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
      { if(!(redirecting_stderr != (_Bool)0)) { reach_error(); abort(); } };
      { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
      }
      }
    }
    {
    { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
    { if(!(redirecting_stderr != (_Bool)0)) { reach_error(); abort(); } };
    { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
    if (stdout_is_closed) {
      {
      { if(!(stdout_is_closed != (_Bool)0)) { reach_error(); abort(); } };
      {
      close(out_fd);
      { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
      { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
      }
      }
    }
    }
    }
  }
  {
  tmp___35 = ferror_unlocked(stderr);
  }
  if (tmp___35) {
    {
    { if(!(tmp___35 != 0)) { reach_error(); abort(); } };
    {
    exit(exit_internal_failure);
    { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
    { if(!(tmp___35 == 0)) { reach_error(); abort(); } };
    { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
    }
    }
  }
  {
  { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
  { if(!(tmp___35 == 0)) { reach_error(); abort(); } };
  { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
  {
  signal(1, (void (*)(int ))1);
  { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
  { if(!(tmp___35 == 0)) { reach_error(); abort(); } };
  { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
  cmd = argv + rpl_optind;
  execvp((char const *)*cmd, (char **)cmd);
  { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
  { if(!(tmp___35 == 0)) { reach_error(); abort(); } };
  { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
  tmp___37 = __errno_location();
  }
  }
  if (*tmp___37 == 2) {
    {
    {
    exit_status = 127;
    { if(!(exit_status != 0)) { reach_error(); abort(); } };
    }
    }
  } else {
    {
    {
    exit_status = 126;
    { if(!(exit_status != 0)) { reach_error(); abort(); } };
    }
    }
  }
  {
  { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
  { if(!(tmp___35 == 0)) { reach_error(); abort(); } };
  { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
  { if(!(exit_status != 0)) { reach_error(); abort(); } };
  {
  tmp___38 = __errno_location();
  saved_errno___0 = *tmp___38;
  tmp___41 = dup2(saved_stderr_fd, 2);
  }
  }
  if (tmp___41 == 2) {
    {
    { if(!(tmp___41 == 2)) { reach_error(); abort(); } };
    {
    tmp___39 = quote((char const *)*cmd);
    tmp___40 = gettext((char const *)"failed to run command %s");
    error(0, saved_errno___0, (char const *)tmp___40, tmp___39);
    { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
    { if(!(tmp___35 == 0)) { reach_error(); abort(); } };
    { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
    { if(!(exit_status != 0)) { reach_error(); abort(); } };
    }
    }
  }
  {
  { if(!(tmp___1 == -1)) { reach_error(); abort(); } };
  { if(!(tmp___35 == 0)) { reach_error(); abort(); } };
  { if(!(exit_internal_failure != 0)) { reach_error(); abort(); } };
  { if(!(exit_status != 0)) { reach_error(); abort(); } };
  {
  exit(exit_status);
  }
  }
}
}
