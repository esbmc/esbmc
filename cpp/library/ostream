#ifndef STL_OSTREAM
#define STL_OSTREAM

#include "ios"
#include "definitions.h"
#include "iomanip"

#include "vector"

namespace std
{
struct ostream
{
	typedef int streampos;
	typedef int streamoff;

	ostream(int id): id(id){}
	int id;
	void fill(char c);
	void precision(int p);
	void put(char c);
	void write(char str[], size_t n);
	ostream& seekp ( streampos pos ); //model
	ostream& seekp ( streamoff off, ios_base::seekdir dir ); //model
	ios_base::fmtflags flags ( ) const;
	ios_base::fmtflags flags ( ios_base::fmtflags fmtfl );

private:
	ostream(const ostream&); // disabled
	ostream& operator=(const ostream&); // disabled
};
}

namespace esbmc
{
	void esbmc_print_cstr(int o, const char* cstr){}
	void esbmc_print_char(int o, char c){}
	void esbmc_print_int(int o, int i){}
	void esbmc_print_double(int o, double d){}
	void esbmc_print_unsigned(int o, unsigned i){}
	void esbmc_print_bool(int o, bool b){}
	void esbmc_print_long_long(int o, long long i){}
	void esbmc_print_unsigned_long_long(int o, unsigned long long i){}

}

namespace std{

template < typename T >  // or template< typename T >
inline ostream& operator <<( ostream& o, T i )
{
	return o;
}

inline ostream& operator << (ostream& o, const char*  cstr)
{
	esbmc::esbmc_print_cstr(o.id, cstr);
	return o;
}

inline ostream& operator << (ostream& o, char  c)
{
	esbmc::esbmc_print_char(o.id, c);
	return o;
}

inline ostream&  operator << (ostream& o, int  i)
{
	esbmc::esbmc_print_int(o.id, i);
	return o;
}

inline ostream&  operator << (ostream& o, double  d) // Felipe Rodrigues
{
	esbmc::esbmc_print_double(o.id, d);
	return o;
}

inline ostream& operator << (ostream& o, unsigned  i)
{
	esbmc::esbmc_print_unsigned(o.id, i);
	return o;

}
inline ostream& operator << (ostream& o, long long  i)
{
	esbmc::esbmc_print_long_long(o.id, i);
	return o;
}

inline ostream& operator << (ostream& o, unsigned long long  i)
{
	esbmc::esbmc_print_unsigned_long_long(o.id, i);
	return o;
}

inline ostream& operator << (ostream& o, bool  b)
{
	esbmc::esbmc_print_bool(o.id, b);
	return o;
}

inline ostream& operator << (ostream& o, fixedStruct)
{
	return o;
}

inline ostream& operator << (ostream& o, setprecision)
{
	return o;
}

inline ostream& operator << (ostream& o, setw)
{
	return o;
}

inline ostream& operator << (ostream& o, leftStruct)
{
	return o;
}

inline ostream& operator << (ostream& o, rightStruct)
{
	return o;
}

inline ostream& operator << (ostream& o, hexStruct)
{
	return o;
}

inline ostream& operator << (ostream& o, decStruct)
{
	return o;
}

inline ostream& operator << (ostream& o, octStruct)
{
	return o;
}

inline ostream& operator << (ostream& o, setbase)
{
	return o;
}

inline ostream& operator << (ostream& o, flushStruct)
{
	return o;
}

inline ostream& operator << (ostream& o, setfill)
{
	return o;
}

inline ostream& operator << (ostream& o, scientificStruct)
{
	return o;
}

inline ostream& operator << (ostream& o, showpointStruct)
{
	return o;
}

inline ostream& operator << (ostream& o, showbaseStruct)
{
	return o;
}

inline ostream& operator << (ostream& o, internalStruct)
{
	return o;
}

inline ostream& operator << (ostream& o, showposStruct)
{
	return o;
}

inline ostream& operator << (ostream& o, boolalphaStruct)
{
	return o;
}

inline ostream& operator << (ostream& o, noboolalphaStruct)
{
	return o;
}

inline ostream& operator << (ostream& o, uppercaseStruct)
{
	return o;
}

}

namespace std
{
	void ostream::fill(char c)
	{
		setfill(c);
	}

	void ostream::precision(int p)
	{
		setprecision(p);
	}

	void ostream::put(char c)
	{
	}

	void ostream::write(char str[], size_t n)
	{
	}
}

#endif
