
 
 
 bool clang_c_convertert::get_function(const clang::FunctionDecl &fd, exprt &)
 {
-  // Don't convert if clang thinks that the functions was implicitly converted
-  if(fd.isImplicit())
+  // Don't convert if implicit, unless it's a constructor or destructor
+  // A compiler-generated default ctor/dtor is considered implicit, but we have
+  // to parse it.
+  auto isContructorOrDestructor = [](const clang::FunctionDecl &fd) {
+    return fd.getKind() == clang::Decl::CXXConstructor ||
+           fd.getKind() == clang::Decl::CXXDestructor;
+  };
+
+  if(fd.isImplicit() && !isContructorOrDestructor(fd))
     return false;
 
   // If the function is not defined but this is not the definition, skip it
@@ -540,14 +641,8 @@ bool clang_c_convertert::get_function(const clang::FunctionDecl &fd, exprt &)
 
   // We convert the parameters first so their symbol are added to context
   // before converting the body, as they may appear on the function body
-  for(auto const &pdecl : fd.parameters())
-  {
-    code_typet::argumentt param;
-    if(get_function_params(*pdecl, param))
-      return true;
-
-    type.arguments().push_back(param);
-  }
+  if(get_function_params(fd, type.arguments()))
+    return true;
 
   // Apparently, if the type has no arguments, we assume ellipsis
   if(!type.arguments().size())
@@ -558,11 +653,8 @@ bool clang_c_convertert::get_function(const clang::FunctionDecl &fd, exprt &)
   // We need: a type, a name, and an optional body
   if(fd.hasBody())
   {
-    exprt body_exprt;
-    if(get_expr(*fd.getBody(), body_exprt))
+    if(get_function_body(fd, added_symbol.value))
       return true;
-
-    added_symbol.value = body_exprt;
   }
 
   // Restore old functionDecl
@@ -571,7 +663,40 @@ bool clang_c_convertert::get_function(const clang::FunctionDecl &fd, exprt &)
   return false;
 }
 
+bool clang_c_convertert::get_function_body(
+  const clang::FunctionDecl &fd,
+  exprt &new_expr)
+{
+  assert(fd.hasBody());
+
+  exprt body_exprt;
+  if(get_expr(*fd.getBody(), body_exprt))
+    return true; // return true if failing to parse function body
+
+  new_expr = body_exprt;
+  return false;
+}
+
 bool clang_c_convertert::get_function_params(
+  const clang::FunctionDecl &fd,
+  code_typet::argumentst &params)
+{
+  if(!fd.parameters().size()) // return if no parameter
+    return false;
+
+  for(auto const &pdecl : fd.parameters())
+  {
+    code_typet::argumentt param;
+    if(get_function_param(*pdecl, param))
+      return true; // return true if failling to parse a parameter
+
+    params.push_back(param);
+  }
+
+  return false;
+}
+
+bool clang_c_convertert::get_function_param(
   const clang::ParmVarDecl &pd,
   exprt &param)
 {
@@ -729,7 +854,7 @@ bool clang_c_convertert::get_type(const clang::Type &the_type, typet &new_type)
     llvm::APInt val = arr.getSize();
     if(val.getBitWidth() > 64)
     {
-      msg.error(
+      log_error(
         "ESBMC currently does not support integers bigger "
         "than 64 bits");
       return true;
@@ -758,8 +883,7 @@ bool clang_c_convertert::get_type(const clang::Type &the_type, typet &new_type)
     if(get_type(arr.getElementType(), sub_type))
       return true;
 
-    new_type = array_typet(sub_type, gen_zero(index_type()));
-    new_type.set("incomplete", "true");
+    new_type = array_typet(sub_type, gen_one(index_type()));
     break;
   }
 
@@ -921,9 +1045,18 @@ bool clang_c_convertert::get_type(const clang::Type &the_type, typet &new_type)
     const clang::LValueReferenceType &lvrt =
       static_cast<const clang::LValueReferenceType &>(the_type);
 
-    if(get_type(lvrt.getPointeeTypeAsWritten(), new_type))
+    typet sub_type;
+    if(get_type(lvrt.getPointeeTypeAsWritten(), sub_type))
       return true;
 
+    if(sub_type.is_struct() || sub_type.is_union())
+    {
+      struct_union_typet t = to_struct_union_type(sub_type);
+      sub_type = symbol_typet("tag-" + t.tag().as_string());
+    }
+
+    new_type = gen_pointer_type(sub_type);
+    new_type.set("#reference", true);
     break;
   }
 
@@ -982,11 +1115,16 @@ bool clang_c_convertert::get_type(const clang::Type &the_type, typet &new_type)
     break;
   }
 
-  case clang::Type::ExtInt:
+#if CLANG_VERSION_MAJOR < 14
+#define BITINT_TAG clang::Type::ExtInt
+#define BITINT_TYPE clang::ExtIntType
+#else
+#define BITINT_TAG clang::Type::BitInt
+#define BITINT_TYPE clang::BitIntType
+#endif
+  case BITINT_TAG:
   {
-    const clang::ExtIntType &eit =
-      static_cast<const clang::ExtIntType &>(the_type);
-
+    const BITINT_TYPE &eit = static_cast<const BITINT_TYPE &>(the_type);
     const unsigned n = eit.getNumBits();
     if(eit.isSigned())
       new_type = signedbv_typet(n);
@@ -999,9 +1137,12 @@ bool clang_c_convertert::get_type(const clang::Type &the_type, typet &new_type)
     new_type.set("#extint", true);
     break;
   }
+#undef BITINT_TAG
+#undef BITINT_TYPE
+
   case clang::Type::ExtVector:
   {
-    // NOTE: some bitshift operations with classic vectors are parsed as this
+    // NOTE: some bitshift operations with 'clang::Type::ExtVector' vectors are parsed as this
     //   e.g vsi << 2 becomes ExtVector
     //       vsi << vsi2 becomes Vector
     const clang::ExtVectorType &vec =
@@ -1044,7 +1185,7 @@ bool clang_c_convertert::get_type(const clang::Type &the_type, typet &new_type)
     ross << the_type.getTypeClassName() << "\n";
     the_type.dump(ross, *ASTContext);
     ross.flush();
-    msg.error(oss.str());
+    log_error("{}", oss.str());
     return true;
   }
 
@@ -1183,7 +1324,7 @@ bool clang_c_convertert::get_builtin_type(
          << "\n";
     bt.dump(ross, *ASTContext);
     ross.flush();
-    msg.error(oss.str());
+    log_error("{}", oss.str());
     return true;
   }
   }
@@ -1351,12 +1492,12 @@ bool clang_c_convertert::get_expr(const clang::Stmt &stmt, exprt &new_expr)
     bool res = offset.EvaluateAsInt(result, *ASTContext);
     if(!res)
     {
-      msg.error("Clang could not calculate offset");
+      log_error("Clang could not calculate offset");
       std::ostringstream oss;
       llvm::raw_os_ostream ross(oss);
       offset.dump(ross, *ASTContext);
       ross.flush();
-      msg.error(oss.str());
+      log_error("{}", oss.str());
       return true;
     }
 
@@ -1492,14 +1633,14 @@ bool clang_c_convertert::get_expr(const clang::Stmt &stmt, exprt &new_expr)
     get_default_symbol(
       cl, get_modulename_from_path(path), t, cl.name, cl.id, location);
 
-    cl.static_lifetime = compound.isFileScope();
+    cl.static_lifetime = !current_block || compound.isFileScope();
     cl.is_extern = false;
     cl.file_local = true;
     cl.value = initializer;
 
     new_expr = symbol_expr(cl);
 
-    if(current_block)
+    if(!cl.static_lifetime)
     {
       /* The underlying storage is automatic here, i.e., local. In order for
        * it to be recognized as being local in ESBMC, it requires a declaration,
@@ -1511,7 +1652,6 @@ bool clang_c_convertert::get_expr(const clang::Stmt &stmt, exprt &new_expr)
     }
     else
     {
-      assert(cl.static_lifetime);
       /* Symbols appearing in file scope do not need a declaration.
        * clang_c_main::static_lifetime_init() takes care of the initialization.
        */
@@ -1746,8 +1886,7 @@ bool clang_c_convertert::get_expr(const clang::Stmt &stmt, exprt &new_expr)
           elem_type = to_array_type(t).subtype();
         else
           elem_type = to_vector_type(t).subtype();
-        if(elem_type.get("incomplete") != "true")
-          gen_typecast(ns, init, elem_type);
+        gen_typecast(ns, init, elem_type);
         inits.operands().at(i) = init;
       }
 
 
@@ -2880,7 +3019,7 @@ void clang_c_convertert::get_default_symbol(
   irep_idt id,
   locationt location)
 {
-  symbol.mode = "C";
+  symbol.mode = mode;
   symbol.module = module_name;
   symbol.location = std::move(location);
   symbol.type = std::move(type);
@@ -2888,7 +3027,7 @@ void clang_c_convertert::get_default_symbol(
   symbol.id = id;
 }
 
-static std::string get_decl_name(const clang::NamedDecl &nd)
+std::string clang_c_convertert::get_decl_name(const clang::NamedDecl &nd)
 {
   if(const clang::IdentifierInfo *identifier = nd.getIdentifier())
     return identifier->getName().str();
@@ -2915,7 +3054,7 @@ void clang_c_convertert::get_decl_name(
   std::string &name,
   std::string &id)
 {
-  id = name = ::get_decl_name(nd);
+  id = name = get_decl_name(nd);
 
   switch(nd.getKind())
   {

 
@@ -3008,7 +3147,7 @@ void clang_c_convertert::get_start_location_from_stmt(
   std::string function_name;
 
   if(current_functionDecl)
-    function_name = ::get_decl_name(*current_functionDecl);
+    function_name = get_decl_name(*current_functionDecl);
 
   clang::PresumedLoc PLoc;
   get_presumed_location(stmt.getSourceRange().getBegin(), PLoc);
@@ -3025,7 +3164,7 @@ void clang_c_convertert::get_final_location_from_stmt(
   std::string function_name;
 
   if(current_functionDecl)
-    function_name = ::get_decl_name(*current_functionDecl);
+    function_name = get_decl_name(*current_functionDecl);
 
   clang::PresumedLoc PLoc;
   get_presumed_location(stmt.getSourceRange().getEnd(), PLoc);
@@ -3046,7 +3185,7 @@ void clang_c_convertert::get_location_from_decl(
     const clang::FunctionDecl &funcd =
       static_cast<const clang::FunctionDecl &>(*decl.getDeclContext());
 
-    function_name = ::get_decl_name(funcd);
+    function_name = get_decl_name(funcd);
   }
 
   clang::PresumedLoc PLoc;
@@ -3104,37 +3243,7 @@ std::string clang_c_convertert::get_filename_from_path(std::string path)
 
 symbolt *clang_c_convertert::move_symbol_to_context(symbolt &symbol)
 {
-  symbolt *s = context.find_symbol(symbol.id);
-  if(s == nullptr)
-  {
-    if(context.move(symbol, s))
-    {
-      msg.error(fmt::format(
-        "Couldn't add symbol {} to symbol table\n{}", symbol.name, symbol));
-      abort();
-    }
-  }
-  else
-  {
-    // types that are code means functions
-    if(s->type.is_code())
-    {
-      if(symbol.value.is_not_nil() && !s->value.is_not_nil())
-        s->swap(symbol);
-    }
-    else if(s->is_type)
-    {
-      if(symbol.type.is_not_nil() && !s->type.is_not_nil())
-        s->swap(symbol);
-    }
-    else if(s->is_extern && !symbol.is_extern)
-    {
-      s->swap(symbol);
-      s->type.swap(symbol.type);
-    }
-  }
-
-  return s;
+  return context.move_symbol_to_context(symbol);
 }
 
 void clang_c_convertert::convert_expression_to_code(exprt &expr)
@@ -3182,56 +3291,3 @@ clang_c_convertert::get_top_FunctionDecl_from_Stmt(const clang::Stmt &stmt)
 
   return nullptr;
 }
-
-bool clang_c_convertert::foo(
-  const clang::VarDecl &vd,
-  symbolt symbol,
-  exprt &new_expr)
-{
-  // We have to add the symbol before converting the initial assignment
-  // because we might have something like 'int x = x + 1;' which is
-  // completely wrong but allowed by the language
-  symbolt &added_symbol = *move_symbol_to_context(symbol);
-
-  //if(id == "c:@R_Range1") added_symbol.dump();
-
-  code_declt decl(symbol_expr(added_symbol));
-
-  if(vd.hasInit())
-  {
-    exprt val;
-    if(get_expr(*vd.getInit(), val))
-      return true;
-
-    // Get type
-    typet t;
-    if(get_type(vd.getType(), t))
-      return true;
-    gen_typecast(ns, val, t);
-
-    added_symbol.value = val;
-    decl.operands().push_back(val);
-  }
-
-  locationt location_begin;
-  get_location_from_decl(vd, location_begin);
-  decl.location() = location_begin;
-
-  new_expr = decl;
-  return false;
-}
-
-bool clang_c_convertert::skip_extern_symbol(const symbolt symbol)
-{
-  if(symbol.is_extern && symbol.type.is_array())
-  {
-    auto size = to_array_type(symbol.type).size();
-    if(size.is_constant())
-    {
-      BigInt number(to_constant_expr(size).value().c_str(), 2);
-      if(number.to_uint64() == 1)
-        return true;
-    }
-  }
-  return false;
-}
diff --git a/src/clang-c-frontend/clang_c_convert.h b/src/clang-c-frontend/clang_c_convert.h
index 1ba1ee8b6..cbe053d46 100644
--- a/src/clang-c-frontend/clang_c_convert.h
+++ b/src/clang-c-frontend/clang_c_convert.h
@@ -8,7 +8,6 @@
 #include <util/namespace.h>
 #include <util/std_code.h>
 #include <util/std_types.h>
-#include <unordered_map>
 #include <util/symbol_generator.h>
 
 // Forward dec, to avoid bringing in clang headers
@@ -47,7 +46,7 @@ public:
   clang_c_convertert(
     contextt &_context,
     std::vector<std::unique_ptr<clang::ASTUnit>> &_ASTs,
-    const messaget &msg);
+    irep_idt _mode);
   virtual ~clang_c_convertert() = default;
 
   bool convert();
@@ -62,33 +61,24 @@ public:
  * @param type Union type
  * @param msg  Message object
  */
-  static void
-  gen_typecast_to_union(exprt &dest, const typet &type, const messaget &msg);
-
-  void set_symbols_to_add(std::vector<symbolt> &v)
-  {
-    symbols_to_add = v;
-  }
-  std::vector<symbolt> get_symbols_to_add()
-  {
-    return symbols_to_add;
-  }
+  static void gen_typecast_to_union(exprt &dest, const typet &type);
 
   static std::string get_decl_name(const clang::NamedDecl &nd);
 
-
 protected:
   clang::ASTContext *ASTContext;
   contextt &context;
   namespacet ns;
   std::vector<std::unique_ptr<clang::ASTUnit>> &ASTs;
-  const messaget &msg;
+  irep_idt mode;
   symbol_generator anon_symbol;
 
   unsigned int current_scope_var_num;
-  /* During get_expr(), which also transforms blocks/scopes, this represents
-   * the latest opened blocks from the top-level. A nullptr 'current_block'
-   * thus means file scope. */
+  /**
+   *  During get_expr(), which also transforms blocks/scopes, this represents
+   *  the latest opened blocks from the top-level. A nullptr 'current_block'
+   *  thus means file scope.
+   */
   code_blockt *current_block;
 
   clang::SourceManager *sm;
@@ -98,13 +88,32 @@ protected:
   bool convert_builtin_types();
   bool convert_top_level_decl();
 
+  /**
+   *  Since this class is inherited by clang-cpp-frontend,
+   *  some get_* functions are made `virtual' to deal with clang CXX declarations
+   */
   virtual bool get_decl(const clang::Decl &decl, exprt &new_expr);
 
   virtual bool get_var(const clang::VarDecl &vd, exprt &new_expr);
 
   virtual bool get_function(const clang::FunctionDecl &fd, exprt &new_expr);
 
-  bool get_function_params(const clang::ParmVarDecl &pd, exprt &param);
+  virtual bool
+  get_function_body(const clang::FunctionDecl &fd, exprt &new_expr);
+
+  /**
+   *  Parse function parameters
+   *  This function simply contains a loop to populate the code argument list
+   *  and calls get_function_body to parse each individual parameter.
+   */
+  virtual bool get_function_params(
+    const clang::FunctionDecl &fd,
+    code_typet::argumentst &params);
+
+  /**
+   *  Parse each individual parameter of the function
+   */
+  bool get_function_param(const clang::ParmVarDecl &pd, exprt &param);
 
   virtual bool get_struct_union_class(const clang::RecordDecl &recordd);
 
@@ -194,11 +203,6 @@ protected:
   const clang::Decl *get_DeclContext_from_Stmt(const clang::Stmt &stmt);
 
   const clang::Decl *get_top_FunctionDecl_from_Stmt(const clang::Stmt &stmt);
-
-  void gen_typecast_to_union(exprt &dest, const typet &type);
-  bool foo(const clang::VarDecl &vd, symbolt symbol, exprt &new_expr);
-  bool skip_extern_symbol(const symbolt symbol);
-  std::vector<symbolt> symbols_to_add;
 };
 
 #endif /* CLANG_C_FRONTEND_CLANG_C_CONVERT_H_ */
diff --git a/src/clang-c-frontend/clang_c_language.cpp b/src/clang-c-frontend/clang_c_language.cpp
index c839a9c5a..74ea3c37c 100644
--- a/src/clang-c-frontend/clang_c_language.cpp
+++ b/src/clang-c-frontend/clang_c_language.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: C++ Language Module
-
-Author: Daniel Kroening, kroening@cs.cmu.edu
-
-\*******************************************************************/
-
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wstrict-aliasing"
 #pragma GCC diagnostic ignored "-Wunused-parameter"
@@ -23,17 +15,17 @@ Author: Daniel Kroening, kroening@cs.cmu.edu
 #include <clang-c-frontend/expr2c.h>
 #include <sstream>
 #include <util/c_link.h>
-#include <util/message/format.h>
+
 #include <util/filesystem.h>
 
 #include <ac_config.h>
 
-languaget *new_clang_c_language(const messaget &msg)
+languaget *new_clang_c_language()
 {
-  return new clang_c_languaget(msg);
+  return new clang_c_languaget();
 }
 
-clang_c_languaget::clang_c_languaget(const messaget &msg) : languaget(msg)
+clang_c_languaget::clang_c_languaget()
 {
   // Build the compile arguments
   build_compiler_args(clang_headers_path());
@@ -43,6 +35,9 @@ void clang_c_languaget::build_compiler_args(const std::string &tmp_dir)
 {
   compiler_args.emplace_back("clang-tool");
 
+  // TODO: Implement a similar way to add opertional models for C++. For the time being,
+  // we are still following the way old ESBMC++ includes these operational models using -I.
+  // See discussions in PR834.
   const std::string *libc_headers = internal_libc_header_dir();
   if(libc_headers)
   {
@@ -63,8 +58,7 @@ void clang_c_languaget::build_compiler_args(const std::string &tmp_dir)
     break;
 
   default:
-    msg.error(
-      fmt::format("Unknown word size: {}\n", config.ansi_c.word_size).c_str());
+    log_error("Unknown word size: {}\n", config.ansi_c.word_size);
     abort();
   }
 
@@ -100,7 +94,7 @@ void clang_c_languaget::build_compiler_args(const std::string &tmp_dir)
   for(auto const &def : config.ansi_c.defines)
     compiler_args.push_back("-D" + def);
 
-  if(msg.get_verbosity() >= VerbosityLevel::Debug)
+  if(messaget::state.verbosity >= VerbosityLevel::Debug)
     compiler_args.emplace_back("-v");
 
   compiler_args.emplace_back("-target");
@@ -205,12 +199,12 @@ void clang_c_languaget::force_file_type()
   compiler_args.push_back("c");
 }
 
-bool clang_c_languaget::parse(const std::string &path, const messaget &msg)
+bool clang_c_languaget::parse(const std::string &path)
 {
   // preprocessing
 
   std::ostringstream o_preprocessed;
-  if(preprocess(path, o_preprocessed, msg))
+  if(preprocess(path, o_preprocessed))
     return true;
 
   // Force the file type, .c for the C frontend and .cpp for the C++ one
@@ -236,80 +230,44 @@ bool clang_c_languaget::parse(const std::string &path, const messaget &msg)
   return false;
 }
 
-bool clang_c_languaget::typecheck(
-  contextt &context,
-  const std::string &module,
-  const messaget &msg)
+bool clang_c_languaget::typecheck(contextt &context, const std::string &module)
 {
-  contextt new_context(msg);
+  contextt new_context;
 
-  clang_c_convertert converter(new_context, ASTs, msg);
-  converter.set_symbols_to_add(extern_symbols);
+  clang_c_convertert converter(new_context, ASTs, "C");
   if(converter.convert())
     return true;
-  extern_symbols = converter.get_symbols_to_add();
-  clang_c_adjust adjuster(new_context, msg);
+
+  clang_c_adjust adjuster(new_context);
   if(adjuster.adjust())
     return true;
 
-  if(c_link(context, new_context, msg, module))
+  if(c_link(context, new_context, module))
     return true;
 
   return false;
 }
 
-#include <util/expr_util.h>
-bool clang_c_languaget::add_later(contextt &context, symbolt symbol)
-{
-  exprt dummy;
-  symbolt *s = context.find_symbol(symbol.id);
-  if(s == nullptr)
-  {
-    if(context.move(symbol, s))
-    {
-      msg.error(fmt::format(
-        "Couldn't add symbol {} to symbol table\n{}", symbol.name, symbol));
-      abort();
-    }
-  }
-  else
-  {
-    return true;
-  }
-  /*
-  symbolt &added_symbol = *s;
-  code_declt decl(symbol_expr(added_symbol));
-  decl.location() = symbol.location;
-  dummy = decl;
-  */
-  return false;
-}
-
 void clang_c_languaget::show_parse(std::ostream &)
 {
   for(auto const &translation_unit : ASTs)
     (*translation_unit).getASTContext().getTranslationUnitDecl()->dump();
 }
 
-bool clang_c_languaget::preprocess(
-  const std::string &,
-  std::ostream &,
-  const messaget &)
+bool clang_c_languaget::preprocess(const std::string &, std::ostream &)
 {
 // TODO: Check the preprocess situation.
 #if 0
-  return c_preprocess(path, outstream, false, message_handler);
+  return c_preprocess(path, outstream, false);
 #endif
   return false;
 }
 
-bool clang_c_languaget::final(contextt &context, const messaget &msg)
+bool clang_c_languaget::final(contextt &context)
 {
-  for(auto x : extern_symbols)
-    add_later(context, x);
-
-  add_cprover_library(context, msg, this);
-  return clang_main(context, msg);
+  add_cprover_library(context, this);
+  // adds __ESBMC__main symbol
+  return clang_main(context);
 }
 
 std::string clang_c_languaget::internal_additions()
@@ -323,7 +281,8 @@ _Bool __ESBMC_same_object(const void *, const void *);
 void __ESBMC_yield();
 void __ESBMC_atomic_begin();
 void __ESBMC_atomic_end();
-void __ESBMC_init_var(void*);
+/** Explicitly initialize a new object */
+void __ESBMC_init_object(void*);
 
 int __ESBMC_abs(int);
 long int __ESBMC_labs(long int);
@@ -337,9 +296,6 @@ signed __ESBMC_POINTER_OFFSET(const void *);
 __attribute__((annotate("__ESBMC_inf_size")))
 _Bool __ESBMC_alloc[1];
 
-__attribute__((annotate("__ESBMC_inf_size")))
-_Bool __ESBMC_deallocated[1];
-
 __attribute__((annotate("__ESBMC_inf_size")))
 _Bool __ESBMC_is_dynamic[1];
 
@@ -349,9 +305,6 @@ unsigned __ESBMC_alloc_size[1];
 // Get object size
 unsigned __ESBMC_get_object_size(const void *);
 
-// Modular Verification Framework
-void __ESBMC_enable_assert_mode(char);
-void __ESBMC_disable_assert_mode(char);
 
 _Bool __ESBMC_is_little_endian();
 
diff --git a/src/clang-c-frontend/clang_c_language.h b/src/clang-c-frontend/clang_c_language.h
index d2bf51bf8..8cbd0ccaf 100644
--- a/src/clang-c-frontend/clang_c_language.h
+++ b/src/clang-c-frontend/clang_c_language.h
@@ -1,16 +1,7 @@
-/*******************************************************************\
-
-Module: Clang C Language Module
-
-Author:
-
-\*******************************************************************/
-
 #ifndef CLANG_C_FRONTEND_CLANG_C_LANGUAGE_H_
 #define CLANG_C_FRONTEND_CLANG_C_LANGUAGE_H_
 
 #include <util/language.h>
-#include <unordered_map>
 
 #define __STDC_LIMIT_MACROS
 #define __STDC_FORMAT_MACROS
@@ -24,19 +15,13 @@ class ASTUnit;
 class clang_c_languaget : public languaget
 {
 public:
-  virtual bool preprocess(
-    const std::string &path,
-    std::ostream &outstream,
-    const messaget &msg);
+  virtual bool preprocess(const std::string &path, std::ostream &outstream);
 
-  bool parse(const std::string &path, const messaget &msg) override;
+  bool parse(const std::string &path) override;
 
-  bool final(contextt &context, const messaget &msg) override;
+  bool final(contextt &context) override;
 
-  bool typecheck(
-    contextt &context,
-    const std::string &module,
-    const messaget &msg) override;
+  bool typecheck(contextt &context, const std::string &module) override;
 
   std::string id() const override
   {
@@ -53,14 +38,14 @@ public:
   bool from_type(const typet &type, std::string &code, const namespacet &ns)
     override;
 
-  languaget *new_language(const messaget &msg) const override
+  languaget *new_language() const override
   {
-    return new clang_c_languaget(msg);
+    return new clang_c_languaget();
   }
 
   // constructor, destructor
   ~clang_c_languaget() override = default;
-  explicit clang_c_languaget(const messaget &msg);
+  explicit clang_c_languaget();
 
 protected:
   virtual std::string internal_additions();
@@ -71,11 +56,8 @@ protected:
 
   std::vector<std::string> compiler_args;
   std::vector<std::unique_ptr<clang::ASTUnit>> ASTs;
-
-  std::vector<symbolt> extern_symbols;
-  bool add_later(contextt &ctx, symbolt symbol);
 };
 
-languaget *new_clang_c_language(const messaget &msg);
+languaget *new_clang_c_language();
 
 #endif
diff --git a/src/clang-c-frontend/clang_c_main.cpp b/src/clang-c-frontend/clang_c_main.cpp
index 29d121616..2ddeee39b 100644
--- a/src/clang-c-frontend/clang_c_main.cpp
+++ b/src/clang-c-frontend/clang_c_main.cpp
@@ -3,7 +3,7 @@
 #include <util/c_types.h>
 #include <util/config.h>
 #include <util/expr_util.h>
-#include <util/message/message.h>
+#include <util/message.h>
 #include <util/namespace.h>
 #include <util/std_code.h>
 #include <util/std_expr.h>
@@ -47,7 +47,7 @@ static inline void static_lifetime_init(const contextt &context, codet &dest)
   });
 }
 
-bool clang_main(contextt &context, const messaget &message_handler)
+bool clang_main(contextt &context)
 {
   irep_idt main_symbol;
 
@@ -70,19 +70,17 @@ bool clang_main(contextt &context, const messaget &message_handler)
 
   if(matches.empty())
   {
-    messaget message(message_handler);
-    message.error("main symbol `" + main + "' not found");
+    log_error("main symbol `" + main + "' not found");
     return true; // give up
   }
 
   if(matches.size() >= 2)
   {
-    messaget message(message_handler);
     if(matches.size() == 2)
-      message.error("warning: main symbol `" + main + "' is ambiguous");
+      log_error("warning: main symbol `" + main + "' is ambiguous");
     else
     {
-      message.error("main symbol `" + main + "' is ambiguous");
+      log_error("main symbol `" + main + "' is ambiguous");
       return true;
     }
   }
@@ -126,8 +124,8 @@ bool clang_main(contextt &context, const messaget &message_handler)
     {
       namespacet ns(context);
 
-      const symbolt &argc_symbol = ns.lookup("argc'");
-      const symbolt &argv_symbol = ns.lookup("argv'");
+      const symbolt &argc_symbol = *ns.lookup("argc'");
+      const symbolt &argv_symbol = *ns.lookup("argv'");
 
       // assume argc is at least one
       exprt one = from_integer(1, argc_symbol.type);
@@ -199,8 +197,8 @@ bool clang_main(contextt &context, const messaget &message_handler)
 
       if(arguments.size() == 3)
       {
-        const symbolt &envp_symbol = ns.lookup("envp'");
-        const symbolt &envp_size_symbol = ns.lookup("envp_size'");
+        const symbolt &envp_symbol = *ns.lookup("envp'");
+        const symbolt &envp_size_symbol = *ns.lookup("envp_size'");
 
         exprt envp_ge(">=", bool_type());
         envp_ge.copy_to_operands(symbol_expr(envp_size_symbol), one);
@@ -276,7 +274,7 @@ bool clang_main(contextt &context, const messaget &message_handler)
 
   if(context.move(new_symbol))
   {
-    message_handler.error("main already defined by another language module");
+    log_error("main already defined by another language module");
     return true;
   }
 
diff --git a/src/clang-c-frontend/clang_c_main.h b/src/clang-c-frontend/clang_c_main.h
index 9a32eb2c6..592146108 100644
--- a/src/clang-c-frontend/clang_c_main.h
+++ b/src/clang-c-frontend/clang_c_main.h
@@ -2,9 +2,9 @@
 #define CLANG_C_FRONTEND_CLANG_MAIN_H_
 
 #include <util/context.h>
-#include <util/message/message.h>
+#include <util/message.h>
 #include <util/std_code.h>
 
-bool clang_main(contextt &context, const messaget &msg);
+bool clang_main(contextt &context);
 
 #endif /* CLANG_C_FRONTEND_CLANG_MAIN_H_ */
diff --git a/src/clang-c-frontend/clang_headers.cpp b/src/clang-c-frontend/clang_headers.cpp
index 373641419..2ebc62f53 100644
--- a/src/clang-c-frontend/clang_headers.cpp
+++ b/src/clang-c-frontend/clang_headers.cpp
@@ -1,6 +1,7 @@
 #include <clang-c-frontend/clang_c_language.h>
 #include <fstream>
 #include <ac_config.h>
+#include <util/filesystem.h>
 
 #ifdef ESBMC_CLANG_HEADERS_BUNDLED
 extern "C"
diff --git a/src/clang-c-frontend/expr2c.cpp b/src/clang-c-frontend/expr2c.cpp
index d9c356ded..76236aef2 100644
--- a/src/clang-c-frontend/expr2c.cpp
+++ b/src/clang-c-frontend/expr2c.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <clang-c-frontend/expr2c.h>
 #include <util/arith_tools.h>
 #include <util/c_misc.h>
@@ -21,9 +13,9 @@ Author: Daniel Kroening, kroening@kroening.com
 std::string expr2ct::id_shorthand(const exprt &expr) const
 {
   const irep_idt &identifier = expr.identifier();
-  const symbolt *symbol;
+  const symbolt *symbol = ns.lookup(identifier);
 
-  if(!ns.lookup(identifier, symbol))
+  if(symbol)
     return id2string(symbol->name);
 
   std::string sh = id2string(identifier);
@@ -1090,38 +1082,29 @@ std::string expr2ct::convert_constant(const exprt &src, unsigned &precedence)
   return dest;
 }
 
-std::string expr2ct::convert_struct(const exprt &src, unsigned &precedence)
+std::string expr2ct::convert_struct_union_body(
+  const exprt::operandst &operands,
+  const struct_union_typet::componentst &components)
 {
-  const typet full_type = ns.follow(src.type());
-
-  if(full_type.id() != "struct")
-    return convert_norep(src, precedence);
-
-  const struct_typet &struct_type = to_struct_type(full_type);
-
-  const struct_typet::componentst &components = struct_type.components();
-
-  if(components.size() != src.operands().size())
-    return convert_norep(src, precedence);
+  size_t n = components.size();
+  assert(n == operands.size());
 
   std::string dest = "{ ";
 
-  exprt::operandst::const_iterator o_it = src.operands().begin();
-
   bool first = true;
   bool newline = false;
   unsigned last_size = 0;
 
-  for(const auto &component : struct_type.components())
+  for(size_t i = 0; i < n; i++)
   {
-    if(o_it->type().is_code())
+    const auto &operand = operands[i];
+    const auto &component = components[i];
+
+    if(component.type().is_code())
       continue;
 
     if(component.get_is_padding())
-    {
-      ++o_it;
       continue;
-    }
 
     if(first)
       first = false;
@@ -1135,7 +1118,7 @@ std::string expr2ct::convert_struct(const exprt &src, unsigned &precedence)
         dest += " ";
     }
 
-    std::string tmp = convert(*o_it);
+    std::string tmp = convert(operand);
 
     if(last_size + 40 < dest.size())
     {
@@ -1149,8 +1132,6 @@ std::string expr2ct::convert_struct(const exprt &src, unsigned &precedence)
     dest += component.pretty_name().as_string();
     dest += "=";
     dest += tmp;
-
-    o_it++;
   }
 
   dest += " }";
@@ -1158,20 +1139,57 @@ std::string expr2ct::convert_struct(const exprt &src, unsigned &precedence)
   return dest;
 }
 
+std::string expr2ct::convert_struct(const exprt &src, unsigned &precedence)
+{
+  const typet full_type = ns.follow(src.type());
+
+  if(full_type.id() != "struct")
+    return convert_norep(src, precedence);
+
+  const struct_typet &struct_type = to_struct_type(full_type);
+  const struct_union_typet::componentst &components = struct_type.components();
+
+  if(components.size() != src.operands().size())
+    return convert_norep(src, precedence);
+
+  return convert_struct_union_body(src.operands(), components);
+}
+
 std::string expr2ct::convert_union(const exprt &src, unsigned &precedence)
 {
-  std::string dest = "{ ";
-  if(src.operands().size() != 1)
+  const typet full_type = ns.follow(src.type());
+
+  if(full_type.id() != "union")
     return convert_norep(src, precedence);
 
-  std::string tmp = convert(src.op0());
-  dest += ".";
-  dest += src.component_name().as_string();
-  dest += "=";
-  dest += tmp;
+  const exprt::operandst &operands = src.operands();
+  const irep_idt &init [[maybe_unused]] = src.component_name();
 
-  dest += " }";
-  return dest;
+  if(operands.size() == 1)
+  {
+    /* Initializer known */
+    assert(!init.empty());
+    std::string dest = "{ ";
+
+    std::string tmp = convert(src.op0());
+
+    dest += ".";
+    dest += init.as_string();
+    dest += "=";
+    dest += tmp;
+
+    dest += " }";
+
+    return dest;
+  }
+  else
+  {
+    /* Initializer unknown, expect operands assigned to each member and convert
+     * all of them */
+    assert(init.empty());
+    return convert_struct_union_body(
+      operands, to_union_type(full_type).components());
+  }
 }
 
 std::string expr2ct::convert_array(const exprt &src, unsigned &)
@@ -1522,8 +1540,8 @@ std::string expr2ct::convert_code_decl(const codet &src, unsigned indent)
 
   std::string dest = indent_str(indent);
 
-  const symbolt *symbol = NULL;
-  if(!ns.lookup(to_symbol_expr(src.op0()).get_identifier(), symbol))
+  const symbolt *symbol = ns.lookup(to_symbol_expr(src.op0()).get_identifier());
+  if(symbol)
   {
     if(
       symbol->file_local &&
@@ -1741,12 +1759,7 @@ std::string expr2ct::convert_code_assign(const codet &src, unsigned indent)
   unsigned int precedent = 15;
   std::string tmp = convert(src.op0(), precedent);
   tmp += "=";
-  if(
-    src.op1().id() == "constant" && src.op1().type().id() == "array" &&
-    src.op1().pretty().find("byte_extract") != std::string::npos)
-    tmp += "FLATTENED_UNION_LITERAL()";
-  else
-    tmp += convert(src.op1(), precedent);
+  tmp += convert(src.op1(), precedent);
 
   std::string dest = indent_str(indent) + tmp + ";";
 
@@ -2011,6 +2024,73 @@ std::string expr2ct::convert_extract(const exprt &src)
          std::to_string(lower) + ")";
 }
 
+/* Checks whether the expression `e` is one performing pointer-arithmetic, that
+ * is, addition/subtraction of an integer-typed expression to/from a
+ * pointer-typed expression.
+ *
+ * If so, `true` is returned and `ptr` holds the address of the inner-most
+ * pointer-typed expression while `idx` gets assigned a (newly constructed, in
+ * case of multiple levels of pointer-typed expressions) expression that
+ * corresponds to the index into `*ptr`.
+ *
+ * Note, just a pointer-typed symbol (or constant) is not recognized as pointer-
+ * arithmetic.
+ */
+static bool is_pointer_arithmetic(const exprt &e, const exprt *&ptr, exprt &idx)
+{
+  if(e.type().id() != "pointer")
+    return false;
+
+  ptr = &e;
+
+  /* a pointer-typed arithmetic (+ or -) expression cannot be unary in the C
+   * language */
+  assert(!(e.id() == "unary+" || (e.id() == "+" && e.operands().size() == 1)));
+  assert(!(e.id() == "unary-" || (e.id() == "-" && e.operands().size() == 1)));
+
+  if(e.id() == "+" || e.id() == "-")
+  {
+    assert(e.operands().size() == 2);
+    const exprt *p = nullptr, *i = nullptr;
+    auto categorize = [&p, &i](const exprt &e) {
+      const irep_idt &tid = e.type().id();
+      if(tid == "pointer")
+        p = &e;
+      else if(tid == "signedbv" || tid == "unsignedbv")
+        i = &e;
+    };
+    categorize(e.op0());
+    categorize(e.op1());
+    if(p && i)
+    {
+      if(e.id() == "-")
+        assert(i == &e.op1());
+      exprt j;
+      if(is_pointer_arithmetic(*p, p, j))
+      {
+        auto is_unsigned = [](const exprt &e) {
+          return e.type().id() == "unsignedbv";
+        };
+        const char *type =
+          is_unsigned(j) || is_unsigned(*i) ? "unsignedbv" : "signedbv";
+        idx = exprt(e.id(), typet(type));
+        idx.copy_to_operands(j, *i);
+      }
+      else if(e.id() == "-")
+      {
+        idx = exprt("unary-", i->type());
+        idx.copy_to_operands(*i);
+      }
+      else
+        idx = *i;
+      ptr = p;
+      return true;
+    }
+  }
+
+  return false;
+}
+
 std::string expr2ct::convert(const exprt &src, unsigned &precedence)
 {
   precedence = 16;
@@ -2212,6 +2292,21 @@ std::string expr2ct::convert(const exprt &src, unsigned &precedence)
     if(src.operands().size() != 1)
       return convert_norep(src, precedence);
 
+    /* Special case for `*(p+i)` and `*(p-i)`: these constructs could either
+     * already be in the source or it was created artificially by the frontend
+     * for `p[i]`, see clang_c_adjust::adjust_index() and also Github issue
+     * #725. As those expressions are semantically indistinguishable and also
+     * supported by verifiers, choose to print the succint form `p[i]` in all
+     * cases. */
+    exprt idx;
+    const exprt *ptr;
+    if(is_pointer_arithmetic(src.op0(), ptr, idx))
+    {
+      exprt subst("index", src.type());
+      subst.copy_to_operands(*ptr, idx);
+      return convert_index(subst, precedence = 16);
+    }
+
     return convert_unary(src, "*", precedence = 15);
   }
 
diff --git a/src/clang-c-frontend/expr2c.h b/src/clang-c-frontend/expr2c.h
index 8bbc69f87..951c51b0e 100644
--- a/src/clang-c-frontend/expr2c.h
+++ b/src/clang-c-frontend/expr2c.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_EXPR2C_H
 #define CPROVER_EXPR2C_H
 
@@ -179,6 +171,9 @@ protected:
 
   std::string convert_norep(const exprt &src, unsigned &precedence);
 
+  std::string convert_struct_union_body(
+    const exprt::operandst &operands,
+    const struct_union_typet::componentst &components);
   virtual std::string convert_struct(const exprt &src, unsigned &precedence);
   std::string convert_union(const exprt &src, unsigned &precedence);
   std::string convert_array(const exprt &src, unsigned &precedence);
diff --git a/src/clang-c-frontend/padding.cpp b/src/clang-c-frontend/padding.cpp
index b883bc232..c8f565d6e 100644
--- a/src/clang-c-frontend/padding.cpp
+++ b/src/clang-c-frontend/padding.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: C++ Language Type Checking
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 /// \file
 /// C++ Language Type Checking
 
@@ -165,13 +157,19 @@ void add_padding(struct_typet &type, const namespacet &ns)
         it != components.end();
         it++)
     {
-      if(
-        it->type().get_bool("#bitfield") &&
-        string2integer(it->type().width().as_string()) != 0)
+      bool is_bitfield = it->type().get_bool("#bitfield");
+      bool is_extint = it->type().get_bool("#extint");
+      irep_idt width = it->type().width();
+
+      /* Bitfields and _ExtInt need their width set. */
+      assert(!(is_bitfield || is_extint) || !width.empty());
+
+      size_t w = string2integer(width.as_string()).to_uint64();
+
+      if(is_bitfield && w != 0)
       {
         // count the bits
-        bit_field_bits +=
-          string2integer(it->type().width().as_string()).to_uint64();
+        bit_field_bits += w;
       }
       else if(bit_field_bits != 0)
       {
@@ -187,15 +185,13 @@ void add_padding(struct_typet &type, const namespacet &ns)
       }
 
       // Pad out extints that arent in bitfields
-      if(it->type().get_bool("#extint") && !it->type().get_bool("#bitfield"))
+      if(is_extint && !is_bitfield)
       {
         assert(bit_field_bits == 0);
 
         // Pad to nearest multiple of representation width
         const std::size_t repr_bytes = ext_int_representation_bytes(it->type());
         const std::size_t repr_bits = repr_bytes * config.ansi_c.char_width;
-        const std::size_t w =
-          string2integer(it->type().width().as_string()).to_uint64();
 
         const std::size_t unaligned_bits = w % repr_bits;
         const std::size_t pad = unaligned_bits ? repr_bits - unaligned_bits : 0;
diff --git a/src/clang-c-frontend/padding.h b/src/clang-c-frontend/padding.h
index f1f69a92a..45bba96a8 100644
--- a/src/clang-c-frontend/padding.h
+++ b/src/clang-c-frontend/padding.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: ANSI-C Language Type Checking
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 /// \file
 /// ANSI-C Language Type Checking
 
diff --git a/src/clang-c-frontend/typecast.cpp b/src/clang-c-frontend/typecast.cpp
index f64a6b9c4..127972c9d 100644
--- a/src/clang-c-frontend/typecast.cpp
+++ b/src/clang-c-frontend/typecast.cpp
@@ -5,6 +5,7 @@
 #include <stdexcept>
 #include <sstream>
 #include <clang-c-frontend/clang_c_convert.h>
+#include <util/message.h>
 
 void gen_typecast(const namespacet &ns, exprt &dest, const typet &type)
 {
@@ -30,14 +31,6 @@ void gen_typecast_arithmetic(const namespacet &ns, exprt &expr)
 }
 
 void clang_c_convertert::gen_typecast_to_union(exprt &e, const typet &t)
-{
-  clang_c_convertert::gen_typecast_to_union(e, t, msg);
-}
-
-void clang_c_convertert::gen_typecast_to_union(
-  exprt &e,
-  const typet &t,
-  const messaget &msg)
 {
   // If RHS is already of same union type, don't do anything
   if(e.type() == t.type())
@@ -59,8 +52,6 @@ void clang_c_convertert::gen_typecast_to_union(
 
   /* We should never reach here since clang frontend already checks for this
    * however... we should prevent any funny things to happen */
-  std::ostringstream oss;
-  oss << "Couldn't map type " << e.type().pretty_name() << " into the union";
-  msg.error(oss.str());
+  log_error("Couldn't map type {} into the union", e.type().pretty_name());
   abort();
-}
\ No newline at end of file
+}
diff --git a/src/clang-cpp-frontend/CMakeLists.txt b/src/clang-cpp-frontend/CMakeLists.txt
index 704985b8a..ffc0623ed 100644
--- a/src/clang-cpp-frontend/CMakeLists.txt
+++ b/src/clang-cpp-frontend/CMakeLists.txt
@@ -4,4 +4,5 @@ target_include_directories(clangcppfrontend
     PRIVATE ${CLANG_INCLUDE_DIRS}
     PRIVATE ${Boost_INCLUDE_DIRS}
 )
-target_link_libraries(clangcppfrontend  fmt::fmt)
\ No newline at end of file
+
+target_link_libraries(clangcppfrontend fmt::fmt)
diff --git a/src/clang-cpp-frontend/clang_cpp_adjust.h b/src/clang-cpp-frontend/clang_cpp_adjust.h
index dfb4e7680..e04bf3da3 100644
--- a/src/clang-cpp-frontend/clang_cpp_adjust.h
+++ b/src/clang-cpp-frontend/clang_cpp_adjust.h
@@ -6,13 +6,14 @@
 class clang_cpp_adjust : public clang_c_adjust
 {
 public:
-  clang_cpp_adjust(contextt &_context, const messaget &msg);
+  explicit clang_cpp_adjust(contextt &_context);
   virtual ~clang_cpp_adjust() = default;
 
   void adjust_ifthenelse(codet &code) override;
   void adjust_while(codet &code) override;
   void adjust_switch(codet &code) override;
   void adjust_for(codet &code) override;
+  void adjust_decl_block(codet &code) override;
 
   void adjust_side_effect(side_effect_exprt &expr) override;
 
diff --git a/src/clang-cpp-frontend/clang_cpp_adjust_code.cpp b/src/clang-cpp-frontend/clang_cpp_adjust_code.cpp
index 80974533c..125230934 100644
--- a/src/clang-cpp-frontend/clang_cpp_adjust_code.cpp
+++ b/src/clang-cpp-frontend/clang_cpp_adjust_code.cpp
@@ -1,5 +1,17 @@
 #include <clang-cpp-frontend/clang_cpp_adjust.h>
 
+void convert_expression_to_code(exprt &expr)
+{
+  if(expr.is_code())
+    return;
+
+  codet code("expression");
+  code.location() = expr.location();
+  code.move_to_operands(expr);
+
+  expr.swap(code);
+}
+
 void clang_cpp_adjust::adjust_ifthenelse(codet &code)
 {
   // In addition to the C syntax, C++ also allows a declaration
@@ -127,3 +139,62 @@ void clang_cpp_adjust::adjust_for(codet &code)
   else
     clang_c_adjust::adjust_for(code);
 }
+
+void clang_cpp_adjust::adjust_decl_block(codet &code)
+{
+  codet new_block("decl-block");
+
+  Forall_operands(it, code)
+  {
+    if(it->is_code() && (it->statement() == "skip"))
+      continue;
+
+    code_declt &code_decl = to_code_decl(to_code(*it));
+
+    if(code_decl.operands().size() == 2)
+    {
+      exprt &rhs = code_decl.rhs();
+      exprt &lhs = code_decl.lhs();
+      if(
+        rhs.id() == "sideeffect" && rhs.statement() == "function_call" &&
+        rhs.get_bool("constructor"))
+      {
+        // turn struct BLAH bleh = BLAH() into two instructions:
+        // struct BLAH bleh;
+        // BLAH(&bleh);
+
+        // First, create new decl without rhs
+        code_declt object(code_decl.lhs());
+        new_block.copy_to_operands(object);
+
+        // Get rhs
+        side_effect_expr_function_callt &init =
+          to_side_effect_expr_function_call(rhs);
+
+        // Get lhs
+        init.arguments().push_back(address_of_exprt(code_decl.lhs()));
+
+        // Now convert the side_effect into an expression
+        convert_expression_to_code(init);
+
+        // and copy to new_block
+        new_block.copy_to_operands(init);
+
+        continue;
+      }
+
+      if(lhs.type().get_bool("#reference"))
+      {
+        // adjust rhs to address_off:
+        // `int &r = g;` is turned into `int &r = &g;`
+        exprt result_expr = exprt("address_of", rhs.type());
+        result_expr.copy_to_operands(rhs.op0());
+        rhs.swap(result_expr);
+      }
+    }
+
+    new_block.copy_to_operands(code_decl);
+  }
+
+  code.swap(new_block);
+}
diff --git a/src/clang-cpp-frontend/clang_cpp_adjust_expr.cpp b/src/clang-cpp-frontend/clang_cpp_adjust_expr.cpp
index c41440c84..5b23057ee 100644
--- a/src/clang-cpp-frontend/clang_cpp_adjust_expr.cpp
+++ b/src/clang-cpp-frontend/clang_cpp_adjust_expr.cpp
@@ -1,8 +1,9 @@
 #include <clang-cpp-frontend/clang_cpp_adjust.h>
 #include <util/c_sizeof.h>
+#include <util/destructor.h>
 
-clang_cpp_adjust::clang_cpp_adjust(contextt &_context, const messaget &msg)
-  : clang_c_adjust(_context, msg)
+clang_cpp_adjust::clang_cpp_adjust(contextt &_context)
+  : clang_c_adjust(_context)
 {
 }
 
@@ -14,6 +15,30 @@ void clang_cpp_adjust::adjust_side_effect(side_effect_exprt &expr)
   {
     adjust_new(expr);
   }
+  else if(statement == "cpp_delete" || statement == "cpp_delete[]")
+  {
+    // adjust side effect node to explicitly call class destructor
+    // e.g. the adjustment here will add the following instruction in GOTO:
+    // FUNCTION_CALL:  ~t2(&(*p))
+    code_function_callt destructor = get_destructor(ns, expr.type());
+    if(destructor.is_not_nil())
+    {
+      exprt new_object("new_object", expr.type());
+      new_object.cmt_lvalue(true);
+
+      destructor.arguments().push_back(address_of_exprt(new_object));
+      expr.set("destructor", destructor);
+    }
+  }
+  else if(statement == "temporary_object")
+  {
+    exprt &initializer = static_cast<exprt &>(expr.add("initializer"));
+
+    side_effect_expr_function_callt &constructor_call =
+      to_side_effect_expr_function_call(initializer.op0());
+
+    adjust_function_call_arguments(constructor_call);
+  }
   else
     clang_c_adjust::adjust_side_effect(expr);
 }
diff --git a/src/clang-cpp-frontend/clang_cpp_convert.cpp b/src/clang-cpp-frontend/clang_cpp_convert.cpp
index 550c8d352..b7cf76053 100644
--- a/src/clang-cpp-frontend/clang_cpp_convert.cpp
+++ b/src/clang-cpp-frontend/clang_cpp_convert.cpp
@@ -12,19 +12,22 @@
 #include <clang/AST/Type.h>
 #include <clang/Index/USRGeneration.h>
 #include <clang/Frontend/ASTUnit.h>
+#include <clang/AST/ParentMapContext.h>
+#include <llvm/Support/raw_os_ostream.h>
 #pragma GCC diagnostic pop
 
 #include <clang-cpp-frontend/clang_cpp_convert.h>
 #include <util/expr_util.h>
+#include <util/message.h>
 #include <util/std_code.h>
 #include <util/std_expr.h>
-#include <util/message/format.h>
+#include <fmt/core.h>
 
 clang_cpp_convertert::clang_cpp_convertert(
   contextt &_context,
   std::vector<std::unique_ptr<clang::ASTUnit>> &_ASTs,
-  const messaget &msg)
-  : clang_c_convertert(_context, _ASTs, msg)
+  irep_idt _mode)
+  : clang_c_convertert(_context, _ASTs, _mode)
 {
 }
 
@@ -213,7 +216,7 @@ bool clang_cpp_convertert::get_function(
   const clang::FunctionDecl &fd,
   exprt &new_expr)
 {
-  // Only convert instantiated functions/methods
+  // Only convert instantiated functions/methods not depending on a template parameter
   if(fd.isDependentContext())
     return false;
 
@@ -222,7 +225,7 @@ bool clang_cpp_convertert::get_function(
 
 bool clang_cpp_convertert::get_struct_union_class(const clang::RecordDecl &rd)
 {
-  // Only convert instantiated functions/methods
+  // Only convert RecordDecl not depending on a template parameter
   if(rd.isDependentContext())
     return false;
 
@@ -280,7 +283,7 @@ bool clang_cpp_convertert::get_struct_union_class_methods(
 
   if(cxxrd->bases().begin() != cxxrd->bases().end())
   {
-    msg.error(fmt::format("inheritance is not supported in {}", __func__));
+    log_error("inheritance is not supported in {}", __func__);
     abort();
   }
 
@@ -298,7 +301,7 @@ bool clang_cpp_convertert::get_struct_union_class_methods(
         llvm::dyn_cast<clang::FunctionTemplateDecl>(decl))
     {
       assert(ftd->isThisDeclarationADefinition());
-      msg.error(fmt::format("template is not supported in {}", __func__));
+      log_error("template is not supported in {}", __func__);
       abort();
     }
     else
@@ -319,8 +322,7 @@ bool clang_cpp_convertert::get_struct_union_class_methods(
       // Add only if it isn't static
       if(!cxxmd->isStatic())
       {
-        msg.error(
-          fmt::format("static method is not supported in {}", __func__));
+        log_error("static method is not supported in {}", __func__);
         abort();
       }
     }
@@ -337,7 +339,7 @@ bool clang_cpp_convertert::get_expr(const clang::Stmt &stmt, exprt &new_expr)
   switch(stmt.getStmtClass())
   {
   case clang::Stmt::CXXReinterpretCastExprClass:
-    // TODO: ReinterpretCast should actually generate a bitcast
+  // TODO: ReinterpretCast should actually generate a bitcast
   case clang::Stmt::CXXFunctionalCastExprClass:
   case clang::Stmt::CXXStaticCastExprClass:
   case clang::Stmt::CXXConstCastExprClass:
@@ -551,6 +553,32 @@ bool clang_cpp_convertert::get_expr(const clang::Stmt &stmt, exprt &new_expr)
     break;
   }
 
+  case clang::Stmt::CXXDeleteExprClass:
+  {
+    const clang::CXXDeleteExpr &de =
+      static_cast<const clang::CXXDeleteExpr &>(stmt);
+
+    new_expr = de.isArrayFormAsWritten()
+                 ? side_effect_exprt("cpp_delete[]", empty_typet())
+                 : side_effect_exprt("cpp_delete", empty_typet());
+
+    exprt arg;
+    if(get_expr(*de.getArgument(), arg))
+      return true;
+
+    new_expr.move_to_operands(arg);
+
+    if(de.getDestroyedType()->getAsCXXRecordDecl())
+    {
+      typet destt;
+      if(get_type(de.getDestroyedType(), destt))
+        return true;
+      new_expr.type() = destt;
+    }
+
+    break;
+  }
+
   case clang::Stmt::CXXPseudoDestructorExprClass:
   {
     new_expr = exprt("pseudo_destructor");
@@ -584,16 +612,23 @@ bool clang_cpp_convertert::get_expr(const clang::Stmt &stmt, exprt &new_expr)
 
   case clang::Stmt::CXXConstructExprClass:
   {
-    // Reference to a declared construstor
-    const clang::CXXConstructExpr &ctr_call =
+    const clang::CXXConstructExpr &cxxc =
       static_cast<const clang::CXXConstructExpr &>(stmt);
 
-    if(ctr_call.getNumArgs() != 0)
+    // Avoid materializing a temporary for an elidable copy/move constructor.
+    if(cxxc.isElidable() && !cxxc.requiresZeroInitialization())
     {
-      return true;
+      const clang::MaterializeTemporaryExpr *mt =
+        llvm::dyn_cast<clang::MaterializeTemporaryExpr>(cxxc.getArg(0));
+
+      if(mt != nullptr)
+      {
+        log_error("elidable copy/move is not supported in {}", __func__);
+        abort();
+      }
     }
 
-    
+    if(get_constructor_call(cxxc, new_expr))
       return true;
 
     break;
@@ -610,15 +645,19 @@ bool clang_cpp_convertert::get_expr(const clang::Stmt &stmt, exprt &new_expr)
     this_mapt::iterator it = this_map.find(address);
     if(this_map.find(address) == this_map.end())
     {
-      /*
-      // no additional annotation for zero-arg constructor
-      typet t;
-      if(get_type(ctr_call.getType(), t))
-        return true;
-      new_expr = gen_zero(t);
-      */return true;
+      log_error(
+        "Pointer `this' for method {} was not added to scope",
+        clang_c_convertert::get_decl_name(*current_functionDecl));
+      abort();
     }
 
+    typet this_type;
+    if(get_type(this_expr.getType(), this_type))
+      return true;
+
+    assert(this_type == it->second.second);
+
+    new_expr = symbol_exprt(it->second.first, it->second.second);
     break;
   }
 
@@ -634,7 +673,6 @@ bool clang_cpp_convertert::get_constructor_call(
   const clang::CXXConstructExpr &constructor_call,
   exprt &new_expr)
 {
-  /*
   // Get constructor call
   exprt callee_decl;
   if(get_decl_ref(*constructor_call.getConstructor(), callee_decl))
@@ -652,10 +690,22 @@ bool clang_cpp_convertert::get_constructor_call(
   // Try to get the object that this constructor is constructing
   auto it = ASTContext->getParents(constructor_call).begin();
 
-  //exprt object;
   const clang::Decl *objectDecl = it->get<clang::Decl>();
+  if(!objectDecl)
+  {
+    address_of_exprt tmp_expr;
+    tmp_expr.type() = pointer_typet();
+    tmp_expr.type().subtype() = type;
 
-  //call.arguments().push_back(object);
+    exprt new_object("new_object");
+    new_object.set("#lvalue", true);
+    new_object.type() = type;
+
+    tmp_expr.operands().resize(0);
+    tmp_expr.move_to_operands(new_object);
+
+    call.arguments().push_back(tmp_expr);
+  }
 
   // Do args
   for(const clang::Expr *arg : constructor_call.arguments())
@@ -669,18 +719,10 @@ bool clang_cpp_convertert::get_constructor_call(
 
   call.set("constructor", 1);
 
-  // Now, if we built a new object, then we must build a temporary
-  // object around it
-  if(objectDecl != nullptr)
-  {
-    new_expr.swap(call);
-  }
-  else
-  {
-    msg.error(fmt::format("temporary is not supported in {}", __func__));
-    abort();
-  }
-*/
+  // We don't build a temporary obejct around it.
+  // We follow the old cpp frontend to just add the ctor function call.
+  new_expr.swap(call);
+
   return false;
 }
 
@@ -691,10 +733,12 @@ void clang_cpp_convertert::build_member_from_component(
   // Add this pointer as first argument
   std::size_t address = reinterpret_cast<std::size_t>(fd.getFirstDecl());
 
-  this_mapt::iterator it;
+  this_mapt::iterator it = this_map.find(address);
   if(this_map.find(address) == this_map.end())
   {
-    
+    log_error(
+      "Pointer `this' for method {} was not added to scope",
+      clang_c_convertert::get_decl_name(fd));
     abort();
   }
 
@@ -713,22 +757,72 @@ bool clang_cpp_convertert::get_function_body(
   // do nothing if function body doesn't exist
   if(!fd.hasBody())
     return false;
-/*
+
   // Parse body
   if(clang_c_convertert::get_function_body(fd, new_expr))
     return true;
-*/
+
+  code_blockt &body = to_code_block(to_code(new_expr));
+
   // if it's a constructor, check for initializers
   if(fd.getKind() == clang::Decl::CXXConstructor)
   {
     const clang::CXXConstructorDecl &cxxcd =
       static_cast<const clang::CXXConstructorDecl &>(fd);
 
+    // Parse the initializers, if any
     if(cxxcd.init_begin() != cxxcd.init_end())
     {
-      msg.error(
-        fmt::format("initializer list is not supported in {}", __func__));
-      abort();
+      // Resize the number of operands
+      exprt::operandst initializers;
+      initializers.reserve(cxxcd.getNumCtorInitializers());
+
+      for(auto init : cxxcd.inits())
+      {
+        exprt initializer;
+
+        if(!init->isBaseInitializer())
+        {
+          exprt lhs;
+          if(init->isMemberInitializer())
+          {
+            // parsing non-static member initializer
+            if(get_decl_ref(*init->getMember(), lhs))
+              return true;
+          }
+          else
+          {
+            log_error("Unsupported initializer in {}", __func__);
+            abort();
+          }
+
+          build_member_from_component(fd, lhs);
+
+          exprt rhs;
+          if(get_expr(*init->getInit(), rhs))
+            return true;
+
+          initializer = side_effect_exprt("assign", lhs.type());
+          initializer.copy_to_operands(lhs, rhs);
+        }
+        else
+        {
+          log_error("Base class initializer is not supported in {}", __func__);
+          abort();
+        }
+
+        // Convert to code and insert side-effect in the operands list
+        // Essentially we convert an initializer to assignment, e.g:
+        // t1() : i(2){ }
+        // is converted to
+        // t1() { this->i = 2; }
+        convert_expression_to_code(initializer);
+        initializers.push_back(initializer);
+      }
+
+      // Insert at the beginning of the body
+      body.operands().insert(
+        body.operands().begin(), initializers.begin(), initializers.end());
     }
   }
 
@@ -791,7 +885,6 @@ bool clang_cpp_convertert::get_function_params(
   const clang::FunctionDecl &fd,
   code_typet::argumentst &params)
 {
-  /*
   // On C++, all methods have an implicit reference to the
   // class of the object
   const clang::CXXMethodDecl &cxxmd =
@@ -822,7 +915,6 @@ bool clang_cpp_convertert::get_function_params(
     // of the this pointer (first arg)
     params[i + 1].swap(param);
   }
-  */
 
   return false;
 }
@@ -888,15 +980,9 @@ bool clang_cpp_convertert::get_decl_ref(
   switch(decl.getKind())
   {
   case clang::Decl::Var:
+  case clang::Decl::Field:
   {
-    const clang::VarDecl &vd = static_cast<const clang::VarDecl &>(decl);
-
-    get_decl_name(vd, name, id);
-
-    if(get_type(vd.getType(), type))
-      return true;
-
-    break;
+    return clang_c_convertert::get_decl_ref(decl, new_expr);
   }
   case clang::Decl::CXXConstructor:
   {
@@ -916,9 +1002,18 @@ bool clang_cpp_convertert::get_decl_ref(
 
   default:
   {
-    msg.error(fmt::format(
-      "Conversion of unsupported clang decl ref: {}", decl.getDeclKindName()));
-    abort();
+    // Cases not handled above are unknown clang decls; we print an warning.
+    // It might be possible to support them either here or in clang_c_frontend::get_decl_ref()
+    // depending on whether they are C++-specific or not.
+    std::ostringstream oss;
+    llvm::raw_os_ostream ross(oss);
+    decl.dump(ross);
+    ross.flush();
+    log_warning(
+      "Conversion of unsupported clang decl ref for: {}\n{}",
+      decl.getDeclKindName(),
+      oss.str());
+    return true;
   }
   }
 
diff --git a/src/clang-cpp-frontend/clang_cpp_convert.h b/src/clang-cpp-frontend/clang_cpp_convert.h
index 284cc4142..00946c09f 100644
--- a/src/clang-cpp-frontend/clang_cpp_convert.h
+++ b/src/clang-cpp-frontend/clang_cpp_convert.h
@@ -12,7 +12,7 @@ public:
   clang_cpp_convertert(
     contextt &_context,
     std::vector<std::unique_ptr<clang::ASTUnit>> &_ASTs,
-    const messaget &msg);
+    irep_idt _mode);
   virtual ~clang_cpp_convertert() = default;
 
 protected:
@@ -44,7 +44,7 @@ protected:
     exprt &new_expr);
 
   bool
-  get_function_body(const clang::FunctionDecl &fd, exprt &new_expr) ;
+  get_function_body(const clang::FunctionDecl &fd, exprt &new_expr) override;
 
   /**
    *  Get function params for C++
@@ -52,7 +52,7 @@ protected:
    */
   bool get_function_params(
     const clang::FunctionDecl &fd,
-    code_typet::argumentst &params) ;
+    code_typet::argumentst &params) override;
 
   /**
    *  Add implicit `this' when parsing C++ class member functions, e.g:
diff --git a/src/clang-cpp-frontend/clang_cpp_language.cpp b/src/clang-cpp-frontend/clang_cpp_language.cpp
index 9bce6ac15..34fd4e63a 100644
--- a/src/clang-cpp-frontend/clang_cpp_language.cpp
+++ b/src/clang-cpp-frontend/clang_cpp_language.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: C++ Language Module
-
-Author: Daniel Kroening, kroening@cs.cmu.edu
-
-\*******************************************************************/
-
 // Remove warnings from Clang headers
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wstrict-aliasing"
@@ -22,14 +14,9 @@ Author: Daniel Kroening, kroening@cs.cmu.edu
 #include <clang-cpp-frontend/expr2cpp.h>
 #include <regex>
 
-languaget *new_clang_cpp_language(const messaget &msg)
-{
-  return new clang_cpp_languaget(msg);
-}
-
-clang_cpp_languaget::clang_cpp_languaget(const messaget &msg)
-  : clang_c_languaget(msg)
+languaget *new_clang_cpp_language()
 {
+  return new clang_cpp_languaget;
 }
 
 void clang_cpp_languaget::force_file_type()
@@ -54,31 +41,28 @@ std::string clang_cpp_languaget::internal_additions()
 
 bool clang_cpp_languaget::typecheck(
   contextt &context,
-  const std::string &module,
-  const messaget &message_handler)
+  const std::string &module)
 {
-  contextt new_context(message_handler);
+  contextt new_context;
 
-  clang_cpp_convertert converter(new_context, ASTs, message_handler);
+  clang_cpp_convertert converter(new_context, ASTs, "C++");
   if(converter.convert())
     return true;
 
-  clang_cpp_adjust adjuster(new_context, message_handler);
+  clang_cpp_adjust adjuster(new_context);
   if(adjuster.adjust())
     return true;
 
-  if(c_link(context, new_context, message_handler, module))
+  if(c_link(context, new_context, module))
     return true;
 
   return false;
 }
 
-bool clang_cpp_languaget::final(
-  contextt &context,
-  const messaget &message_handler)
+bool clang_cpp_languaget::final(contextt &context)
 {
-  add_cprover_library(context, message_handler);
-  return clang_main(context, message_handler);
+  add_cprover_library(context);
+  return clang_main(context);
 }
 
 bool clang_cpp_languaget::from_expr(
diff --git a/src/clang-cpp-frontend/clang_cpp_language.h b/src/clang-cpp-frontend/clang_cpp_language.h
index 3d68b326c..86a6cfc53 100644
--- a/src/clang-cpp-frontend/clang_cpp_language.h
+++ b/src/clang-cpp-frontend/clang_cpp_language.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Clang C++ Language Module
-
-Author:
-
-\*******************************************************************/
-
 #ifndef CLANG_CPP_FRONTEND_CLANG_CPP_LANGUAGE_H_
 #define CLANG_CPP_FRONTEND_CLANG_CPP_LANGUAGE_H_
 
@@ -17,12 +9,9 @@ Author:
 class clang_cpp_languaget : public clang_c_languaget
 {
 public:
-  bool final(contextt &context, const messaget &message_handler) override;
+  bool final(contextt &context) override;
 
-  bool typecheck(
-    contextt &context,
-    const std::string &module,
-    const messaget &message_handler) override;
+  bool typecheck(contextt &context, const std::string &module) override;
 
   std::string id() const override
   {
@@ -37,20 +26,16 @@ public:
   bool from_type(const typet &type, std::string &code, const namespacet &ns)
     override;
 
-  languaget *new_language(const messaget &msg) const override
+  languaget *new_language() const override
   {
-    return new clang_cpp_languaget(msg);
+    return new clang_cpp_languaget;
   }
 
-  // constructor, destructor
-  ~clang_cpp_languaget() override = default;
-  explicit clang_cpp_languaget(const messaget &msg);
-
 protected:
   std::string internal_additions() override;
   void force_file_type() override;
 };
 
-languaget *new_clang_cpp_language(const messaget &msg);
+languaget *new_clang_cpp_language();
 
 #endif
diff --git a/src/clang-cpp-frontend/expr2cpp.cpp b/src/clang-cpp-frontend/expr2cpp.cpp
index 2bdf15921..44102b772 100644
--- a/src/clang-cpp-frontend/expr2cpp.cpp
+++ b/src/clang-cpp-frontend/expr2cpp.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@cs.cmu.edu
-
-\*******************************************************************/
-
 #include <cassert>
 #include <clang-c-frontend/expr2c.h>
 #include <clang-cpp-frontend/expr2cpp.h>
@@ -182,7 +174,7 @@ std::string expr2cppt::convert_rec(
   {
     const irep_idt &identifier = src.identifier();
 
-    const symbolt &symbol = ns.lookup(identifier);
+    const symbolt &symbol = *ns.lookup(identifier);
 
     if(symbol.type.id() == "struct" || symbol.type.id() == "incomplete_struct")
     {
@@ -343,7 +335,7 @@ expr2cppt::convert_code_cpp_delete(const exprt &src, unsigned indent)
 
   std::string tmp = convert(src.op0());
 
-  dest += tmp + ";\n";
+  dest += tmp + ";";
 
   return dest;
 }
@@ -352,16 +344,22 @@ std::string expr2cppt::convert(const exprt &src, unsigned &precedence)
 {
   if(src.id() == "cpp-this")
     return convert_cpp_this(src, precedence = 15);
+
   if(
     src.id() == "sideeffect" &&
     (src.statement() == "cpp_new" || src.statement() == "cpp_new[]"))
     return convert_cpp_new(src, precedence = 15);
-  else if(src.id() == "unassigned")
+
+  if(src.id() == "cpp_delete" || src.id() == "cpp_delete[]")
+    return convert_code_cpp_delete(src, precedence = 0);
+
+  if(src.id() == "unassigned")
     return "?";
-  else if(src.id() == "pod_constructor")
+
+  if(src.id() == "pod_constructor")
     return "pod_constructor";
-  else
-    return expr2ct::convert(src, precedence);
+
+  return expr2ct::convert(src, precedence);
 }
 
 std::string expr2cppt::convert_code(const codet &src, unsigned indent)
diff --git a/src/clang-cpp-frontend/expr2cpp.h b/src/clang-cpp-frontend/expr2cpp.h
index 58ef90994..02c845e40 100644
--- a/src/clang-cpp-frontend/expr2cpp.h
+++ b/src/clang-cpp-frontend/expr2cpp.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@cs.cmu.edu
-
-\*******************************************************************/
-
 #ifndef CPROVER_EXPR2CPP_H
 #define CPROVER_EXPR2CPP_H
 
diff --git a/src/cpp/CMakeLists.txt b/src/cpp/CMakeLists.txt
index babac709a..79b0bd77e 100644
--- a/src/cpp/CMakeLists.txt
+++ b/src/cpp/CMakeLists.txt
@@ -1,7 +1,8 @@
 
 FLEX_TARGET(cppscanner scanner.lpp ${CMAKE_CURRENT_BINARY_DIR}/scanner.cpp COMPILE_FLAGS "--header-file=scanner.hpp -Pyycpp")
 
-add_library(cppfrontend ${CMAKE_CURRENT_BINARY_DIR}/scanner.cpp cpp_id.cpp cpp_language.cpp cpp_parser.cpp cpp_typecheck.cpp cpp_convert_type.cpp cpp_typecheck_expr.cpp cpp_typecheck_code.cpp cpp_typecheck_type.cpp parse.cpp cpp_parse_tree.cpp cpp_token_buffer.cpp cpp_typecheck_fargs.cpp cpp_typecheck_resolve.cpp cpp_util.cpp cpp_typecheck_function.cpp cpp_typecheck_namespace.cpp cpp_name.cpp cpp_is_pod.cpp cpp_scope.cpp cpp_typecheck_find_constructor.cpp template_map.cpp cpp_scopes.cpp cpp_typecheck_linkage_spec.cpp cpp_declarator.cpp cpp_type2name.cpp cpp_instantiate_template.cpp cpp_typecheck_template.cpp cpp_typecheck_function_bodies.cpp cpp_typecheck_initializer.cpp cpp_typecheck_compound_type.cpp cpp_constructor.cpp cpp_destructor.cpp cpp_final.cpp cpp_typecheck_conversions.cpp cpp_typecheck_declaration.cpp cpp_declarator_converter.cpp cpp_declaration.cpp cpp_namespace_spec.cpp cpp_typecheck_using.cpp cpp_exception_id.cpp cpp_typecheck_enum_type.cpp cpp_typecheck_bases.cpp cpp_typecheck_constructor.cpp cpp_typecheck_virtual_table.cpp)
-target_include_directories(cppfrontend 
+add_library(cppfrontend ${CMAKE_CURRENT_BINARY_DIR}/scanner.cpp cpp_id.cpp cpp_language.cpp cpp_parser.cpp cpp_typecheck.cpp cpp_convert_type.cpp cpp_typecheck_expr.cpp cpp_typecheck_code.cpp cpp_typecheck_type.cpp parse.cpp cpp_parse_tree.cpp cpp_token_buffer.cpp cpp_typecheck_fargs.cpp cpp_typecheck_resolve.cpp cpp_util.cpp cpp_typecheck_function.cpp cpp_typecheck_namespace.cpp cpp_name.cpp cpp_is_pod.cpp cpp_scope.cpp template_map.cpp cpp_scopes.cpp cpp_typecheck_linkage_spec.cpp cpp_declarator.cpp cpp_type2name.cpp cpp_instantiate_template.cpp cpp_typecheck_template.cpp cpp_typecheck_function_bodies.cpp cpp_typecheck_initializer.cpp cpp_typecheck_compound_type.cpp cpp_constructor.cpp cpp_destructor.cpp cpp_final.cpp cpp_typecheck_conversions.cpp cpp_typecheck_declaration.cpp cpp_declarator_converter.cpp cpp_declaration.cpp cpp_namespace_spec.cpp cpp_typecheck_using.cpp cpp_exception_id.cpp cpp_typecheck_enum_type.cpp cpp_typecheck_bases.cpp cpp_typecheck_constructor.cpp cpp_typecheck_virtual_table.cpp)
+target_include_directories(cppfrontend
     PRIVATE ${Boost_INCLUDE_DIRS}
 )
+target_link_libraries(cppfrontend PUBLIC fmt::fmt)
diff --git a/src/cpp/cpp_constructor.cpp b/src/cpp/cpp_constructor.cpp
index 23f4a976b..0d5bbdb63 100644
--- a/src/cpp/cpp_constructor.cpp
+++ b/src/cpp/cpp_constructor.cpp
@@ -25,7 +25,6 @@ codet cpp_typecheckt::cpp_constructor(
   follow_symbol(tmp_type);
 
   assert(!is_reference(tmp_type));
-
   if(tmp_type.id() == "array")
   {
     // We allow only one operand and it must be tagged with '#array_ini'.
@@ -148,6 +147,12 @@ codet cpp_typecheckt::cpp_constructor(
       assign.location() = location;
       assign.copy_to_operands(object_tc, operands_tc.front());
       typecheck_side_effect_assignment(assign);
+      if(new_code.operands().size() == 1)
+      {
+        // remove zombie operands
+        if(new_code.operands().front().id() == "")
+          new_code.operands().clear();
+      }
       new_code.move_to_operands(assign);
     }
     else
@@ -201,6 +206,14 @@ codet cpp_typecheckt::cpp_constructor(
       assign.move_to_operands(member, val);
       typecheck_side_effect_assignment(assign);
       code_expressiont code_exp;
+
+      if(code_exp.operands().size() == 1)
+      {
+        // remove zombie operands
+        if(code_exp.operands().front().id() == "")
+          code_exp.operands().clear();
+      }
+
       code_exp.move_to_operands(assign);
       block.move_to_operands(code_exp);
     }
@@ -254,7 +267,7 @@ codet cpp_typecheckt::cpp_constructor(
     {
       // Alas, we need to add a type.
       function_call.add("#this_expr") = object;
-      const symbolt &sym = lookup(object.identifier());
+      const symbolt &sym = *lookup(object.identifier());
       function_call.add("#this_expr").type() = sym.type;
     }
     else
@@ -315,6 +328,7 @@ codet cpp_typecheckt::cpp_constructor(
 
   codet nil;
   nil.make_nil();
+
   return nil;
 }
 
diff --git a/src/cpp/cpp_declarator_converter.cpp b/src/cpp/cpp_declarator_converter.cpp
index 965edd109..e74f8f869 100644
--- a/src/cpp/cpp_declarator_converter.cpp
+++ b/src/cpp/cpp_declarator_converter.cpp
@@ -107,10 +107,11 @@ symbolt &cpp_declarator_convertert::convert(
 
       if(s == nullptr)
       {
-        cpp_typecheck.err_location(declarator.name());
-        cpp_typecheck.str << "member `" << base_name << "' not found in scope `"
-                          << scope->identifier << "'";
-        throw 0;
+        err_location(declarator.name());
+        str << "member `" << base_name << "' not found in scope `"
+            << scope->identifier << "'";
+        log_error(str.str());
+        abort();
       }
     }
 
@@ -132,13 +133,14 @@ symbolt &cpp_declarator_convertert::convert(
 
       if(symbol_expr.id() != "type" || symbol_expr.type().id() != "symbol")
       {
-        cpp_typecheck.err_location(name.location());
-        cpp_typecheck.str << "error: expected type";
-        throw 0;
+        err_location(name.location());
+        str << "error: expected type";
+        log_error(str.str());
+        abort();
       }
 
       irep_idt identifier = symbol_expr.type().identifier();
-      const symbolt &symb = cpp_typecheck.lookup(identifier);
+      const symbolt &symb = *cpp_typecheck.lookup(identifier);
       const typet &type = symb.type;
       assert(type.id() == "struct");
 
@@ -170,8 +172,8 @@ symbolt &cpp_declarator_convertert::convert(
     final_type.id() == "code" &&
     to_code_type(final_type).return_type().id() == "constructor")
   {
-    cpp_typecheck.err_location(declarator.name().location());
-    cpp_typecheck.str << "function must have return type";
+    err_location(declarator.name().location());
+    str << "function must have return type";
     throw 0;
   }
 
@@ -244,14 +246,13 @@ void cpp_declarator_convertert::combine_types(
           // The 'this' argument of virtual functions mismatches
           if(i != 0 || !symbol_code_type.get_bool("#is_virtual"))
           {
-            cpp_typecheck.err_location(location);
-            cpp_typecheck.str << "symbol `" << symbol.name << "': argument "
-                              << (i + 1) << " type mismatch" << std::endl;
-            cpp_typecheck.str << "previous type: "
-                              << cpp_typecheck.to_string(symbol_argument.type())
-                              << std::endl;
-            cpp_typecheck.str << "new type: "
-                              << cpp_typecheck.to_string(decl_argument.type());
+            err_location(location);
+            str << "symbol `" << symbol.name << "': argument " << (i + 1)
+                << " type mismatch" << std::endl;
+            str << "previous type: "
+                << cpp_typecheck.to_string(symbol_argument.type()) << std::endl;
+            str << "new type: "
+                << cpp_typecheck.to_string(decl_argument.type());
             throw 0;
           }
         }
@@ -278,12 +279,11 @@ void cpp_declarator_convertert::combine_types(
     return; // ok
   }
 
-  cpp_typecheck.err_location(location);
-  cpp_typecheck.str << "symbol `" << symbol.name
-                    << "' already declared with different type" << std::endl;
-  cpp_typecheck.str << "previous type: " << cpp_typecheck.to_string(symbol.type)
-                    << std::endl;
-  cpp_typecheck.str << "new type: " << cpp_typecheck.to_string(final_type);
+  err_location(location);
+  str << "symbol `" << symbol.name << "' already declared with different type"
+      << std::endl;
+  str << "previous type: " << cpp_typecheck.to_string(symbol.type) << std::endl;
+  str << "new type: " << cpp_typecheck.to_string(final_type);
   throw 0;
 }
 
@@ -330,14 +330,14 @@ void cpp_declarator_convertert::handle_initializer(
   else
   {
 #if 0
-    cpp_typecheck.err_location(declarator.name());
+    err_location(declarator.name());
 
     if(is_code)
-      cpp_typecheck.str << "body of function `"
+      str << "body of function `"
                         << symbol.display_name()
                         << "' has already been defined";
     else
-      cpp_typecheck.str << "symbol `"
+      str << "symbol `"
                         << symbol.display_name()
                         << "' already has an initializer";
 
@@ -423,7 +423,7 @@ symbolt &cpp_declarator_convertert::convert_new_symbol(
         }
         else if(storage_spec.is_extern())
         {
-          cpp_typecheck.err_location(storage_spec);
+          err_location(storage_spec);
           throw "external storage not permitted here";
         }
       }
@@ -454,8 +454,8 @@ symbolt &cpp_declarator_convertert::convert_new_symbol(
 
       if(!id.is_class() && !id.is_enum())
       {
-        cpp_typecheck.err_location(new_symbol->location);
-        cpp_typecheck.str << "`" << base_name << "' already in scope";
+        err_location(new_symbol->location);
+        str << "`" << base_name << "' already in scope";
         throw 0;
       }
     }
@@ -526,7 +526,7 @@ void cpp_declarator_convertert::main_function_rules(const symbolt &symbol)
   {
     if(symbol.type.id() != "code")
     {
-      cpp_typecheck.err_location(symbol.location);
+      err_location(symbol.location);
       throw "main must be function";
     }
 
@@ -535,7 +535,7 @@ void cpp_declarator_convertert::main_function_rules(const symbolt &symbol)
 
     if(return_type != int_type())
     {
-      cpp_typecheck.err_location(symbol.location);
+      err_location(symbol.location);
       throw "main must return int";
     }
   }
diff --git a/src/cpp/cpp_declarator_converter.h b/src/cpp/cpp_declarator_converter.h
index a999d481f..07c8f62f5 100644
--- a/src/cpp/cpp_declarator_converter.h
+++ b/src/cpp/cpp_declarator_converter.h
@@ -22,7 +22,7 @@ class cpp_declarator_convertert
 {
 public:
   cpp_declarator_convertert(class cpp_typecheckt &_cpp_typecheck);
-
+  std::ostringstream str;
   bool is_typedef;
   bool is_template;
   bool is_template_argument;
diff --git a/src/cpp/cpp_destructor.cpp b/src/cpp/cpp_destructor.cpp
index 2331a509d..e7b2c3e52 100644
--- a/src/cpp/cpp_destructor.cpp
+++ b/src/cpp/cpp_destructor.cpp
@@ -94,7 +94,7 @@ codet cpp_typecheckt::cpp_destructor(
     // there is always a destructor for non-PODs
     assert(dtor_name != "");
 
-    const symbolt &symb = lookup(struct_type.name());
+    const symbolt &symb = *lookup(struct_type.name());
 
     irept cpp_name("cpp-name");
 
diff --git a/src/cpp/cpp_exception_id.cpp b/src/cpp/cpp_exception_id.cpp
index 9434cd45f..23a097173 100644
--- a/src/cpp/cpp_exception_id.cpp
+++ b/src/cpp/cpp_exception_id.cpp
@@ -46,7 +46,7 @@ void cpp_exception_list_rec(
     irep_idt identifier = src.identifier();
 
     // We must check if is a derived class
-    typet type = ns.lookup(identifier).type;
+    typet type = ns.lookup(identifier)->type;
 
     if(
       type.id() == "struct" &&
diff --git a/src/cpp/cpp_final.cpp b/src/cpp/cpp_final.cpp
index 1f23ab392..1931440c0 100644
--- a/src/cpp/cpp_final.cpp
+++ b/src/cpp/cpp_final.cpp
@@ -10,9 +10,9 @@ Author: Daniel Kroening, kroening@cs.cmu.edu
 #include <c2goto/cprover_library.h>
 #include <cpp/cpp_final.h>
 
-bool cpp_final(contextt &context, const messaget &message_handler)
+bool cpp_final(contextt &context)
 {
-  add_cprover_library(context, message_handler);
+  add_cprover_library(context);
 
   return false;
 }
diff --git a/src/cpp/cpp_final.h b/src/cpp/cpp_final.h
index f3a5e79d0..42ef991d4 100644
--- a/src/cpp/cpp_final.h
+++ b/src/cpp/cpp_final.h
@@ -10,8 +10,8 @@ Author: Daniel Kroening, kroening@cs.cmu.edu
 #define CPROVER_CPP_FINAL_H
 
 #include <util/context.h>
-#include <util/message/message.h>
+#include <util/message.h>
 
-bool cpp_final(contextt &context, const messaget &message_handler);
+bool cpp_final(contextt &context);
 
 #endif
diff --git a/src/cpp/cpp_instantiate_template.cpp b/src/cpp/cpp_instantiate_template.cpp
index d79747a04..82f75d5a2 100644
--- a/src/cpp/cpp_instantiate_template.cpp
+++ b/src/cpp/cpp_instantiate_template.cpp
@@ -87,7 +87,7 @@ void cpp_typecheckt::show_instantiation_stack(std::ostream &out)
       s_it != instantiation_stack.end();
       s_it++)
   {
-    const symbolt &symbol = lookup(s_it->identifier);
+    const symbolt &symbol = *lookup(s_it->identifier);
     out << "instantiating `" << symbol.name << "' with <";
 
     forall_expr(a_it, s_it->full_template_args.arguments())
@@ -112,14 +112,14 @@ const symbolt *cpp_typecheckt::is_template_instantiated(
   // Check whether the instance already exists. The 'template_instances' irep
   // contains a list of already instantiated patterns, and the symbol names
   // where the resulting thing is.
-  const symbolt &template_symbol = lookup(template_symbol_name);
+  const symbolt &template_symbol = *lookup(template_symbol_name);
   const irept &instances = template_symbol.value.find("template_instances");
   if(!instances.is_nil())
   {
     if(instances.get(template_pattern_name) != "")
     {
       // It has already been instantianted! Look up the symbol.
-      const symbolt &symb = lookup(instances.get(template_pattern_name));
+      const symbolt &symb = *lookup(instances.get(template_pattern_name));
 
       // continue if the type is incomplete only -- it might now be complete(?).
       if(symb.type.id() != "incomplete_struct" || symb.value.is_not_nil())
@@ -432,7 +432,7 @@ const symbolt &cpp_typecheckt::instantiate_template(
     convert(new_decl);
 
     symbolt &new_symb =
-      const_cast<symbolt &>(lookup(new_decl.type().identifier()));
+      const_cast<symbolt &>(*lookup(new_decl.type().identifier()));
 
     // Mark template as instantiated before instantiating template methods,
     // as they might then go and instantiate recursively.
@@ -557,7 +557,7 @@ const symbolt &cpp_typecheckt::instantiate_template(
 
   const irep_idt &new_sym_name = new_decl.declarators()[0].identifier();
   mark_template_instantiated(template_symbol.id, subscope_name, new_sym_name);
-  return lookup(new_sym_name);
+  return *lookup(new_sym_name);
 }
 
 void cpp_typecheckt::put_template_args_in_scope(
@@ -624,7 +624,7 @@ void cpp_typecheckt::put_template_arg_into_scope(
   }
 
   // Find declaration of that templated type.
-  const symbolt &orig_symbol = lookup(templ_param_id);
+  const symbolt &orig_symbol = *lookup(templ_param_id);
 
   // Construct a new, concrete type symbol, with the base name as the templated
   // type name, and with the current scopes prefix.
diff --git a/src/cpp/cpp_is_pod.cpp b/src/cpp/cpp_is_pod.cpp
index 82fbf022d..94fdd4583 100644
--- a/src/cpp/cpp_is_pod.cpp
+++ b/src/cpp/cpp_is_pod.cpp
@@ -83,7 +83,7 @@ bool cpp_typecheckt::cpp_is_pod(const typet &type) const
   }
   else if(type.id() == "symbol")
   {
-    const symbolt &symb = lookup(type.identifier());
+    const symbolt &symb = *lookup(type.identifier());
     assert(symb.is_type);
     return cpp_is_pod(symb.type);
   }
diff --git a/src/cpp/cpp_language.cpp b/src/cpp/cpp_language.cpp
index 18a3f582a..9d9dcf413 100644
--- a/src/cpp/cpp_language.cpp
+++ b/src/cpp/cpp_language.cpp
@@ -21,13 +21,10 @@ Author: Daniel Kroening, kroening@cs.cmu.edu
 #include <util/config.h>
 #include <util/replace_symbol.h>
 
-bool cpp_languaget::preprocess(
-  const std::string &path,
-  std::ostream &outstream,
-  const messaget &message_handler)
+bool cpp_languaget::preprocess(const std::string &path, std::ostream &outstream)
 {
   if(path == "")
-    return c_preprocess("", outstream, true, message_handler);
+    return c_preprocess("", outstream, true);
 
   // check extension
 
@@ -44,10 +41,10 @@ bool cpp_languaget::preprocess(
     return false;
   }
 
-  return c_preprocess(path, outstream, true, message_handler);
+  return c_preprocess(path, outstream, true);
 }
 
-cpp_languaget::cpp_languaget(const messaget &msg) : languaget(msg)
+cpp_languaget::cpp_languaget()
 {
 }
 
@@ -81,8 +78,6 @@ void cpp_languaget::internal_additions(std::ostream &out)
   out << "bool __ESBMC_alloc[__CPROVER::constant_infinity_uint];" << std::endl;
   out << "unsigned __ESBMC_alloc_size[__CPROVER::constant_infinity_uint];"
       << std::endl;
-  out << "bool __ESBMC_deallocated[__CPROVER::constant_infinity_uint];"
-      << std::endl;
   out << "bool __ESBMC_is_dynamic[__CPROVER::constant_infinity_uint];"
       << std::endl;
 
@@ -132,9 +127,7 @@ void cpp_languaget::internal_additions(std::ostream &out)
   out << "}" << std::endl;
 }
 
-bool cpp_languaget::parse(
-  const std::string &path,
-  const messaget &message_handler)
+bool cpp_languaget::parse(const std::string &path)
 {
   // store the path
 
@@ -146,7 +139,7 @@ bool cpp_languaget::parse(
 
   internal_additions(o_preprocessed);
 
-  if(preprocess(path, o_preprocessed, message_handler))
+  if(preprocess(path, o_preprocessed))
     return true;
 
   std::istringstream i_preprocessed(o_preprocessed.str());
@@ -176,24 +169,21 @@ bool cpp_languaget::parse(
   return result;
 }
 
-bool cpp_languaget::typecheck(
-  contextt &context,
-  const std::string &module,
-  const messaget &message_handler)
+bool cpp_languaget::typecheck(contextt &context, const std::string &module)
 {
-  contextt new_context(message_handler);
+  contextt new_context;
 
-  if(cpp_typecheck(cpp_parse_tree, new_context, module, message_handler))
+  if(cpp_typecheck(cpp_parse_tree, new_context, module))
     return true;
 
-  return c_link(context, new_context, message_handler, module);
+  return c_link(context, new_context, module);
 }
 
-bool cpp_languaget::final(contextt &context, const messaget &message_handler)
+bool cpp_languaget::final(contextt &context)
 {
-  if(cpp_final(context, message_handler))
+  if(cpp_final(context))
     return true;
-  if(c_main(context, "main", message_handler))
+  if(c_main(context, "main"))
     return true;
 
   return false;
@@ -247,9 +237,9 @@ void cpp_languaget::show_parse(std::ostream &out, const cpp_itemt &item)
     out << "UNKNOWN: " << item << std::endl;
 }
 
-languaget *new_cpp_language(const messaget &msg)
+languaget *new_cpp_language()
 {
-  return new cpp_languaget(msg);
+  return new cpp_languaget();
 }
 
 bool cpp_languaget::from_expr(
diff --git a/src/cpp/cpp_language.h b/src/cpp/cpp_language.h
index 8357e3d69..f7ad84351 100644
--- a/src/cpp/cpp_language.h
+++ b/src/cpp/cpp_language.h
@@ -15,32 +15,25 @@ Author: Daniel Kroening, kroening@cs.cmu.edu
 class cpp_languaget : public languaget
 {
 public:
-  virtual bool preprocess(
-    const std::string &path,
-    std::ostream &outstream,
-    const messaget &message_handler);
+  virtual bool preprocess(const std::string &path, std::ostream &outstream);
 
-  bool parse(const std::string &path, const messaget &message_handler) override;
+  bool parse(const std::string &path) override;
 
-  bool typecheck(
-    contextt &context,
-    const std::string &module,
-    const messaget &message_handler) override;
+  bool typecheck(contextt &context, const std::string &module) override;
 
   bool merge_context(
     contextt &dest,
     contextt &src,
-    const messaget &message_handler,
     const std::string &module,
     class replace_symbolt &replace_symbol) const;
 
-  bool final(contextt &context, const messaget &message_handler) override;
+  bool final(contextt &context) override;
 
   void show_parse(std::ostream &out) override;
 
   // constructor, destructor
   ~cpp_languaget() override = default;
-  explicit cpp_languaget(const messaget &msg);
+  explicit cpp_languaget();
 
   // conversion from expression into string
   bool from_expr(const exprt &expr, std::string &code, const namespacet &ns)
@@ -50,9 +43,9 @@ public:
   bool from_type(const typet &type, std::string &code, const namespacet &ns)
     override;
 
-  languaget *new_language(const messaget &msg) const override
+  languaget *new_language() const override
   {
-    return new cpp_languaget(msg);
+    return new cpp_languaget();
   }
 
 protected:
@@ -68,6 +61,6 @@ protected:
   }
 };
 
-languaget *new_cpp_language(const messaget &msg);
+languaget *new_cpp_language();
 
 #endif
diff --git a/src/cpp/cpp_typecheck.cpp b/src/cpp/cpp_typecheck.cpp
index ea0759591..3c2cf2c44 100644
--- a/src/cpp/cpp_typecheck.cpp
+++ b/src/cpp/cpp_typecheck.cpp
@@ -41,6 +41,10 @@ std::string cpp_typecheckt::to_string(const typet &type)
 
 void cpp_typecheckt::convert(cpp_itemt &item)
 {
+  // top-level conversion function:
+  // the conversion modifies the originial cpp_itemt
+  // dumping cpp_itemt contents before and after conversion give different results
+
   if(item.is_declaration())
     convert(to_cpp_declaration(item));
   else if(item.is_linkage_spec())
@@ -74,48 +78,12 @@ void cpp_typecheckt::typecheck()
 bool cpp_typecheck(
   cpp_parse_treet &cpp_parse_tree,
   contextt &context,
-  const std::string &module,
-  const messaget &message_handler)
+  const std::string &module)
 {
-  cpp_typecheckt cpp_typecheck(
-    cpp_parse_tree, context, module, message_handler);
+  cpp_typecheckt cpp_typecheck(cpp_parse_tree, context, module);
   return cpp_typecheck.typecheck_main();
 }
 
-bool cpp_typecheck(
-  exprt &expr,
-  const messaget &message_handler,
-  const namespacet &ns)
-{
-  contextt context(message_handler);
-  cpp_parse_treet cpp_parse_tree;
-
-  cpp_typecheckt cpp_typecheck(
-    cpp_parse_tree, context, ns.get_context(), "", message_handler);
-
-  try
-  {
-    cpp_typecheck.typecheck_expr(expr);
-  }
-
-  catch(int e)
-  {
-    cpp_typecheck.error();
-  }
-
-  catch(const char *e)
-  {
-    cpp_typecheck.error(e);
-  }
-
-  catch(const std::string &e)
-  {
-    cpp_typecheck.error(e);
-  }
-
-  return cpp_typecheck.get_error_found();
-}
-
 void cpp_typecheckt::static_initialization()
 {
   code_blockt block_sini; // Static Initialization Block
@@ -244,7 +212,7 @@ void cpp_typecheckt::do_not_typechecked()
         cpp_declaratort declarator;
         declarator.location() = sym->location;
         default_assignop_value(
-          lookup(sym->type.get("#member_name")), declarator);
+          *lookup(sym->type.get("#member_name")), declarator);
         sym->value.swap(declarator.value());
         convert_function(*sym);
         cont = true;
diff --git a/src/cpp/cpp_typecheck.h b/src/cpp/cpp_typecheck.h
index eb1161189..63b0ca7ac 100644
--- a/src/cpp/cpp_typecheck.h
+++ b/src/cpp/cpp_typecheck.h
@@ -27,13 +27,7 @@ Author: Daniel Kroening, kroening@cs.cmu.edu
 bool cpp_typecheck(
   cpp_parse_treet &cpp_parse_tree,
   contextt &context,
-  const std::string &module,
-  const messaget &message_handler);
-
-bool cpp_typecheck(
-  exprt &expr,
-  const messaget &message_handler,
-  const namespacet &ns);
+  const std::string &module);
 
 class cpp_typecast_rank
 {
@@ -109,23 +103,8 @@ public:
   cpp_typecheckt(
     cpp_parse_treet &_cpp_parse_tree,
     contextt &_context,
-    const std::string &_module,
-    const messaget &message_handler)
-    : c_typecheck_baset(_context, _module, message_handler),
-      cpp_parse_tree(_cpp_parse_tree),
-      template_counter(0),
-      anon_counter(0),
-      disable_access_control(false)
-  {
-  }
-
-  cpp_typecheckt(
-    cpp_parse_treet &_cpp_parse_tree,
-    contextt &_context1,
-    const contextt &_context2,
-    const std::string &_module,
-    const messaget &message_handler)
-    : c_typecheck_baset(_context1, _context2, _module, message_handler),
+    const std::string &_module)
+    : c_typecheck_baset(_context, _module),
       cpp_parse_tree(_cpp_parse_tree),
       template_counter(0),
       anon_counter(0),
@@ -139,8 +118,8 @@ public:
 
   // overload to use C++ syntax
 
-  std::string to_string(const typet &type) override;
-  std::string to_string(const exprt &expr) override;
+  std::string to_string(const typet &type);
+  std::string to_string(const exprt &expr);
 
   friend class cpp_typecheck_resolvet;
   friend class cpp_declarator_convertert;
@@ -307,8 +286,6 @@ protected:
   // Misc
   //
 
-  void find_constructor(const typet &dest_type, exprt &symbol_expr);
-
   void default_ctor(
     const locationt &location,
     const irep_idt &base_name,
diff --git a/src/cpp/cpp_typecheck_bases.cpp b/src/cpp/cpp_typecheck_bases.cpp
index c69bb7089..ce120a97c 100644
--- a/src/cpp/cpp_typecheck_bases.cpp
+++ b/src/cpp/cpp_typecheck_bases.cpp
@@ -35,7 +35,7 @@ void cpp_typecheckt::typecheck_compound_bases(struct_typet &type)
       throw 0;
     }
 
-    const symbolt &base_symbol = lookup(base_symbol_expr.type());
+    const symbolt &base_symbol = *lookup(base_symbol_expr.type());
 
     if(
       base_symbol.type.id() == "incomplete_struct" ||
@@ -151,7 +151,7 @@ void cpp_typecheckt::add_base_components(
     else if(access == "protected" && sub_access != "private")
       sub_access = "protected";
 
-    const symbolt &symb = lookup(it->type().identifier());
+    const symbolt &symb = *lookup(it->type().identifier());
 
     bool is_virtual = it->get_bool("virtual");
 
diff --git a/src/cpp/cpp_typecheck_code.cpp b/src/cpp/cpp_typecheck_code.cpp
index d884985ee..31ada4410 100644
--- a/src/cpp/cpp_typecheck_code.cpp
+++ b/src/cpp/cpp_typecheck_code.cpp
@@ -261,6 +261,12 @@ void cpp_typecheckt::typecheck_member_initializer(codet &code)
     make_ptr_typecast(this_expr, tmp_this.type());
     tmp_this.swap(this_expr);
     code = code_expressiont();
+    if(code.operands().size() == 1)
+    {
+      // remove zombie operands
+      if(code.operands().front().id() == "")
+        code.operands().clear();
+    }
     code.move_to_operands(initializer);
   }
   else
@@ -329,6 +335,14 @@ void cpp_typecheckt::typecheck_member_initializer(codet &code)
         assign.copy_to_operands(symbol_expr, code.op0());
         typecheck_side_effect_assignment(assign);
         code_expressiont new_code;
+
+        if(new_code.operands().size() == 1)
+        {
+          // remove zombie operands
+          if(new_code.operands().front().id() == "")
+            new_code.operands().clear();
+        }
+
         new_code.move_to_operands(assign);
         code.swap(new_code);
       }
@@ -466,6 +480,14 @@ void cpp_typecheckt::typecheck_assign(codet &code)
   typecheck_expr(expr);
 
   code_expressiont code_expr;
+
+  if(code_expr.operands().size() == 1)
+  {
+    // remove zombie operands
+    if(code_expr.operands().front().id() == "")
+      code_expr.operands().clear();
+  }
+
   code_expr.copy_to_operands(expr);
   code_expr.location() = code.location();
 
diff --git a/src/cpp/cpp_typecheck_compound_type.cpp b/src/cpp/cpp_typecheck_compound_type.cpp
index 56346b0bd..86b831f04 100644
--- a/src/cpp/cpp_typecheck_compound_type.cpp
+++ b/src/cpp/cpp_typecheck_compound_type.cpp
@@ -584,7 +584,7 @@ void cpp_typecheckt::typecheck_compound_declarator(
           to_code_type(component.type()).arguments()[0].type());
 
         late_cast.op0() =
-          symbol_expr(namespacet(context).lookup(args[0].cmt_identifier()));
+          symbol_expr(*namespacet(context).lookup(args[0].cmt_identifier()));
 
         if(
           code_type.return_type().id() != "empty" &&
@@ -600,7 +600,7 @@ void cpp_typecheckt::typecheck_compound_declarator(
           for(unsigned i = 1; i < args.size(); i++)
           {
             expr_call.arguments().push_back(symbol_expr(
-              namespacet(context).lookup(args[i].cmt_identifier())));
+              *namespacet(context).lookup(args[i].cmt_identifier())));
           }
 
           code_returnt code_return;
@@ -619,7 +619,7 @@ void cpp_typecheckt::typecheck_compound_declarator(
           for(unsigned i = 1; i < args.size(); i++)
           {
             code_func.arguments().push_back(symbol_expr(
-              namespacet(context).lookup(args[i].cmt_identifier())));
+              *namespacet(context).lookup(args[i].cmt_identifier())));
           }
 
           func_symb.value = code_func;
@@ -1401,10 +1401,11 @@ void cpp_typecheckt::add_anonymous_members_to_scope(
 
     if(struct_union_component.get_anonymous())
     {
-      const symbolt &symbol =
+      const symbolt *symbol =
         lookup(struct_union_component.type().get("identifier"));
-      // recrusive call
-      add_anonymous_members_to_scope(symbol);
+      assert(symbol);
+      // recursive call
+      add_anonymous_members_to_scope(*symbol);
     }
     else
     {
@@ -1582,7 +1583,7 @@ bool cpp_typecheckt::check_component_access(
         return false; // ok
 
       const struct_typet &scope_struct =
-        to_struct_type(lookup(pscope->identifier).type);
+        to_struct_type(lookup(pscope->identifier)->type);
 
       if(subtype_typecast(struct_type, scope_struct))
         return false; // ok
@@ -1629,7 +1630,7 @@ void cpp_typecheckt::get_bases(
     assert(it->get("type") == "symbol");
 
     const struct_typet &base =
-      to_struct_type(lookup(it->type().identifier()).type);
+      to_struct_type(lookup(it->type().identifier())->type);
 
     set_bases.insert(base.name());
     get_bases(base, set_bases);
@@ -1651,7 +1652,7 @@ void cpp_typecheckt::get_virtual_bases(
     assert(it->get("type") == "symbol");
 
     const struct_typet &base =
-      to_struct_type(lookup(it->type().identifier()).type);
+      to_struct_type(lookup(it->type().identifier())->type);
 
     if(it->get_bool("virtual"))
       vbases.push_back(base.name());
diff --git a/src/cpp/cpp_typecheck_constructor.cpp b/src/cpp/cpp_typecheck_constructor.cpp
index fb9ef83d2..6ec4e2173 100644
--- a/src/cpp/cpp_typecheck_constructor.cpp
+++ b/src/cpp/cpp_typecheck_constructor.cpp
@@ -247,7 +247,7 @@ void cpp_typecheckt::default_cpctor(
     assert(parent_it->id() == "base");
     assert(parent_it->get("type") == "symbol");
 
-    const symbolt &parsymb = lookup(parent_it->type().identifier());
+    const symbolt &parsymb = *lookup(parent_it->type().identifier());
 
     if(cpp_is_pod(parsymb.type))
       copy_parent(location, parsymb.name, arg_name, block);
@@ -289,9 +289,9 @@ void cpp_typecheckt::default_cpctor(
       cppname.move_to_sub(name);
 
       const symbolt &virtual_table_symbol_type =
-        namespacet(context).lookup(mem_it->type().subtype().identifier());
+        *namespacet(context).lookup(mem_it->type().subtype().identifier());
 
-      const symbolt &virtual_table_symbol_var = namespacet(context).lookup(
+      const symbolt &virtual_table_symbol_var = *namespacet(context).lookup(
         virtual_table_symbol_type.id.as_string() + "@" + symbol.id.as_string());
 
       exprt var = symbol_expr(virtual_table_symbol_var);
@@ -437,7 +437,7 @@ void cpp_typecheckt::default_assignop_value(
     assert(parent_it->id() == "base");
     assert(parent_it->get("type") == "symbol");
 
-    const symbolt &symb = lookup(parent_it->type().identifier());
+    const symbolt &symb = *lookup(parent_it->type().identifier());
 
     copy_parent(location, symb.name, arg_name, block);
   }
@@ -562,7 +562,7 @@ void cpp_typecheckt::check_member_initializers(
         if(type.id() != "symbol")
           continue;
 
-        const symbolt &symb = lookup(type.identifier());
+        const symbolt &symb = *lookup(type.identifier());
         if(symb.type.id() != "struct")
           break;
 
@@ -602,7 +602,7 @@ void cpp_typecheckt::check_member_initializers(
 
           // check for a indirect parent
           irep_idt identifier = parent_it->type().identifier();
-          const symbolt &isymb = lookup(identifier);
+          const symbolt &isymb = *lookup(identifier);
           const typet &type = isymb.type;
           assert(type.id() == "struct");
           const irept &ibase = type.find("bases");
@@ -665,7 +665,7 @@ void cpp_typecheckt::full_member_initialization(
 
     while(!vbases.empty())
     {
-      const symbolt &symb = lookup(vbases.front());
+      const symbolt &symb = *lookup(vbases.front());
       if(!cpp_is_pod(symb.type))
       {
         // default initializer
@@ -691,7 +691,7 @@ void cpp_typecheckt::full_member_initialization(
     assert(parent_it->id() == "base");
     assert(parent_it->get("type") == "symbol");
 
-    const symbolt &ctorsymb = lookup(parent_it->type().identifier());
+    const symbolt &ctorsymb = *lookup(parent_it->type().identifier());
 
     if(cpp_is_pod(ctorsymb.type))
       continue;
@@ -751,7 +751,7 @@ void cpp_typecheckt::full_member_initialization(
 
       // initialize the indirect parent
       irep_idt identifier = parent_it->type().identifier();
-      const symbolt &isymb = lookup(identifier);
+      const symbolt &isymb = *lookup(identifier);
       const typet &type = isymb.type;
       assert(type.id() == "struct");
       const irept &ibase = type.find("bases");
@@ -820,9 +820,9 @@ void cpp_typecheckt::full_member_initialization(
       cppname.move_to_sub(name);
 
       const symbolt &virtual_table_symbol_type =
-        lookup(mem_it->type().subtype().identifier());
+        *lookup(mem_it->type().subtype().identifier());
 
-      const symbolt &virtual_table_symbol_var = lookup(
+      const symbolt &virtual_table_symbol_var = *lookup(
         virtual_table_symbol_type.id.as_string() + "@" +
         struct_type.name().as_string());
 
@@ -1062,9 +1062,9 @@ void cpp_typecheckt::dtor(
       cppname.move_to_sub(name);
 
       const symbolt &virtual_table_symbol_type =
-        namespacet(context).lookup(cit->type().subtype().identifier());
+        *namespacet(context).lookup(cit->type().subtype().identifier());
 
-      const symbolt &virtual_table_symbol_var = namespacet(context).lookup(
+      const symbolt &virtual_table_symbol_var = *namespacet(context).lookup(
         virtual_table_symbol_type.id.as_string() + "@" + symb.id.as_string());
 
       exprt var = symbol_expr(virtual_table_symbol_var);
@@ -1126,7 +1126,7 @@ void cpp_typecheckt::dtor(
   {
     assert(bit->id() == "base");
     assert(bit->type().id() == "symbol");
-    const symbolt &psymb = lookup(bit->type().identifier());
+    const symbolt &psymb = *lookup(bit->type().identifier());
 
     exprt object("dereference");
     object.operands().emplace_back("cpp-this");
diff --git a/src/cpp/cpp_typecheck_conversions.cpp b/src/cpp/cpp_typecheck_conversions.cpp
index b3fc29de5..b11cec456 100644
--- a/src/cpp/cpp_typecheck_conversions.cpp
+++ b/src/cpp/cpp_typecheck_conversions.cpp
@@ -1306,8 +1306,8 @@ bool cpp_typecheckt::dynamic_typecast(
     irep_idt badcast_identifier = "std::tag.bad_cast";
 
     // We must check if the user included typeinfo
-    const symbolt *bad_cast_symbol;
-    bool is_included = lookup(badcast_identifier, bad_cast_symbol);
+    const symbolt *bad_cast_symbol = lookup(badcast_identifier);
+    bool is_included = !bad_cast_symbol;
 
     if(is_included)
       throw "Error: must #include <typeinfo>. Bad_cast throw";
@@ -1372,11 +1372,11 @@ bool cpp_typecheckt::dynamic_typecast(
         symbolt t;
         if(e.identifier() != "")
         {
-          t = lookup(e.identifier());
+          t = *lookup(e.identifier());
         }
         else if(e.op0().identifier() != "") // Array
         {
-          t = lookup(e.op0().identifier());
+          t = *lookup(e.op0().identifier());
         }
         else
           return false;
diff --git a/src/cpp/cpp_typecheck_expr.cpp b/src/cpp/cpp_typecheck_expr.cpp
index 74decc21f..f9335a924 100644
--- a/src/cpp/cpp_typecheck_expr.cpp
+++ b/src/cpp/cpp_typecheck_expr.cpp
@@ -31,7 +31,7 @@ bool cpp_typecheckt::find_parent(
 {
   forall_irep(bit, symb.type.find("bases").get_sub())
   {
-    if(lookup(bit->type().identifier()).name == base_name)
+    if(lookup(bit->type().identifier())->name == base_name)
     {
       identifier = bit->type().identifier();
       return true;
@@ -593,7 +593,7 @@ void cpp_typecheckt::typecheck_expr_address_of(exprt &expr)
   {
     // we take the address of the method.
     assert(expr.op0().id() == "member");
-    exprt symb = cpp_symbol_expr(lookup(expr.op0().component_name()));
+    exprt symb = cpp_symbol_expr(*lookup(expr.op0().component_name()));
     exprt address("address_of", typet("pointer"));
     address.copy_to_operands(symb);
     address.type().subtype() = symb.type();
@@ -840,7 +840,7 @@ void cpp_typecheckt::typecheck_expr_this(exprt &expr)
   if(cpp_scopes.current_scope().class_identifier.empty())
   {
     err_location(expr);
-    error("`this' is not allowed here");
+    log_error("`this' is not allowed here");
     throw 0;
   }
 
@@ -955,12 +955,12 @@ void cpp_typecheckt::typecheck_expr_member(
 
   typet op_type = op0.type();
   // Follow symbolic types up until the last one.
-  while(lookup(op_type.identifier()).type.id() == "symbol")
-    op_type = lookup(op_type.identifier()).type;
+  while(lookup(op_type.identifier())->type.id() == "symbol")
+    op_type = lookup(op_type.identifier())->type;
 
   const irep_idt &struct_identifier = to_symbol_type(op_type).get_identifier();
 
-  const symbolt &struct_symbol = lookup(struct_identifier);
+  const symbolt &struct_symbol = *lookup(struct_identifier);
 
   if(
     struct_symbol.type.id() == "incomplete_struct" ||
@@ -1021,7 +1021,7 @@ void cpp_typecheckt::typecheck_expr_member(
         symbol_expr.type().get("return_type") == "constructor")
       {
         err_location(expr);
-        str << "error: member `" << lookup(symbol_expr.identifier()).name
+        str << "error: member `" << lookup(symbol_expr.identifier())->name
             << "' is a constructor";
         throw 0;
       }
@@ -1369,7 +1369,7 @@ void cpp_typecheckt::typecheck_expr_typeid(exprt &expr)
 
     // If the object on typeid is a null pointer we must
     // throw a bad_typeid exception
-    symbolt pointer_symbol = lookup(arguments.identifier());
+    symbolt pointer_symbol = *lookup(arguments.identifier());
 
     if(pointer_symbol.value.value() == "NULL")
     {
@@ -1379,8 +1379,8 @@ void cpp_typecheckt::typecheck_expr_typeid(exprt &expr)
       irep_idt bad_typeid_identifier = "std::tag.bad_typeid";
 
       // We must check if the user included typeinfo
-      const symbolt *bad_typeid_symbol;
-      bool is_included = lookup(bad_typeid_identifier, bad_typeid_symbol);
+      const symbolt *bad_typeid_symbol = lookup(bad_typeid_identifier);
+      bool is_included = !bad_typeid_symbol;
 
       if(is_included)
         throw "Error: must #include <typeinfo> before using typeid";
@@ -1402,7 +1402,7 @@ void cpp_typecheckt::typecheck_expr_typeid(exprt &expr)
     if(arguments.type().id() == "incomplete_array")
     {
       err_location(arguments.location());
-      str << "storage size of " << lookup(arguments.identifier()).name;
+      str << "storage size of " << lookup(arguments.identifier())->name;
       str << " isnt known\n";
       throw 0;
     }
@@ -1891,7 +1891,7 @@ void cpp_typecheckt::typecheck_method_application(
   exprt member_expr;
   member_expr.swap(expr.function());
 
-  const symbolt &symbol = lookup(member_expr.component_name());
+  const symbolt &symbol = *lookup(member_expr.component_name());
 
   // build new function expression
   exprt new_function(cpp_symbol_expr(symbol));
@@ -1975,8 +1975,8 @@ void cpp_typecheckt::typecheck_side_effect_assignment(exprt &expr)
       //Array
       else if(expr.op0().type().subtype().identifier() != "")
       {
-        const symbolt *symbol;
-        bool is_included = lookup(expr.op0().op0().identifier(), symbol);
+        const symbolt *symbol = lookup(expr.op0().op0().identifier());
+        bool is_included = !symbol;
 
         if(expr.op1().has_operands())
         {
diff --git a/src/cpp/cpp_typecheck_find_constructor.cpp b/src/cpp/cpp_typecheck_find_constructor.cpp
deleted file mode 100644
index b5cc3b3c0..000000000
--- a/src/cpp/cpp_typecheck_find_constructor.cpp
+++ /dev/null
@@ -1,61 +0,0 @@
-/*******************************************************************\
-
-Module: C++ Language Type Checking
-
-Author: Daniel Kroening, kroening@cs.cmu.edu
-
-\*******************************************************************/
-
-#include <cpp/cpp_typecheck.h>
-#include <util/type_eq.h>
-
-void cpp_typecheckt::find_constructor(
-  const typet &start_dest_type,
-  exprt &constructor_expr)
-{
-  constructor_expr.make_nil();
-
-  locationt location = start_dest_type.location();
-  typet dest_type(start_dest_type);
-  follow_symbol(dest_type);
-
-  if(dest_type.id() != "struct")
-    return;
-
-  const struct_typet::componentst &components =
-    to_struct_type(dest_type).components();
-
-  for(const auto &component : components)
-  {
-    const typet &type = component.type();
-
-    if(type.return_type().id() == "constructor")
-    {
-      const irept::subt &arguments = type.arguments().get_sub();
-
-      namespacet ns(context);
-
-      if(arguments.size() == 1)
-      {
-        const exprt &argument = (exprt &)arguments.front();
-        const typet &arg_type = argument.type();
-
-        if(
-          arg_type.id() == "pointer" &&
-          type_eq(arg_type.subtype(), dest_type, ns))
-        {
-          // found!
-          const irep_idt &identifier = component.name();
-
-          if(identifier == "")
-            throw "constructor without identifier";
-
-          constructor_expr = exprt("symbol", type);
-          constructor_expr.identifier(identifier);
-          constructor_expr.location() = location;
-          return;
-        }
-      }
-    }
-  }
-}
diff --git a/src/cpp/cpp_typecheck_function.cpp b/src/cpp/cpp_typecheck_function.cpp
index 9cdd29151..e91370cd1 100644
--- a/src/cpp/cpp_typecheck_function.cpp
+++ b/src/cpp/cpp_typecheck_function.cpp
@@ -87,7 +87,7 @@ void cpp_typecheckt::convert_function(symbolt &symbol)
   // if it is a destructor, add the implicit code
   if(symbol.type.get("return_type") == "destructor")
   {
-    const symbolt &msymb = lookup(symbol.type.get("#member_name"));
+    const symbolt &msymb = *lookup(symbol.type.get("#member_name"));
 
     assert(symbol.value.id() == "code");
     assert(symbol.value.statement() == "block");
diff --git a/src/cpp/cpp_typecheck_initializer.cpp b/src/cpp/cpp_typecheck_initializer.cpp
index a7bcb5642..cf0a4e7c3 100644
--- a/src/cpp/cpp_typecheck_initializer.cpp
+++ b/src/cpp/cpp_typecheck_initializer.cpp
@@ -109,8 +109,8 @@ void cpp_typecheckt::convert_initializer(symbolt &symbol)
       }
       else if(resolved_expr.id() == "member")
       {
-        symbol.value =
-          address_of_exprt(symbol_expr(lookup(resolved_expr.component_name())));
+        symbol.value = address_of_exprt(
+          symbol_expr(*lookup(resolved_expr.component_name())));
 
         symbol.value.type().add("to-member") = resolved_expr.op0().type();
       }
diff --git a/src/cpp/cpp_typecheck_resolve.cpp b/src/cpp/cpp_typecheck_resolve.cpp
index 20f736762..b71e59df5 100644
--- a/src/cpp/cpp_typecheck_resolve.cpp
+++ b/src/cpp/cpp_typecheck_resolve.cpp
@@ -115,7 +115,7 @@ void cpp_typecheck_resolvet::guess_function_template_args(
     assert(e.id() == "template_function_instance");
 
     const symbolt &template_symbol =
-      cpp_typecheck.lookup(e.type().get("#template"));
+      *cpp_typecheck.lookup(e.type().get("#template"));
 
     const cpp_template_args_tct &template_args =
       to_cpp_template_args_tc(e.type().find("#template_arguments"));
@@ -247,7 +247,7 @@ void cpp_typecheck_resolvet::disambiguate_copy_constructor(
     // template flag.
     const irep_idt &name =
       (it->id() == "symbol") ? it->identifier() : it->component_name();
-    const symbolt &sym = cpp_typecheck.lookup(name);
+    const symbolt &sym = *cpp_typecheck.lookup(name);
     if(sym.value.get("#speculative_template") == "1")
       it = identifiers.erase(it);
     else
@@ -266,7 +266,7 @@ exprt cpp_typecheck_resolvet::convert_template_argument(
     // No. In that case, see whether we've picked up the template argument from
     // the instantiation scope, which will mean it has a type attached.
 
-    const symbolt &sym = cpp_typecheck.lookup(identifier.identifier);
+    const symbolt &sym = *cpp_typecheck.lookup(identifier.identifier);
     exprt e2;
     if(sym.is_type)
     {
@@ -283,10 +283,10 @@ exprt cpp_typecheck_resolvet::convert_template_argument(
 
     if(e2.is_nil() || e2.type().is_nil())
     {
-      cpp_typecheck.err_location(location);
-      cpp_typecheck.str
-        << "internal error: template parameter without instance:" << std::endl
-        << identifier << std::endl;
+      location.dump();
+      str << "internal error: template parameter without instance:" << std::endl
+          << identifier << std::endl;
+      log_error(str.str());
       throw 0;
     }
 
@@ -315,7 +315,7 @@ exprt cpp_typecheck_resolvet::convert_identifier(
     // a regular struct or union member
 
     const symbolt &class_symbol =
-      cpp_typecheck.lookup(identifier.class_identifier);
+      *cpp_typecheck.lookup(identifier.class_identifier);
 
     assert(
       class_symbol.type.id() == "struct" || class_symbol.type.id() == "union");
@@ -414,7 +414,7 @@ exprt cpp_typecheck_resolvet::convert_identifier(
       {
         // this has to be a method
         if(identifier.is_method)
-          e = cpp_symbol_expr(cpp_typecheck.lookup(identifier.identifier));
+          e = cpp_symbol_expr(*cpp_typecheck.lookup(identifier.identifier));
         else
           e.make_nil();
       }
@@ -422,7 +422,7 @@ exprt cpp_typecheck_resolvet::convert_identifier(
   }
   else
   {
-    const symbolt &symbol = cpp_typecheck.lookup(identifier.identifier);
+    const symbolt &symbol = *cpp_typecheck.lookup(identifier.identifier);
 
     if(symbol.is_type)
     {
@@ -448,7 +448,7 @@ exprt cpp_typecheck_resolvet::convert_identifier(
 
       while(followed_type.id() == "symbol")
       {
-        typet tmp = cpp_typecheck.lookup(followed_type).type;
+        typet tmp = cpp_typecheck.lookup(followed_type)->type;
         followed_type = tmp;
         constant |= followed_type.cmt_constant();
       }
@@ -526,7 +526,7 @@ void cpp_typecheck_resolvet::filter(
   for(auto it : old_set)
   {
     // OK; what kind of template are we dealing with here...
-    const symbolt &sym = cpp_typecheck.lookup(it->identifier);
+    const symbolt &sym = *cpp_typecheck.lookup(it->identifier);
     if(sym.type.type().id() == "struct")
       id_set.insert(it);
   }
@@ -733,14 +733,14 @@ void cpp_typecheck_resolvet::make_constructors(
     {
       cpp_save_scopet cpp_saved_scope(cpp_typecheck.cpp_scopes);
       cpp_typecheck.cpp_scopes.set_scope(struct_type.name());
-      const symbolt &the_sym = cpp_typecheck.lookup(struct_type.name());
+      const symbolt &the_sym = *cpp_typecheck.lookup(struct_type.name());
 
       cpp_scopest::id_sett id_set;
       cpp_typecheck.cpp_scopes.get_ids(the_sym.name, id_set, true);
 
       for(auto it : id_set)
       {
-        const symbolt &sub_sym = cpp_typecheck.lookup(it->identifier);
+        const symbolt &sub_sym = *cpp_typecheck.lookup(it->identifier);
 
         // Pick out member expressions that are constructors
         if(
@@ -773,7 +773,7 @@ exprt cpp_typecheck_resolvet::do_builtin(
   {
     if(arguments.size() != 1)
     {
-      cpp_typecheck.err_location(location);
+      err_location(location);
       throw id2string(base_name) +
         " expects one template argument, "
         "but got " +
@@ -784,7 +784,7 @@ exprt cpp_typecheck_resolvet::do_builtin(
 
     if(argument.id() == "type")
     {
-      cpp_typecheck.err_location(location);
+      location.dump();
       throw id2string(base_name) +
         " expects one integer template argument, "
         "but got type";
@@ -793,13 +793,13 @@ exprt cpp_typecheck_resolvet::do_builtin(
     BigInt i;
     if(to_integer(argument, i))
     {
-      cpp_typecheck.err_location(location);
+      location.dump();
       throw "template argument must be constant";
     }
 
     if(i < 1)
     {
-      cpp_typecheck.err_location(location);
+      location.dump();
       throw "template argument must be greater than zero";
     }
 
@@ -810,7 +810,7 @@ exprt cpp_typecheck_resolvet::do_builtin(
   {
     if(arguments.size() != 2)
     {
-      cpp_typecheck.err_location(location);
+      err_location(location);
       throw id2string(base_name) +
         " expects two template arguments, "
         "but got " +
@@ -822,7 +822,7 @@ exprt cpp_typecheck_resolvet::do_builtin(
 
     if(argument0.id() == "type")
     {
-      cpp_typecheck.err_location(argument0);
+      err_location(argument0);
       throw id2string(base_name) +
         " expects two integer template arguments, "
         "but got type";
@@ -830,7 +830,7 @@ exprt cpp_typecheck_resolvet::do_builtin(
 
     if(argument1.id() == "type")
     {
-      cpp_typecheck.err_location(argument1);
+      err_location(argument1);
       throw id2string(base_name) +
         " expects two integer template arguments, "
         "but got type";
@@ -840,31 +840,31 @@ exprt cpp_typecheck_resolvet::do_builtin(
 
     if(to_integer(argument0, width))
     {
-      cpp_typecheck.err_location(argument0);
+      err_location(argument0);
       throw "template argument must be constant";
     }
 
     if(to_integer(argument1, integer_bits))
     {
-      cpp_typecheck.err_location(argument1);
+      err_location(argument1);
       throw "template argument must be constant";
     }
 
     if(width < 1)
     {
-      cpp_typecheck.err_location(argument0);
+      err_location(argument0);
       throw "template argument must be greater than zero";
     }
 
     if(integer_bits < 0)
     {
-      cpp_typecheck.err_location(argument1);
+      err_location(argument1);
       throw "template argument must be greater or equal zero";
     }
 
     if(integer_bits > width)
     {
-      cpp_typecheck.err_location(argument1);
+      err_location(argument1);
       throw "template argument must be smaller or equal width";
     }
 
@@ -880,27 +880,25 @@ exprt cpp_typecheck_resolvet::do_builtin(
   else if(base_name == "dump_scopes")
   {
     dest = exprt("constant", typet("empty"));
-    cpp_typecheck.str << "Scopes in location " << location << std::endl;
-    cpp_typecheck.cpp_scopes.get_root_scope().print(cpp_typecheck.str);
-    cpp_typecheck.warning();
+    str << "Scopes in location " << location << std::endl;
+    cpp_typecheck.cpp_scopes.get_root_scope().print(str);
+    log_warning(str.str());
   }
   else if(base_name == "current_scope")
   {
     dest = exprt("constant", typet("empty"));
-    cpp_typecheck.str << "Scope in location " << location << ": "
-                      << original_scope->prefix;
-    cpp_typecheck.warning();
+    str << "Scope in location " << location << ": " << original_scope->prefix;
+    log_warning(str.str());
   }
   else if(base_name == "context")
   {
     dest = exprt("constant", typet("empty"));
     cpp_typecheck.context.dump();
-    cpp_typecheck.warning();
   }
   else
   {
-    cpp_typecheck.err_location(location);
-    cpp_typecheck.str << "unknown built-in identifier: " << base_name;
+    err_location(location);
+    str << "unknown built-in identifier: " << base_name;
     throw 0;
   }
 
@@ -989,16 +987,16 @@ cpp_scopet &cpp_typecheck_resolvet::resolve_scope(
 
         if(id_set.empty())
         {
-          cpp_typecheck.show_instantiation_stack(cpp_typecheck.str);
-          cpp_typecheck.err_location(location);
-          cpp_typecheck.str << "scope `" << final_base_name << "' not found";
+          cpp_typecheck.show_instantiation_stack(str);
+          err_location(location);
+          str << "scope `" << final_base_name << "' not found";
           throw 0;
         }
         if(id_set.size() >= 2)
         {
-          cpp_typecheck.show_instantiation_stack(cpp_typecheck.str);
-          cpp_typecheck.err_location(location);
-          cpp_typecheck.str << "scope `" << final_base_name << "' is ambiguous";
+          cpp_typecheck.show_instantiation_stack(str);
+          err_location(location);
+          str << "scope `" << final_base_name << "' is ambiguous";
           throw 0;
         }
 
@@ -1048,9 +1046,9 @@ const symbolt &cpp_typecheck_resolvet::disambiguate_template_classes(
 {
   if(id_set.empty())
   {
-    cpp_typecheck.show_instantiation_stack(cpp_typecheck.str);
-    cpp_typecheck.err_location(location);
-    cpp_typecheck.str << "template scope `" << base_name << "' not found";
+    cpp_typecheck.show_instantiation_stack(str);
+    err_location(location);
+    str << "template scope `" << base_name << "' not found";
     throw 0;
   }
 
@@ -1060,7 +1058,7 @@ const symbolt &cpp_typecheck_resolvet::disambiguate_template_classes(
   {
     const irep_idt id = it->identifier;
 
-    const symbolt &s = cpp_typecheck.lookup(id);
+    const symbolt &s = *cpp_typecheck.lookup(id);
     if(!s.type.get_bool("is_template"))
       continue;
 
@@ -1079,16 +1077,16 @@ const symbolt &cpp_typecheck_resolvet::disambiguate_template_classes(
 
   if(primary_templates.size() >= 2)
   {
-    cpp_typecheck.show_instantiation_stack(cpp_typecheck.str);
-    cpp_typecheck.err_location(location);
-    cpp_typecheck.str << "template scope `" << base_name << "' is ambiguous";
+    cpp_typecheck.show_instantiation_stack(str);
+    err_location(location);
+    str << "template scope `" << base_name << "' is ambiguous";
     throw 0;
   }
 
   assert(primary_templates.size() == 1);
 
   const symbolt &primary_template_symbol =
-    cpp_typecheck.lookup(*primary_templates.begin());
+    *cpp_typecheck.lookup(*primary_templates.begin());
 
   // We typecheck the template arguments in the context
   // of the original scope!
@@ -1116,7 +1114,7 @@ const symbolt &cpp_typecheck_resolvet::disambiguate_template_classes(
   for(auto it : id_set)
   {
     const irep_idt id = it->identifier;
-    const symbolt &s = cpp_typecheck.lookup(id);
+    const symbolt &s = *cpp_typecheck.lookup(id);
 
     irep_idt specialization_of = s.type.get("specialization_of");
     if(specialization_of == "")
@@ -1146,8 +1144,8 @@ const symbolt &cpp_typecheck_resolvet::disambiguate_template_classes(
 
     if(template_scope == nullptr)
     {
-      cpp_typecheck.err_location(location);
-      cpp_typecheck.str << "template identifier: " << id << std::endl;
+      err_location(location);
+      str << "template identifier: " << id << std::endl;
       throw "class template instantiation error";
     }
 
@@ -1260,7 +1258,7 @@ const symbolt &cpp_typecheck_resolvet::disambiguate_template_classes(
       match = zero_distance_matches.at(0);
   }
 
-  const symbolt &choice = cpp_typecheck.lookup(match.id);
+  const symbolt &choice = *cpp_typecheck.lookup(match.id);
 
   // build instance
   const symbolt &instance = cpp_typecheck.instantiate_template(
@@ -1271,8 +1269,8 @@ const symbolt &cpp_typecheck_resolvet::disambiguate_template_classes(
     instance.type.id() != "incomplete_struct" &&
     instance.type.id() != "symbol") // Recursive template def.
   {
-    cpp_typecheck.err_location(location);
-    cpp_typecheck.str << "template `" << base_name << "' is not a class";
+    err_location(location);
+    str << "template `" << base_name << "' is not a class";
     throw 0;
   }
 
@@ -1298,8 +1296,8 @@ cpp_scopet &cpp_typecheck_resolvet::resolve_namespace(const cpp_namet &cpp_name)
 
   if(id_set.empty())
   {
-    cpp_typecheck.err_location(location);
-    cpp_typecheck.str << "namespace `" << base_name << "' not found";
+    err_location(location);
+    str << "namespace `" << base_name << "' not found";
     throw 0;
   }
   if(id_set.size() == 1)
@@ -1309,8 +1307,8 @@ cpp_scopet &cpp_typecheck_resolvet::resolve_namespace(const cpp_namet &cpp_name)
   }
   else
   {
-    cpp_typecheck.err_location(location);
-    cpp_typecheck.str << "namespace `" << base_name << "' is ambigous";
+    err_location(location);
+    str << "namespace `" << base_name << "' is ambigous";
     throw 0;
   }
 }
@@ -1357,7 +1355,7 @@ void cpp_typecheck_resolvet::show_identifiers(
 
       if(id_expr.type().get_bool("is_template"))
       {
-        out << cpp_typecheck.lookup(to_symbol_expr(id_expr)).name;
+        out << cpp_typecheck.lookup(to_symbol_expr(id_expr))->name;
       }
       else if(id_expr.type().id() == "code")
       {
@@ -1393,20 +1391,20 @@ void cpp_typecheck_resolvet::show_identifiers(
 
       if(id_expr.id() == "symbol")
       {
-        const symbolt &symbol = cpp_typecheck.lookup(to_symbol_expr(id_expr));
+        const symbolt &symbol = *cpp_typecheck.lookup(to_symbol_expr(id_expr));
         out << " (" << symbol.location << ")";
       }
       else if(id_expr.id() == "member")
       {
-        const symbolt *symbol;
-        bool found = cpp_typecheck.lookup(id_expr.component_name(), symbol);
+        const symbolt *symbol = cpp_typecheck.lookup(id_expr.component_name());
+        bool found = !symbol;
         if(!found)
           out << " (" << symbol->location << ")";
       }
       else if(id_expr.id() == "template_function_instance")
       {
         const symbolt &symbol =
-          cpp_typecheck.lookup(id_expr.type().get("#template"));
+          *cpp_typecheck.lookup(id_expr.type().get("#template"));
         out << " (" << symbol.location << ")";
       }
     }
@@ -1493,18 +1491,17 @@ exprt cpp_typecheck_resolvet::resolve(
     if(!fail_with_exception)
       return nil_exprt();
 
-    cpp_typecheck.show_instantiation_stack(cpp_typecheck.str);
-    cpp_typecheck.err_location(location);
-    cpp_typecheck.str << "symbol `" << base_name << "' not found";
+    cpp_typecheck.show_instantiation_stack(str);
+    err_location(location);
+    str << "symbol `" << base_name << "' not found";
 
     if(qualified)
     {
       if(cpp_typecheck.cpp_scopes.current_scope().is_root_scope())
-        cpp_typecheck.str << " in root scope";
+        str << " in root scope";
       else
-        cpp_typecheck.str << " in scope `"
-                          << cpp_typecheck.cpp_scopes.current_scope().prefix
-                          << "'";
+        str << " in scope `" << cpp_typecheck.cpp_scopes.current_scope().prefix
+            << "'";
     }
 
     //cpp_typecheck.cpp_scopes.get_root_scope().print(std::cout);
@@ -1523,7 +1520,7 @@ exprt cpp_typecheck_resolvet::resolve(
     for(auto it : id_set)
     {
       const irep_idt id = it->identifier;
-      const symbolt &s = cpp_typecheck.lookup(id);
+      const symbolt &s = *cpp_typecheck.lookup(id);
       assert(s.type.get_bool("is_template"));
       if(to_cpp_declaration(s.type).is_class_template())
         have_classes = true;
@@ -1536,9 +1533,9 @@ exprt cpp_typecheck_resolvet::resolve(
       if(!fail_with_exception)
         return nil_exprt();
 
-      cpp_typecheck.show_instantiation_stack(cpp_typecheck.str);
-      cpp_typecheck.err_location(location);
-      cpp_typecheck.str << "template symbol `" << base_name << "' is ambiguous";
+      cpp_typecheck.show_instantiation_stack(str);
+      err_location(location);
+      str << "template symbol `" << base_name << "' is ambiguous";
       throw 0;
     }
 
@@ -1551,7 +1548,7 @@ exprt cpp_typecheck_resolvet::resolve(
       {
         const irep_idt id = it->identifier;
 
-        const symbolt &s = cpp_typecheck.lookup(id);
+        const symbolt &s = *cpp_typecheck.lookup(id);
         if(!s.type.get_bool("is_template"))
           continue;
 
@@ -1632,35 +1629,34 @@ exprt cpp_typecheck_resolvet::resolve(
 
     if(new_identifiers.empty())
     {
-      cpp_typecheck.err_location(location);
-      cpp_typecheck.str << "found no match for symbol `" << base_name
-                        << "', candidates are:" << std::endl;
-      show_identifiers(base_name, identifiers, cpp_typecheck.str);
+      err_location(location);
+      str << "found no match for symbol `" << base_name
+          << "', candidates are:" << std::endl;
+      show_identifiers(base_name, identifiers, str);
     }
     else
     {
-      cpp_typecheck.err_location(location);
-      cpp_typecheck.str << "symbol `" << base_name
-                        << "' does not uniquely resolve:" << std::endl;
-      show_identifiers(base_name, new_identifiers, cpp_typecheck.str);
+      err_location(location);
+      str << "symbol `" << base_name
+          << "' does not uniquely resolve:" << std::endl;
+      show_identifiers(base_name, new_identifiers, str);
     }
 
     if(fargs.in_use)
     {
-      cpp_typecheck.str << std::endl;
-      cpp_typecheck.str << "argument types:" << std::endl;
+      str << std::endl;
+      str << "argument types:" << std::endl;
 
       for(const auto &operand : fargs.operands)
       {
-        cpp_typecheck.str << "  " << cpp_typecheck.to_string(operand.type())
-                          << std::endl;
+        str << "  " << cpp_typecheck.to_string(operand.type()) << std::endl;
       }
     }
 
     if(!cpp_typecheck.instantiation_stack.empty())
     {
-      cpp_typecheck.str << std::endl;
-      cpp_typecheck.show_instantiation_stack(cpp_typecheck.str);
+      str << std::endl;
+      cpp_typecheck.show_instantiation_stack(str);
     }
 
     throw 0;
@@ -1674,10 +1670,10 @@ exprt cpp_typecheck_resolvet::resolve(
       if(!fail_with_exception)
         return nil_exprt();
 
-      cpp_typecheck.err_location(location);
+      err_location(location);
 
-      cpp_typecheck.str << "error: expected expression, but got type `"
-                        << cpp_typecheck.to_string(result.type()) << "'";
+      str << "error: expected expression, but got type `"
+          << cpp_typecheck.to_string(result.type()) << "'";
 
       throw 0;
     }
@@ -1689,10 +1685,10 @@ exprt cpp_typecheck_resolvet::resolve(
       if(!fail_with_exception)
         return nil_exprt();
 
-      cpp_typecheck.err_location(location);
+      err_location(location);
 
-      cpp_typecheck.str << "error: expected type, but got expression `"
-                        << cpp_typecheck.to_string(result) << "'";
+      str << "error: expected type, but got expression `"
+          << cpp_typecheck.to_string(result) << "'";
 
       throw 0;
     }
@@ -1905,7 +1901,7 @@ bool cpp_typecheck_resolvet::guess_template_args(
         // Does the argument type we're dealing with already have assigned
         // template arguments in its type?
         symbolt &s = const_cast<symbolt &>(
-          cpp_typecheck.lookup(desired_type.identifier()));
+          *cpp_typecheck.lookup(desired_type.identifier()));
         exprt &template_arguments = const_cast<exprt &>(
           static_cast<const exprt &>(s.type.find("#template_arguments")));
 
@@ -1929,7 +1925,7 @@ bool cpp_typecheck_resolvet::guess_template_args(
             if(parent.id_class == cpp_idt::ROOT_SCOPE)
               break;
 
-            const symbolt &s2 = cpp_typecheck.lookup(parent.identifier);
+            const symbolt &s2 = *cpp_typecheck.lookup(parent.identifier);
 
             const exprt &template_arguments2 =
               static_cast<const exprt &>(s2.type.find("#template_arguments"));
@@ -2130,7 +2126,7 @@ exprt cpp_typecheck_resolvet::guess_function_template_args(
 
   irep_idt template_identifier = to_symbol_expr(expr).get_identifier();
 
-  const symbolt &template_symbol = cpp_typecheck.lookup(template_identifier);
+  const symbolt &template_symbol = *cpp_typecheck.lookup(template_identifier);
 
   // alright, set up template arguments as 'unassigned'
 
@@ -2147,7 +2143,7 @@ exprt cpp_typecheck_resolvet::guess_function_template_args(
   // and that needs to have function type
   if(function_declarator.type().id() != "function_type")
   {
-    cpp_typecheck.err_location(location);
+    err_location(location);
     throw "expected function type for function template";
   }
 
@@ -2159,9 +2155,8 @@ exprt cpp_typecheck_resolvet::guess_function_template_args(
 
   if(template_scope == nullptr)
   {
-    cpp_typecheck.err_location(location);
-    cpp_typecheck.str << "template identifier: " << template_identifier
-                      << std::endl;
+    err_location(location);
+    str << "template identifier: " << template_identifier << std::endl;
     throw "function template instantiation error";
   }
 
@@ -2245,7 +2240,7 @@ void cpp_typecheck_resolvet::apply_template_args(
   if(expr.id() != "symbol")
     return; // templates are always symbols
 
-  const symbolt &template_symbol = cpp_typecheck.lookup(expr.identifier());
+  const symbolt &template_symbol = *cpp_typecheck.lookup(expr.identifier());
 
   if(!template_symbol.type.get_bool("is_template"))
     return;
@@ -2308,9 +2303,9 @@ void cpp_typecheck_resolvet::apply_template_args(
       // do we have an object?
       if(fargs.has_object)
         type_symb =
-          cpp_typecheck.lookup(fargs.operands.begin()->type().identifier());
+          *cpp_typecheck.lookup(fargs.operands.begin()->type().identifier());
       else
-        type_symb = cpp_typecheck.lookup(original_scope->class_identifier);
+        type_symb = *cpp_typecheck.lookup(original_scope->class_identifier);
 
       assert(type_symb.type.id() == "struct");
 
@@ -2440,7 +2435,7 @@ void cpp_typecheck_resolvet::filter_for_named_scopes(
       if(id.is_member)
       {
         struct_typet struct_type = static_cast<const struct_typet &>(
-          cpp_typecheck.lookup(id.class_identifier).type);
+          cpp_typecheck.lookup(id.class_identifier)->type);
         const exprt pcomp = struct_type.get_component(identifier);
         assert(pcomp.is_not_nil());
         assert(pcomp.is_type());
@@ -2454,7 +2449,7 @@ void cpp_typecheck_resolvet::filter_for_named_scopes(
 
       while(true)
       {
-        const symbolt &symbol = cpp_typecheck.lookup(identifier);
+        const symbolt &symbol = *cpp_typecheck.lookup(identifier);
         assert(symbol.is_type);
 
         // todo? maybe do enum here, too?
@@ -2475,7 +2470,7 @@ void cpp_typecheck_resolvet::filter_for_named_scopes(
     }
     else if(id.id_class == cpp_scopet::TEMPLATE)
     {
-      const symbolt symbol = cpp_typecheck.lookup(id.identifier);
+      const symbolt &symbol = *cpp_typecheck.lookup(id.identifier);
       if(symbol.type.get("type") == "struct")
         new_set.insert(&id);
     }
@@ -2496,7 +2491,7 @@ void cpp_typecheck_resolvet::filter_for_named_scopes(
         {
           irep_idt identifier = type.identifier();
 
-          const symbolt &symbol = cpp_typecheck.lookup(identifier);
+          const symbolt &symbol = *cpp_typecheck.lookup(identifier);
           assert(symbol.is_type);
 
           if(symbol.type.id() == "symbol")
diff --git a/src/cpp/cpp_typecheck_resolve.h b/src/cpp/cpp_typecheck_resolve.h
index 316965601..2e9c66e68 100644
--- a/src/cpp/cpp_typecheck_resolve.h
+++ b/src/cpp/cpp_typecheck_resolve.h
@@ -30,7 +30,7 @@ public:
     const wantt want,
     const cpp_typecheck_fargst &fargs,
     bool fail_with_exception = true);
-
+  std::ostringstream str;
   // Returns the scope as a side-effect as 'current_scope'.
   // Should really return explicitly.
   cpp_scopet &resolve_scope(
diff --git a/src/cpp/cpp_typecheck_template.cpp b/src/cpp/cpp_typecheck_template.cpp
index 868e48662..38d25ca3f 100644
--- a/src/cpp/cpp_typecheck_template.cpp
+++ b/src/cpp/cpp_typecheck_template.cpp
@@ -82,7 +82,7 @@ void cpp_typecheckt::typecheck_class_template(cpp_declarationt &declaration)
       // It is ok to be share the name if it's an specialization
       if(declaration.get_specialization_of() == "")
       {
-        const symbolt &previous = lookup((*id_set.begin())->identifier);
+        const symbolt &previous = *lookup((*id_set.begin())->identifier);
         if(previous.id != symbol_name || id_set.size() > 1)
         {
           err_location(cpp_name.location());
@@ -482,7 +482,7 @@ void cpp_typecheckt::convert_class_template_specialization(
     cpp_scopest::id_sett::iterator next = it;
     next++;
 
-    if(lookup((*it)->identifier).type.find("specialization_of").is_not_nil())
+    if(lookup((*it)->identifier)->type.find("specialization_of").is_not_nil())
       id_set.erase(it);
 
     it = next;
@@ -595,7 +595,7 @@ void cpp_typecheckt::convert_template_function_or_member_specialization(
       str << "template function `" << base_name << "' is ambiguous";
     }
 
-    const symbolt &template_symbol = lookup((*id_set.begin())->identifier);
+    const symbolt &template_symbol = *lookup((*id_set.begin())->identifier);
 
     cpp_template_args_tct template_args = typecheck_template_args(
       declaration.location(),
diff --git a/src/cpp/cpp_typecheck_virtual_table.cpp b/src/cpp/cpp_typecheck_virtual_table.cpp
index ae85e5e4f..1fef40b50 100644
--- a/src/cpp/cpp_typecheck_virtual_table.cpp
+++ b/src/cpp/cpp_typecheck_virtual_table.cpp
@@ -48,8 +48,8 @@ void cpp_typecheckt::do_virtual_table(const symbolt &symbol)
   {
     const std::map<irep_idt, exprt> &value_map = cit->second;
 
-    const symbolt &late_cast_symb = namespacet(context).lookup(cit->first);
-    const symbolt &vt_symb_type = namespacet(context).lookup(
+    const symbolt &late_cast_symb = *namespacet(context).lookup(cit->first);
+    const symbolt &vt_symb_type = *namespacet(context).lookup(
       "virtual_table::" + late_cast_symb.id.as_string());
 
     symbolt vt_symb_var;
diff --git a/src/cpp/parse.cpp b/src/cpp/parse.cpp
index 40379334c..4900b9be5 100644
--- a/src/cpp/parse.cpp
+++ b/src/cpp/parse.cpp
@@ -34,7 +34,6 @@
 #include <util/std_code.h>
 #include <util/std_expr.h>
 #include <util/std_types.h>
-#include <util/message/verbosity.h>
 
 //#define DEBUG
 
@@ -295,9 +294,9 @@ bool Parser::SyntaxError()
         message += t[i].text;
       }
 
-    message += "'";
+    message += "'\nLocation{}";
 
-    parser->print(VerbosityLevel::Error, message, location);
+    log_error(message, location.to_string());
   }
 
   return bool(++number_of_errors < MaxErrors);
@@ -6113,13 +6112,14 @@ bool Parser::rTryStatement(codet &statement)
       if(has_catch_ellipsis)
       {
         std::string message =
-          "... handler must be the last handler for its try block";
+          "... handler must be the last handler for its try block\nLocation: "
+          "{}";
 
         locationt location;
         location.set_file(op.filename);
         location.set_line(i2string(op.line_no));
 
-        parser->print(VerbosityLevel::Error, message, location);
+        log_error(message, location.to_string());
         return false;
       }
 
diff --git a/src/esbmc/CMakeLists.txt b/src/esbmc/CMakeLists.txt
index 961436406..2290ffd30 100644
--- a/src/esbmc/CMakeLists.txt
+++ b/src/esbmc/CMakeLists.txt
@@ -9,6 +9,9 @@ endif()
 if(ENABLE_GOTO_CONTRACTOR)
   set(GOTO_CONTRACTOR_TARGETS gotocontractor)
 endif()
+if(ENABLE_JIMPLE_FRONTEND)
+  set(JIMPLE_FRONTEND_TARGETS jimple)
+endif()
 
 add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/buildidobj.txt
   COMMAND ${Python_EXECUTABLE} ${CMAKE_SOURCE_DIR}/scripts/buildidobj.py ${CMAKE_CURRENT_BINARY_DIR}/buildidobj.txt
@@ -32,8 +35,8 @@ target_include_directories(esbmc
     PRIVATE ${Boost_INCLUDE_DIRS}
 )
 
-target_link_libraries(esbmc ${OLD_FRONTEND_TARGETS} ${SOLIDITY_FRONTEND_TARGETS} ${GOTO_CONTRACTOR_TARGETS} clangcfrontend
-  clangcppfrontend symex pointeranalysis langapi util_esbmc bigint
-  solvers clibs default_message gotoalgorithms nlohmann_json::nlohmann_json ${Boost_LIBRARIES})
+target_link_libraries(esbmc ${OLD_FRONTEND_TARGETS} ${SOLIDITY_FRONTEND_TARGETS} ${GOTO_CONTRACTOR_TARGETS} ${JIMPLE_FRONTEND_TARGETS} clangcfrontend
+  clangcppfrontend filesystem symex pointeranalysis langapi util_esbmc bigint
+  solvers clibs gotoalgorithms ${Boost_LIBRARIES})
 
 install(TARGETS esbmc DESTINATION bin)
diff --git a/src/esbmc/bmc.cpp b/src/esbmc/bmc.cpp
index ec50c5c6c..65d3f1bd3 100644
--- a/src/esbmc/bmc.cpp
+++ b/src/esbmc/bmc.cpp
@@ -1,12 +1,3 @@
-/*******************************************************************\
-
-Module: Symbolic Execution of ANSI-C
-
-Authors: Daniel Kroening, kroening@kroening.com
-         Lucas Cordeiro, lcc08r@ecs.soton.ac.uk
-
-\*******************************************************************/
-
 #include <csignal>
 #include <sys/types.h>
 
@@ -37,36 +28,28 @@ Authors: Daniel Kroening, kroening@kroening.com
 #include <util/i2string.h>
 #include <irep2/irep2.h>
 #include <util/location.h>
-#include <util/message/message_stream.h>
-#include <util/message/format.h>
+
 #include <util/migrate.h>
 #include <util/show_symbol_table.h>
 #include <util/time_stopping.h>
-#include <nlohmann/json.hpp>
-
-bmct::bmct(
-  goto_functionst &funcs,
-  optionst &opts,
-  contextt &_context,
-  const messaget &_message_handler)
-  : options(opts), context(_context), ns(context), msg(_message_handler)
+
+bmct::bmct(goto_functionst &funcs, optionst &opts, contextt &_context)
+  : options(opts), context(_context), ns(context)
 {
   interleaving_number = 0;
   interleaving_failed = 0;
 
   if(options.get_bool_option("smt-during-symex"))
   {
-    runtime_solver =
-      std::shared_ptr<smt_convt>(create_solver_factory("", ns, options, msg));
+    runtime_solver = std::shared_ptr<smt_convt>(create_solver("", ns, options));
 
     symex = std::make_shared<reachability_treet>(
       funcs,
       ns,
       options,
       std::shared_ptr<runtime_encoded_equationt>(
-        new runtime_encoded_equationt(ns, *runtime_solver, msg)),
-      _context,
-      _message_handler);
+        new runtime_encoded_equationt(ns, *runtime_solver)),
+      _context);
   }
   else
   {
@@ -74,10 +57,8 @@ bmct::bmct(
       funcs,
       ns,
       options,
-      std::shared_ptr<symex_target_equationt>(
-        new symex_target_equationt(ns, msg)),
-      _context,
-      _message_handler);
+      std::shared_ptr<symex_target_equationt>(new symex_target_equationt(ns)),
+      _context);
   }
 }
 
@@ -97,9 +78,9 @@ void bmct::successful_trace()
   if(witness_output != "")
   {
     goto_tracet goto_trace;
-    msg.status("Building successful trace");
+    log_status("Building successful trace");
     /* build_successful_goto_trace(eq, ns, goto_trace); */
-    correctness_graphml_goto_trace(options, ns, goto_trace, msg);
+    correctness_graphml_goto_trace(options, ns, goto_trace);
   }
 }
 
@@ -110,7 +91,7 @@ void bmct::error_trace(
   if(options.get_bool_option("result-only"))
     return;
 
-  msg.status("Building error trace");
+  log_status("Building error trace");
 
   bool is_compact_trace = true;
   if(
@@ -119,23 +100,23 @@ void bmct::error_trace(
     is_compact_trace = false;
 
   goto_tracet goto_trace;
-  build_goto_trace(eq, smt_conv, goto_trace, is_compact_trace, msg);
+  build_goto_trace(eq, smt_conv, goto_trace, is_compact_trace);
 
   std::string output_file = options.get_option("cex-output");
   if(output_file != "")
   {
     std::ofstream out(output_file);
-    show_goto_trace(out, ns, goto_trace, msg);
+    show_goto_trace(out, ns, goto_trace);
   }
 
   std::string witness_output = options.get_option("witness-output");
   if(witness_output != "")
-    violation_graphml_goto_trace(options, ns, goto_trace, msg);
+    violation_graphml_goto_trace(options, ns, goto_trace);
 
   std::ostringstream oss;
   oss << "\nCounterexample:\n";
-  show_goto_trace(oss, ns, goto_trace, msg);
-  msg.result(oss.str());
+  show_goto_trace(oss, ns, goto_trace);
+  log_result("{}", oss.str());
 }
 
 smt_convt::resultt bmct::run_decision_procedure(
@@ -153,17 +134,14 @@ smt_convt::resultt bmct::run_decision_procedure(
   else
     logic = "integer/real arithmetic";
 
-  msg.status(fmt::format("Encoding remaining VCC(s) using {}", logic));
+  log_status("Encoding remaining VCC(s) using {}", logic);
 
   fine_timet encode_start = current_time();
   do_cbmc(smt_conv, eq);
   fine_timet encode_stop = current_time();
 
-  std::ostringstream str;
-  str << "Encoding to solver time: ";
-  output_time(encode_stop - encode_start, str);
-  str << "s";
-  msg.status(str.str());
+  log_status(
+    "Encoding to solver time: {}s", time2string(encode_stop - encode_start));
 
   if(
     options.get_bool_option("smt-formula-too") ||
@@ -174,32 +152,27 @@ smt_convt::resultt bmct::run_decision_procedure(
       return smt_convt::P_SMTLIB;
   }
 
-  std::stringstream ss;
-  ss << "Solving with solver " << smt_conv->solver_text();
-  msg.status(ss.str());
+  log_status("Solving with solver {}", smt_conv->solver_text());
 
   fine_timet sat_start = current_time();
   smt_convt::resultt dec_result = smt_conv->dec_solve();
   fine_timet sat_stop = current_time();
 
   // output runtime
-  str.clear();
-  str << "\nRuntime decision procedure: ";
-  output_time(sat_stop - sat_start, str);
-  str << "s";
-  msg.status(str.str());
+  log_status(
+    "Runtime decision procedure: {}s", time2string(sat_stop - sat_start));
 
   return dec_result;
 }
 
 void bmct::report_success()
 {
-  msg.status("\nVERIFICATION SUCCESSFUL");
+  log_status("\nVERIFICATION SUCCESSFUL");
 }
 
 void bmct::report_failure()
 {
-  msg.status("\nVERIFICATION FAILED");
+  log_status("\nVERIFICATION FAILED");
 }
 
 void bmct::show_program(std::shared_ptr<symex_target_equationt> &eq)
@@ -207,9 +180,9 @@ void bmct::show_program(std::shared_ptr<symex_target_equationt> &eq)
   unsigned int count = 1;
   std::ostringstream oss;
   if(config.options.get_bool_option("ssa-symbol-table"))
-    ::show_symbol_table_plain(ns, oss, msg);
+    ::show_symbol_table_plain(ns, oss);
 
-  languagest languages(ns, MODE_C, msg);
+  languagest languages(ns, language_idt::C);
 
   oss << "\nProgram constraints: \n";
 
@@ -246,7 +219,7 @@ void bmct::show_program(std::shared_ptr<symex_target_equationt> &eq)
     }
     else if(it.is_renumber())
     {
-      oss << "renumber: " << from_expr(ns, "", it.lhs, msg) << "\n";
+      oss << "renumber: " << from_expr(ns, "", it.lhs) << "\n";
     }
 
     if(!migrate_expr_back(it.guard).is_true())
@@ -259,7 +232,7 @@ void bmct::show_program(std::shared_ptr<symex_target_equationt> &eq)
     oss << '\n';
     count++;
   }
-  msg.status(oss.str());
+  log_status("{}", oss.str());
 }
 
 void bmct::report_trace(
@@ -320,7 +293,7 @@ void bmct::report_result(smt_convt::resultt &res)
     }
     else
     {
-      msg.status("No bug has been found in the base case");
+      log_status("No bug has been found in the base case");
     }
     break;
 
@@ -331,11 +304,11 @@ void bmct::report_result(smt_convt::resultt &res)
     }
     else if(fc)
     {
-      msg.status("The forward condition is unable to prove the property");
+      log_status("The forward condition is unable to prove the property");
     }
     else if(is)
     {
-      msg.status("The inductive step is unable to prove the property");
+      log_status("The inductive step is unable to prove the property");
     }
     break;
 
@@ -346,16 +319,16 @@ void bmct::report_result(smt_convt::resultt &res)
     return;
 
   default:
-    msg.error("SMT solver failed");
+    log_error("SMT solver failed");
     break;
   }
 
   if((interleaving_number > 0) && options.get_bool_option("all-runs"))
   {
-    msg.status(
+    log_status(
       "Number of generated interleavings: " +
       integer2string((interleaving_number)));
-    msg.status(
+    log_status(
       "Number of failed interleavings: " +
       integer2string((interleaving_failed)));
   }
@@ -382,8 +355,7 @@ smt_convt::resultt bmct::run(std::shared_ptr<symex_target_equationt> &eq)
   do
   {
     if(++interleaving_number > 1)
-      msg.status(
-        fmt::format("*** Thread interleavings {} ***", interleaving_number));
+      log_status("Thread interleavings {}", interleaving_number);
 
     fine_timet bmc_start = current_time();
     res = run_thread(eq);
@@ -407,11 +379,7 @@ smt_convt::resultt bmct::run(std::shared_ptr<symex_target_equationt> &eq)
     }
     fine_timet bmc_stop = current_time();
 
-    std::ostringstream str;
-    str << "BMC program time: ";
-    output_time(bmc_stop - bmc_start, str);
-    str << "s";
-    msg.status(str.str());
+    log_status("BMC program time: {}s", time2string(bmc_stop - bmc_start));
 
     // Only run for one run
     if(options.get_bool_option("interactive-ileaves"))
@@ -459,7 +427,7 @@ void bmct::bidirectional_search(
     assert(fit != symex->goto_functions.function_map.end());
 
     // Find function loops
-    goto_loopst loops(f.function, symex->goto_functions, fit->second, msg);
+    goto_loopst loops(f.function, symex->goto_functions, fit->second);
 
     if(!loops.get_loops().size())
       continue;
@@ -501,8 +469,7 @@ void bmct::bidirectional_search(
         continue;
 
       expr2tc new_lhs = ssait.original_lhs;
-      renaming::renaming_levelt::get_original_name(
-        new_lhs, symbol2t::level0, msg);
+      renaming::renaming_levelt::get_original_name(new_lhs, symbol2t::level0);
 
       if(all_loop_vars.find(new_lhs) == all_loop_vars.end())
         continue;
@@ -522,8 +489,8 @@ void bmct::bidirectional_search(
       if(is_array_type(it.second.first) || is_pointer_type(it.second.first))
         return;
 
-      auto lhs = build_lhs(smt_conv, it.second.first, msg);
-      auto value = build_rhs(smt_conv, it.second.second, msg);
+      auto lhs = build_lhs(smt_conv, it.second.first);
+      auto value = build_rhs(smt_conv, it.second.second);
 
       // Add lhs and rhs to the list of new constraints
       equalities.push_back(equality2tc(lhs, value));
@@ -571,19 +538,19 @@ smt_convt::resultt bmct::run_thread(std::shared_ptr<symex_target_equationt> &eq)
 
   catch(std::string &error_str)
   {
-    msg.error(error_str);
+    log_error("{}", error_str);
     return smt_convt::P_ERROR;
   }
 
   catch(const char *error_str)
   {
-    msg.error(error_str);
+    log_error("{}", error_str);
     return smt_convt::P_ERROR;
   }
 
   catch(std::bad_alloc &)
   {
-    msg.error("Out of memory\n");
+    log_error("Out of memory\n");
     return smt_convt::P_ERROR;
   }
 
@@ -591,14 +558,10 @@ smt_convt::resultt bmct::run_thread(std::shared_ptr<symex_target_equationt> &eq)
 
   eq = std::dynamic_pointer_cast<symex_target_equationt>(result->target);
 
-  {
-    std::ostringstream str;
-    str << "Symex completed in: ";
-    output_time(symex_stop - symex_start, str);
-    str << "s";
-    str << " (" << eq->SSA_steps.size() << " assignments)";
-    msg.status(str.str());
-  }
+  log_status(
+    "Symex completed in: {}s ({} assignments)",
+    time2string(symex_stop - symex_start),
+    eq->SSA_steps.size());
 
   if(options.get_bool_option("double-assign-check"))
     eq->check_for_duplicate_assigns();
@@ -606,33 +569,14 @@ smt_convt::resultt bmct::run_thread(std::shared_ptr<symex_target_equationt> &eq)
   try
   {
     fine_timet slice_start = current_time();
-    BigInt ignored;
-    if(!options.get_bool_option("no-slice"))
-    {
-      std::unordered_set<std::string> ignored_symbols;
-      auto ignored_symbols_file = options.get_option("json-options-input");
-      if(ignored_symbols_file != "")
-      {
-        std::ifstream i(ignored_symbols_file);
-        nlohmann::json j;
-        i >> j;
-        j.at("no-slice-symbols").get_to(ignored_symbols);
-      }
-      ignored = slicer::slice(
-        eq, options.get_bool_option("slice-assumes"), ignored_symbols);
-    }
-    else
-      ignored = slicer::simple_slice(eq);
+    BigInt ignored = slice(eq);
+
     fine_timet slice_stop = current_time();
 
-    {
-      std::ostringstream str;
-      str << "Slicing time: ";
-      output_time(slice_stop - slice_start, str);
-      str << "s";
-      str << " (removed " << ignored << " assignments)";
-      msg.status(str.str());
-    }
+    log_status(
+      "Slicing time: {}s (removed {} assignments)",
+      time2string(slice_stop - slice_start),
+      ignored);
 
     if(
       options.get_bool_option("program-only") ||
@@ -642,19 +586,17 @@ smt_convt::resultt bmct::run_thread(std::shared_ptr<symex_target_equationt> &eq)
     if(options.get_bool_option("program-only"))
       return smt_convt::P_SMTLIB;
 
-    {
-      std::ostringstream str;
-      str << "Generated " << result->total_claims << " VCC(s), ";
-      str << result->remaining_claims << " remaining after simplification ";
-      str << "(" << BigInt(eq->SSA_steps.size()) - ignored << " assignments)";
-      msg.status(str.str());
-    }
+    log_status(
+      "Generated {} VCC(s), {} remaining after simplification ({} assignments)",
+      result->total_claims,
+      result->remaining_claims,
+      BigInt(eq->SSA_steps.size()) - ignored);
 
     if(options.get_bool_option("document-subgoals"))
     {
       std::ostringstream oss;
       document_subgoals(*eq.get(), oss);
-      msg.status(oss.str());
+      log_status(oss.str());
       return smt_convt::P_SMTLIB;
     }
 
@@ -668,7 +610,7 @@ smt_convt::resultt bmct::run_thread(std::shared_ptr<symex_target_equationt> &eq)
     {
       if(options.get_bool_option("smt-formula-only"))
       {
-        msg.status(
+        log_status(
           "No VCC remaining, no SMT formula will be generated for"
           " this program\n");
         return smt_convt::P_SMTLIB;
@@ -680,7 +622,7 @@ smt_convt::resultt bmct::run_thread(std::shared_ptr<symex_target_equationt> &eq)
     if(!options.get_bool_option("smt-during-symex"))
     {
       runtime_solver =
-        std::shared_ptr<smt_convt>(create_solver_factory("", ns, options, msg));
+        std::shared_ptr<smt_convt>(create_solver("", ns, options));
     }
 
     return run_decision_procedure(runtime_solver, eq);
@@ -688,19 +630,19 @@ smt_convt::resultt bmct::run_thread(std::shared_ptr<symex_target_equationt> &eq)
 
   catch(std::string &error_str)
   {
-    msg.error(error_str);
+    log_error("{}", error_str);
     return smt_convt::P_ERROR;
   }
 
   catch(const char *error_str)
   {
-    msg.error(error_str);
+    log_error("{}", error_str);
     return smt_convt::P_ERROR;
   }
 
   catch(std::bad_alloc &)
   {
-    msg.error("Out of memory\n");
+    log_error("Out of memory\n");
     return smt_convt::P_ERROR;
   }
 }
diff --git a/src/esbmc/bmc.h b/src/esbmc/bmc.h
index 0067dd6fd..f37427625 100644
--- a/src/esbmc/bmc.h
+++ b/src/esbmc/bmc.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Bounded Model Checking for ANSI-C + HDL
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_CBMC_BMC_H
 #define CPROVER_CBMC_BMC_H
 
@@ -22,11 +14,7 @@ Author: Daniel Kroening, kroening@kroening.com
 class bmct
 {
 public:
-  bmct(
-    goto_functionst &funcs,
-    optionst &opts,
-    contextt &_context,
-    const messaget &_message_handler);
+  bmct(goto_functionst &funcs, optionst &opts, contextt &_context);
 
   optionst &options;
 
@@ -40,7 +28,7 @@ public:
 protected:
   const contextt &context;
   namespacet ns;
-  const messaget &msg;
+
   std::shared_ptr<smt_convt> runtime_solver;
   std::shared_ptr<reachability_treet> symex;
   virtual smt_convt::resultt run_decision_procedure(
diff --git a/src/esbmc/document_subgoals.cpp b/src/esbmc/document_subgoals.cpp
index 088185f85..22ac1d710 100644
--- a/src/esbmc/document_subgoals.cpp
+++ b/src/esbmc/document_subgoals.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Subgoal Documentation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <clang-c-frontend/expr2c.h>
 #include <esbmc/document_subgoals.h>
 #include <fstream>
diff --git a/src/esbmc/document_subgoals.h b/src/esbmc/document_subgoals.h
index dd5991851..75fca7cf9 100644
--- a/src/esbmc/document_subgoals.h
+++ b/src/esbmc/document_subgoals.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Subgoal Documentation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <goto-symex/symex_target_equation.h>
 
 void document_subgoals(
diff --git a/src/esbmc/esbmc_parseoptions.cpp b/src/esbmc/esbmc_parseoptions.cpp
index e27cd7c56..a90bb417d 100644
--- a/src/esbmc/esbmc_parseoptions.cpp
+++ b/src/esbmc/esbmc_parseoptions.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Main Module
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <ac_config.h>
 
 #ifndef _WIN32
@@ -41,6 +33,7 @@ extern "C"
 #include <goto-programs/interval_analysis.h>
 #include <goto-programs/loop_numbers.h>
 #include <goto-programs/read_goto_binary.h>
+#include <goto-programs/write_goto_binary.h>
 #include <goto-programs/remove_skip.h>
 #include <goto-programs/remove_unreachable.h>
 #include <goto-programs/set_claims.h>
@@ -56,8 +49,6 @@ extern "C"
 #include <pointer-analysis/value_set_analysis.h>
 #include <util/symbol.h>
 #include <util/time_stopping.h>
-#include <util/message/format.h>
-#include <util/message/fmt_message_handler.h>
 
 #ifndef _WIN32
 #include <sys/wait.h>
@@ -71,8 +62,6 @@ extern "C"
 #include <goto-programs/goto_contractor.h>
 #endif
 
-#include <util/message/default_message.h>
-
 enum PROCESS_TYPE
 {
   BASE_CASE,
@@ -90,8 +79,7 @@ struct resultt
 #ifndef _WIN32
 void timeout_handler(int)
 {
-  default_message msg;
-  msg.error("Timed out");
+  log_error("Timed out");
   // Unfortunately some highly useful pieces of code hook themselves into
   // aexit and attempt to free some memory. That doesn't really make sense to
   // occur on exit, but more importantly doesn't mix well with signal handlers,
@@ -100,7 +88,7 @@ void timeout_handler(int)
 }
 #endif
 
-void esbmc_parseoptionst::set_verbosity_msg(messaget &message)
+void esbmc_parseoptionst::set_verbosity_msg()
 {
   VerbosityLevel v = VerbosityLevel::Status;
 
@@ -113,10 +101,10 @@ void esbmc_parseoptionst::set_verbosity_msg(messaget &message)
       v = VerbosityLevel::Debug;
   }
 
-  message.set_verbosity(v);
+  messaget::state.verbosity = v;
 }
 
-extern "C" uint8_t *esbmc_version_string;
+extern "C" const uint8_t *const esbmc_version_string;
 
 uint64_t esbmc_parseoptionst::read_time_spec(const char *str)
 {
@@ -139,7 +127,7 @@ uint64_t esbmc_parseoptionst::read_time_spec(const char *str)
       mult = 86400;
       break;
     default:
-      msg.error("Unrecognized timeout suffix");
+      log_error("Unrecognized timeout suffix");
       abort();
     }
   }
@@ -174,7 +162,7 @@ uint64_t esbmc_parseoptionst::read_mem_spec(const char *str)
       mult = 1024 * 1024 * 1024;
       break;
     default:
-      msg.error("Unrecognized memlimit suffix");
+      log_error("Unrecognized memlimit suffix");
       abort();
     }
   }
@@ -215,24 +203,22 @@ static std::string format_target()
     break;
   }
   assert(lib);
-  return fmt::format(
-    "{}-bit {}-endian {} with {} libc",
-    config.ansi_c.word_size,
-    endian,
-    config.ansi_c.target.to_string(),
-    lib);
+  std::ostringstream oss;
+  oss << config.ansi_c.word_size << "-bit " << endian << "-endian "
+      << config.ansi_c.target.to_string() << " with " << lib << "libc";
+  return oss.str();
 }
 
 void esbmc_parseoptionst::get_command_line_options(optionst &options)
 {
-  if(config.set(cmdline, msg))
+  if(config.set(cmdline))
   {
     exit(1);
   }
-  msg.status(fmt::format("Target: {}", format_target()));
+  log_status("Target: {}", format_target());
 
   options.cmdline(cmdline);
-  set_verbosity_msg(msg);
+  set_verbosity_msg();
 
   if(cmdline.isset("cex-output"))
     options.set_option("cex-output", cmdline.getval("cex-output"));
@@ -250,14 +236,14 @@ void esbmc_parseoptionst::get_command_line_options(optionst &options)
 
   if(cmdline.isset("git-hash"))
   {
-    msg.result(fmt::format("{}", esbmc_version_string));
+    log_result("{}", esbmc_version_string);
     exit(0);
   }
 
   if(cmdline.isset("list-solvers"))
   {
     // Generated for us by autoconf,
-    msg.result(fmt::format("Available solvers: {}", ESBMC_AVAILABLE_SOLVERS));
+    log_result("Available solvers: {}", ESBMC_AVAILABLE_SOLVERS);
     exit(0);
   }
 
@@ -297,7 +283,7 @@ void esbmc_parseoptionst::get_command_line_options(optionst &options)
 
   if(cmdline.isset("smt-during-symex"))
   {
-    msg.status("Enabling --no-slice due to presence of --smt-during-symex");
+    log_status("Enabling --no-slice due to presence of --smt-during-symex");
     options.set_option("no-slice", true);
   }
 
@@ -305,7 +291,7 @@ void esbmc_parseoptionst::get_command_line_options(optionst &options)
   {
     if(!cmdline.isset("smt-during-symex"))
     {
-      msg.error(
+      log_error(
         "Please explicitly specify --smt-during-symex if you want "
         "to use features that involve encoding SMT during symex");
       abort();
@@ -324,7 +310,7 @@ void esbmc_parseoptionst::get_command_line_options(optionst &options)
     // check whether k-step is greater than max-k-step
     if(k_step_inc >= max_k_step)
     {
-      msg.error(
+      log_error(
         "Please specify --k-step smaller than max-k-step if you want "
         "to use incremental verification.");
       abort();
@@ -361,7 +347,7 @@ void esbmc_parseoptionst::get_command_line_options(optionst &options)
   if(cmdline.isset("timeout"))
   {
 #ifdef _WIN32
-    msg.error("Timeout unimplemented on Windows, sorry");
+    log_error("Timeout unimplemented on Windows, sorry");
     abort();
 #else
     const char *time = cmdline.getval("timeout");
@@ -374,7 +360,7 @@ void esbmc_parseoptionst::get_command_line_options(optionst &options)
   if(cmdline.isset("memlimit"))
   {
 #ifdef _WIN32
-    msg.error("Can't memlimit on Windows, sorry");
+    log_error("Can't memlimit on Windows, sorry");
     abort();
 #else
     uint64_t size = read_mem_spec(cmdline.getval("memlimit"));
@@ -426,47 +412,54 @@ int esbmc_parseoptionst::doit()
     FILE *f = fopen(cmdline.getval("file-output"), "w+");
     out = f;
     err = f;
+    messaget::state.err = f;
+    messaget::state.out = f;
   }
-
-  std::shared_ptr<message_handlert> handler =
-    std::make_shared<fmt_message_handler>(out, err);
-  msg.add_message_handler(handler);
   //
   // Print a banner
   //
-  msg.status(fmt::format(
+  log_status(
     "ESBMC version {} {}-bit {} {}",
     ESBMC_VERSION,
     sizeof(void *) * 8,
     config.this_architecture(),
-    config.this_operating_system()));
+    config.this_operating_system());
 
   if(cmdline.isset("version"))
     return 0;
 
-  //
   // unwinding of transition systems
-  //
 
   if(cmdline.isset("module") || cmdline.isset("gen-interface"))
-
   {
-    msg.error(
+    log_error(
       "This version has no support for "
       " hardware modules.");
     return 1;
   }
 
-  //
   // command line options
-  //
-
   if(cmdline.isset("preprocess"))
   {
     preprocessing();
     return 0;
   }
 
+  // initialize goto_functions algorithms
+  {
+    // loop unroll
+    if(cmdline.isset("goto-unwind") && !cmdline.isset("unwind"))
+    {
+      size_t unroll_limit = cmdline.isset("unlimited-goto-unwind") ? -1 : 1000;
+      goto_preprocess_algorithms.push_back(
+        std::make_unique<bounded_loop_unroller>(unroll_limit));
+    }
+
+    // mark declarations as nondet
+    if(cmdline.isset("initialize-nondet-variables"))
+      goto_preprocess_algorithms.emplace_back(
+        std::make_unique<mark_decl_as_non_det>(context));
+  }
   if(cmdline.isset("termination"))
     return doit_termination();
 
@@ -491,7 +484,7 @@ int esbmc_parseoptionst::doit()
   if(cmdline.isset("show-claims"))
   {
     const namespacet ns(context);
-    show_claims(ns, goto_functions, msg);
+    show_claims(ns, goto_functions);
     return 0;
   }
 
@@ -502,7 +495,7 @@ int esbmc_parseoptionst::doit()
     return 0;
 
   // do actual BMC
-  bmct bmc(goto_functions, opts, context, msg);
+  bmct bmc(goto_functions, opts, context);
 
   return do_bmc(bmc);
 }
@@ -510,7 +503,7 @@ int esbmc_parseoptionst::doit()
 int esbmc_parseoptionst::doit_k_induction_parallel()
 {
 #ifdef _WIN32
-  msg.error("Windows does not support parallel kind");
+  log_error("Windows does not support parallel kind");
   abort();
 #else
   // Pipes for communication between processes
@@ -521,13 +514,13 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
 
   if(pipe(forward_pipe))
   {
-    msg.status("\nPipe Creation Failed, giving up.");
+    log_status("\nPipe Creation Failed, giving up.");
     _exit(1);
   }
 
   if(pipe(backward_pipe))
   {
-    msg.status("\nPipe Creation Failed, giving up.");
+    log_status("\nPipe Creation Failed, giving up.");
     _exit(1);
   }
 
@@ -545,7 +538,7 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
 
     if(pid == -1)
     {
-      msg.status("\nFork Failed, giving up.");
+      log_status("\nFork Failed, giving up.");
       _exit(1);
     }
 
@@ -563,7 +556,7 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
 
   if(process_type == PARENT && num_p != 3)
   {
-    msg.error("Child processes were not created sucessfully.");
+    log_error("Child processes were not created sucessfully.");
     abort();
   }
 
@@ -581,7 +574,7 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
     if(cmdline.isset("show-claims"))
     {
       const namespacet ns(context);
-      show_claims(ns, goto_functions, msg);
+      show_claims(ns, goto_functions);
       return 0;
     }
 
@@ -626,8 +619,8 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
         else
         {
           // Invalid size read.
-          msg.error("Short read communicating with kinduction children");
-          msg.error(fmt::format("Size {}, expected {}", read, sizeof(resultt)));
+          log_error("Short read communicating with kinduction children");
+          log_error("Size {}, expected {}", read_size, sizeof(resultt));
           abort();
         }
       }
@@ -649,7 +642,7 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
         }
         else
         {
-          msg.warning("**** WARNING: Base case process crashed.");
+          log_warning("base case process crashed.");
           bc_finished = fc_finished = is_finished = true;
         }
       }
@@ -669,7 +662,7 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
         }
         else
         {
-          msg.warning("**** WARNING: Forward condition process crashed.");
+          log_warning("forward condition process crashed.");
           fc_finished = bc_finished = is_finished = true;
         }
       }
@@ -689,7 +682,7 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
         }
         else
         {
-          msg.warning("**** WARNING: Inductive step process crashed.");
+          log_warning("inductive step process crashed.");
           is_finished = bc_finished = fc_finished = true;
         }
       }
@@ -712,7 +705,7 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
         break;
 
       default:
-        msg.error(
+        log_error(
           "Message from unrecognized k-induction child "
           "process");
         abort();
@@ -777,9 +770,9 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
     // Check if a solution was found by the base case
     if(bc_finished && (bc_solution != 0) && (bc_solution != max_k_step))
     {
-      msg.result(fmt::format(
+      log_result(
         "\nBug found by the base case (k = {})\nVERIFICATION FAILED",
-        bc_solution));
+        bc_solution);
       return true;
     }
 
@@ -790,11 +783,11 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
       // and haven't crashed (if it crashed, bc_solution will be UINT_MAX
       if(bc_finished && (bc_solution != max_k_step))
       {
-        msg.result(fmt::format(
+        log_result(
           "\nSolution found by the forward condition; "
           "all states are reachable (k = {:d})\n"
           "VERIFICATION SUCCESSFUL",
-          fc_solution));
+          fc_solution);
         return false;
       }
     }
@@ -806,17 +799,17 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
       // and haven't crashed (if it crashed, bc_solution will be UINT_MAX
       if(bc_finished && (bc_solution != max_k_step))
       {
-        msg.result(fmt::format(
+        log_result(
           "\nSolution found by the inductive step "
           "(k = {:d})\n"
           "VERIFICATION SUCCESSFUL",
-          is_solution));
+          is_solution);
         return false;
       }
     }
 
     // Couldn't find a bug or a proof for the current deepth
-    msg.result("\nVERIFICATION UNKNOWN");
+    log_result("\nVERIFICATION UNKNOWN");
     return false;
   }
 
@@ -842,10 +835,10 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
     // 2. It couldn't find a bug
     for(BigInt k_step = 1; k_step <= max_k_step; k_step += k_step_inc)
     {
-      bmct bmc(goto_functions, opts, context, msg);
+      bmct bmc(goto_functions, opts, context);
       bmc.options.set_option("unwind", integer2string(k_step));
 
-      msg.status(fmt::format("*** Checking base case, k = {:d}\n", k_step));
+      log_status("Checking base case, k = {:d}\n", k_step);
 
       // If an exception was thrown, we should abort the process
       int res = smt_convt::P_ERROR;
@@ -868,7 +861,7 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
         assert(len == sizeof(r) && "short write");
         (void)len; //ndebug
 
-        msg.status("BASE CASE PROCESS FINISHED.\n");
+        log_status("BASE CASE PROCESS FINISHED.\n");
         return true;
       }
 
@@ -892,9 +885,8 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
         else
         {
           // Invalid size read.
-          msg.error("Short read communicating with kinduction parent");
-          msg.error(
-            fmt::format("Size {}, expected {}", read_size, sizeof(resultt)));
+          log_error("Short read communicating with kinduction parent");
+          log_error("Size {}, expected {}", read_size, sizeof(resultt));
 
           abort();
         }
@@ -920,7 +912,7 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
     assert(len == sizeof(r) && "short write");
     (void)len; //ndebug
 
-    msg.status("BASE CASE PROCESS FINISHED.\n");
+    log_status("BASE CASE PROCESS FINISHED.\n");
     return false;
   }
 
@@ -947,11 +939,10 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
     // 2. It couldn't find a proof
     for(BigInt k_step = 2; k_step <= max_k_step; k_step += k_step_inc)
     {
-      bmct bmc(goto_functions, opts, context, msg);
+      bmct bmc(goto_functions, opts, context);
       bmc.options.set_option("unwind", integer2string(k_step));
 
-      msg.status(
-        fmt::format("*** Checking forward condition, k = {:d}", k_step));
+      log_status("Checking forward condition, k = {:d}", k_step);
 
       // If an exception was thrown, we should abort the process
       int res = smt_convt::P_ERROR;
@@ -977,7 +968,7 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
         assert(len == sizeof(r) && "short write");
         (void)len; //ndebug
 
-        msg.status("FORWARD CONDITION PROCESS FINISHED.");
+        log_status("FORWARD CONDITION PROCESS FINISHED.");
         return false;
       }
     }
@@ -989,7 +980,7 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
     assert(len == sizeof(r) && "short write");
     (void)len; //ndebug
 
-    msg.status("FORWARD CONDITION PROCESS FINISHED.");
+    log_status("FORWARD CONDITION PROCESS FINISHED.");
     return true;
   }
 
@@ -1015,11 +1006,11 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
     // 2. It couldn't find a proof
     for(BigInt k_step = 2; k_step <= max_k_step; k_step += k_step_inc)
     {
-      bmct bmc(goto_functions, opts, context, msg);
+      bmct bmc(goto_functions, opts, context);
 
       bmc.options.set_option("unwind", integer2string(k_step));
 
-      msg.status(fmt::format("*** Checking inductive step, k = {:d}", k_step));
+      log_status("Checking inductive step, k = {:d}", k_step);
 
       // If an exception was thrown, we should abort the process
       int res = smt_convt::P_ERROR;
@@ -1045,7 +1036,7 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
         assert(len == sizeof(r) && "short write");
         (void)len; //ndebug
 
-        msg.status("INDUCTIVE STEP PROCESS FINISHED.");
+        log_status("INDUCTIVE STEP PROCESS FINISHED.");
         return false;
       }
     }
@@ -1057,7 +1048,7 @@ int esbmc_parseoptionst::doit_k_induction_parallel()
     assert(len == sizeof(r) && "short write");
     (void)len; //ndebug
 
-    msg.status("INDUCTIVE STEP PROCESS FINISHED.");
+    log_status("INDUCTIVE STEP PROCESS FINISHED.");
     return true;
   }
 
@@ -1081,7 +1072,7 @@ int esbmc_parseoptionst::doit_k_induction()
   if(cmdline.isset("show-claims"))
   {
     const namespacet ns(context);
-    show_claims(ns, goto_functions, msg);
+    show_claims(ns, goto_functions);
     return 0;
   }
 
@@ -1108,8 +1099,8 @@ int esbmc_parseoptionst::doit_k_induction()
       return false;
   }
 
-  msg.status("Unable to prove or falsify the program, giving up.");
-  msg.status("VERIFICATION UNKNOWN");
+  log_status("Unable to prove or falsify the program, giving up.");
+  log_status("VERIFICATION UNKNOWN");
 
   return 0;
 }
@@ -1125,7 +1116,7 @@ int esbmc_parseoptionst::doit_falsification()
   if(cmdline.isset("show-claims"))
   {
     const namespacet ns(context);
-    show_claims(ns, goto_functions, msg);
+    show_claims(ns, goto_functions);
     return 0;
   }
 
@@ -1146,8 +1137,8 @@ int esbmc_parseoptionst::doit_falsification()
       return true;
   }
 
-  msg.status("Unable to prove or falsify the program, giving up.");
-  msg.status("VERIFICATION UNKNOWN");
+  log_status("Unable to prove or falsify the program, giving up.");
+  log_status("VERIFICATION UNKNOWN");
 
   return 0;
 }
@@ -1164,7 +1155,7 @@ int esbmc_parseoptionst::doit_incremental()
   {
     const namespacet ns(context);
     std::ostringstream oss;
-    show_claims(ns, goto_functions, msg);
+    show_claims(ns, goto_functions);
     return 0;
   }
 
@@ -1188,8 +1179,8 @@ int esbmc_parseoptionst::doit_incremental()
       return false;
   }
 
-  msg.status("Unable to prove or falsify the program, giving up.");
-  msg.status("VERIFICATION UNKNOWN");
+  log_status("Unable to prove or falsify the program, giving up.");
+  log_status("VERIFICATION UNKNOWN");
 
   return 0;
 }
@@ -1205,7 +1196,7 @@ int esbmc_parseoptionst::doit_termination()
   if(cmdline.isset("show-claims"))
   {
     const namespacet ns(context);
-    show_claims(ns, goto_functions, msg);
+    show_claims(ns, goto_functions);
     return 0;
   }
 
@@ -1231,8 +1222,8 @@ int esbmc_parseoptionst::doit_termination()
     */
   }
 
-  msg.status("Unable to prove or falsify the program, giving up.");
-  msg.status("VERIFICATION UNKNOWN");
+  log_status("Unable to prove or falsify the program, giving up.");
+  log_status("VERIFICATION UNKNOWN");
 
   return 0;
 }
@@ -1249,11 +1240,11 @@ int esbmc_parseoptionst::do_base_case(
   opts.set_option("no-unwinding-assertions", true);
   opts.set_option("partial-loops", false);
 
-  bmct bmc(goto_functions, opts, context, msg);
+  bmct bmc(goto_functions, opts, context);
 
   bmc.options.set_option("unwind", integer2string(k_step));
 
-  msg.status(fmt::format("*** Checking base case, k = {:d}", k_step));
+  log_status("Checking base case, k = {:d}", k_step);
   switch(do_bmc(bmc))
   {
   case smt_convt::P_UNSATISFIABLE:
@@ -1262,11 +1253,11 @@ int esbmc_parseoptionst::do_base_case(
     break;
 
   case smt_convt::P_SATISFIABLE:
-    msg.result(fmt::format("\nBug found (k = {:d})", k_step));
+    log_result("\nBug found (k = {:d})", k_step);
     return true;
 
   default:
-    msg.result("Unknown BMC result");
+    log_result("Unknown BMC result");
     abort();
   }
 
@@ -1295,11 +1286,11 @@ int esbmc_parseoptionst::do_forward_condition(
   // Turn assertions off
   opts.set_option("no-assertions", true);
 
-  bmct bmc(goto_functions, opts, context, msg);
+  bmct bmc(goto_functions, opts, context);
 
   bmc.options.set_option("unwind", integer2string(k_step));
 
-  msg.status(fmt::format("*** Checking forward condition, k = {:d}", k_step));
+  log_status("Checking forward condition, k = {:d}", k_step);
   auto res = do_bmc(bmc);
 
   // Restore the no assertion flag, before checking the other steps
@@ -1313,14 +1304,14 @@ int esbmc_parseoptionst::do_forward_condition(
     break;
 
   case smt_convt::P_UNSATISFIABLE:
-    msg.result(fmt::format(
+    log_result(
       "\nSolution found by the forward condition; "
       "all states are reachable (k = {:d})",
-      k_step));
+      k_step);
     return false;
 
   default:
-    msg.result("Unknown BMC result");
+    log_result("Unknown BMC result");
     abort();
   }
 
@@ -1351,10 +1342,10 @@ int esbmc_parseoptionst::do_inductive_step(
   opts.set_option("no-unwinding-assertions", true);
   opts.set_option("partial-loops", true);
 
-  bmct bmc(goto_functions, opts, context, msg);
+  bmct bmc(goto_functions, opts, context);
   bmc.options.set_option("unwind", integer2string(k_step));
 
-  msg.status(fmt::format("*** Checking inductive step, k = {:d}", k_step));
+  log_status("Checking inductive step, k = {:d}", k_step);
   switch(do_bmc(bmc))
   {
   case smt_convt::P_SATISFIABLE:
@@ -1363,14 +1354,14 @@ int esbmc_parseoptionst::do_inductive_step(
     break;
 
   case smt_convt::P_UNSATISFIABLE:
-    msg.result(fmt::format(
+    log_result(
       "\nSolution found by the inductive step "
       "(k = {:d})",
-      k_step));
+      k_step);
     return false;
 
   default:
-    msg.result("Unknown BMC result\n");
+    log_result("Unknown BMC result\n");
     abort();
   }
 
@@ -1387,13 +1378,13 @@ bool esbmc_parseoptionst::set_claims(goto_functionst &goto_functions)
 
   catch(const char *e)
   {
-    msg.error(e);
+    log_error(e);
     return true;
   }
 
   catch(const std::string &e)
   {
-    msg.error(e);
+    log_error(e);
     return true;
   }
 
@@ -1414,14 +1405,17 @@ bool esbmc_parseoptionst::get_goto_program(
   {
     if(cmdline.args.size() == 0)
     {
-      msg.error("Please provide a program to verify");
+      log_error("Please provide a program to verify");
       return true;
     }
 
+    // Ahem
+    migrate_namespace_lookup = new namespacet(context);
+
     // If the user is providing the GOTO functions, we don't need to parse
     if(cmdline.isset("binary"))
     {
-      msg.status("Reading GOTO program from file");
+      log_status("Reading GOTO program from file");
 
       if(read_goto_binary(goto_functions))
         return true;
@@ -1438,7 +1432,7 @@ bool esbmc_parseoptionst::get_goto_program(
         languaget &language = *language_files.filemap.begin()->second.language;
         std::ostringstream oss;
         language.show_parse(oss);
-        msg.status(oss.str());
+        log_status("{}", oss.str());
         if(cmdline.isset("parse-tree-only"))
           return true;
       }
@@ -1457,52 +1451,44 @@ bool esbmc_parseoptionst::get_goto_program(
       {
         std::ostringstream oss;
         show_symbol_table_plain(oss);
-        msg.status(oss.str());
+        log_status("{}", oss.str());
         if(cmdline.isset("symbol-table-only"))
           return true;
       }
 
-      msg.status("Generating GOTO Program");
+      log_status("Generating GOTO Program");
 
-      // Ahem
-      migrate_namespace_lookup = new namespacet(context);
-
-      goto_convert(context, options, goto_functions, msg);
+      goto_convert(context, options, goto_functions);
     }
 
     fine_timet parse_stop = current_time();
-    std::ostringstream str;
-    str << "GOTO program creation time: ";
-    output_time(parse_stop - parse_start, str);
-    str << "s";
-    msg.status(str.str());
+    log_status(
+      "GOTO program creation time: {}s", time2string(parse_stop - parse_start));
 
     fine_timet process_start = current_time();
     if(process_goto_program(options, goto_functions))
       return true;
     fine_timet process_stop = current_time();
-    std::ostringstream str2;
-    str2 << "GOTO program processing time: ";
-    output_time(process_stop - process_start, str2);
-    str2 << "s";
-    msg.status(str2.str());
+    log_status(
+      "GOTO program processing time: {}s",
+      time2string(process_stop - process_start));
   }
 
   catch(const char *e)
   {
-    msg.error(e);
+    log_error("{}", e);
     return true;
   }
 
   catch(const std::string &e)
   {
-    msg.error(e);
+    log_error("{}", e);
     return true;
   }
 
   catch(std::bad_alloc &)
   {
-    msg.error("Out of memory");
+    log_error("Out of memory");
     return true;
   }
 
@@ -1515,7 +1501,7 @@ void esbmc_parseoptionst::preprocessing()
   {
     if(cmdline.args.size() != 1)
     {
-      msg.error("Please provide one program to preprocess");
+      log_error("Please provide one program to preprocess");
       return;
     }
 
@@ -1525,29 +1511,29 @@ void esbmc_parseoptionst::preprocessing()
     std::ifstream infile(filename.c_str());
     if(!infile)
     {
-      msg.error("failed to open input file");
+      log_error("failed to open input file");
       return;
     }
 #ifdef ENABLE_OLD_FRONTEND
     std::ostringstream oss;
-    if(c_preprocess(filename, oss, false, msg))
-      msg.error("PREPROCESSING ERROR");
-    msg.status(oss.str());
+    if(c_preprocess(filename, oss, false))
+      log_error("PREPROCESSING ERROR");
+    log_status("{}", oss.str());
 #endif
   }
   catch(const char *e)
   {
-    msg.error(e);
+    log_error("{}", e);
   }
 
   catch(const std::string &e)
   {
-    msg.error(e);
+    log_error("{}", e);
   }
 
   catch(std::bad_alloc &)
   {
-    msg.error("Out of memory");
+    log_error("Out of memory");
   }
 }
 
@@ -1555,9 +1541,9 @@ bool esbmc_parseoptionst::read_goto_binary(goto_functionst &goto_functions)
 {
   for(const auto &arg : _cmdline.args)
   {
-    if(::read_goto_binary(arg, context, goto_functions, msg))
+    if(::read_goto_binary(arg, context, goto_functions))
     {
-      msg.error("Failed to open `" + arg + "'");
+      log_error("Failed to open `{}'", arg);
       return true;
     }
   }
@@ -1572,26 +1558,16 @@ bool esbmc_parseoptionst::process_goto_program(
   try
   {
     namespacet ns(context);
-    if(
-      options.get_bool_option("goto-unwind") &&
-      !options.get_bool_option("unwind"))
-    {
-      size_t unroll_limit =
-        options.get_bool_option("unlimited-goto-unwind") ? -1 : 1000;
-      bounded_loop_unroller unwind_loops(goto_functions, unroll_limit);
-      unwind_loops.run();
-    }
-
-    if(options.get_bool_option("initialize-nondet-variables"))
-      mark_decl_as_non_det(context, goto_functions).run();
+    for(auto &algorithm : goto_preprocess_algorithms)
+      algorithm->run(goto_functions);
 
     // do partial inlining
     if(!cmdline.isset("no-inlining"))
     {
       if(cmdline.isset("full-inlining"))
-        goto_inline(goto_functions, options, ns, msg);
+        goto_inline(goto_functions, options, ns);
       else
-        goto_partial_inline(goto_functions, options, ns, msg);
+        goto_partial_inline(goto_functions, options, ns);
     }
 
     if(cmdline.isset("interval-analysis") || cmdline.isset("goto-contractor"))
@@ -1603,15 +1579,15 @@ bool esbmc_parseoptionst::process_goto_program(
       cmdline.isset("inductive-step") || cmdline.isset("k-induction") ||
       cmdline.isset("k-induction-parallel"))
     {
-      goto_k_induction(goto_functions, msg);
+      goto_k_induction(goto_functions);
     }
 
     if(cmdline.isset("goto-contractor"))
     {
 #ifdef ENABLE_GOTO_CONTRACTOR
-      goto_contractor(goto_functions, msg);
+      goto_contractor(goto_functions);
 #else
-      msg.error(
+      log_error(
         "Current build does not support contractors. If ibex is installed, add "
         "-DENABLE_IBEX = ON");
       abort();
@@ -1620,19 +1596,19 @@ bool esbmc_parseoptionst::process_goto_program(
 
     if(cmdline.isset("termination"))
     {
-      goto_termination(goto_functions, msg);
+      goto_termination(goto_functions);
     }
 
-    goto_check(ns, options, goto_functions, msg);
+    goto_check(ns, options, goto_functions);
 
     // show it?
     if(cmdline.isset("show-goto-value-sets"))
     {
-      value_set_analysist value_set_analysis(ns, msg);
+      value_set_analysist value_set_analysis(ns);
       value_set_analysis(goto_functions);
       std::ostringstream oss;
       show_value_sets(goto_functions, value_set_analysis, oss);
-      msg.result(oss.str());
+      log_result("{}", oss.str());
       return true;
     }
 
@@ -1667,12 +1643,12 @@ bool esbmc_parseoptionst::process_goto_program(
 
     if(cmdline.isset("data-races-check"))
     {
-      msg.status("Adding Data Race Checks");
+      log_status("Adding Data Race Checks");
 
-      value_set_analysist value_set_analysis(ns, msg);
+      value_set_analysist value_set_analysis(ns);
       value_set_analysis(goto_functions);
 
-      add_race_assertions(value_set_analysis, context, goto_functions, msg);
+      add_race_assertions(value_set_analysis, context, goto_functions);
 
       value_set_analysis.update(goto_functions);
     }
@@ -1680,7 +1656,20 @@ bool esbmc_parseoptionst::process_goto_program(
     // show it?
     if(cmdline.isset("show-loops"))
     {
-      show_loop_numbers(goto_functions, msg);
+      show_loop_numbers(goto_functions);
+      return true;
+    }
+
+    if(cmdline.isset("output-goto"))
+    {
+      log_status("Writing GOTO program to file");
+      std::ofstream oss(
+        cmdline.getval("output-goto"), std::ios::out | std::ios::binary);
+      if(write_goto_binary(oss, context, goto_functions))
+      {
+        log_error("Failed to generate goto binary file"); // TODO: explain why
+        abort();
+      };
       return true;
     }
 
@@ -1691,7 +1680,7 @@ bool esbmc_parseoptionst::process_goto_program(
     {
       std::ostringstream oss;
       goto_functions.output(ns, oss);
-      msg.status(oss.str());
+      log_status("{}", oss.str());
       if(cmdline.isset("goto-functions-only"))
         return true;
     }
@@ -1699,19 +1688,19 @@ bool esbmc_parseoptionst::process_goto_program(
 
   catch(const char *e)
   {
-    msg.error(e);
+    log_error("{}", e);
     return true;
   }
 
   catch(const std::string &e)
   {
-    msg.error(e);
+    log_error("{}", e);
     return true;
   }
 
   catch(std::bad_alloc &)
   {
-    msg.error("Out of memory");
+    log_error("Out of memory");
     return true;
   }
 
@@ -1721,7 +1710,7 @@ bool esbmc_parseoptionst::process_goto_program(
 int esbmc_parseoptionst::do_bmc(bmct &bmc)
 { // do actual BMC
 
-  msg.status("Starting Bounded Model Checking");
+  log_status("Starting Bounded Model Checking");
 
   smt_convt::resultt res = bmc.start_bmc();
   if(res == smt_convt::P_ERROR)
@@ -1741,10 +1730,8 @@ int esbmc_parseoptionst::do_bmc(bmct &bmc)
 
 void esbmc_parseoptionst::help()
 {
-  default_message dmsg;
-  dmsg.status(
-    fmt::format("\n* * *           ESBMC {}          * * *", ESBMC_VERSION));
+  log_status("\n* * *           ESBMC {}          * * *", ESBMC_VERSION);
   std::ostringstream oss;
   oss << cmdline.cmdline_options;
-  dmsg.status(oss.str());
+  log_status("{}", oss.str());
 }
diff --git a/src/esbmc/esbmc_parseoptions.h b/src/esbmc/esbmc_parseoptions.h
index f3c0d4db0..c7efb63bc 100644
--- a/src/esbmc/esbmc_parseoptions.h
+++ b/src/esbmc/esbmc_parseoptions.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Command Line Parsing
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_ESBMC_PARSEOPTIONS_H
 #define CPROVER_ESBMC_PARSEOPTIONS_H
 
@@ -15,6 +7,7 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <util/cmdline.h>
 #include <util/options.h>
 #include <util/parseoptions.h>
+#include <util/algorithms.h>
 
 extern const struct group_opt_templ all_cmd_options[];
 
@@ -24,9 +17,8 @@ public:
   int doit() override;
   void help() override;
 
-  esbmc_parseoptionst(int argc, const char **argv, messaget &msg)
-    : parseoptions_baset(all_cmd_options, argc, argv, msg),
-      language_uit(cmdline, msg)
+  esbmc_parseoptionst(int argc, const char **argv)
+    : parseoptions_baset(all_cmd_options, argc, argv), language_uit(cmdline)
   {
   }
 
@@ -73,7 +65,7 @@ protected:
 
   bool set_claims(goto_functionst &goto_functions);
 
-  void set_verbosity_msg(messaget &message);
+  void set_verbosity_msg();
 
   uint64_t read_time_spec(const char *str);
   uint64_t read_mem_spec(const char *str);
@@ -85,6 +77,9 @@ protected:
   FILE *out = stdout;
   FILE *err = stderr;
 
+  std::vector<std::unique_ptr<goto_functions_algorithm>>
+    goto_preprocess_algorithms;
+
 private:
   void close_file(FILE *f)
   {
diff --git a/src/esbmc/globals.cpp b/src/esbmc/globals.cpp
index 4e883155d..1b770cd30 100644
--- a/src/esbmc/globals.cpp
+++ b/src/esbmc/globals.cpp
@@ -1,22 +1,21 @@
 #include <langapi/mode.h>
 
 const mode_table_et mode_table[] = {
-  LANGAPI_HAVE_MODE_CLANG_C,
-  LANGAPI_HAVE_MODE_CLANG_CPP,
+  LANGAPI_MODE_CLANG_C,
+  LANGAPI_MODE_CLANG_CPP,
 // put a new mode before old-frontend,
 // otherwise language_uit::parse() will return different mode when old-frontend is enabled
 #ifdef ENABLE_SOLIDITY_FRONTEND
-  LANGAPI_HAVE_MODE_SOLAST,
+  LANGAPI_MODE_SOLAST,
+#endif
+#ifdef ENABLE_JIMPLE_FRONTEND
+  LANGAPI_MODE_JIMPLE,
 #endif
 #ifdef ENABLE_OLD_FRONTEND
-  LANGAPI_HAVE_MODE_C,
-  LANGAPI_HAVE_MODE_CPP,
+  LANGAPI_MODE_C,
+  LANGAPI_MODE_CPP,
 #endif
-  LANGAPI_HAVE_MODE_END};
+  LANGAPI_MODE_END};
 
-extern "C" uint8_t buildidstring_buf[1];
-#ifdef _WIN32
-extern "C" uint8_t *esbmc_version_string = buildidstring_buf;
-#else
-uint8_t *esbmc_version_string = buildidstring_buf;
-#endif
+extern "C" const uint8_t buildidstring_buf[];
+extern "C" const uint8_t *const esbmc_version_string = buildidstring_buf;
diff --git a/src/esbmc/main.cpp b/src/esbmc/main.cpp
index 0eb96f489..97c14645e 100644
--- a/src/esbmc/main.cpp
+++ b/src/esbmc/main.cpp
@@ -1,32 +1,11 @@
-/*******************************************************************\
-
-Module: Main Module
-
-Author: Lucas Cordeiro, lcc08r@ecs.soton.ac.uk
-		Jeremy Morse, jcmm106@ecs.soton.ac.uk
-
-\*******************************************************************/
-
-/*
-
-  ESBMC
-  SMT-based Context-Bounded Model Checking for ANSI-C/C++
-  Copyright (c) 2009-2011, Lucas Cordeiro, Federal University of Amazonas
-  Jeremy Morse, Denis Nicole, Bernd Fischer, University of Southampton,
-  Joao Marques Silva, University College Dublin.
-  All rights reserved.
-
-*/
-
 #include <cstdint>
 #include <esbmc/esbmc_parseoptions.h>
 #include <langapi/mode.h>
-#include <util/message/default_message.h>
+
 #include <irep2/irep2.h>
 
 int main(int argc, const char **argv)
 {
-  messaget msg;
-  esbmc_parseoptionst parseoptions(argc, argv, msg);
+  esbmc_parseoptionst parseoptions(argc, argv);
   return parseoptions.main();
 }
diff --git a/src/esbmc/options.cpp b/src/esbmc/options.cpp
index 3a25eed97..52b8fc4fe 100644
--- a/src/esbmc/options.cpp
+++ b/src/esbmc/options.cpp
@@ -1,5 +1,6 @@
 #include <esbmc/esbmc_parseoptions.h>
 #include <fstream>
+#include <solvers/solver_config.h>
 #include <util/cmdline.h>
 
 const struct group_opt_templ all_cmd_options[] = {
@@ -84,6 +85,9 @@ const struct group_opt_templ all_cmd_options[] = {
     {"document-subgoals", NULL, "generate subgoals documentation"},
     {"no-arch", NULL, "don't set up an architecture"},
     {"no-library", NULL, "disable built-in abstract C library"},
+    {"output-goto",
+     boost::program_options::value<std::string>(),
+     "export generated goto program"},
     {"binary", NULL, "read goto program instead of source code"},
     {"little-endian", NULL, "allow little-endian word-byte conversions"},
     {"big-endian", NULL, "allow big-endian word-byte conversions"},
@@ -99,23 +103,13 @@ const struct group_opt_templ all_cmd_options[] = {
      "redirects every message into a file (no stdout/stderr)"},
     {"witness-output",
      boost::program_options::value<std::string>(),
-     "redirects every message into a file (no stdout/stderr)"},
-    {"cex-output",
-     boost::program_options::value<std::string>(),
-     "save the counterexample into a file"},
-     {
-      "witness-output",
-      boost::program_options::value<std::string>(),
-      "generate the verification result witness in GraphML format"},
+     "generate the verification result witness in GraphML format"},
     {"witness-producer", boost::program_options::value<std::string>(), ""},
     {"witness-programfile", boost::program_options::value<std::string>(), ""},
     {"old-frontend",
      NULL,
      "parse source files using our old frontend {deprecated},"},
     {"result-only", NULL, "do not print the counter-example"},
-    {"json-options-input",
-     boost::program_options::value<std::string>(),
-     "use a JSON file as the configuration input"},
 #ifdef _WIN32
     {"i386-macos", NULL, "set MACOS/I386 architecture"},
     {"ppc-macos", NULL, "set PPC/I386 architecture"},
@@ -154,6 +148,14 @@ const struct group_opt_templ all_cmd_options[] = {
     {"partial-loops", NULL, "permit paths with partial loops"},
     {"unroll-loops", NULL, ""},
     {"no-slice", NULL, "do not remove unused equations"},
+    {"no-slice-name",
+     boost::program_options::value<std::vector<std::string>>()->value_name(
+       "name"),
+     "disable slicing for all symbols generated with the given name"},
+    {"no-slice-id",
+     boost::program_options::value<std::vector<std::string>>()->value_name(
+       "id"),
+     "disable slicing for the symbol with the given id"},
     {"initialize-nondet-variables",
      NULL,
      "initialize declarations with nondet expression (if it hasn`t a default "
@@ -182,6 +184,13 @@ const struct group_opt_templ all_cmd_options[] = {
     {"bv", NULL, "use solver with bit-vector arithmetic"},
     {"ir", NULL, "use solver with integer/real arithmetic"},
     {"smtlib", NULL, "use SMT lib format"},
+    {"default-solver",
+     boost::program_options::value<std::string>()->value_name("<solver>"),
+     "override default solver used if no concrete one is specified"
+#ifdef BOOLECTOR
+     " (Boolector)"
+#endif
+    },
     {"non-supported-models-as-zero",
      NULL,
      "if ESBMC can't extract a type/expression from the solver, then the value "
diff --git a/src/esbmc/show_vcc.cpp b/src/esbmc/show_vcc.cpp
index 1856407ce..6c00b3eca 100644
--- a/src/esbmc/show_vcc.cpp
+++ b/src/esbmc/show_vcc.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Symbolic Execution of ANSI-C
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <esbmc/bmc.h>
 #include <fmt/format.h>
 #include <fstream>
@@ -21,7 +13,7 @@ void bmct::show_vcc(
 {
   out << "\nVERIFICATION CONDITIONS:\n\n";
 
-  languagest languages(ns, MODE_C, msg);
+  languagest languages(ns, language_idt::C);
 
   for(symex_target_equationt::SSA_stepst::iterator it = eq->SSA_steps.begin();
       it != eq->SSA_steps.end();
@@ -68,14 +60,14 @@ void bmct::show_vcc(std::shared_ptr<symex_target_equationt> &eq)
   {
     std::ostringstream oss;
     show_vcc(oss, eq);
-    msg.status(oss.str());
+    log_status("{}", oss.str());
   }
 
   else
   {
     std::ofstream out(filename.c_str());
     if(!out)
-      msg.error(fmt::format("failed to open {}", filename));
+      log_error("failed to open {}", filename);
     else
       show_vcc(out, eq);
   }
diff --git a/src/goto-programs/add_race_assertions.cpp b/src/goto-programs/add_race_assertions.cpp
index 4ac084f25..571b48bf0 100644
--- a/src/goto-programs/add_race_assertions.cpp
+++ b/src/goto-programs/add_race_assertions.cpp
@@ -1,15 +1,3 @@
-/*******************************************************************\
-
-Module: Race Detection for Threaded Goto Programs
-
-Author: Daniel Kroening
-		Lucas Cordeiro (lcc08r@ecs.soton.ac.uk)
-
-Date: February 2006
-	  May 2010
-
-\*******************************************************************/
-
 #include <goto-programs/add_race_assertions.h>
 #include <goto-programs/remove_skip.h>
 #include <goto-programs/rw_set.h>
@@ -78,7 +66,7 @@ void w_guardst::add_initialization(goto_programt &goto_program) const
 
   for(const auto &w_guard : w_guards)
   {
-    exprt symbol = symbol_expr(ns.lookup(w_guard));
+    exprt symbol = symbol_expr(*ns.lookup(w_guard));
     expr2tc new_sym;
     migrate_expr(symbol, new_sym);
 
@@ -94,8 +82,7 @@ void add_race_assertions(
   value_setst &value_sets,
   contextt &context,
   goto_programt &goto_program,
-  w_guardst &w_guards,
-  const messaget &msg)
+  w_guardst &w_guards)
 {
   namespacet ns(context);
 
@@ -106,7 +93,7 @@ void add_race_assertions(
     if(instruction.is_assign())
     {
       exprt tmp_expr = migrate_expr_back(instruction.code);
-      rw_sett rw_set(ns, value_sets, i_it, to_code(tmp_expr), msg);
+      rw_sett rw_set(ns, value_sets, i_it, to_code(tmp_expr));
 
       if(rw_set.entries.empty())
         continue;
@@ -176,12 +163,11 @@ void add_race_assertions(
 void add_race_assertions(
   value_setst &value_sets,
   contextt &context,
-  goto_programt &goto_program,
-  const messaget &msg)
+  goto_programt &goto_program)
 {
   w_guardst w_guards(context);
 
-  add_race_assertions(value_sets, context, goto_program, w_guards, msg);
+  add_race_assertions(value_sets, context, goto_program, w_guards);
 
   w_guards.add_initialization(goto_program);
   goto_program.update();
@@ -190,13 +176,12 @@ void add_race_assertions(
 void add_race_assertions(
   value_setst &value_sets,
   contextt &context,
-  goto_functionst &goto_functions,
-  const messaget &msg)
+  goto_functionst &goto_functions)
 {
   w_guardst w_guards(context);
 
   Forall_goto_functions(f_it, goto_functions)
-    add_race_assertions(value_sets, context, f_it->second.body, w_guards, msg);
+    add_race_assertions(value_sets, context, f_it->second.body, w_guards);
 
   // get "main"
   goto_functionst::function_mapt::iterator m_it =
diff --git a/src/goto-programs/add_race_assertions.h b/src/goto-programs/add_race_assertions.h
index d977a2b77..7d4908011 100644
--- a/src/goto-programs/add_race_assertions.h
+++ b/src/goto-programs/add_race_assertions.h
@@ -1,13 +1,3 @@
-/*******************************************************************\
-
-Module: Race Detection for Threaded Goto Programs
-
-Author: Daniel Kroening
-
-Date: February 2006
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_PROGRAMS_RACE_DETECTION_H
 #define CPROVER_GOTO_PROGRAMS_RACE_DETECTION_H
 
@@ -18,13 +8,11 @@ Date: February 2006
 void add_race_assertions(
   value_setst &value_sets,
   contextt &context,
-  goto_programt &goto_program,
-  const messaget &msg);
+  goto_programt &goto_program);
 
 void add_race_assertions(
   value_setst &value_sets,
   contextt &context,
-  goto_functionst &goto_functions,
-  const messaget &msg);
+  goto_functionst &goto_functions);
 
 #endif
diff --git a/src/goto-programs/ai.cpp b/src/goto-programs/ai.cpp
index ce07ba266..09013fa95 100644
--- a/src/goto-programs/ai.cpp
+++ b/src/goto-programs/ai.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Abstract Interpretation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 /// \file
 /// Abstract Interpretation
 
@@ -18,10 +10,8 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <util/std_code.h>
 #include <util/std_expr.h>
 
-void ai_baset::output(
-  const goto_functionst &goto_functions,
-  std::ostream &out,
-  const messaget &msg) const
+void ai_baset::output(const goto_functionst &goto_functions, std::ostream &out)
+  const
 {
   forall_goto_functions(f_it, goto_functions)
   {
@@ -34,12 +24,11 @@ void ai_baset::output(
 
       forall_goto_program_instructions(i_it, f_it->second.body)
       {
-        out << "**** " << i_it->location_number << " " << i_it->location
-            << "\n";
+        out << i_it->location_number << " " << i_it->location << "\n";
 
         abstract_state_before(i_it)->output(out);
         out << "\n";
-        i_it->output_instruction(*migrate_namespace_lookup, "", out, msg);
+        i_it->output_instruction(*migrate_namespace_lookup, "", out);
         out << "\n";
       }
     }
diff --git a/src/goto-programs/ai.h b/src/goto-programs/ai.h
index 66ecaa828..aef29bdf7 100644
--- a/src/goto-programs/ai.h
+++ b/src/goto-programs/ai.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Abstract Interpretation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 /// \file
 /// Abstract Interpretation
 
@@ -20,16 +12,6 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <util/xml.h>
 #include <util/expr.h>
 
-// This is a stand-in for std::make_unique, which isn't part of the standard
-// library until C++14.  When we move to C++14, we should do a find-and-replace
-// on this to use std::make_unique instead.
-
-template <typename T, typename... Ts>
-static inline std::unique_ptr<T> util_make_unique(Ts &&...ts)
-{
-  return std::unique_ptr<T>(new T(std::forward<Ts>(ts)...));
-}
-
 /// The basic interface of an abstract interpreter.  This should be enough
 /// to create, run and query an abstract interpreter.
 // don't use me -- I am just a base class
@@ -91,10 +73,8 @@ public:
   {
   }
 
-  virtual void output(
-    const goto_functionst &goto_functions,
-    std::ostream &out,
-    const messaget &msg) const;
+  virtual void
+  output(const goto_functionst &goto_functions, std::ostream &out) const;
 
 protected:
   // overload to add a factory
@@ -211,12 +191,12 @@ public:
     typename state_mapt::const_iterator it = state_map.find(t);
     if(it == state_map.end())
     {
-      std::unique_ptr<statet> d = util_make_unique<domainT>();
+      std::unique_ptr<statet> d = std::make_unique<domainT>();
       assert(d->is_bottom());
       return d;
     }
 
-    return util_make_unique<domainT>(it->second);
+    return std::make_unique<domainT>(it->second);
   }
 
   void clear() override
@@ -262,7 +242,7 @@ protected:
 
   std::unique_ptr<statet> make_temporary_state(const statet &s) override
   {
-    return util_make_unique<domainT>(static_cast<const domainT &>(s));
+    return std::make_unique<domainT>(static_cast<const domainT &>(s));
   }
 
   void fixedpoint(const goto_functionst &goto_functions, const namespacet &ns)
diff --git a/src/goto-programs/ai_domain.cpp b/src/goto-programs/ai_domain.cpp
index e6a037d04..e0df898f1 100644
--- a/src/goto-programs/ai_domain.cpp
+++ b/src/goto-programs/ai_domain.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Abstract Interpretation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 /// \file
 /// Abstract Interpretation Domain
 
diff --git a/src/goto-programs/ai_domain.h b/src/goto-programs/ai_domain.h
index dde2100c3..aecc7acac 100644
--- a/src/goto-programs/ai_domain.h
+++ b/src/goto-programs/ai_domain.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Abstract Interpretation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 /// \file
 /// Abstract Interpretation Domain
 
diff --git a/src/goto-programs/builtin_functions.cpp b/src/goto-programs/builtin_functions.cpp
index b3ad8f785..05ff81dfb 100644
--- a/src/goto-programs/builtin_functions.cpp
+++ b/src/goto-programs/builtin_functions.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Program Transformation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <goto-programs/goto_convert_class.h>
 #include <regex>
@@ -15,23 +7,24 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <util/expr_util.h>
 #include <util/i2string.h>
 #include <util/location.h>
+#include <util/message.h>
+#include <util/message/format.h>
 #include <util/prefix.h>
 #include <util/simplify_expr.h>
 #include <util/std_code.h>
 #include <util/std_expr.h>
 #include <util/type_byte_size.h>
 
-static const std::string &
-get_string_constant(const exprt &expr, const messaget &msg)
+static const std::string &get_string_constant(const exprt &expr)
 {
   if(expr.id() == "typecast" && expr.operands().size() == 1)
-    return get_string_constant(expr.op0(), msg);
+    return get_string_constant(expr.op0());
 
   if(
     !expr.is_address_of() || expr.operands().size() != 1 ||
     !expr.op0().is_index() || expr.op0().operands().size() != 2)
   {
-    msg.error(fmt::format("expected string constant, but got:\n{}", expr));
+    log_error("expected string constant, but got:\n{}", expr);
     abort();
   }
 
@@ -122,14 +115,14 @@ void goto_convertt::do_atomic_begin(
 {
   if(lhs.is_not_nil())
   {
-    err_location(lhs);
-    throw "atomic_begin does not expect an LHS";
+    log_error("atomic_begin does not expect an LHS");
+    abort();
   }
 
   if(arguments.size() != 0)
   {
-    err_location(function);
-    throw "atomic_begin takes zero argument";
+    log_error("atomic_begin takes zero argument");
+    abort();
   }
 
   // We should allow a context switch to happen before synchronization points.
@@ -151,14 +144,14 @@ void goto_convertt::do_atomic_end(
 {
   if(lhs.is_not_nil())
   {
-    err_location(lhs);
-    throw "atomic_end does not expect an LHS";
+    log_error("atomic_end does not expect an LHS");
+    abort();
   }
 
   if(!arguments.empty())
   {
-    err_location(function);
-    throw "atomic_end takes no arguments";
+    log_error("atomic_end takes no arguments");
+    abort();
   }
 
   goto_programt::targett t = dest.add_instruction(ATOMIC_END);
@@ -271,7 +264,7 @@ void goto_convertt::do_cpp_new(
   }
 
   // grab initializer
-  goto_programt tmp_initializer(get_message_handler());
+  goto_programt tmp_initializer;
   cpp_new_initializer(lhs, rhs, tmp_initializer);
 
   exprt alloc_size;
@@ -319,10 +312,6 @@ void goto_convertt::do_cpp_new(
   valid_expr.copy_to_operands(lhs);
   exprt neg_valid_expr = gen_not(valid_expr);
 
-  exprt deallocated_expr("deallocated_object", typet("bool"));
-  deallocated_expr.copy_to_operands(lhs);
-  exprt neg_deallocated_expr = gen_not(deallocated_expr);
-
   exprt pointer_offset_expr("pointer_offset", pointer_type());
   pointer_offset_expr.copy_to_operands(lhs);
 
@@ -353,12 +342,6 @@ void goto_convertt::do_cpp_new(
   migrate_expr(assign, t_s_a->code);
   t_s_a->location = rhs.find_location();
 
-  //now set deallocated bit
-  goto_programt::targett t_d_i = dest.add_instruction(ASSIGN);
-  codet tmp = code_assignt(deallocated_expr, false_exprt());
-  migrate_expr(tmp, t_d_i->code);
-  t_d_i->location = rhs.find_location();
-
   // run initializer
   dest.destructive_append(tmp_initializer);
 }
@@ -421,8 +404,8 @@ void goto_convertt::do_exit(
 {
   if(arguments.size() != 1)
   {
-    err_location(function);
-    throw "exit expected to have one argument";
+    log_error("exit expected to have one argument");
+    abort();
   }
 
   // same as assume(false)
@@ -440,8 +423,8 @@ void goto_convertt::do_abort(
 {
   if(arguments.size() != 0)
   {
-    err_location(function);
-    throw "abort expected to have no arguments";
+    log_error("abort expected to have no arguments");
+    abort();
   }
 
   // same as assume(false)
@@ -459,8 +442,8 @@ void goto_convertt::do_free(
 {
   if(lhs.is_not_nil())
   {
-    err_location(function);
-    throw "free is expected not to have LHS";
+    log_error("free is expected not to have LHS");
+    abort();
   }
 
   // preserve the call
@@ -514,18 +497,18 @@ void goto_convertt::do_function_call_symbol(
   // lookup symbol
   const irep_idt &identifier = function.identifier();
 
-  const symbolt *symbol;
-  if(ns.lookup(identifier, symbol))
+  const symbolt *symbol = ns.lookup(identifier);
+  if(!symbol)
   {
-    err_location(function);
-    throw "error: function `" + id2string(identifier) + "' not found";
+    log_error("error: function `{}' not found", id2string(identifier));
+    abort();
   }
 
   if(!symbol->type.is_code())
   {
-    err_location(function);
-    throw "error: function `" + id2string(identifier) +
-      "' type mismatch: expected code";
+    log_error(
+      "error: function `{}' type mismatch: expected code",
+      id2string(identifier));
   }
 
   // If the symbol is not nil, i.e., the user defined the expected behaviour of
@@ -553,8 +536,8 @@ void goto_convertt::do_function_call_symbol(
   {
     if(arguments.size() != 1)
     {
-      err_location(function);
-      throw "`" + id2string(base_name) + "' expected to have one argument";
+      log_error("`{}' expected to have one argument", id2string(base_name));
+      abort();
     }
 
     if(options.get_bool_option("no-assertions") && !is_assume)
@@ -581,16 +564,18 @@ void goto_convertt::do_function_call_symbol(
 
     if(lhs.is_not_nil())
     {
-      err_location(function);
-      throw id2string(base_name) + " expected not to have LHS";
+      log_error("{} expected not to have LHS", id2string(base_name));
+      abort();
     }
   }
   else if(base_name == "__ESBMC_assert")
   {
-    if(arguments.size() != 2)
+    // 1 argument --> Default assertion
+    // 2 arguments --> Normal assertion + MSG
+    if(arguments.size() > 2)
     {
-      err_location(function);
-      throw "`" + id2string(base_name) + "' expected to have two arguments";
+      log_error("`{}' expected to have two arguments", id2string(base_name));
+      abort();
     }
 
     if(options.get_bool_option("no-assertions"))
@@ -599,18 +584,18 @@ void goto_convertt::do_function_call_symbol(
     goto_programt::targett t = dest.add_instruction(ASSERT);
     migrate_expr(arguments[0], t->guard);
 
-    const std::string &description =
-      get_string_constant(arguments[1], message_handler);
+    const std::string &description = arguments.size() == 1
+                                       ? "ESBMC assertion"
+                                       : get_string_constant(arguments[1]);
     t->location = function.location();
     t->location.user_provided(true);
     t->location.property("assertion");
     t->location.comment(description);
-    t->assert_mode = goto_assertions::USER;
 
     if(lhs.is_not_nil())
     {
-      err_location(function);
-      throw id2string(base_name) + " expected not to have LHS";
+      log_error("{} expected not to have LHS", id2string(base_name));
+      abort();
     }
   }
   else if(
@@ -619,8 +604,8 @@ void goto_convertt::do_function_call_symbol(
   {
     if(!arguments.empty())
     {
-      err_location(function);
-      throw "`" + id2string(base_name) + "' expected to have no arguments";
+      log_error("`{}' expected to have no arguments", id2string(base_name));
+      abort();
     }
 
     goto_programt::targett t = dest.add_instruction(ASSERT);
@@ -628,12 +613,11 @@ void goto_convertt::do_function_call_symbol(
     t->location = function.location();
     t->location.user_provided(true);
     t->location.property("assertion");
-    t->assert_mode = goto_assertions::USER;
 
     if(lhs.is_not_nil())
     {
-      err_location(function);
-      throw "`" + id2string(base_name) + "' expected not to have LHS";
+      log_error("`{}' expected not to have LHS", id2string(base_name));
+      abort();
     }
 
     // __VERIFIER_error has abort() semantics, even if no assertions
@@ -712,13 +696,12 @@ void goto_convertt::do_function_call_symbol(
 
     if(arguments.size() != 4)
     {
-      err_location(function);
-      throw "`" + id2string(base_name) + "' expected to have four arguments";
+      log_error("`{}' expected to have four arguments", id2string(base_name));
+      abort();
     }
 
     const irep_idt description =
-      "assertion " +
-      id2string(get_string_constant(arguments[0], message_handler));
+      "assertion " + id2string(get_string_constant(arguments[0]));
 
     if(options.get_bool_option("no-assertions"))
       return;
@@ -729,7 +712,6 @@ void goto_convertt::do_function_call_symbol(
     t->location.user_provided(true);
     t->location.property("assertion");
     t->location.comment(description);
-    t->assert_mode = goto_assertions::USER;
     // we ignore any LHS
   }
   else if(config.ansi_c.target.is_freebsd() && base_name == "__assert")
@@ -738,13 +720,12 @@ void goto_convertt::do_function_call_symbol(
 
     if(arguments.size() != 4)
     {
-      err_location(function);
-      throw "`" + id2string(base_name) + "' expected to have four arguments";
+      log_error("`{}' expected to have four arguments", id2string(base_name));
+      abort();
     }
 
     const irep_idt description =
-      "assertion " +
-      id2string(get_string_constant(arguments[3], message_handler));
+      "assertion " + id2string(get_string_constant(arguments[3]));
 
     if(options.get_bool_option("no-assertions"))
       return;
@@ -755,7 +736,6 @@ void goto_convertt::do_function_call_symbol(
     t->location.user_provided(true);
     t->location.property("assertion");
     t->location.comment(description);
-    t->assert_mode = goto_assertions::USER;
     // we ignore any LHS
   }
   else if(base_name == "_wassert")
@@ -764,12 +744,12 @@ void goto_convertt::do_function_call_symbol(
 
     if(arguments.size() != 3)
     {
-      err_location(function);
-      throw "`" + id2string(base_name) + "' expected to have three arguments";
+      log_error("`{}' expected to have three arguments", id2string(base_name));
+      abort();
     }
 
     const std::string description =
-      "assertion " + get_string_constant(arguments[0], message_handler);
+      "assertion " + get_string_constant(arguments[0]);
 
     if(options.get_bool_option("no-assertions"))
       return;
@@ -780,7 +760,6 @@ void goto_convertt::do_function_call_symbol(
     t->location.user_provided(true);
     t->location.property("assertion");
     t->location.comment(description);
-    t->assert_mode = goto_assertions::USER;
     // we ignore any LHS
   }
   else if(base_name == "operator new")
@@ -810,8 +789,8 @@ void goto_convertt::do_function_call_symbol(
 
     if(arguments.size() != 1)
     {
-      err_location(function);
-      throw "`" + id2string(base_name) + "' expected to have one argument";
+      log_error("`{}' expected to have one argument", id2string(base_name));
+      abort();
     }
 
     exprt list_arg = make_va_list(arguments[0]);
@@ -843,8 +822,8 @@ void goto_convertt::do_function_call_symbol(
   {
     if(arguments.size() != 2)
     {
-      err_location(function);
-      throw "`" + id2string(base_name) + "' expected to have two arguments";
+      log_error("`{}' expected to have two arguments", id2string(base_name));
+      abort();
     }
 
     exprt dest_expr = make_va_list(arguments[0]);
@@ -852,8 +831,8 @@ void goto_convertt::do_function_call_symbol(
 
     if(!is_lvalue(dest_expr))
     {
-      err_location(dest_expr);
-      throw "va_copy argument expected to be lvalue";
+      log_error("va_copy argument expected to be lvalue");
+      abort();
     }
 
     goto_programt::targett t = dest.add_instruction(ASSIGN);
@@ -867,8 +846,8 @@ void goto_convertt::do_function_call_symbol(
     // parameter argument.
     if(arguments.size() != 2)
     {
-      err_location(function);
-      throw "`" + id2string(base_name) + "' expected to have two arguments";
+      log_error("`{}' expected to have two arguments", id2string(base_name));
+      abort();
     }
 
     exprt dest_expr = make_va_list(arguments[0]);
@@ -877,8 +856,8 @@ void goto_convertt::do_function_call_symbol(
 
     if(!is_lvalue(dest_expr))
     {
-      err_location(dest_expr);
-      throw "va_start argument expected to be lvalue";
+      log_error("va_start argument expected to be lvalue");
+      abort();
     }
 
     goto_programt::targett t = dest.add_instruction(ASSIGN);
@@ -891,16 +870,16 @@ void goto_convertt::do_function_call_symbol(
     // Invalidates the argument. We do so by setting it to NULL.
     if(arguments.size() != 1)
     {
-      err_location(function);
-      throw "`" + id2string(base_name) + "' expected to have one argument";
+      log_error("`{}' expected to have one argument", id2string(base_name));
+      abort();
     }
 
     exprt dest_expr = make_va_list(arguments[0]);
 
     if(!is_lvalue(dest_expr))
     {
-      err_location(dest_expr);
-      throw "va_end argument expected to be lvalue";
+      log_error("va_end argument expected to be lvalue");
+      abort();
     }
 
     // our __builtin_va_list is a pointer
diff --git a/src/goto-programs/destructor.cpp b/src/goto-programs/destructor.cpp
index eeec90c82..8b92fdc4a 100644
--- a/src/goto-programs/destructor.cpp
+++ b/src/goto-programs/destructor.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Destructor Calls
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <goto-programs/destructor.h>
 
 bool get_destructor(
diff --git a/src/goto-programs/destructor.h b/src/goto-programs/destructor.h
index 896371245..198e916f8 100644
--- a/src/goto-programs/destructor.h
+++ b/src/goto-programs/destructor.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Destructor Calls
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_PROGRAMS_DESTRUCTOR_H
 #define CPROVER_GOTO_PROGRAMS_DESTRUCTOR_H
 
diff --git a/src/goto-programs/format_strings.cpp b/src/goto-programs/format_strings.cpp
index 869e53afb..b1b6f5bdd 100644
--- a/src/goto-programs/format_strings.cpp
+++ b/src/goto-programs/format_strings.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Format String Parser
-
-Author: CM Wintersteiger
-
-\*******************************************************************/
-
 #include <cctype>
 #include <goto-programs/format_strings.h>
 
diff --git a/src/goto-programs/format_strings.h b/src/goto-programs/format_strings.h
index 8a3a561a4..3d86b5e22 100644
--- a/src/goto-programs/format_strings.h
+++ b/src/goto-programs/format_strings.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Format String Parser
-
-Author: CM Wintersteiger
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_PROGRAMS_FORMAT_STRINGS_H_
 #define CPROVER_GOTO_PROGRAMS_FORMAT_STRINGS_H_
 
diff --git a/src/goto-programs/goto_assert_mode.h b/src/goto-programs/goto_assert_mode.h
deleted file mode 100644
index 39c9a8ea0..000000000
--- a/src/goto-programs/goto_assert_mode.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*******************************************************************\
- Module: GOTO Assert Mode
- Author: Rafael S Menezes
- Date: June 2022
-
- Description: The assert mode will categorize every assertion that
-              ESBMC does. This needs to work with primitive integers
-              as user will use that to comunicate with the symex
-\*******************************************************************/
-
-namespace goto_assertions
-{
-/**
- * Assertions should belong to a specific category
- */
-enum goto_assertion_mode
-{
-  USER = 1, // __ESBMC_assert, assert
-  POINTER_SAFETY =
-    2, // leaks, double-free, segmentation fault, dereference invalid address
-  ARRAY_SAFETY = 4, // out-of-bounds
-  ARITHMETIC_SAFETY =
-    8,       // arithmetic overflows/underflows, division by zero, NaN
-  OTHER = 16 // Default for every other assertion (TODO: will remove this)
-};
-
-constexpr goto_assertion_mode ALL_MODES = (goto_assertion_mode)0xFF;
-
-inline bool is_mode_enabled(const goto_assertion_mode &assertions, char mode)
-{
-  return (mode & assertions) != 0;
-};
-
-inline void disable_mode(goto_assertion_mode &assertions, char mode)
-{
-  assertions = (goto_assertion_mode)(assertions & ~mode);
-}
-
-inline void enable_mode(goto_assertion_mode &assertions, char mode)
-{
-  assertions = (goto_assertion_mode)(assertions | mode);
-}
-} // namespace goto_assertions
\ No newline at end of file
diff --git a/src/goto-programs/goto_check.cpp b/src/goto-programs/goto_check.cpp
index eb9d154d8..1cd1affac 100644
--- a/src/goto-programs/goto_check.cpp
+++ b/src/goto-programs/goto_check.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************
- Module: GOTO Programs
-
- Author: Daniel Kroening, kroening@kroening.com Lucas Cordeiro,
- lcc08r@ecs.soton.ac.uk
-
- \*******************************************************************/
-
 #include <goto-programs/goto_check.h>
 #include <util/arith_tools.h>
 #include <util/array_name.h>
@@ -19,11 +11,9 @@
 class goto_checkt
 {
 public:
-  goto_checkt(const namespacet &_ns, optionst &_options, const messaget &msg)
+  goto_checkt(const namespacet &_ns, optionst &_options)
     : ns(_ns),
       options(_options),
-      msg(msg),
-      new_code(msg),
       disable_bounds_check(options.get_bool_option("no-bounds-check")),
       disable_pointer_check(options.get_bool_option("no-pointer-check")),
       disable_div_by_zero_check(
@@ -40,7 +30,6 @@ public:
 protected:
   const namespacet &ns;
   optionst &options;
-  const messaget &msg;
 
   void check(const expr2tc &expr, const locationt &location);
 
@@ -81,8 +70,7 @@ protected:
     const std::string &comment,
     const std::string &property,
     const locationt &location,
-    const guardt &guard,
-    const goto_assertions::goto_assertion_mode mode = goto_assertions::OTHER);
+    const guardt &guard);
 
   goto_programt new_code;
   std::set<expr2tc> assertions;
@@ -120,8 +108,7 @@ void goto_checkt::div_by_zero_check(
     "division by zero",
     "division-by-zero",
     loc,
-    guard,
-    goto_assertions::ARITHMETIC_SAFETY);
+    guard);
 }
 
 void goto_checkt::float_overflow_check(
@@ -180,8 +167,7 @@ void goto_checkt::float_overflow_check(
       "arithmetic overflow on floating-point " + get_expr_id(expr),
       "overflow",
       loc,
-      guard,
-      goto_assertions::ARITHMETIC_SAFETY);
+      guard);
   }
   else if(is_ieee_add2t(expr) || is_ieee_sub2t(expr) || is_ieee_mul2t(expr))
   {
@@ -200,8 +186,7 @@ void goto_checkt::float_overflow_check(
       "arithmetic overflow on floating-point " + get_expr_id(expr),
       "overflow",
       loc,
-      guard,
-      goto_assertions::ARITHMETIC_SAFETY);
+      guard);
   }
 }
 
@@ -215,7 +200,12 @@ void goto_checkt::overflow_check(
 
   // First, check type.
   const type2tc &type = ns.follow(expr->type);
-  if(!is_signedbv_type(type))
+  if(config.language == language_idt::SOLIDITY)
+  {
+    if(!is_signedbv_type(type) && !is_unsignedbv_type(type))
+      return;
+  }
+  else if(!is_signedbv_type(type))
     return;
 
   // Don't check pointer overflow
@@ -233,8 +223,7 @@ void goto_checkt::overflow_check(
     "arithmetic overflow on " + get_expr_id(expr),
     "overflow",
     loc,
-    guard,
-    goto_assertions::ARITHMETIC_SAFETY);
+    guard);
 }
 
 void goto_checkt::nan_check(
@@ -254,13 +243,7 @@ void goto_checkt::nan_check(
   expr2tc isnan = expr2tc(new isnan2t(expr));
   make_not(isnan);
 
-  add_guarded_claim(
-    isnan,
-    "NaN on " + get_expr_id(expr),
-    "NaN",
-    loc,
-    guard,
-    goto_assertions::ARITHMETIC_SAFETY);
+  add_guarded_claim(isnan, "NaN on " + get_expr_id(expr), "NaN", loc, guard);
 }
 
 void goto_checkt::pointer_rel_check(
@@ -283,12 +266,7 @@ void goto_checkt::pointer_rel_check(
 
     same_object2tc same_object(side_1, side_2);
     add_guarded_claim(
-      same_object,
-      "Same object violation",
-      "pointer",
-      loc,
-      guard,
-      goto_assertions::POINTER_SAFETY);
+      same_object, "Same object violation", "pointer", loc, guard);
   }
 }
 
@@ -353,7 +331,6 @@ void goto_checkt::bounds_check(
 
   std::string name =
     "array bounds violated: " + array_name(ns, ind.source_value);
-
   const expr2tc &the_index = ind.index;
 
   // Lower bound access should be greather than zero
@@ -361,44 +338,13 @@ void goto_checkt::bounds_check(
   assert(!is_nil_expr(zero));
 
   greaterthanequal2tc lower(the_index, zero);
-  add_guarded_claim(
-    lower,
-    name + " lower bound",
-    "array bounds",
-    loc,
-    guard,
-    goto_assertions::ARRAY_SAFETY);
+  add_guarded_claim(lower, name + " lower bound", "array bounds", loc, guard);
 
   assert(is_array_type(t) || is_string_type(t) || is_vector_type(t));
 
   // We can't check the upper bound of an infinite sized array
-  // or of FAMs
-  // TODO: Rewrite this in a proper way
-  if(
-    is_array_type(t) &&
-    (to_array_type(t).size_is_infinite || !to_array_type(t).get_width()))
-  {
-    // Is it a FAM?
-    if(is_member2t(ind.source_value))
-    {
-      auto member = to_member2t(ind.source_value);
-      if(is_symbol2t(member.source_value))
-      {
-        // Lookup for FAM
-        auto fam = ns.lookup(to_symbol2t(member.source_value).thename);
-
-        // If it is a dereference, lets check it later!
-        if(fam.value.is_dereference())
-          return;
-
-        // We can add the bound check then!
-      }
-      else
-        return;
-    }
-    else
-      return;
-  }
+  if(is_array_type(t) && to_array_type(t).size_is_infinite)
+    return;
 
   const expr2tc &array_size =
     is_array_type(t) ? to_array_type(t).array_size
@@ -409,13 +355,7 @@ void goto_checkt::bounds_check(
   // Cast size to index type
   typecast2tc casted_size(the_index->type, array_size);
   lessthan2tc upper(the_index, casted_size);
-  add_guarded_claim(
-    upper,
-    name + " upper bound",
-    "array bounds",
-    loc,
-    guard,
-    goto_assertions::ARRAY_SAFETY);
+  add_guarded_claim(upper, name + " upper bound", "array bounds", loc, guard);
 }
 
 void goto_checkt::add_guarded_claim(
@@ -423,8 +363,7 @@ void goto_checkt::add_guarded_claim(
   const std::string &comment,
   const std::string &property,
   const locationt &location,
-  const guardt &guard,
-  const goto_assertions::goto_assertion_mode mode)
+  const guardt &guard)
 {
   expr2tc e = expr;
 
@@ -446,7 +385,6 @@ void goto_checkt::add_guarded_claim(
     t->location = location;
     t->location.comment(comment);
     t->location.property(property);
-    t->assert_mode = mode;
   }
 }
 
@@ -660,17 +598,16 @@ void goto_check(
   optionst &options,
   goto_programt &goto_program)
 {
-  goto_checkt goto_check(ns, options, goto_program.msg);
+  goto_checkt goto_check(ns, options);
   goto_check.goto_check(goto_program);
 }
 
 void goto_check(
   const namespacet &ns,
   optionst &options,
-  goto_functionst &goto_functions,
-  const messaget &msg)
+  goto_functionst &goto_functions)
 {
-  goto_checkt goto_check(ns, options, msg);
+  goto_checkt goto_check(ns, options);
 
   for(auto &it : goto_functions.function_map)
   {
diff --git a/src/goto-programs/goto_check.h b/src/goto-programs/goto_check.h
index e467b7dcb..e346f0659 100644
--- a/src/goto-programs/goto_check.h
+++ b/src/goto-programs/goto_check.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Program Transformation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_PROGRAMS_GOTO_CHECK_H
 #define CPROVER_GOTO_PROGRAMS_GOTO_CHECK_H
 
@@ -17,7 +9,6 @@ Author: Daniel Kroening, kroening@kroening.com
 void goto_check(
   const namespacet &ns,
   optionst &options,
-  goto_functionst &goto_functions,
-  const messaget &msg);
+  goto_functionst &goto_functions);
 
 #endif
diff --git a/src/goto-programs/goto_contractor.cpp b/src/goto-programs/goto_contractor.cpp
index cdd257bd0..0315f781e 100644
--- a/src/goto-programs/goto_contractor.cpp
+++ b/src/goto-programs/goto_contractor.cpp
@@ -1,14 +1,8 @@
-//
-// Created by Mohannad Aldughaim on 09/01/2022.
-//
-
 #include <goto-programs/goto_contractor.h>
 
-void goto_contractor(
-  goto_functionst &goto_functions,
-  const messaget &message_handler)
+void goto_contractor(goto_functionst &goto_functions)
 {
-  goto_contractort gotoContractort(goto_functions, message_handler);
+  goto_contractort gotoContractort(goto_functions);
 
   goto_functions.update();
 }
@@ -39,7 +33,7 @@ void goto_contractort::get_intervals(goto_functionst goto_functions)
       parse_intervals(ins.guard);
 }
 
-void goto_contractort::parse_intervals(irep_container<expr2t> expr)
+void goto_contractort::parse_intervals(expr2tc expr)
 {
   symbol2tc symbol;
   BigInt value;
@@ -80,7 +74,6 @@ void goto_contractort::parse_intervals(irep_container<expr2t> expr)
 
   value = to_constant_int2t(side2).as_long() * (neg ? -1 : 1);
 
-  //int index = map->find(symbol->get_symbol_name());
   if(map.find(symbol->get_symbol_name()) == CspMap::NOT_FOUND)
     return;
   switch(expr->expr_id)
@@ -104,39 +97,49 @@ void goto_contractort::parse_intervals(irep_container<expr2t> expr)
 void goto_contractort::insert_assume(goto_functionst goto_functions)
 {
   loopst loop;
+  unsigned int last_loc = 0;
+
+  ///This loop is to find the last loop in the code based on location
   for(auto &function_loop : function_loops)
-    loop = function_loop;
+    if(last_loc < function_loop.get_original_loop_head()->location_number)
+    {
+      loop = function_loop;
+      last_loc = loop.get_original_loop_head()->location_number;
+    }
 
   auto loop_exit = loop.get_original_loop_exit();
 
-  goto_programt dest(message_handler);
+  goto_programt dest;
 
   auto goto_function = goto_functions.function_map.find("c:@F@main")->second;
 
-  for(auto const &var : map.var_map)
+  if(map.is_empty_set())
   {
-    symbol2tc X = var.second.getSymbol();
-    if(var.second.isIntervalChanged())
+    auto cond = gen_zero(int_type2());
+    goto_programt tmp_e;
+    goto_programt::targett e = tmp_e.add_instruction(ASSUME);
+    e->inductive_step_instruction = false;
+    e->guard = cond;
+    e->location = loop_exit->location;
+    goto_function.body.destructive_insert(loop_exit, tmp_e);
+  }
+  else
+    for(auto const &var : map.var_map)
     {
-      auto lb = create_value_expr(var.second.getInterval().lb(), int_type2());
-      auto cond = create_greaterthanequal_relation(X, lb);
-      goto_programt tmp_e(message_handler);
-      goto_programt::targett e = tmp_e.add_instruction(ASSUME);
-      e->inductive_step_instruction = false;
-      e->guard = cond;
-      e->location = loop_exit->location;
-      goto_function.body.destructive_insert(loop_exit, tmp_e);
-
-      auto ub = create_value_expr(var.second.getInterval().ub(), int_type2());
-      auto cond2 = create_lessthanequal_relation(X, ub);
-      goto_programt tmp_e2(message_handler);
-      goto_programt::targett e2 = tmp_e2.add_instruction(ASSUME);
-      e2->inductive_step_instruction = false;
-      e2->guard = cond2;
-      e2->location = loop_exit->location;
-      goto_function.body.destructive_insert(loop_exit, tmp_e2);
+      symbol2tc X = var.second.getSymbol();
+      if(var.second.isIntervalChanged())
+      {
+        //only update upperbound
+        auto ub = create_value_expr(var.second.getInterval().ub(), int_type2());
+        auto cond2 = create_lessthanequal_relation(X, ub);
+        goto_programt tmp_e2;
+        goto_programt::targett e2 = tmp_e2.add_instruction(ASSUME);
+        e2->inductive_step_instruction = false;
+        e2->guard = cond2;
+        e2->location = loop_exit->location;
+        goto_function.body.destructive_insert(loop_exit, tmp_e2);
+      }
     }
-  }
 }
 
 void goto_contractort::contractor()
@@ -165,7 +168,7 @@ void goto_contractort::contractor()
   oss << "\n\t- Domains (after): " << X;
   map.update_intervals(X);
 
-  message_handler.status(oss.str());
+  log_status("{}", oss.str());
 }
 
 ibex::CmpOp goto_contractort::get_complement(ibex::CmpOp op)
@@ -181,21 +184,22 @@ ibex::CmpOp goto_contractort::get_complement(ibex::CmpOp op)
   case ibex::LT:
     return ibex::GEQ;
   default:
-    message_handler.status("cant process equal");
+    log_status("cant process equal");
     break;
   }
   return ibex::GEQ;
 }
 
 ibex::NumConstraint *
-goto_contractort::create_constraint_from_expr2t(irep_container<expr2t> expr)
+goto_contractort::create_constraint_from_expr2t(expr2tc expr)
 {
   ibex::NumConstraint *c;
-  if(
-    is_arith_expr(expr) || is_constant_number(expr) || is_symbol2t(expr) ||
-    is_notequal2t(expr) || is_equality2t(expr))
+  if(is_unsupported_operator(expr))
   {
-    message_handler.status("Expression is complex, skipping this assert");
+    std::ostringstream oss;
+    oss << get_expr_id(expr);
+    oss << "Expression is complex, skipping this assert.\n";
+    log_debug("{}", oss.str());
     return nullptr;
   }
 
@@ -227,6 +231,14 @@ goto_contractort::create_constraint_from_expr2t(irep_container<expr2t> expr)
   return c;
 }
 
+bool goto_contractort::is_unsupported_operator(expr2tc expr)
+{
+  expr2tc e = get_base_object(expr);
+  return is_arith_expr(e) || is_constant_number(e) || is_symbol2t(e) ||
+         is_notequal2t(e) || is_equality2t(e) || is_not2t(e) ||
+         is_modulus2t(e) || is_or2t(e) || is_and2t(e);
+}
+
 ibex::Function *
 goto_contractort::create_function_from_expr2t(irep_container<expr2t> expr)
 {
@@ -280,7 +292,7 @@ goto_contractort::create_function_from_expr2t(irep_container<expr2t> expr)
     }
     else
     {
-      message_handler.error("ERROR: MAX VAR SIZE REACHED");
+      log_error("ERROR: MAX VAR SIZE REACHED");
       return nullptr;
     }
     break;
@@ -321,8 +333,7 @@ bool goto_contractort::initialize_main_function_loops()
     runOnFunction(*it);
     if(it->second.body_available)
     {
-      const messaget msg;
-      goto_loopst goto_loops(it->first, goto_functions, it->second, msg);
+      goto_loopst goto_loops(it->first, goto_functions, it->second);
       this->function_loops = goto_loops.get_loops();
     }
   }
@@ -334,10 +345,12 @@ const ibex::Interval &vart::getInterval() const
 {
   return interval;
 }
+
 int vart::getIndex() const
 {
   return index;
 }
+
 vart::vart(const string &varName, const symbol2tc &symbol, const size_t &index)
 {
   this->var_name = varName;
@@ -345,19 +358,23 @@ vart::vart(const string &varName, const symbol2tc &symbol, const size_t &index)
   this->index = index;
   interval_changed = false;
 }
+
 void vart::setInterval(const ibex::Interval &interval)
 {
   this->interval = interval;
 }
+
 bool vart::isIntervalChanged() const
 {
   return interval_changed;
 }
+
 void vart::setIntervalChanged(bool intervalChanged)
 {
   interval_changed = intervalChanged;
 }
+
 const symbol2tc &vart::getSymbol() const
 {
   return symbol;
-}
\ No newline at end of file
+}
diff --git a/src/goto-programs/goto_contractor.h b/src/goto-programs/goto_contractor.h
index 5c580e11d..4fe943e03 100644
--- a/src/goto-programs/goto_contractor.h
+++ b/src/goto-programs/goto_contractor.h
@@ -1,7 +1,3 @@
-//
-// Created by Mohannad Aldughaim on 09/01/2022.
-//
-
 #ifndef ESBMC_GOTO_CONTRACTOR_H
 #define ESBMC_GOTO_CONTRACTOR_H
 
@@ -9,13 +5,12 @@
 #include <util/goto_expr_factory.h>
 #include <goto-programs/goto_functions.h>
 #include <util/algorithms.h>
-#include <util/message/message.h>
+#include <util/message.h>
 #include <goto-programs/goto_loops.h>
 #include <goto-programs/remove_skip.h>
 #include <goto-programs/goto_functions.h>
 #include <goto-programs/goto_functions.h>
 #include <goto-programs/loopst.h>
-#include <util/message/message_stream.h>
 #include <util/std_types.h>
 #include <ibex.h>
 #include <ibex/ibex_Interval.h>
@@ -24,9 +19,7 @@
 #include <irep2/irep2.h>
 #include <util/type_byte_size.h>
 
-void goto_contractor(
-  goto_functionst &goto_functions,
-  const messaget &message_handler);
+void goto_contractor(goto_functionst &goto_functions);
 
 class vart
 {
@@ -115,6 +108,11 @@ public:
 
   void update_intervals(ibex::IntervalVector vector)
   {
+    //check if interval box is empty set or if the interval is degenerated
+    // in the case of a single interval
+    if(vector.is_empty() || (vector.size() == 1 && vector[0].is_degenerated()))
+      is_empty_vector = true;
+
     for(auto &var : var_map)
     {
       if(var.second.getInterval() != vector[var.second.getIndex()])
@@ -127,6 +125,13 @@ public:
 
 private:
   size_t n = 0;
+  bool is_empty_vector = false;
+
+public:
+  bool is_empty_set() const
+  {
+    return is_empty_vector;
+  }
 };
 
 class goto_contractort : public goto_functions_algorithm
@@ -140,40 +145,38 @@ public:
    * Third, applying the contractor.
    * Fourth, inserting assumes in the program to reflect the contracted intervals.
    * @param _goto_functions
-   * @param _message_handler
    */
-  goto_contractort(
-    goto_functionst &_goto_functions,
-    const messaget &_message_handler)
-    : goto_functions_algorithm(_goto_functions, true)
+  goto_contractort(goto_functionst &_goto_functions)
+    : goto_functions_algorithm(true), goto_functions(_goto_functions)
   {
-    message_handler = _message_handler;
     initialize_main_function_loops();
     if(!function_loops.empty())
     {
       vars = new ibex::Variable(CspMap::MAX_VAR);
-      message_handler.status(
-        "1/4 - Parsing asserts to create CSP Constraints.");
+      log_status("1/4 - Parsing asserts to create CSP Constraints.");
       get_constraints(_goto_functions);
       if(constraint == nullptr)
       {
-        message_handler.status(
+        log_status(
           "Constraint expression not supported. Aborting goto-contractor");
         return;
       }
 
-      message_handler.status(
+      log_status(
         "2/4 - Parsing assumes to set values for variables intervals.");
       get_intervals(_goto_functions);
 
-      message_handler.status("3/4 - Applying contractor.");
+      log_status("3/4 - Applying contractor.");
       contractor();
 
-      message_handler.status("4/4 - Inserting assumes.");
+      log_status("4/4 - Inserting assumes.");
       insert_assume(_goto_functions);
     }
   }
 
+protected:
+  goto_functionst &goto_functions;
+
 private:
   ibex::IntervalVector domains;
   ///vars variable references to be used in Ibex formulas
@@ -188,8 +191,6 @@ private:
   typedef std::list<loopst> function_loopst;
   function_loopst function_loops;
 
-  messaget message_handler;
-
   /// \Function get_constraint is a function that will go through each asert
   /// in the program and parse it from ESBMC expression to an IBEX expression
   /// that will be added to constraints in the CSP. the function will return
@@ -206,11 +207,15 @@ private:
   /// \param functionst list of functions in the goto program
   void get_intervals(goto_functionst functionst);
 
-  /// \Function contractor function will apply the contractor on the parsed constraint and intervals. it will apply the inner contractor by calculating the complement of the assert and contract.
-  /// \return Interval vector that represents the area that should be checked by the bmc.
+  /// \Function contractor function will apply the contractor on the parsed
+  /// constraint and intervals. it will apply the inner contractor by
+  /// calculating the complement of the assert and contract.
+  /// \return Interval vector that represents the area that should be checked
+  /// by the bmc.
   void contractor();
 
-  /** \Function get_complement will take a comparison operation and get its complement. Operators are defined in ibex as the enumeration ibex::CmpOP.
+  /** \Function get_complement will take a comparison operation and get its
+   * complement. Operators are defined in ibex as the enumeration ibex::CmpOP.
    * @param CmpOp is a comparison operator.
    * @return complement to to received CmpOP.
    */
@@ -219,14 +224,18 @@ private:
    * @function insert_assume is the function that will use the intervals
    * produced by the contractor and compare it to the original intervals.
    * If there are any changes, it will be inserted into the program as assumes
-   * in the format of assume(<variable> <operator> <value>) where variable is
-   * the variable name, operator is <=,>= depending if its an upper or a lower
-   * limit and value is the value of the interval limit.
+   * in the format of assume(<variable> <operator> <value>) where <variable> is
+   * the variable name, <operator> is <=,>= depending if its an upper or a lower
+   * limit and <value> is the value of the interval limit. If the resulting
+   * interval is empty (check via is_empty_vector flag), it will insert
+   * assume(0). It will also search for the last loop in the program based
+   * on location.
    * @param goto_functions goto program functions
    * @param vector result from the contractor.
    */
   void insert_assume(goto_functionst goto_functions);
 
+  bool is_unsupported_operator(expr2tc expr);
   ibex::NumConstraint *create_constraint_from_expr2t(irep_container<expr2t>);
   ibex::Function *create_function_from_expr2t(irep_container<expr2t>);
   int create_variable_from_expr2t(irep_container<expr2t>);
@@ -234,13 +243,5 @@ private:
   void parse_intervals(irep_container<expr2t> expr);
 
   bool initialize_main_function_loops();
-
-  /**
- * Naive appraoch to determine if a loop is monotonic
- * This function will be replaced later with exrapolation by using intervals
- * from frama-c eva plugin
- * @param functionst
- */
 };
-
 #endif //ESBMC_GOTO_CONTRACTOR_H
\ No newline at end of file
diff --git a/src/goto-programs/goto_convert.cpp b/src/goto-programs/goto_convert.cpp
index e7e55bf19..2d9152292 100644
--- a/src/goto-programs/goto_convert.cpp
+++ b/src/goto-programs/goto_convert.cpp
@@ -1,12 +1,3 @@
-/*******************************************************************\
-
-Module: Program Transformation
-
-Author: Daniel Kroening, kroening@kroening.com
-		Lucas Cordeiro, lcc08r@ecs.soton.ac.uk
-
-\*******************************************************************/
-
 #include <cassert>
 #include <goto-programs/destructor.h>
 #include <goto-programs/goto_convert_class.h>
@@ -16,6 +7,8 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <util/cprover_prefix.h>
 #include <util/i2string.h>
 #include <irep2/irep2_utils.h>
+#include <util/message.h>
+#include <util/message/format.h>
 #include <util/prefix.h>
 #include <util/std_expr.h>
 #include <util/type_byte_size.h>
@@ -43,8 +36,7 @@ void goto_convertt::finish_gotos(goto_programt &dest)
 
       if(l_it == targets.labels.end())
       {
-        message_handler.error(
-          fmt::format("goto label {} not found\n{}", goto_label, *i.code));
+        log_error("goto label {} not found\n{}", goto_label, *i.code);
         abort();
       }
 
@@ -56,7 +48,7 @@ void goto_convertt::finish_gotos(goto_programt &dest)
       auto unwind_to_size = label_stack.size();
       if(unwind_to_size < goto_stack.size())
       {
-        goto_programt destructor_code(dest.msg);
+        goto_programt destructor_code;
         unwind_destructor_stack(
           i.location, unwind_to_size, destructor_code, goto_stack);
         dest.destructive_insert(it.first, destructor_code);
@@ -66,8 +58,8 @@ void goto_convertt::finish_gotos(goto_programt &dest)
     }
     else
     {
-      err_location(migrate_expr_back(i.code));
-      throw "finish_gotos: unexpected goto";
+      log_error("finish_gotos: unexpected goto");
+      abort();
     }
   }
 
@@ -146,13 +138,12 @@ void goto_convertt::convert_label(const code_labelt &code, goto_programt &dest)
 {
   if(code.operands().size() != 1)
   {
-    err_location(code);
-    throw "label statement expected to have one operand";
+    log_error("label statement expected to have one operand");
   }
 
   // grab the label
   const irep_idt &label = code.get_label();
-  goto_programt tmp(get_message_handler());
+  goto_programt tmp;
 
   convert(to_code(code.op0()), tmp);
 
@@ -170,7 +161,6 @@ void goto_convertt::convert_label(const code_labelt &code, goto_programt &dest)
     t->location.property("error label");
     t->location.comment("error label");
     t->location.user_provided(true);
-    t->assert_mode = goto_assertions::USER;
 
     target = t;
     dest.destructive_append(tmp);
@@ -191,11 +181,11 @@ void goto_convertt::convert_switch_case(
 {
   if(code.operands().size() != 2)
   {
-    err_location(code);
-    throw "switch-case statement expected to have two operands";
+    log_error("switch-case statement expected to have two operands");
+    abort();
   }
 
-  goto_programt tmp(get_message_handler());
+  goto_programt tmp;
   convert(code.code(), tmp);
 
   goto_programt::targett target = tmp.instructions.begin();
@@ -278,6 +268,8 @@ void goto_convertt::convert(const codet &code, goto_programt &dest)
     convert_cpp_delete(code, dest);
   else if(statement == "cpp-catch")
     convert_catch(code, dest);
+  else if(statement == "cpp-throw")
+    convert_throw(code, dest);
   else if(statement == "throw_decl")
     convert_throw_decl(code, dest);
   else if(statement == "throw_decl_end")
@@ -331,6 +323,29 @@ void goto_convertt::convert_throw_decl(const exprt &expr, goto_programt &dest)
   migrate_expr(c, throw_decl_instruction->code);
 }
 
+void goto_convertt::convert_throw(const exprt &expr, goto_programt &dest)
+{
+  // add the THROW_DECL instruction to 'dest'
+  goto_programt::targett throw_instruction = dest.add_instruction();
+  codet c("code");
+  c.set_statement("cpp-throw");
+
+  // the THROW instruction is annotated with a list of IDs,
+  // one per target
+  irept::subt &throw_list = c.add("throw_list").get_sub();
+  for(const auto &block : expr.operands())
+  {
+    irept type = irept(block.get("throw_decl_id"));
+
+    // grab the ID and add to THROW_DECL instruction
+    throw_list.emplace_back(type);
+  }
+
+  throw_instruction->make_throw();
+  throw_instruction->location = expr.location();
+  migrate_expr(c, throw_instruction->code);
+}
+
 void goto_convertt::convert_catch(const codet &code, goto_programt &dest)
 {
   assert(code.operands().size() >= 2);
@@ -345,12 +360,12 @@ void goto_convertt::convert_catch(const codet &code, goto_programt &dest)
   std::vector<irep_idt> exception_list;
 
   // add a SKIP target for the end of everything
-  goto_programt end(get_message_handler());
+  goto_programt end;
   goto_programt::targett end_target = end.add_instruction();
   end_target->make_skip();
 
   // the first operand is the 'try' block
-  goto_programt tmp(get_message_handler());
+  goto_programt tmp;
   convert(to_code(code.op0()), tmp);
   dest.destructive_append(tmp);
 
@@ -422,8 +437,7 @@ void goto_convertt::convert_expression(const codet &code, goto_programt &dest)
 {
   if(code.operands().size() != 1)
   {
-    err_location(code);
-    message_handler.error("expression statement takes one operand\n");
+    log_error("expression statement takes one operand\n");
     abort();
   }
 
@@ -460,7 +474,7 @@ bool goto_convertt::rewrite_vla_decl_size(exprt &size, goto_programt &dest)
   // Remove side effect
   if(has_sideeffect(size))
   {
-    goto_programt sideeffects(get_message_handler());
+    goto_programt sideeffects;
     remove_sideeffects(size, sideeffects);
     dest.destructive_append(sideeffects);
     return true;
@@ -562,8 +576,8 @@ void goto_convertt::convert_decl(const codet &code, goto_programt &dest)
 {
   if(code.operands().size() != 1 && code.operands().size() != 2)
   {
-    err_location(code);
-    throw "decl statement takes one or two operands";
+    log_error("decl statement takes one or two operands");
+    abort();
   }
 
   // We might change the symbol
@@ -572,8 +586,8 @@ void goto_convertt::convert_decl(const codet &code, goto_programt &dest)
   exprt &var = new_code.op0();
   if(!var.is_symbol())
   {
-    err_location(var);
-    throw "decl statement expects symbol as first operand";
+    log_error("decl statement expects symbol as first operand");
+    abort();
   }
 
   const irep_idt &identifier = var.identifier();
@@ -598,6 +612,9 @@ void goto_convertt::convert_decl(const codet &code, goto_programt &dest)
   exprt initializer = nil_exprt();
   if(new_code.operands().size() == 2)
   {
+    // Example of an codet decl statement with 2 operands is:
+    // "t2 *p = new t2;" where the op0 refers to the RHS pointer symbol
+    // and op1 refers to the LHS side effect (initializer)
     initializer = new_code.op1();
 
     // just resize the vector, this will get rid of op1
@@ -619,7 +636,8 @@ void goto_convertt::convert_decl(const codet &code, goto_programt &dest)
 
   if(!initializer.is_nil())
   {
-    goto_programt sideeffects(get_message_handler());
+    goto_programt sideeffects;
+    // the side effect is not just removed. Actually, it's converted and removed.
     remove_sideeffects(initializer, sideeffects);
     dest.destructive_append(sideeffects);
 
@@ -662,8 +680,8 @@ void goto_convertt::convert_assign(
 {
   if(code.operands().size() != 2)
   {
-    err_location(code);
-    throw "assignment statement takes two operands";
+    log_error("assignment statement takes two operands");
+    abort();
   }
 
   exprt lhs = code.lhs(), rhs = code.rhs();
@@ -674,8 +692,8 @@ void goto_convertt::convert_assign(
   {
     if(rhs.operands().size() != 2)
     {
-      err_location(rhs);
-      throw "function_call sideeffect takes two operands";
+      log_error("function_call sideeffect takes two operands");
+      abort();
     }
 
     Forall_operands(it, rhs)
@@ -837,11 +855,12 @@ void goto_convertt::break_globals2assignments_rec(
     if(identifier.empty())
       return;
 
-    const symbolt &symbol = ns.lookup(identifier);
+    const symbolt *symbol = ns.lookup(identifier);
+    assert(symbol);
 
     if(
       !(identifier == "__ESBMC_alloc" || identifier == "__ESBMC_alloc_size") &&
-      (symbol.static_lifetime || symbol.type.is_dynamic_set()))
+      (symbol->static_lifetime || symbol->type.is_dynamic_set()))
     {
       // make new assignment to temp for each global symbol
       symbolt &new_symbol = new_tmp_symbol(rhs.type());
@@ -868,8 +887,9 @@ void goto_convertt::break_globals2assignments_rec(
   else if(rhs.id() == "symbol")
   {
     const irep_idt &identifier = rhs.identifier();
-    const symbolt &symbol = ns.lookup(identifier);
-    if(symbol.static_lifetime || symbol.type.is_dynamic_set())
+    const symbolt *symbol = ns.lookup(identifier);
+    assert(symbol);
+    if(symbol->static_lifetime || symbol->type.is_dynamic_set())
     {
       // make new assignment to temp for each global symbol
       symbolt &new_symbol = new_tmp_symbol(rhs.type());
@@ -914,13 +934,14 @@ unsigned int goto_convertt::get_expr_number_globals(const exprt &expr)
   if(expr.id() == "symbol")
   {
     const irep_idt &identifier = expr.identifier();
-    const symbolt &symbol = ns.lookup(identifier);
+    const symbolt *symbol = ns.lookup(identifier);
+    assert(symbol);
 
     if(identifier == "__ESBMC_alloc" || identifier == "__ESBMC_alloc_size")
     {
       return 0;
     }
-    if(symbol.static_lifetime || symbol.type.is_dynamic_set())
+    if(symbol->static_lifetime || symbol->type.is_dynamic_set())
     {
       return 1;
     }
@@ -951,13 +972,14 @@ unsigned int goto_convertt::get_expr_number_globals(const expr2tc &expr)
   if(is_symbol2t(expr))
   {
     irep_idt identifier = to_symbol2t(expr).get_symbol_name();
-    const symbolt &symbol = ns.lookup(identifier);
+    const symbolt *symbol = ns.lookup(identifier);
+    assert(symbol);
 
     if(identifier == "__ESBMC_alloc" || identifier == "__ESBMC_alloc_size")
     {
       return 0;
     }
-    if(symbol.static_lifetime || symbol.type.is_dynamic_set())
+    if(symbol->static_lifetime || symbol->type.is_dynamic_set())
     {
       return 1;
     }
@@ -980,8 +1002,8 @@ void goto_convertt::convert_init(const codet &code, goto_programt &dest)
 {
   if(code.operands().size() != 2)
   {
-    err_location(code);
-    throw "init statement takes two operands";
+    log_error("init statement takes two operands");
+    abort();
   }
 
   // make it an assignment
@@ -995,8 +1017,7 @@ void goto_convertt::convert_cpp_delete(const codet &code, goto_programt &dest)
 {
   if(code.operands().size() != 1)
   {
-    err_location(code);
-    throw "cpp_delete statement takes one operand";
+    log_error("cpp_delete statement takes one operand");
   }
 
   exprt tmp_op = code.op0();
@@ -1058,8 +1079,8 @@ void goto_convertt::convert_assert(const codet &code, goto_programt &dest)
 {
   if(code.operands().size() != 1)
   {
-    err_location(code);
-    throw "assert statement takes one operand";
+    log_error("assert statement takes one operand");
+    abort();
   }
 
   exprt cond = code.op0();
@@ -1098,8 +1119,8 @@ void goto_convertt::convert_assume(const codet &code, goto_programt &dest)
 {
   if(code.operands().size() != 1)
   {
-    err_location(code);
-    throw "assume statement takes one operand";
+    log_error("assume statement takes one operand");
+    abort();
   }
 
   exprt op = code.op0();
@@ -1124,8 +1145,8 @@ void goto_convertt::convert_for(const codet &code, goto_programt &dest)
 {
   if(code.operands().size() != 4)
   {
-    err_location(code);
-    throw "for takes four operands";
+    log_error("for takes four operands");
+    abort();
   }
 
   // turn for(A; c; B) { P } into
@@ -1146,7 +1167,7 @@ void goto_convertt::convert_for(const codet &code, goto_programt &dest)
   exprt tmp = code.op1();
 
   exprt cond = tmp;
-  goto_programt sideeffects(get_message_handler());
+  goto_programt sideeffects;
 
   remove_sideeffects(cond, sideeffects);
 
@@ -1157,16 +1178,16 @@ void goto_convertt::convert_for(const codet &code, goto_programt &dest)
   goto_programt::targett u = sideeffects.instructions.begin();
 
   // do the v label
-  goto_programt tmp_v(get_message_handler());
+  goto_programt tmp_v;
   goto_programt::targett v = tmp_v.add_instruction();
 
   // do the z label
-  goto_programt tmp_z(get_message_handler());
+  goto_programt tmp_z;
   goto_programt::targett z = tmp_z.add_instruction(SKIP);
   z->location = code.location();
 
   // do the x label
-  goto_programt tmp_x(get_message_handler());
+  goto_programt tmp_x;
   if(code.op2().is_nil())
   {
     tmp_x.add_instruction(SKIP);
@@ -1195,11 +1216,11 @@ void goto_convertt::convert_for(const codet &code, goto_programt &dest)
   v->location = cond.location();
 
   // do the w label
-  goto_programt tmp_w(get_message_handler());
+  goto_programt tmp_w;
   convert(to_code(code.op3()), tmp_w);
 
   // y: goto u;
-  goto_programt tmp_y(get_message_handler());
+  goto_programt tmp_y;
   goto_programt::targett y = tmp_y.add_instruction();
   y->make_goto(u);
   y->guard = gen_true_expr();
@@ -1220,8 +1241,8 @@ void goto_convertt::convert_while(const codet &code, goto_programt &dest)
 {
   if(code.operands().size() != 2)
   {
-    err_location(code);
-    throw "while takes two operands";
+    log_error("while takes two operands");
+    abort();
   }
 
   exprt tmp = code.op0();
@@ -1239,19 +1260,19 @@ void goto_convertt::convert_while(const codet &code, goto_programt &dest)
   break_continue_targetst old_targets(targets);
 
   // do the z label
-  goto_programt tmp_z(get_message_handler());
+  goto_programt tmp_z;
   goto_programt::targett z = tmp_z.add_instruction();
   z->make_skip();
   z->location = location;
 
-  goto_programt tmp_branch(get_message_handler());
+  goto_programt tmp_branch;
   generate_conditional_branch(gen_not(*cond), z, location, tmp_branch);
 
   // do the v label
   goto_programt::targett v = tmp_branch.instructions.begin();
 
   // do the y label
-  goto_programt tmp_y(get_message_handler());
+  goto_programt tmp_y;
   goto_programt::targett y = tmp_y.add_instruction();
 
   // set the targets
@@ -1259,7 +1280,7 @@ void goto_convertt::convert_while(const codet &code, goto_programt &dest)
   targets.set_continue(y);
 
   // do the x label
-  goto_programt tmp_x(get_message_handler());
+  goto_programt tmp_x;
   convert(to_code(code.op1()), tmp_x);
 
   // y: if(c) goto v;
@@ -1280,8 +1301,8 @@ void goto_convertt::convert_dowhile(const codet &code, goto_programt &dest)
 {
   if(code.operands().size() != 2)
   {
-    err_location(code);
-    throw "dowhile takes two operands";
+    log_error("dowhile takes two operands");
+    abort();
   }
 
   // save location
@@ -1289,7 +1310,7 @@ void goto_convertt::convert_dowhile(const codet &code, goto_programt &dest)
 
   exprt cond = code.op0();
 
-  goto_programt sideeffects(get_message_handler());
+  goto_programt sideeffects;
   remove_sideeffects(cond, sideeffects);
 
   //    do P while(c);
@@ -1303,11 +1324,11 @@ void goto_convertt::convert_dowhile(const codet &code, goto_programt &dest)
   break_continue_targetst old_targets(targets);
 
   // do the y label
-  goto_programt tmp_y(get_message_handler());
+  goto_programt tmp_y;
   goto_programt::targett y = tmp_y.add_instruction();
 
   // do the z label
-  goto_programt tmp_z(get_message_handler());
+  goto_programt tmp_z;
   goto_programt::targett z = tmp_z.add_instruction();
   z->make_skip();
   z->location = code.location();
@@ -1324,7 +1345,7 @@ void goto_convertt::convert_dowhile(const codet &code, goto_programt &dest)
   targets.set_continue(x);
 
   // do the w label
-  goto_programt tmp_w(get_message_handler());
+  goto_programt tmp_w;
   convert(to_code(code.op1()), tmp_w);
   goto_programt::targett w = tmp_w.instructions.begin();
 
@@ -1399,14 +1420,14 @@ void goto_convertt::convert_switch(const codet &code, goto_programt &dest)
 
   exprt argument = code.op0();
 
-  goto_programt sideeffects(get_message_handler());
+  goto_programt sideeffects;
   remove_sideeffects(argument, sideeffects);
 
   // save break/default/cases targets
   break_switch_targetst old_targets(targets);
 
   // do the z label
-  goto_programt tmp_z(get_message_handler());
+  goto_programt tmp_z;
   goto_programt::targett z = tmp_z.add_instruction();
   z->make_skip();
   z->location = code.location();
@@ -1416,10 +1437,10 @@ void goto_convertt::convert_switch(const codet &code, goto_programt &dest)
   targets.set_default(z);
   targets.cases.clear();
 
-  goto_programt tmp(get_message_handler());
+  goto_programt tmp;
   convert(to_code_switch(code).body(), tmp);
 
-  goto_programt tmp_cases(get_message_handler());
+  goto_programt tmp_cases;
 
   for(auto &it : targets.cases)
   {
@@ -1462,8 +1483,8 @@ void goto_convertt::convert_break(const code_breakt &code, goto_programt &dest)
 {
   if(!targets.break_set)
   {
-    err_location(code);
-    throw "break without target";
+    log_error("break without target");
+    abort();
   }
 
   // need to process destructor stack
@@ -1480,14 +1501,14 @@ void goto_convertt::convert_return(
 {
   if(!targets.return_set)
   {
-    err_location(code);
-    throw "return without target";
+    log_error("return without target");
+    abort();
   }
 
   code_returnt new_code(code);
   if(new_code.has_return_value())
   {
-    goto_programt sideeffects(get_message_handler());
+    goto_programt sideeffects;
     remove_sideeffects(new_code.return_value(), sideeffects);
     dest.destructive_append(sideeffects);
 
@@ -1500,15 +1521,15 @@ void goto_convertt::convert_return(
     }
   }
 
-  goto_programt dummy(get_message_handler());
+  goto_programt dummy;
   unwind_destructor_stack(code.location(), 0, dummy);
 
   if(targets.has_return_value)
   {
     if(!new_code.has_return_value())
     {
-      err_location(new_code);
-      throw "function must return value";
+      log_error("function must return value");
+      abort();
     }
 
     // Now add a return node to set the return value.
@@ -1523,8 +1544,8 @@ void goto_convertt::convert_return(
       new_code.has_return_value() &&
       new_code.return_value().type().id() != "empty")
     {
-      err_location(new_code);
-      throw "function must not return value";
+      log_error("function must not return value");
+      abort();
     }
   }
 
@@ -1540,8 +1561,8 @@ void goto_convertt::convert_continue(
 {
   if(!targets.continue_set)
   {
-    err_location(code);
-    throw "continue without target";
+    log_error("continue without target");
+    abort();
   }
 
   // need to process destructor stack
@@ -1575,8 +1596,8 @@ void goto_convertt::convert_atomic_begin(const codet &code, goto_programt &dest)
 {
   if(code.operands().size() != 0)
   {
-    err_location(code);
-    throw "atomic_begin expects no operands";
+    log_error("atomic_begin expects no operands");
+    abort();
   }
 
   copy(code, ATOMIC_BEGIN, dest);
@@ -1586,8 +1607,8 @@ void goto_convertt::convert_atomic_end(const codet &code, goto_programt &dest)
 {
   if(code.operands().size() != 0)
   {
-    err_location(code);
-    throw "atomic_end expects no operands";
+    log_error("atomic_end expects no operands");
+    abort();
   }
 
   copy(code, ATOMIC_END, dest);
@@ -1604,7 +1625,7 @@ void goto_convertt::generate_ifthenelse(
   if(true_case.instructions.empty() && false_case.instructions.empty())
   {
     // hmpf. Useless branch.
-    goto_programt tmp_z(get_message_handler());
+    goto_programt tmp_z;
     goto_programt::targett z = tmp_z.add_instruction();
     z->make_skip();
     goto_programt::targett v = dest.add_instruction();
@@ -1698,16 +1719,16 @@ void goto_convertt::generate_ifthenelse(
   // z: ;
 
   // do the x label
-  goto_programt tmp_x(get_message_handler());
+  goto_programt tmp_x;
   goto_programt::targett x = tmp_x.add_instruction();
 
   // do the z label
-  goto_programt tmp_z(get_message_handler());
+  goto_programt tmp_z;
   goto_programt::targett z = tmp_z.add_instruction();
   z->make_skip();
 
   // y: Q;
-  goto_programt tmp_y(get_message_handler());
+  goto_programt tmp_y;
   goto_programt::targett y;
   if(has_else)
   {
@@ -1716,12 +1737,12 @@ void goto_convertt::generate_ifthenelse(
   }
 
   // v: if(!c) goto z/y;
-  goto_programt tmp_v(get_message_handler());
+  goto_programt tmp_v;
   generate_conditional_branch(
     gen_not(guard), has_else ? y : z, location, tmp_v);
 
   // w: P;
-  goto_programt tmp_w(get_message_handler());
+  goto_programt tmp_w;
   tmp_w.swap(true_case);
 
   // x: goto z;
@@ -1747,8 +1768,8 @@ void goto_convertt::convert_ifthenelse(const codet &c, goto_programt &dest)
 
   if(code.operands().size() != 2 && code.operands().size() != 3)
   {
-    err_location(code);
-    throw "ifthenelse takes two or three operands";
+    log_error("ifthenelse takes two or three operands");
+    abort();
   }
 
   bool has_else = code.operands().size() == 3 && !code.op2().is_nil();
@@ -1774,10 +1795,10 @@ void goto_convertt::convert_ifthenelse(const codet &c, goto_programt &dest)
   }
 
   // convert 'then'-branch
-  goto_programt tmp_op1(get_message_handler());
+  goto_programt tmp_op1;
   convert(to_code(code.op1()), tmp_op1);
 
-  goto_programt tmp_op2(get_message_handler());
+  goto_programt tmp_op2;
 
   if(has_else)
     convert(to_code(code.op2()), tmp_op2);
@@ -1833,7 +1854,7 @@ void goto_convertt::generate_conditional_branch(
   // if(guard) goto target; else goto next;
   // next: skip;
 
-  goto_programt tmp(get_message_handler());
+  goto_programt tmp;
   goto_programt::targett target_false = tmp.add_instruction();
   target_false->make_skip();
 
diff --git a/src/goto-programs/goto_convert_class.h b/src/goto-programs/goto_convert_class.h
index a5164beae..32050ae79 100644
--- a/src/goto-programs/goto_convert_class.h
+++ b/src/goto-programs/goto_convert_class.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Program Transformation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_PROGRAMS_GOTO_CONVERT_CLASS_H
 #define CPROVER_GOTO_PROGRAMS_GOTO_CONVERT_CLASS_H
 
@@ -15,31 +7,24 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <stack>
 #include <util/expr_util.h>
 #include <util/guard.h>
-#include <util/message/message_stream.h>
 #include <util/namespace.h>
 #include <util/options.h>
 #include <util/symbol_generator.h>
 #include <util/std_code.h>
 
-class goto_convertt : public message_streamt
+class goto_convertt
 {
 public:
   void goto_convert(const codet &code, goto_programt &dest);
 
-  goto_convertt(
-    contextt &_context,
-    optionst &_options,
-    const messaget &_message_handler)
-    : message_streamt(_message_handler),
-      context(_context),
+  goto_convertt(contextt &_context, optionst &_options)
+    : context(_context),
       options(_options),
       ns(_context),
       tmp_symbol("goto_convertt::")
   {
   }
 
-  ~goto_convertt() override = default;
-
 protected:
   contextt &context;
   optionst &options;
@@ -109,6 +94,7 @@ protected:
   void
   remove_function_call(exprt &expr, goto_programt &dest, bool result_is_used);
   void remove_cpp_new(exprt &expr, goto_programt &dest, bool result_is_used);
+  void remove_cpp_delete(exprt &expr, goto_programt &dest);
   void remove_temporary_object(exprt &expr, goto_programt &dest);
   void remove_statement_expression(
     exprt &expr,
@@ -204,6 +190,7 @@ protected:
   //
 
   void convert_catch(const codet &code, goto_programt &dest);
+  void convert_throw(const exprt &expr, goto_programt &dest);
   void convert_throw_decl(const exprt &expr, goto_programt &dest);
   void convert_throw_decl_end(const exprt &expr, goto_programt &dest);
 
diff --git a/src/goto-programs/goto_convert_functions.cpp b/src/goto-programs/goto_convert_functions.cpp
index 73ae4c329..999835d55 100644
--- a/src/goto-programs/goto_convert_functions.cpp
+++ b/src/goto-programs/goto_convert_functions.cpp
@@ -1,13 +1,3 @@
-/*******************************************************************\
-
-Module: Goto Programs with Functions
-
-Author: Daniel Kroening
-
-Date: June 2003
-
-\*******************************************************************/
-
 #include <cassert>
 #include <goto-programs/goto_convert_functions.h>
 #include <goto-programs/goto_inline.h>
@@ -23,9 +13,8 @@ Date: June 2003
 goto_convert_functionst::goto_convert_functionst(
   contextt &_context,
   optionst &_options,
-  goto_functionst &_functions,
-  const messaget &_message_handler)
-  : goto_convertt(_context, _options, _message_handler), functions(_functions)
+  goto_functionst &_functions)
+  : goto_convertt(_context, _options), functions(_functions)
 {
 }
 
@@ -104,7 +93,8 @@ void goto_convert_functionst::convert_function(symbolt &symbol)
 
   auto it = functions.function_map.find(identifier);
   if(it == functions.function_map.end())
-    functions.function_map.emplace(identifier, message_handler);
+    functions.function_map.emplace(identifier, goto_functiont());
+
   goto_functiont &f = functions.function_map.at(identifier);
   f.type = to_code_type(symbol.type);
   f.body_available = symbol.value.is_not_nil();
@@ -114,8 +104,8 @@ void goto_convert_functionst::convert_function(symbolt &symbol)
 
   if(!symbol.value.is_code())
   {
-    err_location(symbol.value);
-    throw "got invalid code for function `" + id2string(identifier) + "'";
+    log_error("got invalid code for function `{}'", id2string(identifier));
+    abort();
   }
 
   const codet &code = to_code(symbol.value);
@@ -129,7 +119,7 @@ void goto_convert_functionst::convert_function(symbolt &symbol)
     end_location.make_nil();
 
   // add "end of function"
-  goto_programt tmp_end_function(get_message_handler());
+  goto_programt tmp_end_function;
   goto_programt::targett end_function = tmp_end_function.add_instruction();
   end_function->type = END_FUNCTION;
   end_function->location = end_location;
@@ -186,36 +176,12 @@ void goto_convert_functionst::convert_function(symbolt &symbol)
 void goto_convert(
   contextt &context,
   optionst &options,
-  goto_functionst &functions,
-  const messaget &message_handler)
+  goto_functionst &functions)
 {
-  goto_convert_functionst goto_convert_functions(
-    context, options, functions, message_handler);
-
-  try
-  {
-    goto_convert_functions.thrash_type_symbols();
-    goto_convert_functions.fixup_unions();
-    goto_convert_functions.goto_convert();
-  }
+  goto_convert_functionst goto_convert_functions(context, options, functions);
 
-  catch(int)
-  {
-    goto_convert_functions.error();
-  }
-
-  catch(const char *e)
-  {
-    goto_convert_functions.error(e);
-  }
-
-  catch(const std::string &e)
-  {
-    goto_convert_functions.error(e);
-  }
-
-  if(goto_convert_functions.get_error_found())
-    throw 0;
+  goto_convert_functions.thrash_type_symbols();
+  goto_convert_functions.goto_convert();
 }
 
 void goto_convert_functionst::collect_type(
@@ -234,124 +200,6 @@ void goto_convert_functionst::collect_type(
   collect_expr(type, deps);
 }
 
-void goto_convert_functionst::fixup_unions()
-{
-  // Iterate over all types and expressions, replacing:
-  //  * Non-pointer union types with byte arrays of corresponding size
-  //  * All union member accesses with the following pattern:
-  //      dataobj.field => ((uniontype*)&dataobj)->field
-  // Thus ensuring that all unions become byte arrays, and all accesses to
-  // them _as_ unions get converted into byte array accesses at the pointer
-  // dereference layer.
-
-  context.Foreach_operand([this](symbolt &s) {
-                            fix_union_type(s.type, false);
-                            fix_union_expr(s.value);
-                          });
-}
-
-void goto_convert_functionst::fix_union_type(typet &type, bool is_pointer)
-{
-  if(!is_pointer && type.is_union())
-  {
-    // Replace with byte array. Must use migrated type though, because we need
-    // one authorative type_byte_size function
-    type2tc new_type = migrate_type(type);
-    auto size = type_byte_size(new_type);
-    new_type = type2tc(
-      new array_type2t(get_uint8_type(), gen_ulong(size.to_uint64()), false));
-    type = migrate_type_back(new_type);
-    return;
-  }
-
-  // Otherwise, recurse, taking care to handle pointers appropriately. All
-  // pointers to unions should remain union types.
-  if(type.is_pointer())
-  {
-    fix_union_type(type.subtype(), true);
-  }
-  else
-  {
-    Forall_irep(it, type.get_sub())
-      fix_union_type((typet &)*it, false);
-    Forall_named_irep(it, type.get_named_sub())
-      fix_union_type((typet &)it->second, false);
-  }
-}
-
-void goto_convert_functionst::fix_union_expr(exprt &expr)
-{
-  // We care about one kind of expression: member expressions that access a
-  // union field. We also need to rewrite types as we come across them.
-  if(expr.is_member())
-  {
-    // Are we accessing a union? If it's already a dereference, that's fine.
-    if(expr.op0().type().is_union() && !expr.op0().is_dereference())
-    {
-      // Rewrite 'dataobj.field' to '((uniontype*)&dataobj)->field'
-      expr2tc dataobj;
-      migrate_expr(expr.op0(), dataobj);
-      type2tc union_type = dataobj->type;
-      auto size = type_byte_size(union_type);
-      type2tc array_type = type2tc(
-        new array_type2t(get_uint8_type(), gen_ulong(size.to_uint64()), false));
-      type2tc union_pointer(new pointer_type2t(union_type));
-
-      address_of2tc addrof(array_type, dataobj);
-      typecast2tc cast(union_pointer, addrof);
-      dereference2tc deref(union_type, cast);
-      expr.op0() = migrate_expr_back(deref);
-
-      // Fix type -- it needs to remain a union at the top level
-      fix_union_type(expr.type(), false);
-      fix_union_expr(expr.op0());
-    }
-    else
-    {
-      Forall_operands(it, expr)
-        fix_union_expr(*it);
-      fix_union_type(expr.type(), false);
-    }
-  }
-  else if(expr.is_union())
-  {
-    // There may be union types embedded within this type; those need their
-    // types fixing too.
-    Forall_operands(it, expr)
-      fix_union_expr(*it);
-    fix_union_type(expr.type(), false);
-
-    // A union expr is a constant/literal union. This needs to be flattened
-    // out at this stage. Handle this by migrating immediately (which will
-    // eliminate anything on union type), and overwriting this expression.
-    expr2tc new_expr;
-    migrate_expr(expr, new_expr);
-    expr = migrate_expr_back(new_expr);
-  }
-  else if(expr.is_dereference())
-  {
-    // We want the dereference of a union pointer to evaluate to a union type,
-    // as that can be picked apart by the pointer handling code. However, do
-    // rewrite types if it points at a struct that contains a union, because
-    // the correct type of a struct reference with a union is it, has it's
-    // fields rewritten to be arrays. Actual accesses to that union field will
-    // be transformed into a dereference to one of the fields _within_ the
-    // union, so we never up constructing a union reference.
-    Forall_operands(it, expr)
-      fix_union_expr(*it);
-    fix_union_type(expr.type(), true);
-  }
-  else
-  {
-    // Default action: recurse and beat types.
-
-    fix_union_type(expr.type(), false);
-
-    Forall_operands(it, expr)
-      fix_union_expr(*it);
-  }
-}
-
 void goto_convert_functionst::collect_expr(
   const irept &expr,
   typename_sett &deps)
@@ -412,8 +260,7 @@ void goto_convert_functionst::rename_types(
       return;
     }
 
-    const symbolt *sym;
-    if(!ns.lookup(type.identifier(), sym))
+    if(ns.lookup(type.identifier()))
     {
       // If we can just look up the current type symbol, use that.
       type2 = ns.follow((typet &)type);
@@ -425,7 +272,7 @@ void goto_convert_functionst::rename_types(
         cur_name_sym.module.as_string() + type.identifier().as_string();
 
       // Try looking that up.
-      if(!ns.lookup(irep_idt(ident), sym))
+      if(ns.lookup(irep_idt(ident)))
       {
         irept tmptype = type;
         tmptype.identifier(irep_idt(ident));
@@ -434,8 +281,8 @@ void goto_convert_functionst::rename_types(
       else
       {
         // And if we fail
-        message_handler.error(fmt::format(
-          "Can't resolve type symbol {} at symbol squashing time", ident));
+        log_error(
+          "Can't resolve type symbol {} at symbol squashing time", ident);
         abort();
       }
     }
diff --git a/src/goto-programs/goto_convert_functions.h b/src/goto-programs/goto_convert_functions.h
index 558f7dff7..537f8d27c 100644
--- a/src/goto-programs/goto_convert_functions.h
+++ b/src/goto-programs/goto_convert_functions.h
@@ -1,13 +1,3 @@
-/*******************************************************************\
-
-Module: Goto Programs with Functions
-
-Author: Daniel Kroening
-
-Date: June 2003
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_CONVERT_FUNCTIONS_H
 #define CPROVER_GOTO_CONVERT_FUNCTIONS_H
 
@@ -18,8 +8,7 @@ Date: June 2003
 void goto_convert(
   contextt &context,
   optionst &options,
-  goto_functionst &functions,
-  const messaget &message_handler);
+  goto_functionst &functions);
 
 class goto_convert_functionst : public goto_convertt
 {
@@ -30,7 +19,6 @@ public:
   void goto_convert();
   void convert_function(symbolt &symbol);
   void thrash_type_symbols();
-  void fixup_unions();
   void collect_type(const irept &type, typename_sett &set);
   void collect_expr(const irept &expr, typename_sett &set);
   void
@@ -39,17 +27,11 @@ public:
   rename_exprs(irept &expr, const symbolt &cur_name_sym, const irep_idt &sname);
   void
   wallop_type(irep_idt name, typename_mapt &typenames, const irep_idt &sname);
-  void fix_union_type(typet &type, bool is_pointer);
-  void fix_union_expr(exprt &expr);
-
 
   goto_convert_functionst(
     contextt &_context,
     optionst &_options,
-    goto_functionst &_functions,
-    const messaget &_message_handler);
-
-  ~goto_convert_functionst() override = default;
+    goto_functionst &_functions);
 
 protected:
   goto_functionst &functions;
diff --git a/src/goto-programs/goto_function.cpp b/src/goto-programs/goto_function.cpp
index f446d6966..d2f033bcd 100644
--- a/src/goto-programs/goto_function.cpp
+++ b/src/goto-programs/goto_function.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Program Transformation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <goto-programs/goto_convert_class.h>
 #include <goto-programs/goto_functions.h>
@@ -15,7 +7,6 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <util/i2string.h>
 #include <util/location.h>
 #include <util/prefix.h>
-#include <util/message/default_message.h>
 
 void goto_convertt::convert_function_call(
   const code_function_callt &function_call,
@@ -71,9 +62,7 @@ void goto_convertt::do_function_call(
   }
   else
   {
-    err_location(function);
-    message_handler.error(fmt::format(
-      "unexpected function argument: {}", new_function.id_string()));
+    log_error("unexpected function argument: {}", new_function.id_string());
     abort();
   }
 }
@@ -86,8 +75,8 @@ void goto_convertt::do_function_call_if(
 {
   if(function.operands().size() != 3)
   {
-    err_location(function);
-    throw "if expects three operands";
+    log_error("if expects three operands");
+    abort();
   }
 
   // case split
@@ -101,20 +90,20 @@ void goto_convertt::do_function_call_if(
   // z: ;
 
   // do the v label
-  goto_programt tmp_v(get_message_handler());
+  goto_programt tmp_v;
   goto_programt::targett v = tmp_v.add_instruction();
 
   // do the x label
-  goto_programt tmp_x(get_message_handler());
+  goto_programt tmp_x;
   goto_programt::targett x = tmp_x.add_instruction();
 
   // do the z label
-  goto_programt tmp_z(get_message_handler());
+  goto_programt tmp_z;
   goto_programt::targett z = tmp_z.add_instruction();
   z->make_skip();
 
   // y: g();
-  goto_programt tmp_y(get_message_handler());
+  goto_programt tmp_y;
   goto_programt::targett y;
 
   do_function_call(lhs, function.op2(), arguments, tmp_y);
@@ -138,7 +127,7 @@ void goto_convertt::do_function_call_if(
   }
 
   // w: f();
-  goto_programt tmp_w(get_message_handler());
+  goto_programt tmp_w;
 
   do_function_call(lhs, function.op1(), arguments, tmp_w);
 
@@ -175,10 +164,9 @@ void goto_convertt::do_function_call_dereference(
 
 void goto_functionst::dump() const
 {
-  default_message msg;
   std::ostringstream oss;
   output(*migrate_namespace_lookup, oss);
-  msg.debug(oss.str());
+  log_debug("{}", oss.str());
 }
 
 void goto_functionst::output(const namespacet &ns, std::ostream &out) const
@@ -191,10 +179,11 @@ void goto_functionst::output(const namespacet &ns, std::ostream &out) const
           << "\n";
       out << "\n";
 
-      const symbolt &symbol = ns.lookup(it.first);
-      out << symbol.name << " (" << symbol.id << "):"
+      const symbolt *symbol = ns.lookup(it.first);
+      assert(symbol);
+      out << symbol->name << " (" << symbol->id << "):"
           << "\n";
-      it.second.body.output(ns, symbol.id, out);
+      it.second.body.output(ns, symbol->id, out);
     }
   }
 }
diff --git a/src/goto-programs/goto_function_serialization.cpp b/src/goto-programs/goto_function_serialization.cpp
index f200bd005..9518a0687 100644
--- a/src/goto-programs/goto_function_serialization.cpp
+++ b/src/goto-programs/goto_function_serialization.cpp
@@ -1,14 +1,3 @@
-/*******************************************************************\
- 
-Module: Convert goto functions to binary format and back (with irep
-        hashing)
- 
-Author: CM Wintersteiger
- 
-Date: May 2007
- 
-\*******************************************************************/
-
 #include <goto-programs/goto_function_serialization.h>
 #include <goto-programs/goto_program_serialization.h>
 
diff --git a/src/goto-programs/goto_function_serialization.h b/src/goto-programs/goto_function_serialization.h
index c057be40a..ed9a1119f 100644
--- a/src/goto-programs/goto_function_serialization.h
+++ b/src/goto-programs/goto_function_serialization.h
@@ -1,14 +1,3 @@
-/*******************************************************************\
- 
-Module: Convert goto functions into binary format and back (with irep
-        hashing).
- 
-Author: CM Wintersteiger
- 
-Date: May 2007
- 
-\*******************************************************************/
-
 #ifndef GOTO_FUNCTION_SERIALIZATION_H_
 #define GOTO_FUNCTION_SERIALIZATION_H_
 
diff --git a/src/goto-programs/goto_functions.h b/src/goto-programs/goto_functions.h
index f9bc56acb..4e94cab1e 100644
--- a/src/goto-programs/goto_functions.h
+++ b/src/goto-programs/goto_functions.h
@@ -1,13 +1,3 @@
-/*******************************************************************\
-
-Module: Goto Programs with Functions
-
-Author: Daniel Kroening
-
-Date: June 2003
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_FUNCTIONS_H
 #define CPROVER_GOTO_FUNCTIONS_H
 
@@ -31,16 +21,12 @@ class goto_functiont
 public:
   goto_programt body;
   code_typet type;
-  bool body_available;
+  bool body_available = false;
 
   // The set of functions that have been inlined into this one. Necessary to
   // make symex renaming work.
   std::set<std::string> inlined_funcs;
 
-  goto_functiont(const messaget &msg) : body(msg), body_available(false)
-  {
-  }
-
   /// update the function member in each instruction
   /// \param function_id: the `function_id` used for assigning empty function
   ///   members
@@ -56,7 +42,6 @@ public:
   typedef std::map<irep_idt, goto_functiont> function_mapt;
   function_mapt function_map;
 
-  ~goto_functionst() = default;
   void clear()
   {
     function_map.clear();
diff --git a/src/goto-programs/goto_inline.cpp b/src/goto-programs/goto_inline.cpp
index afe446dd3..77085aca4 100644
--- a/src/goto-programs/goto_inline.cpp
+++ b/src/goto-programs/goto_inline.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Function Inlining
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <goto-programs/goto_inline.h>
 #include <goto-programs/remove_skip.h>
@@ -34,8 +26,8 @@ void goto_inlinet::parameter_assignments(
     // if you run out of actual arguments there was a mismatch
     if(it1 == arguments.end())
     {
-      err_location(location);
-      throw "function call: not enough arguments";
+      log_error("function call: not enough arguments");
+      abort();
     }
 
     const exprt &argument = static_cast<const exprt &>(argument_type);
@@ -93,14 +85,14 @@ void goto_inlinet::parameter_assignments(
         }
         else
         {
-          err_location(location);
+          std::ostringstream str;
 
           str << "function call: argument `" << identifier
               << "' type mismatch: got "
-              << from_type(ns, identifier, it1->type(), message_handler)
-              << ", expected "
-              << from_type(ns, identifier, arg_type, message_handler);
-          throw 0;
+              << from_type(ns, identifier, it1->type()) << ", expected "
+              << from_type(ns, identifier, arg_type);
+          log_error("{}", str.str());
+          abort();
         }
       }
 
@@ -126,7 +118,7 @@ void goto_inlinet::parameter_assignments(
 void goto_inlinet::replace_return(
   goto_programt &dest,
   const exprt &lhs,
-  const exprt &constrain [[gnu::unused]] /* ndebug */)
+  const exprt &constrain [[maybe_unused]] /* ndebug */)
 {
   for(goto_programt::instructionst::iterator it = dest.instructions.begin();
       it != dest.instructions.end();
@@ -136,7 +128,7 @@ void goto_inlinet::replace_return(
     {
       if(lhs.is_not_nil())
       {
-        goto_programt tmp(message_handler);
+        goto_programt tmp;
         goto_programt::targett assignment = tmp.add_instruction(ASSIGN);
 
         const code_return2t &ret = to_code_return2t(it->code);
@@ -161,7 +153,7 @@ void goto_inlinet::replace_return(
         // Encode evaluation of return expr, so that returns with pointer
         // derefs in them still get dereferenced, even when the result is
         // discarded.
-        goto_programt tmp(message_handler);
+        goto_programt tmp;
         goto_programt::targett expression = tmp.add_instruction(OTHER);
 
         expression->make_other();
@@ -191,9 +183,10 @@ void goto_inlinet::expand_function_call(
   // look it up
   if(function.id() != "symbol")
   {
-    err_location(function);
-    throw "function_call expects symbol as function operand, "
-          "but got `"+function.id_string()+"'";
+    log_error(
+      "function_call expects symbol as function operand, but got `{}'",
+      function.id_string());
+    abort();
   }
 
   const irep_idt &identifier = function.identifier();
@@ -208,8 +201,7 @@ void goto_inlinet::expand_function_call(
     }
 
     // it's really recursive. Give up.
-    err_location(function);
-    warning("Recursion is ignored when inlining");
+    log_warning("Recursion is ignored when inlining");
     target->make_skip();
 
     target++;
@@ -221,9 +213,11 @@ void goto_inlinet::expand_function_call(
 
   if(m_it == goto_functions.function_map.end())
   {
-    err_location(function);
-    str << "failed to find function `" << identifier << "'";
-    throw 0;
+    std::ostringstream str;
+    str << "failed to find function `" << identifier << "'\n";
+    str << "Location: " << function.location();
+    log_error("{}", str.str());
+    abort();
   }
 
   goto_functiont &f = m_it->second;
@@ -249,7 +243,7 @@ void goto_inlinet::expand_function_call(
     recursion_sett::iterator recursion_it =
       recursion_set.insert(identifier).first;
 
-    goto_programt tmp2(message_handler);
+    goto_programt tmp2;
     tmp2.copy_from(f.body);
 
     assert(tmp2.instructions.back().is_end_function());
@@ -257,7 +251,7 @@ void goto_inlinet::expand_function_call(
 
     replace_return(tmp2, lhs, constrain);
 
-    goto_programt tmp(message_handler);
+    goto_programt tmp;
     parameter_assignments(
       tmp2.instructions.front().location, f.type, arguments, tmp);
     tmp.destructive_append(tmp2);
@@ -299,12 +293,13 @@ void goto_inlinet::expand_function_call(
   {
     if(no_body_set.insert(identifier).second)
     {
-      err_location(function);
-      str << "no body for function `" << identifier << "'";
-      warning();
+      std::ostringstream str;
+      str << "no body for function `" << identifier << "'\n";
+      str << "Location: " << function.location();
+      log_warning("{}", str.str());
     }
 
-    goto_programt tmp(message_handler);
+    goto_programt tmp;
 
     // evaluate function arguments -- they might have
     // pointer dereferencing or the like
@@ -419,10 +414,9 @@ void goto_inline(
   goto_functionst &goto_functions,
   optionst &options,
   const namespacet &ns,
-  goto_programt &dest,
-  const messaget &message_handler)
+  goto_programt &dest)
 {
-  goto_inlinet goto_inline(goto_functions, options, ns, message_handler);
+  goto_inlinet goto_inline(goto_functions, options, ns);
 
   {
     // find main
@@ -437,29 +431,7 @@ void goto_inline(
 
     dest.copy_from(it->second.body);
   }
-
-  try
-  {
-    goto_inline.goto_inline(dest);
-  }
-
-  catch(int)
-  {
-    goto_inline.error();
-  }
-
-  catch(const char *e)
-  {
-    goto_inline.error(e);
-  }
-
-  catch(const std::string &e)
-  {
-    goto_inline.error(e);
-  }
-
-  if(goto_inline.get_error_found())
-    throw 0;
+  goto_inline.goto_inline(dest);
 
   // clean up
   for(auto &it : goto_functions.function_map)
@@ -473,40 +445,18 @@ void goto_inline(
 void goto_inline(
   goto_functionst &goto_functions,
   optionst &options,
-  const namespacet &ns,
-  const messaget &message_handler)
+  const namespacet &ns)
 {
-  goto_inlinet goto_inline(goto_functions, options, ns, message_handler);
-
-  try
-  {
-    // find main
-    goto_functionst::function_mapt::iterator it =
-      goto_functions.function_map.find("__ESBMC_main");
-
-    if(it == goto_functions.function_map.end())
-      return;
+  goto_inlinet goto_inline(goto_functions, options, ns);
 
-    goto_inline.goto_inline(it->second.body);
-  }
+  // find main
+  goto_functionst::function_mapt::iterator it =
+    goto_functions.function_map.find("__ESBMC_main");
 
-  catch(int)
-  {
-    goto_inline.error();
-  }
-
-  catch(const char *e)
-  {
-    goto_inline.error(e);
-  }
-
-  catch(const std::string &e)
-  {
-    goto_inline.error(e);
-  }
+  if(it == goto_functions.function_map.end())
+    return;
 
-  if(goto_inline.get_error_found())
-    throw 0;
+  goto_inline.goto_inline(it->second.body);
 
   // clean up
   for(auto &it : goto_functions.function_map)
@@ -521,39 +471,17 @@ void goto_partial_inline(
   goto_functionst &goto_functions,
   optionst &options,
   const namespacet &ns,
-  const messaget &message_handler,
   unsigned _smallfunc_limit)
 {
-  goto_inlinet goto_inline(goto_functions, options, ns, message_handler);
+  goto_inlinet goto_inline(goto_functions, options, ns);
 
   goto_inline.smallfunc_limit = _smallfunc_limit;
 
-  try
-  {
-    for(auto &it : goto_functions.function_map)
-    {
-      goto_inline.inlined_funcs.clear();
-      if(it.second.body_available)
-        goto_inline.goto_inline_rec(it.second.body, false);
-      it.second.inlined_funcs = goto_inline.inlined_funcs;
-    }
-  }
-
-  catch(int)
-  {
-    goto_inline.error();
-  }
-
-  catch(const char *e)
-  {
-    goto_inline.error(e);
-  }
-
-  catch(const std::string &e)
+  for(auto &it : goto_functions.function_map)
   {
-    goto_inline.error(e);
+    goto_inline.inlined_funcs.clear();
+    if(it.second.body_available)
+      goto_inline.goto_inline_rec(it.second.body, false);
+    it.second.inlined_funcs = goto_inline.inlined_funcs;
   }
-
-  if(goto_inline.get_error_found())
-    throw 0;
 }
diff --git a/src/goto-programs/goto_inline.h b/src/goto-programs/goto_inline.h
index a735d89f4..6b643178d 100644
--- a/src/goto-programs/goto_inline.h
+++ b/src/goto-programs/goto_inline.h
@@ -1,17 +1,8 @@
-/*******************************************************************\
-
-Module: Function Inlining
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_INLINE_H
 #define CPROVER_GOTO_INLINE_H
 
 #include <goto-programs/goto_functions.h>
 #include <unordered_set>
-#include <util/message/message_stream.h>
 #include <util/std_types.h>
 
 // do a full inlining
@@ -19,14 +10,12 @@ void goto_inline(
   goto_functionst &goto_functions,
   optionst &options,
   const namespacet &ns,
-  goto_programt &dest,
-  const messaget &message_handler);
+  goto_programt &dest);
 
 void goto_inline(
   goto_functionst &goto_functions,
   optionst &options,
-  const namespacet &ns,
-  const messaget &message_handler);
+  const namespacet &ns);
 
 // inline those functions marked as "inlined"
 // and functions with less than _smallfunc_limit instructions
@@ -34,19 +23,16 @@ void goto_partial_inline(
   goto_functionst &goto_functions,
   optionst &options,
   const namespacet &ns,
-  const messaget &message_handler,
   unsigned _smallfunc_limit = 0);
 
-class goto_inlinet : public message_streamt
+class goto_inlinet
 {
 public:
   goto_inlinet(
     goto_functionst &_goto_functions,
     optionst &_options,
-    const namespacet &_ns,
-    const messaget &_message_handler)
-    : message_streamt(_message_handler),
-      smallfunc_limit(0),
+    const namespacet &_ns)
+    : smallfunc_limit(0),
       goto_functions(_goto_functions),
       options(_options),
       ns(_ns)
diff --git a/src/goto-programs/goto_k_induction.cpp b/src/goto-programs/goto_k_induction.cpp
index 3dd57d63c..1cc58d0cc 100644
--- a/src/goto-programs/goto_k_induction.cpp
+++ b/src/goto-programs/goto_k_induction.cpp
@@ -5,24 +5,20 @@
 #include <util/i2string.h>
 #include <util/std_expr.h>
 
-void goto_k_induction(
-  goto_functionst &goto_functions,
-  const messaget &message_handler)
+void goto_k_induction(goto_functionst &goto_functions)
 {
   Forall_goto_functions(it, goto_functions)
     if(it->second.body_available)
-      goto_k_inductiont(it->first, goto_functions, it->second, message_handler);
+      goto_k_inductiont(it->first, goto_functions, it->second);
 
   goto_functions.update();
 }
 
-void goto_termination(
-  goto_functionst &goto_functions,
-  const messaget &message_handler)
+void goto_termination(goto_functionst &goto_functions)
 {
   Forall_goto_functions(it, goto_functions)
     if(it->second.body_available)
-      goto_k_inductiont(it->first, goto_functions, it->second, message_handler);
+      goto_k_inductiont(it->first, goto_functions, it->second);
   goto_functions.update();
 
   auto function = goto_functions.function_map.find("__ESBMC_main");
@@ -42,7 +38,7 @@ void goto_termination(
   assert(it != function->second.body.instructions.end());
 
   // Create an assert(0)
-  goto_programt dest(message_handler);
+  goto_programt dest;
   goto_programt::targett t = dest.add_instruction(ASSERT);
   t->guard = gen_false_expr();
   t->inductive_step_instruction = true;
@@ -198,7 +194,7 @@ void goto_k_inductiont::make_nondet_assign(
 {
   auto const &loop_vars = loop.get_modified_loop_vars();
 
-  goto_programt dest(message_handler);
+  goto_programt dest;
   for(auto const &lhs : loop_vars)
   {
     // do not assign nondeterministic value to pointers if we assume
@@ -283,7 +279,7 @@ void goto_k_inductiont::assume_loop_entry_cond_before_loop(
     if(is_true(loop_cond) || is_false(loop_cond))
       return;
 
-    goto_programt dest(message_handler);
+    goto_programt dest;
     assume_cond(loop_cond, dest, tmp_head->location);
 
     goto_function.body.insert_swap(tmp_head, dest);
@@ -317,7 +313,7 @@ void goto_k_inductiont::assume_cond(
   goto_programt &dest,
   const locationt &loc)
 {
-  goto_programt tmp_e(message_handler);
+  goto_programt tmp_e;
   goto_programt::targett e = tmp_e.add_instruction(ASSUME);
   e->inductive_step_instruction = true;
   e->guard = cond;
diff --git a/src/goto-programs/goto_k_induction.h b/src/goto-programs/goto_k_induction.h
index 4a6f47d31..1e3f8a440 100644
--- a/src/goto-programs/goto_k_induction.h
+++ b/src/goto-programs/goto_k_induction.h
@@ -4,16 +4,11 @@
 #include <goto-programs/goto_functions.h>
 #include <goto-programs/goto_loops.h>
 #include <util/guard.h>
-#include <util/message/message_stream.h>
 #include <irep2/irep2_expr.h>
 
-void goto_k_induction(
-  goto_functionst &goto_functions,
-  const messaget &message_handler);
+void goto_k_induction(goto_functionst &goto_functions);
 
-void goto_termination(
-  goto_functionst &goto_functions,
-  const messaget &message_handler);
+void goto_termination(goto_functionst &goto_functions);
 
 class goto_k_inductiont : public goto_loopst
 {
@@ -21,13 +16,8 @@ public:
   goto_k_inductiont(
     const irep_idt &_function_name,
     goto_functionst &_goto_functions,
-    goto_functiont &_goto_function,
-    const messaget &_message_handler)
-    : goto_loopst(
-        _function_name,
-        _goto_functions,
-        _goto_function,
-        _message_handler)
+    goto_functiont &_goto_function)
+    : goto_loopst(_function_name, _goto_functions, _goto_function)
   {
     if(function_loops.size())
       goto_k_induction();
diff --git a/src/goto-programs/goto_loops.cpp b/src/goto-programs/goto_loops.cpp
index 9dd463af2..f3d955678 100644
--- a/src/goto-programs/goto_loops.cpp
+++ b/src/goto-programs/goto_loops.cpp
@@ -135,8 +135,7 @@ void goto_loopst::get_modified_variables(
 
     if(it == goto_functions.function_map.end())
     {
-      message_handler.error(fmt::format(
-        "failed to find `{}' in function_map", id2string(identifier)));
+      log_error("failed to find `{}' in function_map", id2string(identifier));
       abort();
     }
 
diff --git a/src/goto-programs/goto_loops.h b/src/goto-programs/goto_loops.h
index 8f81d5025..3818de7c6 100644
--- a/src/goto-programs/goto_loops.h
+++ b/src/goto-programs/goto_loops.h
@@ -3,10 +3,9 @@
 
 #include <goto-programs/goto_functions.h>
 #include <goto-programs/loopst.h>
-#include <util/message/message_stream.h>
 #include <util/std_types.h>
 
-class goto_loopst : public message_streamt
+class goto_loopst
 {
 protected:
   irep_idt function_name;
@@ -34,10 +33,8 @@ public:
   goto_loopst(
     const irep_idt &_function_name,
     goto_functionst &_goto_functions,
-    goto_functiont &_goto_function,
-    const messaget &_message_handler)
-    : message_streamt(_message_handler),
-      function_name(_function_name),
+    goto_functiont &_goto_function)
+    : function_name(_function_name),
       goto_functions(_goto_functions),
       goto_function(_goto_function)
   {
diff --git a/src/goto-programs/goto_main.cpp b/src/goto-programs/goto_main.cpp
index feae38c72..abcff883f 100644
--- a/src/goto-programs/goto_main.cpp
+++ b/src/goto-programs/goto_main.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Program Transformation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <goto-programs/goto_convert_class.h>
 #include <util/rename.h>
 
@@ -22,47 +14,19 @@ void goto_convert(
   const codet &code,
   contextt &context,
   optionst &options,
-  goto_programt &dest,
-  const messaget &message_handler)
+  goto_programt &dest)
 {
-  goto_convertt goto_convert(context, options, message_handler);
-
-  try
-  {
-    goto_convert.goto_convert(code, dest);
-  }
-
-  catch(int)
-  {
-    goto_convert.error();
-  }
-
-  catch(const char *e)
-  {
-    goto_convert.error(e);
-  }
-
-  catch(const std::string &e)
-  {
-    goto_convert.error(e);
-  }
-
-  if(goto_convert.get_error_found())
-    throw 0;
+  goto_convertt goto_convert(context, options);
+  goto_convert.goto_convert(code, dest);
 }
 
-void goto_convert(
-  contextt &context,
-  optionst &options,
-  goto_programt &dest,
-  const messaget &message_handler)
+void goto_convert(contextt &context, optionst &options, goto_programt &dest)
 {
   // find main symbol
   const symbolt *s = context.find_symbol("__ESBMC_main");
   if(s == nullptr)
     throw "failed to find main symbol";
 
-  message_handler.status(
-    "goto_convert : start converting symbol table to goto functions ");
-  ::goto_convert(to_code(s->value), context, options, dest, message_handler);
+  log_status("goto_convert : start converting symbol table to goto functions ");
+  ::goto_convert(to_code(s->value), context, options, dest);
 }
diff --git a/src/goto-programs/goto_program.cpp b/src/goto-programs/goto_program.cpp
index e5b42f140..f4d8ab2ec 100644
--- a/src/goto-programs/goto_program.cpp
+++ b/src/goto-programs/goto_program.cpp
@@ -1,29 +1,18 @@
-/*******************************************************************\
-
-Module: Program Transformation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <goto-programs/goto_program.h>
 #include <iomanip>
 #include <langapi/language_util.h>
-#include <util/message/default_message.h>
 
 void goto_programt::instructiont::dump() const
 {
-  default_message msg;
   std::ostringstream oss;
-  output_instruction(*migrate_namespace_lookup, "", oss, msg);
-  msg.debug(oss.str());
+  output_instruction(*migrate_namespace_lookup, "", oss);
+  log_debug("{}", oss.str());
 }
 
 void goto_programt::instructiont::output_instruction(
   const class namespacet &ns,
   const irep_idt &identifier,
   std::ostream &out,
-  const messaget &msg,
   bool show_location) const
 {
   if(show_location)
@@ -64,7 +53,7 @@ void goto_programt::instructiont::output_instruction(
   case GOTO:
     if(!is_true(guard))
     {
-      out << "IF " << from_expr(ns, identifier, guard, msg) << " THEN ";
+      out << "IF " << from_expr(ns, identifier, guard) << " THEN ";
     }
 
     out << "GOTO ";
@@ -82,7 +71,7 @@ void goto_programt::instructiont::output_instruction(
     break;
 
   case FUNCTION_CALL:
-    out << "FUNCTION_CALL:  " << from_expr(ns, "", migrate_expr_back(code), msg)
+    out << "FUNCTION_CALL:  " << from_expr(ns, "", migrate_expr_back(code))
         << "\n";
     break;
 
@@ -91,7 +80,7 @@ void goto_programt::instructiont::output_instruction(
     std::string arg;
     const code_return2t &ref = to_code_return2t(code);
     if(!is_nil_expr(ref.operand))
-      arg = from_expr(ns, "", ref.operand, msg);
+      arg = from_expr(ns, "", ref.operand);
     out << "RETURN: " << arg << "\n";
   }
   break;
@@ -100,7 +89,7 @@ void goto_programt::instructiont::output_instruction(
   case DEAD:
   case OTHER:
   case ASSIGN:
-    out << from_expr(ns, identifier, code, msg) << "\n";
+    out << from_expr(ns, identifier, code) << "\n";
     break;
 
   case ASSUME:
@@ -108,10 +97,10 @@ void goto_programt::instructiont::output_instruction(
     if(is_assume())
       out << "ASSUME ";
     else
-      out << "ASSERT(" << assert_mode << ") ";
+      out << "ASSERT ";
 
     {
-      out << from_expr(ns, identifier, guard, msg);
+      out << from_expr(ns, identifier, guard);
 
       const irep_idt &comment = location.comment();
       if(comment != "")
@@ -154,7 +143,7 @@ void goto_programt::instructiont::output_instruction(
       }
 
       if(!is_nil_expr(throw_ref.operand))
-        out << ": " << from_expr(ns, identifier, throw_ref.operand, msg);
+        out << ": " << from_expr(ns, identifier, throw_ref.operand);
     }
 
     out << "\n";
@@ -339,7 +328,7 @@ std::ostream &goto_programt::output(
   // output program
 
   for(const auto &instruction : instructions)
-    instruction.output_instruction(ns, identifier, out, msg);
+    instruction.output_instruction(ns, identifier, out);
 
   return out;
 }
@@ -497,10 +486,9 @@ std::ostream &operator<<(std::ostream &out, goto_program_instruction_typet t)
 
 void goto_programt::dump() const
 {
-  default_message msg;
   std::ostringstream oss;
   output(*migrate_namespace_lookup, "", oss);
-  msg.debug(oss.str());
+  log_debug("{}", oss.str());
 }
 
 void goto_programt::get_decl_identifiers(
diff --git a/src/goto-programs/goto_program.h b/src/goto-programs/goto_program.h
index c56a196f6..e170873bd 100644
--- a/src/goto-programs/goto_program.h
+++ b/src/goto-programs/goto_program.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Goto Program Template
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_PROGRAM_H
 #define CPROVER_GOTO_PROGRAM_H
 
@@ -18,7 +10,6 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <util/location.h>
 #include <util/namespace.h>
 #include <util/std_code.h>
-#include <goto-programs/goto_assert_mode.h>
 
 #define forall_goto_program_instructions(it, program)                          \
   for(goto_programt::instructionst::const_iterator it =                        \
@@ -64,11 +55,10 @@ std::ostream &operator<<(std::ostream &, goto_program_instruction_typet);
 class goto_programt
 {
 public:
-  const messaget &msg;
   /*! \brief copy constructor
       \param[in] src an empty goto program
   */
-  inline goto_programt(const goto_programt &src) : msg(src.msg)
+  inline goto_programt(const goto_programt &src)
   {
     // CBMC didn't permit copy-construction, instead requiring calling
     // copy_from instead. While explicit is better than implicit though,
@@ -111,9 +101,6 @@ public:
     //! guard for gotos, assume, assert
     expr2tc guard;
 
-    //! assert mode
-    goto_assertions::goto_assertion_mode assert_mode = goto_assertions::OTHER;
-
     //! the target for gotos and for start_thread nodes
     typedef std::list<class instructiont>::iterator targett;
     typedef std::list<class instructiont>::const_iterator const_targett;
@@ -382,7 +369,6 @@ public:
         inductive_step_instruction, instruction.inductive_step_instruction);
       std::swap(inductive_assertion, instruction.inductive_assertion);
       std::swap(instruction.loop_number, loop_number);
-      std::swap(instruction.assert_mode, assert_mode);
     }
 
     //! A globally unique number to identify a program location.
@@ -427,7 +413,6 @@ public:
       const class namespacet &ns,
       const irep_idt &identifier,
       std::ostream &out,
-      const messaget &msg,
       bool show_location = true) const;
   };
 
@@ -576,7 +561,7 @@ public:
   }
 
   //! Constructor
-  explicit goto_programt(const messaget &msg) : msg(msg), hide(false)
+  goto_programt() : hide(false)
   {
   }
   virtual ~goto_programt() = default;
diff --git a/src/goto-programs/goto_program_irep.cpp b/src/goto-programs/goto_program_irep.cpp
index b6de6934e..b0c89a8c5 100644
--- a/src/goto-programs/goto_program_irep.cpp
+++ b/src/goto-programs/goto_program_irep.cpp
@@ -1,12 +1,3 @@
-/*******************************************************************
- Module: goto_programt -> irep conversion
-
- Author: CM Wintersteiger
-
- Date: May 2007
-
-\*******************************************************************/
-
 #include <goto-programs/goto_program_irep.h>
 #include <util/i2string.h>
 
@@ -122,7 +113,7 @@ void convert(const irept &irep, goto_programt &program)
 
       if(fit == program.instructions.end())
       {
-        program.msg.error(
+        log_error(
           "Warning: could not resolve target link "
           "during irep->goto_program translation.");
         abort();
diff --git a/src/goto-programs/goto_program_irep.h b/src/goto-programs/goto_program_irep.h
index 8a98741df..8170d6a8a 100644
--- a/src/goto-programs/goto_program_irep.h
+++ b/src/goto-programs/goto_program_irep.h
@@ -1,13 +1,3 @@
-/*******************************************************************\
-
-Module: goto_programt -> irep conversion
-
-Author: CM Wintersteiger
-
-Date: May 2007
-
-\*******************************************************************/
-
 #ifndef GOTO_PROGRAM_IREP_H_
 #define GOTO_PROGRAM_IREP_H_
 
diff --git a/src/goto-programs/goto_program_serialization.cpp b/src/goto-programs/goto_program_serialization.cpp
index d51ba19e4..3e4ff4136 100644
--- a/src/goto-programs/goto_program_serialization.cpp
+++ b/src/goto-programs/goto_program_serialization.cpp
@@ -1,14 +1,3 @@
-/*******************************************************************\
- 
-Module: Convert goto programs to binary format and back (with irep
-        hashing)
- 
-Author: CM Wintersteiger
- 
-Date: May 2007
- 
-\*******************************************************************/
-
 #include <goto-programs/goto_program_irep.h>
 #include <goto-programs/goto_program_serialization.h>
 #include <sstream>
diff --git a/src/goto-programs/goto_program_serialization.h b/src/goto-programs/goto_program_serialization.h
index bd1df2ca8..fb6b78801 100644
--- a/src/goto-programs/goto_program_serialization.h
+++ b/src/goto-programs/goto_program_serialization.h
@@ -1,14 +1,3 @@
-/*******************************************************************\
- 
-Module: Convert goto programs to binary format and back (with 
-        irep hashing)
- 
-Author: CM Wintersteiger
- 
-Date: July 2006
- 
-\*******************************************************************/
-
 #ifndef GOTO_PROGRAM_SERIALIZATION_H_
 #define GOTO_PROGRAM_SERIALIZATION_H_
 
diff --git a/src/goto-programs/goto_sideeffects.cpp b/src/goto-programs/goto_sideeffects.cpp
index c45f14e06..113862e09 100644
--- a/src/goto-programs/goto_sideeffects.cpp
+++ b/src/goto-programs/goto_sideeffects.cpp
@@ -1,16 +1,10 @@
-/*******************************************************************\
-
-Module: Program Transformation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <goto-programs/goto_convert_class.h>
 #include <util/c_types.h>
 #include <util/cprover_prefix.h>
 #include <util/expr_util.h>
 #include <util/i2string.h>
+#include <util/message.h>
+#include <util/message/format.h>
 #include <util/rename.h>
 #include <util/std_expr.h>
 
@@ -53,7 +47,11 @@ void goto_convertt::remove_sideeffects(
   if(expr.is_and() || expr.is_or())
   {
     if(!expr.is_boolean())
-      throw expr.id_string() + " must be Boolean, but got " + expr.pretty();
+    {
+      log_error(
+        "{} must be Boolean, but got {}", expr.id_string(), expr.pretty());
+      abort();
+    }
 
     exprt tmp;
 
@@ -72,7 +70,10 @@ void goto_convertt::remove_sideeffects(
       exprt &op = *it;
 
       if(!op.is_boolean())
-        throw expr.id().as_string() + " takes boolean operands only";
+      {
+        log_error("{} takes boolean operands only", expr.id().as_string());
+        abort();
+      }
 
       if(expr.is_and())
       {
@@ -111,10 +112,10 @@ void goto_convertt::remove_sideeffects(
 
     const locationt location = expr.location();
 
-    goto_programt tmp_true(get_message_handler());
+    goto_programt tmp_true;
     remove_sideeffects(if_expr.true_case(), tmp_true, result_is_used);
 
-    goto_programt tmp_false(get_message_handler());
+    goto_programt tmp_false;
     remove_sideeffects(if_expr.false_case(), tmp_false, result_is_used);
 
     if(result_is_used)
@@ -287,6 +288,8 @@ void goto_convertt::remove_sideeffects(
       remove_pre(expr, dest, result_is_used);
     else if(statement == "cpp_new" || statement == "cpp_new[]")
       remove_cpp_new(expr, dest, result_is_used);
+    else if(statement == "cpp_delete" || statement == "cpp_delete[]")
+      remove_cpp_delete(expr, dest);
     else if(statement == "temporary_object")
       remove_temporary_object(expr, dest);
     else if(statement == "nondet")
@@ -312,8 +315,8 @@ void goto_convertt::remove_sideeffects(
     }
     else
     {
-      str << "cannot remove side effect (" << statement << ")";
-      throw 0;
+      log_error("cannot remove side effect ({})", statement);
+      abort();
     }
   }
 }
@@ -341,16 +344,18 @@ void goto_convertt::remove_assignment(
   {
     if(expr.operands().size() != 2)
     {
-      err_location(expr);
-      str << statement << " takes two arguments";
-      throw 0;
+      std::ostringstream str;
+      str << statement << " takes two arguments\n";
+      str << "Location: " << expr.location();
+      log_error(str.str());
+      abort();
     }
 
     exprt rhs;
 
     if(statement == "assign+")
     {
-      if(expr_has_float(expr))
+      if(expr_has_floatbv(expr))
       {
         rhs.id("ieee_add");
       }
@@ -361,7 +366,7 @@ void goto_convertt::remove_assignment(
     }
     else if(statement == "assign-")
     {
-      if(expr_has_float(expr))
+      if(expr_has_floatbv(expr))
       {
         rhs.id("ieee_sub");
       }
@@ -372,7 +377,7 @@ void goto_convertt::remove_assignment(
     }
     else if(statement == "assign*")
     {
-      if(expr_has_float(expr))
+      if(expr_has_floatbv(expr))
       {
         rhs.id("ieee_mul");
       }
@@ -383,7 +388,7 @@ void goto_convertt::remove_assignment(
     }
     else if(statement == "assign_div")
     {
-      if(expr_has_float(expr))
+      if(expr_has_floatbv(expr))
       {
         rhs.id("ieee_div");
       }
@@ -422,9 +427,11 @@ void goto_convertt::remove_assignment(
     }
     else
     {
-      err_location(expr);
-      str << statement << " not yet supported";
-      throw 0;
+      std::ostringstream str;
+      str << statement << " not yet supported\n";
+      str << "Location: " << expr.location();
+      log_error("{}", str.str());
+      abort();
     }
 
     rhs.copy_to_operands(expr.op0(), expr.op1());
@@ -468,9 +475,11 @@ void goto_convertt::remove_pre(
 
   if(expr.operands().size() != 1)
   {
-    err_location(expr);
-    str << statement << " takes one argument";
-    throw 0;
+    std::ostringstream str;
+    str << statement << " takes one argument\n";
+    str << "Location: " << expr.location();
+    log_error("{}", str.str());
+    abort();
   }
 
   exprt rhs;
@@ -517,8 +526,11 @@ void goto_convertt::remove_pre(
       constant_type = op_type;
     else
     {
-      err_location(expr);
-      throw "no constant one of type " + op_type.to_string();
+      std::ostringstream str;
+      str << "no constant one of type " + op_type.to_string() << "\n";
+      str << "Location: " << expr.location();
+      log_error(str.str());
+      abort();
     }
 
     exprt constant = gen_one(constant_type);
@@ -554,9 +566,11 @@ void goto_convertt::remove_post(
 
   if(expr.operands().size() != 1)
   {
-    err_location(expr);
+    std::ostringstream str;
     str << statement << " takes one argument";
-    throw 0;
+    str << "Location: " << expr.location();
+    log_error("{}", str.str());
+    abort();
   }
 
   exprt rhs;
@@ -603,8 +617,11 @@ void goto_convertt::remove_post(
       constant_type = op_type;
     else
     {
-      err_location(expr);
-      throw "no constant one of type " + op_type.to_string();
+      std::ostringstream str;
+      str << "no constant one of type " + op_type.to_string();
+      str << "Location: " << expr.location();
+      log_error(str.str());
+      abort();
     }
 
     exprt constant = gen_one(constant_type);
@@ -617,7 +634,7 @@ void goto_convertt::remove_post(
   code_assignt assignment(expr.op0(), rhs);
   assignment.location() = expr.location();
 
-  goto_programt tmp(get_message_handler());
+  goto_programt tmp;
   convert(assignment, tmp);
 
   // fix up the expression, if needed
@@ -669,16 +686,17 @@ void goto_convertt::remove_function_call(
   if(expr.op0().is_symbol())
   {
     const irep_idt &identifier = expr.op0().identifier();
-    const symbolt &symbol = ns.lookup(identifier);
+    const symbolt *symbol = ns.lookup(identifier);
+    assert(symbol);
 
     std::string new_base_name = id2string(new_symbol.name);
 
     new_base_name += '_';
-    new_base_name += id2string(symbol.name);
+    new_base_name += id2string(symbol->name);
     new_base_name += "$" + std::to_string(++tmp_symbol.counter);
 
     new_symbol.name = new_base_name;
-    new_symbol.mode = symbol.mode;
+    new_symbol.mode = symbol->mode;
   }
 
   new_symbol.id = tmp_symbol.prefix + id2string(new_symbol.name);
@@ -701,7 +719,7 @@ void goto_convertt::remove_function_call(
   assignment.copy_to_operands(symbol_expr(new_symbol));
   assignment.move_to_operands(call);
 
-  goto_programt tmp_program(get_message_handler());
+  goto_programt tmp_program;
   convert(assignment, tmp_program);
   dest.destructive_append(tmp_program);
 
@@ -722,6 +740,10 @@ void goto_convertt::remove_cpp_new(
   goto_programt &dest,
   bool result_is_used)
 {
+  // For side effect with 'cpp_new' statement, `expr' refers to the side effect that
+  // contains an initializer. Technically, this function converts the cpp_new side effect
+  // and replaces it with a new symbol if `result_is_used` is true. It's not just simply
+  // removing the side effect node in the exprt tree.
   codet call;
 
   symbolt new_symbol;
@@ -738,7 +760,7 @@ void goto_convertt::remove_cpp_new(
 
   call = code_assignt(symbol_expr(new_symbol), expr);
 
-  if(result_is_used)
+  if(result_is_used) // e.g. used to construct an assignment 'code_assignt'
     expr = symbol_expr(new_symbol);
   else
     expr.make_nil();
@@ -746,6 +768,20 @@ void goto_convertt::remove_cpp_new(
   convert(call, dest);
 }
 
+void goto_convertt::remove_cpp_delete(exprt &expr, goto_programt &dest)
+{
+  assert(expr.operands().size() == 1); // cpp_delete expects one operand
+
+  codet tmp(expr.statement());
+  tmp.location() = expr.location();
+  tmp.copy_to_operands(to_unary_expr(expr).op0());
+  tmp.set("destructor", expr.find("destructor"));
+
+  convert_cpp_delete(tmp, dest);
+
+  expr.make_nil();
+}
+
 void goto_convertt::remove_temporary_object(exprt &expr, goto_programt &dest)
 {
   if(expr.operands().size() != 1 && expr.operands().size() != 0)
@@ -762,7 +798,7 @@ void goto_convertt::remove_temporary_object(exprt &expr, goto_programt &dest)
     assignment.copy_to_operands(symbol_expr(new_symbol));
     assignment.move_to_operands(expr.op0());
 
-    goto_programt tmp_program(get_message_handler());
+    goto_programt tmp_program;
     convert(assignment, tmp_program);
     dest.destructive_append(tmp_program);
   }
@@ -773,7 +809,7 @@ void goto_convertt::remove_temporary_object(exprt &expr, goto_programt &dest)
     exprt initializer = static_cast<const exprt &>(expr.initializer());
     replace_new_object(symbol_expr(new_symbol), initializer);
 
-    goto_programt tmp_program(get_message_handler());
+    goto_programt tmp_program;
     convert(to_code(initializer), tmp_program);
     dest.destructive_append(tmp_program);
   }
@@ -834,7 +870,7 @@ void goto_convertt::remove_statement_expression(
     throw "statement_expression expects expression or assignment";
 
   {
-    goto_programt tmp(get_message_handler());
+    goto_programt tmp;
     convert(code, tmp);
     dest.destructive_append(tmp);
   }
diff --git a/src/goto-programs/interval_analysis.cpp b/src/goto-programs/interval_analysis.cpp
index e30c4c189..85e23130c 100644
--- a/src/goto-programs/interval_analysis.cpp
+++ b/src/goto-programs/interval_analysis.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Interval Analysis
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 /// \file
 /// Interval Analysis
 
diff --git a/src/goto-programs/interval_analysis.h b/src/goto-programs/interval_analysis.h
index 32ed0fbde..dee2a41d8 100644
--- a/src/goto-programs/interval_analysis.h
+++ b/src/goto-programs/interval_analysis.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Interval Analysis
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 /// \file
 /// Interval Analysis
 
diff --git a/src/goto-programs/interval_domain.cpp b/src/goto-programs/interval_domain.cpp
index 7e1bdc17d..f29bc3f90 100644
--- a/src/goto-programs/interval_domain.cpp
+++ b/src/goto-programs/interval_domain.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Interval Domain
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 /// \file
 /// Interval Domain
 
@@ -15,7 +7,6 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <util/c_typecast.h>
 #include <util/simplify_expr.h>
 #include <util/std_expr.h>
-#include <util/message/default_message.h>
 
 void interval_domaint::output(std::ostream &out) const
 {
@@ -310,10 +301,9 @@ void interval_domaint::assume_rec(const expr2tc &cond, bool negation)
 
 void interval_domaint::dump() const
 {
-  default_message msg;
   std::ostringstream oss;
   output(oss);
-  msg.debug(oss.str());
+  log_debug("{}", oss.str());
 }
 expr2tc interval_domaint::make_expression(const expr2tc &expr) const
 {
diff --git a/src/goto-programs/interval_domain.h b/src/goto-programs/interval_domain.h
index c753f55ba..90c87f7bb 100644
--- a/src/goto-programs/interval_domain.h
+++ b/src/goto-programs/interval_domain.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Interval Domain
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 /// \file
 /// Interval Domain
 
diff --git a/src/goto-programs/interval_template.h b/src/goto-programs/interval_template.h
index cafd9051c..8d2064854 100644
--- a/src/goto-programs/interval_template.h
+++ b/src/goto-programs/interval_template.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_ANALYSES_INTERVAL_TEMPLATE_H
 #define CPROVER_ANALYSES_INTERVAL_TEMPLATE_H
 
diff --git a/src/goto-programs/loop_numbers.cpp b/src/goto-programs/loop_numbers.cpp
index d83a38851..ada9b31ac 100644
--- a/src/goto-programs/loop_numbers.cpp
+++ b/src/goto-programs/loop_numbers.cpp
@@ -1,18 +1,11 @@
-/*******************************************************************\
-
-Module: Loop IDs
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <goto-programs/loop_numbers.h>
 #include <util/i2string.h>
+#include <util/message.h>
+#include <util/message/format.h>
 #include <util/xml.h>
 #include <util/xml_irep.h>
-#include <util/message/format.h>
 
-void show_loop_numbers(const goto_programt &goto_program, const messaget &msg)
+void show_loop_numbers(const goto_programt &goto_program)
 {
   for(const auto &instruction : goto_program.instructions)
   {
@@ -20,15 +13,13 @@ void show_loop_numbers(const goto_programt &goto_program, const messaget &msg)
     {
       unsigned loop_id = instruction.loop_number;
 
-      msg.debug(fmt::format("Loop {}:\n {}\n", loop_id, instruction.location));
+      log_debug("Loop {}:\n {}\n", loop_id, instruction.location);
     }
   }
 }
 
-void show_loop_numbers(
-  const goto_functionst &goto_functions,
-  const messaget &msg)
+void show_loop_numbers(const goto_functionst &goto_functions)
 {
   for(const auto &it : goto_functions.function_map)
-    show_loop_numbers(it.second.body, msg);
+    show_loop_numbers(it.second.body);
 }
diff --git a/src/goto-programs/loop_numbers.h b/src/goto-programs/loop_numbers.h
index 95801376d..ef9f4c230 100644
--- a/src/goto-programs/loop_numbers.h
+++ b/src/goto-programs/loop_numbers.h
@@ -1,20 +1,10 @@
-/*******************************************************************\
-
-Module: Loop IDs
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_CBMC_LOOP_IDS_H
 #define CPROVER_CBMC_LOOP_IDS_H
 
 #include <goto-programs/goto_functions.h>
 
-void show_loop_numbers(
-  const goto_functionst &goto_functions,
-  const messaget &msg);
+void show_loop_numbers(const goto_functionst &goto_functions);
 
-void show_loop_numbers(const goto_programt &goto_program, const messaget &msg);
+void show_loop_numbers(const goto_programt &goto_program);
 
 #endif
diff --git a/src/goto-programs/loop_unroll.cpp b/src/goto-programs/loop_unroll.cpp
index 57c5c09eb..2874eb968 100644
--- a/src/goto-programs/loop_unroll.cpp
+++ b/src/goto-programs/loop_unroll.cpp
@@ -31,8 +31,8 @@ bool unsound_loop_unroller::runOnLoop(loopst &loop, goto_programt &goto_program)
   }
 
   // we make k-1 copies, to be inserted before loop_exit
-  const messaget msg;
-  goto_programt copies(msg);
+
+  goto_programt copies;
   for(int i = 1; i < bound; i++)
   {
     // make a copy
diff --git a/src/goto-programs/loop_unroll.h b/src/goto-programs/loop_unroll.h
index b2afd921a..e7ce4d1bc 100644
--- a/src/goto-programs/loop_unroll.h
+++ b/src/goto-programs/loop_unroll.h
@@ -2,7 +2,7 @@
 #define ESBMC_GOTO_ALGORITHMS_H
 
 #include <util/algorithms.h>
-#include <util/message/message.h>
+#include <util/message.h>
 
 /**
  * @brief This is the base class that unroll
@@ -17,8 +17,7 @@
 class unsound_loop_unroller : public goto_functions_algorithm
 {
 public:
-  unsound_loop_unroller(goto_functionst &goto_functions)
-    : goto_functions_algorithm(goto_functions, true)
+  unsound_loop_unroller() : goto_functions_algorithm(true)
   {
   }
 
@@ -62,10 +61,8 @@ public:
   /**
    * Note: the default value for unroll_limit is based on testing
    */
-  bounded_loop_unroller(
-    goto_functionst &goto_functions,
-    size_t unroll_limit = 1000)
-    : unsound_loop_unroller(goto_functions), unroll_limit(unroll_limit)
+  explicit bounded_loop_unroller(size_t unroll_limit = 1000)
+    : unsound_loop_unroller(), unroll_limit(unroll_limit)
   {
   }
 
@@ -89,4 +86,4 @@ private:
   unsigned number_of_bounded_loops = 0;
 };
 
-#endif
\ No newline at end of file
+#endif
diff --git a/src/goto-programs/loopst.cpp b/src/goto-programs/loopst.cpp
index e928d3be7..99b5bf4d4 100644
--- a/src/goto-programs/loopst.cpp
+++ b/src/goto-programs/loopst.cpp
@@ -1,5 +1,4 @@
 #include <goto-programs/loopst.h>
-#include <util/message/default_message.h>
 
 const loopst::loop_varst &loopst::get_modified_loop_vars() const
 {
@@ -69,16 +68,15 @@ void loopst::output_loop_vars_to(std::ostream &oss) const
 
 void loopst::dump() const
 {
-  default_message msg;
   std::ostringstream oss;
   output_to(oss);
-  msg.debug(oss.str());
-  dump_loop_vars(msg);
+  log_debug("{}", oss.str());
+  dump_loop_vars();
 }
 
-void loopst::dump_loop_vars(const messaget &msg) const
+void loopst::dump_loop_vars() const
 {
   std::ostringstream oss;
   output_loop_vars_to(oss);
-  msg.debug(oss.str());
+  log_debug("{}", oss.str());
 }
diff --git a/src/goto-programs/loopst.h b/src/goto-programs/loopst.h
index f03813870..e9cb282bb 100644
--- a/src/goto-programs/loopst.h
+++ b/src/goto-programs/loopst.h
@@ -26,7 +26,7 @@ public:
   void add_unmodified_var_to_loop(const expr2tc &expr);
 
   void dump() const;
-  void dump_loop_vars(const messaget &msg) const;
+  void dump_loop_vars() const;
   void output_to(std::ostream &oss) const;
   void output_loop_vars_to(std::ostream &oss) const;
 
diff --git a/src/goto-programs/mark_decl_as_non_det.h b/src/goto-programs/mark_decl_as_non_det.h
index 1b58b682a..758b22b96 100644
--- a/src/goto-programs/mark_decl_as_non_det.h
+++ b/src/goto-programs/mark_decl_as_non_det.h
@@ -2,7 +2,7 @@
 
 #include <util/algorithms.h>
 #include <irep2/irep2.h>
-#include <util/message/message.h>
+#include <util/message.h>
 
 /**
  * @brief This will look over non-initialized local declarations
@@ -12,8 +12,8 @@
 class mark_decl_as_non_det : public goto_functions_algorithm
 {
 public:
-  mark_decl_as_non_det(contextt &context, goto_functionst &goto_functions)
-    : goto_functions_algorithm(goto_functions, true), context(context)
+  mark_decl_as_non_det(contextt &context)
+    : goto_functions_algorithm(true), context(context)
   {
   }
 
@@ -21,4 +21,4 @@ protected:
   contextt &context;
   virtual bool
   runOnFunction(std::pair<const dstring, goto_functiont> &F) override;
-};
\ No newline at end of file
+};
diff --git a/src/goto-programs/read_bin_goto_object.cpp b/src/goto-programs/read_bin_goto_object.cpp
index 668ebd5af..b467c8360 100644
--- a/src/goto-programs/read_bin_goto_object.cpp
+++ b/src/goto-programs/read_bin_goto_object.cpp
@@ -1,20 +1,9 @@
-/*******************************************************************\
-
-Module: Read goto object files.
-
-Author: CM Wintersteiger
-
-Date: June 2006
-
-\*******************************************************************/
-
 #include <goto-programs/goto_function_serialization.h>
 #include <goto-programs/goto_program_irep.h>
 #include <goto-programs/read_bin_goto_object.h>
 #include <langapi/mode.h>
 #include <util/base_type.h>
 #include <util/irep_serialization.h>
-#include <util/message/message_stream.h>
 #include <util/namespace.h>
 #include <util/symbol_serialization.h>
 
@@ -24,10 +13,9 @@ bool read_bin_goto_object(
   std::istream &in,
   const std::string &filename,
   contextt &context,
-  goto_functionst &functions,
-  const messaget &message_handler)
+  goto_functionst &functions)
 {
-  message_streamt message_stream(message_handler);
+  std::ostringstream str;
 
   {
     char hdr[4];
@@ -42,18 +30,16 @@ bool read_bin_goto_object(
       if(hdr[0] == 0x7f && hdr[1] == 'E' && hdr[2] == 'L' && hdr[3] == 'F')
       {
         if(filename != "")
-          message_stream.str << "Sorry, but I can't read ELF binary `"
-                             << filename << "'";
+          str << "Sorry, but I can't read ELF binary `" << filename << "'";
         else
-          message_stream.str << "Sorry, but I can't read ELF binaries";
+          str << "Sorry, but I can't read ELF binaries";
       }
       else
-        message_stream.str << "`" << filename << "' is not a goto-binary."
-                           << "\n";
-
-      message_stream.error();
+        str << "`" << filename << "' is not a goto-binary."
+            << "\n";
 
-      return true;
+      log_error("{}", str.str());
+      abort();
     }
   }
 
@@ -67,11 +53,10 @@ bool read_bin_goto_object(
 
     if(version != BINARY_VERSION)
     {
-      message_stream.str
-        << "The input was compiled with a different version of "
-        << "goto-cc, please recompile";
-      message_stream.warning();
-      return true;
+      str << "The input was compiled with a different version of "
+          << "goto-cc, please recompile";
+      log_error("{}", str.str());
+      abort();
     }
   }
 
@@ -91,12 +76,14 @@ bool read_bin_goto_object(
       // the function types.
       auto it = functions.function_map.find(symbol.id);
       if(it == functions.function_map.end())
-        functions.function_map.emplace(symbol.id, message_handler);
+        functions.function_map.emplace(symbol.id, goto_functiont());
       functions.function_map.at(symbol.id).type = to_code_type(symbol.type);
     }
     context.add(symbol);
   }
 
+  assert(migrate_namespace_lookup);
+
   count = irepconverter.read_long(in);
   for(unsigned i = 0; i < count; i++)
   {
@@ -105,7 +92,7 @@ bool read_bin_goto_object(
     gfconverter.convert(in, t);
     auto it = functions.function_map.find(fname);
     if(it == functions.function_map.end())
-      functions.function_map.emplace(fname, message_handler);
+      functions.function_map.emplace(fname, goto_functiont());
     goto_functiont &f = functions.function_map.at(fname);
     convert(t, f.body);
     f.body_available = f.body.instructions.size() > 0;
diff --git a/src/goto-programs/read_bin_goto_object.h b/src/goto-programs/read_bin_goto_object.h
index feff8065e..466bb1262 100644
--- a/src/goto-programs/read_bin_goto_object.h
+++ b/src/goto-programs/read_bin_goto_object.h
@@ -1,19 +1,9 @@
-/*******************************************************************\
- 
-Module: Read goto object files.
- 
-Author: CM Wintersteiger
- 
-Date: May 2007
- 
-\*******************************************************************/
-
 #ifndef READ_BIN_GOTO_OBJECT_H_
 #define READ_BIN_GOTO_OBJECT_H_
 
 #include <goto-programs/goto_functions.h>
 #include <util/context.h>
-#include <util/message/message.h>
+#include <util/message.h>
 
 /** Parses `in`. If failing to do so, a message is printed to `msg_hndlr`.
  *  @return true on error, false on success */
@@ -21,7 +11,6 @@ bool read_bin_goto_object(
   std::istream &in,
   const std::string &filename,
   contextt &context,
-  goto_functionst &functions,
-  const messaget &msg_hndlr);
+  goto_functionst &functions);
 
 #endif /*READ_BIN_GOTO_OBJECT_H_*/
diff --git a/src/goto-programs/read_goto_binary.cpp b/src/goto-programs/read_goto_binary.cpp
index f9912239d..6af52b36e 100644
--- a/src/goto-programs/read_goto_binary.cpp
+++ b/src/goto-programs/read_goto_binary.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Read Goto Programs
-
-Author:
-
-\*******************************************************************/
-
 #include <goto-programs/read_bin_goto_object.h>
 #include <goto-programs/read_goto_binary.h>
 #include <fstream>
@@ -16,20 +8,18 @@ bool read_goto_binary_array(
   const void *data,
   size_t size,
   contextt &context,
-  goto_functionst &dest,
-  const messaget &msg)
+  goto_functionst &dest)
 {
   using namespace boost::iostreams;
   stream<array_source> src(static_cast<const char *>(data), size);
-  return read_bin_goto_object(src, "", context, dest, msg);
+  return read_bin_goto_object(src, "", context, dest);
 }
 
 bool read_goto_binary(
   const std::string &path,
   contextt &context,
-  goto_functionst &dest,
-  const messaget &msg)
+  goto_functionst &dest)
 {
   std::ifstream in(path, std::ios::in | std::ios::binary);
-  return read_bin_goto_object(in, path, context, dest, msg);
+  return read_bin_goto_object(in, path, context, dest);
 }
diff --git a/src/goto-programs/read_goto_binary.h b/src/goto-programs/read_goto_binary.h
index 097a5bacc..6f93401e4 100644
--- a/src/goto-programs/read_goto_binary.h
+++ b/src/goto-programs/read_goto_binary.h
@@ -1,30 +1,20 @@
-/*******************************************************************\
-
-Module: Read Goto Programs
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_PROGRAMS_READ_GOTO_BINARY_H
 #define CPROVER_GOTO_PROGRAMS_READ_GOTO_BINARY_H
 
 #include <goto-programs/goto_functions.h>
 #include <util/context.h>
-#include <util/message/message.h>
+#include <util/message.h>
 #include <util/options.h>
 
 bool read_goto_binary_array(
   const void *data,
   size_t size,
   contextt &context,
-  goto_functionst &dest,
-  const messaget &msg);
+  goto_functionst &dest);
 
 bool read_goto_binary(
   const std::string &path,
   contextt &context,
-  goto_functionst &dest,
-  const messaget &msg);
+  goto_functionst &dest);
 
 #endif
diff --git a/src/goto-programs/remove_skip.cpp b/src/goto-programs/remove_skip.cpp
index 444862215..edca33cd7 100644
--- a/src/goto-programs/remove_skip.cpp
+++ b/src/goto-programs/remove_skip.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Program Transformation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <goto-programs/remove_skip.h>
 
 /// Determine whether the instruction is semantically equivalent to a skip
diff --git a/src/goto-programs/remove_skip.h b/src/goto-programs/remove_skip.h
index cea6dde0d..468c3bdc6 100644
--- a/src/goto-programs/remove_skip.h
+++ b/src/goto-programs/remove_skip.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Program Transformation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_PROGRAMS_REMOVE_SKIP_H
 #define CPROVER_GOTO_PROGRAMS_REMOVE_SKIP_H
 
diff --git a/src/goto-programs/remove_unreachable.cpp b/src/goto-programs/remove_unreachable.cpp
index ca5fb156b..6e1621f1d 100644
--- a/src/goto-programs/remove_unreachable.cpp
+++ b/src/goto-programs/remove_unreachable.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Program Transformation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <goto-programs/remove_unreachable.h>
 #include <set>
 #include <stack>
diff --git a/src/goto-programs/remove_unreachable.h b/src/goto-programs/remove_unreachable.h
index 544d6e981..bde6e6205 100644
--- a/src/goto-programs/remove_unreachable.h
+++ b/src/goto-programs/remove_unreachable.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Program Transformation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_PROGRAMS_REMOVE_UNREACHABLE_H
 #define CPROVER_GOTO_PROGRAMS_REMOVE_UNREACHABLE_H
 
diff --git a/src/goto-programs/rw_set.cpp b/src/goto-programs/rw_set.cpp
index 9e807d46f..072d4281b 100644
--- a/src/goto-programs/rw_set.cpp
+++ b/src/goto-programs/rw_set.cpp
@@ -1,13 +1,3 @@
-/*******************************************************************\
-
-Module: Race Detection for Threaded Goto Programs
-
-Author: Daniel Kroening
-
-Date: February 2006
-
-\*******************************************************************/
-
 #include <goto-programs/rw_set.h>
 #include <pointer-analysis/goto_program_dereference.h>
 #include <util/arith_tools.h>
@@ -43,8 +33,8 @@ void rw_sett::read_write_rec(
   {
     const symbol_exprt &symbol_expr = to_symbol_expr(expr);
 
-    const symbolt *symbol;
-    if(!ns.lookup(symbol_expr.get_identifier(), symbol))
+    const symbolt *symbol = ns.lookup(symbol_expr.get_identifier());
+    if(symbol)
     {
       if(!symbol->static_lifetime /*&& expr.type().id()=="pointer"*/)
       {
@@ -95,7 +85,7 @@ void rw_sett::read_write_rec(
     exprt tmp(expr.op0());
     expr2tc tmp_expr;
     migrate_expr(tmp, tmp_expr);
-    dereference(target, tmp_expr, ns, value_sets, msg);
+    dereference(target, tmp_expr, ns, value_sets);
     tmp = migrate_expr_back(tmp_expr);
 
     read_write_rec(tmp, r, w, suffix, guard);
diff --git a/src/goto-programs/rw_set.h b/src/goto-programs/rw_set.h
index 5d631722c..212578e59 100644
--- a/src/goto-programs/rw_set.h
+++ b/src/goto-programs/rw_set.h
@@ -1,13 +1,3 @@
-/*******************************************************************\
-
-Module: Race Detection for Threaded Goto Programs
-
-Author: Daniel Kroening
-
-Date: February 2006
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_PROGRAMS_RW_SET
 #define CPROVER_GOTO_PROGRAMS_RW_SET
 
@@ -57,9 +47,8 @@ public:
   rw_sett(
     const namespacet &_ns,
     value_setst &_value_sets,
-    goto_programt::const_targett _target,
-    const messaget &msg)
-    : ns(_ns), value_sets(_value_sets), target(_target), msg(msg)
+    goto_programt::const_targett _target)
+    : ns(_ns), value_sets(_value_sets), target(_target)
   {
   }
 
@@ -67,9 +56,8 @@ public:
     const namespacet &_ns,
     value_setst &_value_sets,
     goto_programt::const_targett _target,
-    const codet &code,
-    const messaget &msg)
-    : ns(_ns), value_sets(_value_sets), target(_target), msg(msg)
+    const codet &code)
+    : ns(_ns), value_sets(_value_sets), target(_target)
   {
     compute(code);
   }
@@ -88,7 +76,6 @@ protected:
   const namespacet &ns;
   value_setst &value_sets;
   const goto_programt::const_targett target;
-  const messaget &msg;
 
   void assign(const exprt &lhs, const exprt &rhs);
 
diff --git a/src/goto-programs/set_claims.cpp b/src/goto-programs/set_claims.cpp
index f93ec9911..1a2fb8cc3 100644
--- a/src/goto-programs/set_claims.cpp
+++ b/src/goto-programs/set_claims.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Set Claims
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <goto-programs/set_claims.h>
 #include <util/i2string.h>
 
diff --git a/src/goto-programs/set_claims.h b/src/goto-programs/set_claims.h
index 29a35df81..53417f226 100644
--- a/src/goto-programs/set_claims.h
+++ b/src/goto-programs/set_claims.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Set claims
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_PROGRAMS_SET_CLAIMS_H
 #define CPROVER_GOTO_PROGRAMS_SET_CLAIMS_H
 
diff --git a/src/goto-programs/show_claims.cpp b/src/goto-programs/show_claims.cpp
index 2d6d9cfe6..842df0167 100644
--- a/src/goto-programs/show_claims.cpp
+++ b/src/goto-programs/show_claims.cpp
@@ -1,24 +1,15 @@
-/*******************************************************************\
-
-Module: Show Claims
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <goto-programs/show_claims.h>
 #include <langapi/language_util.h>
 #include <util/i2string.h>
+#include <util/message/format.h>
 #include <util/xml.h>
 #include <util/xml_irep.h>
-#include <util/message/format.h>
 
 void show_claims(
   const namespacet &ns,
   const irep_idt &identifier,
   const goto_programt &goto_program,
-  unsigned &count,
-  const messaget &msg)
+  unsigned &count)
 {
   for(const auto &instruction : goto_program.instructions)
   {
@@ -29,32 +20,26 @@ void show_claims(
       const irep_idt &comment = instruction.location.comment();
       const irep_idt description = (comment == "" ? "assertion" : comment);
 
-      msg.status(fmt::format(
+      log_status(
         "Claim {}:\n  {}\n  {}\n  {}\n",
         count,
         instruction.location,
         description,
-        from_expr(ns, identifier, instruction.guard, msg)));
+        from_expr(ns, identifier, instruction.guard));
     }
   }
 }
 
-void show_claims(
-  const namespacet &ns,
-  const goto_programt &goto_program,
-  const messaget &msg)
+void show_claims(const namespacet &ns, const goto_programt &goto_program)
 {
   unsigned count = 0;
-  show_claims(ns, "", goto_program, count, msg);
+  show_claims(ns, "", goto_program, count);
 }
 
-void show_claims(
-  const namespacet &ns,
-  const goto_functionst &goto_functions,
-  const messaget &msg)
+void show_claims(const namespacet &ns, const goto_functionst &goto_functions)
 {
   unsigned count = 0;
 
   for(const auto &it : goto_functions.function_map)
-    show_claims(ns, it.first, it.second.body, count, msg);
+    show_claims(ns, it.first, it.second.body, count);
 }
diff --git a/src/goto-programs/show_claims.h b/src/goto-programs/show_claims.h
index 8a561587d..d8f7834dc 100644
--- a/src/goto-programs/show_claims.h
+++ b/src/goto-programs/show_claims.h
@@ -1,26 +1,12 @@
-/*******************************************************************\
-
-Module: Show claims
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_PROGRAMS_SHOW_CLAIMS_H
 #define CPROVER_GOTO_PROGRAMS_SHOW_CLAIMS_H
 
 #include <goto-programs/goto_functions.h>
 #include <util/namespace.h>
-#include <util/message/message.h>
+#include <util/message.h>
 
-void show_claims(
-  const namespacet &ns,
-  const goto_functionst &goto_functions,
-  const messaget &msg);
+void show_claims(const namespacet &ns, const goto_functionst &goto_functions);
 
-void show_claims(
-  const namespacet &ns,
-  const goto_programt &goto_program,
-  const messaget &msg);
+void show_claims(const namespacet &ns, const goto_programt &goto_program);
 
 #endif
diff --git a/src/goto-programs/static_analysis.cpp b/src/goto-programs/static_analysis.cpp
index 966f5cf51..5699bedd4 100644
--- a/src/goto-programs/static_analysis.cpp
+++ b/src/goto-programs/static_analysis.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Value Set Propagation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <goto-programs/static_analysis.h>
 #include <memory>
@@ -84,11 +76,11 @@ void static_analysis_baset::output(
 {
   forall_goto_program_instructions(i_it, goto_program)
   {
-    out << "**** " << i_it->location << "\n";
+    out << i_it->location << "\n";
 
     get_state(i_it).output(ns, out);
     out << "\n";
-    i_it->output_instruction(ns, identifier, out, msg);
+    i_it->output_instruction(ns, identifier, out);
     out << "\n";
   }
 }
@@ -372,8 +364,7 @@ void static_analysis_baset::do_function_call_rec(
   }
   else
   {
-    msg.error(fmt::format(
-      "unexpected function_call argument: ", get_expr_id(function)));
+    log_error("unexpected function_call argument: {}", get_expr_id(function));
     abort();
   }
 }
diff --git a/src/goto-programs/static_analysis.h b/src/goto-programs/static_analysis.h
index 98880f87a..a71259199 100644
--- a/src/goto-programs/static_analysis.h
+++ b/src/goto-programs/static_analysis.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Static Analysis
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_PROGRAMS_STATIC_ANALYSIS_H
 #define CPROVER_GOTO_PROGRAMS_STATIC_ANALYSIS_H
 
@@ -25,8 +17,7 @@ public:
 
   typedef goto_programt::const_targett locationt;
 
-  virtual void
-  initialize(const namespacet &ns, locationt l, const messaget &msg) = 0;
+  virtual void initialize(const namespacet &ns, locationt l) = 0;
 
   // how function calls are treated:
   // a) there is an edge from each call site to the function head
@@ -80,8 +71,7 @@ public:
   typedef abstract_domain_baset statet;
   typedef goto_programt::const_targett locationt;
 
-  static_analysis_baset(const namespacet &_ns, const messaget &msg)
-    : ns(_ns), msg(msg), initialized(false)
+  static_analysis_baset(const namespacet &_ns) : ns(_ns), initialized(false)
   {
   }
 
@@ -134,7 +124,6 @@ public:
 
 protected:
   const namespacet &ns;
-  const messaget &msg;
 
   virtual void output(
     const goto_programt &goto_program,
@@ -222,8 +211,7 @@ class static_analysist : public static_analysis_baset
 {
 public:
   // constructor
-  static_analysist(const namespacet &_ns, const messaget &msg)
-    : static_analysis_baset(_ns, msg)
+  static_analysist(const namespacet &_ns) : static_analysis_baset(_ns)
   {
   }
 
@@ -288,7 +276,7 @@ protected:
 
   void generate_state(locationt l) override
   {
-    state_map[l].initialize(ns, l, msg);
+    state_map[l].initialize(ns, l);
   }
 
   void get_reference_set(
diff --git a/src/goto-programs/write_goto_binary.cpp b/src/goto-programs/write_goto_binary.cpp
index 56a162e73..fd91d5fdb 100644
--- a/src/goto-programs/write_goto_binary.cpp
+++ b/src/goto-programs/write_goto_binary.cpp
@@ -1,16 +1,8 @@
-/*******************************************************************\
-
-Module: Write GOTO binaries
-
-Author: CM Wintersteiger
-
-\*******************************************************************/
-
 #include <fstream>
 #include <goto-programs/goto_function_serialization.h>
 #include <goto-programs/write_goto_binary.h>
 #include <util/irep_serialization.h>
-#include <util/message/message.h>
+#include <util/message.h>
 #include <util/symbol_serialization.h>
 
 bool write_goto_binary(
diff --git a/src/goto-programs/write_goto_binary.h b/src/goto-programs/write_goto_binary.h
index 3fc9d6102..2356aac6e 100644
--- a/src/goto-programs/write_goto_binary.h
+++ b/src/goto-programs/write_goto_binary.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Write GOTO binaries
-
-Author: CM Wintersteiger
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_PROGRAMS_WRITE_GOTO_BINARY_H_
 #define CPROVER_GOTO_PROGRAMS_WRITE_GOTO_BINARY_H_
 
diff --git a/src/goto-symex/build_goto_trace.cpp b/src/goto-symex/build_goto_trace.cpp
index 3dbd6a486..fc236bcfe 100644
--- a/src/goto-symex/build_goto_trace.cpp
+++ b/src/goto-symex/build_goto_trace.cpp
@@ -2,10 +2,7 @@
 #include <goto-symex/build_goto_trace.h>
 #include <goto-symex/witnesses.h>
 
-expr2tc build_lhs(
-  std::shared_ptr<smt_convt> &smt_conv,
-  const expr2tc &lhs,
-  const messaget &msg)
+expr2tc build_lhs(std::shared_ptr<smt_convt> &smt_conv, const expr2tc &lhs)
 {
   if(is_nil_expr(lhs))
     return lhs;
@@ -20,7 +17,7 @@ expr2tc build_lhs(
 
     // Build new source value, it might be an index, in case of
     // multidimensional arrays
-    expr2tc new_source_value = build_lhs(smt_conv, index.source_value, msg);
+    expr2tc new_source_value = build_lhs(smt_conv, index.source_value);
     expr2tc new_value = smt_conv->get(index.index);
     new_lhs = index2tc(new_lhs->type, new_source_value, new_value);
     break;
@@ -38,20 +35,17 @@ expr2tc build_lhs(
     break;
   }
 
-  renaming::renaming_levelt::get_original_name(new_lhs, symbol2t::level0, msg);
+  renaming::renaming_levelt::get_original_name(new_lhs, symbol2t::level0);
   return new_lhs;
 }
 
-expr2tc build_rhs(
-  std::shared_ptr<smt_convt> &smt_conv,
-  const expr2tc &rhs,
-  const messaget &msg)
+expr2tc build_rhs(std::shared_ptr<smt_convt> &smt_conv, const expr2tc &rhs)
 {
   if(is_nil_expr(rhs) || is_constant_expr(rhs))
     return rhs;
 
   auto new_rhs = smt_conv->get(rhs);
-  renaming::renaming_levelt::get_original_name(new_rhs, symbol2t::level0, msg);
+  renaming::renaming_levelt::get_original_name(new_rhs, symbol2t::level0);
   return new_rhs;
 }
 
@@ -59,8 +53,7 @@ void build_goto_trace(
   const std::shared_ptr<symex_target_equationt> &target,
   std::shared_ptr<smt_convt> &smt_conv,
   goto_tracet &goto_trace,
-  const bool &is_compact_trace,
-  const messaget &msg)
+  const bool &is_compact_trace)
 {
   unsigned step_nr = 0;
 
@@ -86,15 +79,14 @@ void build_goto_trace(
 
     if(SSA_step.is_assignment())
     {
-      goto_trace_step.lhs = build_lhs(smt_conv, SSA_step.original_lhs, msg);
+      goto_trace_step.lhs = build_lhs(smt_conv, SSA_step.original_lhs);
 
       try
       {
         if(is_nil_expr(SSA_step.original_rhs))
-          goto_trace_step.value = build_rhs(smt_conv, SSA_step.rhs, msg);
+          goto_trace_step.value = build_rhs(smt_conv, SSA_step.rhs);
         else
-          goto_trace_step.value =
-            build_rhs(smt_conv, SSA_step.original_rhs, msg);
+          goto_trace_step.value = build_rhs(smt_conv, SSA_step.original_rhs);
       }
       catch(const type2t::symbolic_type_excp &e)
       {
@@ -124,8 +116,7 @@ void build_goto_trace(
 void build_successful_goto_trace(
   const std::shared_ptr<symex_target_equationt> &target,
   const namespacet &ns,
-  goto_tracet &goto_trace,
-  const messaget &msg)
+  goto_tracet &goto_trace)
 {
   unsigned step_nr = 0;
   for(symex_target_equationt::SSA_stepst::const_iterator it =
@@ -135,7 +126,7 @@ void build_successful_goto_trace(
   {
     if(
       (it->is_assert() || it->is_assume()) &&
-      (is_valid_witness_expr(ns, it->lhs, msg)))
+      (is_valid_witness_expr(ns, it->lhs)))
     {
       // When building the correctness witness, we only care about
       // asserts and assumes
diff --git a/src/goto-symex/build_goto_trace.h b/src/goto-symex/build_goto_trace.h
index c8bd853be..f88bf80bd 100644
--- a/src/goto-symex/build_goto_trace.h
+++ b/src/goto-symex/build_goto_trace.h
@@ -1,13 +1,3 @@
-/*******************************************************************\
-
-Module: Traces of GOTO Programs
-
-Author: Daniel Kroening
-
-Date: July 2005
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_SYMEX_BUILD_GOTO_TRACE_H
 #define CPROVER_GOTO_SYMEX_BUILD_GOTO_TRACE_H
 
@@ -19,22 +9,14 @@ void build_goto_trace(
   const std::shared_ptr<symex_target_equationt> &target,
   std::shared_ptr<smt_convt> &smt_conv,
   goto_tracet &goto_trace,
-  const bool &is_compact_trace,
-  const messaget &msg);
+  const bool &is_compact_trace);
 
 void build_successful_goto_trace(
   const std::shared_ptr<symex_target_equationt> &target,
   const namespacet &ns,
-  goto_tracet &goto_trace,
-  const messaget &msg);
+  goto_tracet &goto_trace);
 
-expr2tc build_lhs(
-  std::shared_ptr<smt_convt> &smt_conv,
-  const expr2tc &lhs,
-  const messaget &msg);
-expr2tc build_rhs(
-  std::shared_ptr<smt_convt> &smt_conv,
-  const expr2tc &rhs,
-  const messaget &msg);
+expr2tc build_lhs(std::shared_ptr<smt_convt> &smt_conv, const expr2tc &lhs);
+expr2tc build_rhs(std::shared_ptr<smt_convt> &smt_conv, const expr2tc &rhs);
 
 #endif
diff --git a/src/goto-symex/builtin_functions.cpp b/src/goto-symex/builtin_functions.cpp
index 272f62026..2e1d25676 100644
--- a/src/goto-symex/builtin_functions.cpp
+++ b/src/goto-symex/builtin_functions.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Symbolic Execution of ANSI-C
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <complex>
 #include <functional>
@@ -23,6 +15,8 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <util/expr_util.h>
 #include <util/i2string.h>
 #include <irep2/irep2.h>
+#include <util/message.h>
+#include <util/message/format.h>
 #include <util/migrate.h>
 #include <util/prefix.h>
 #include <util/std_types.h>
@@ -133,12 +127,6 @@ expr2tc goto_symext::symex_mem(
 
   if(is_nil_type(type))
     type = char_type2();
-  else if(is_union_type(type))
-  {
-    // Filter out creation of instantiated unions. They're now all byte arrays.
-    size_is_one = false;
-    type = char_type2();
-  }
 
   unsigned int &dynamic_counter = get_dynamic_counter();
   dynamic_counter++;
@@ -248,11 +236,6 @@ void goto_symext::track_new_pointer(
   truth = gen_true_expr();
   symex_assign(code_assign2tc(valid_index_expr, truth), true);
 
-  symbol2tc dealloc_sym(sym_type, deallocd_arr_name);
-  index2tc dealloc_index_expr(get_bool_type(), dealloc_sym, ptr_obj);
-  expr2tc falseity = gen_false_expr();
-  symex_assign(code_assign2tc(dealloc_index_expr, falseity), true);
-
   type2tc sz_sym_type =
     type2tc(new array_type2t(uint_type2(), expr2tc(), true));
   symbol2tc sz_sym(sz_sym_type, alloc_size_arr_name);
@@ -316,10 +299,7 @@ void goto_symext::symex_free(const expr2tc &expr)
       expr2tc offset = item.offset;
       expr2tc eq = equality2tc(offset, gen_ulong(0));
       g.guard_expr(eq);
-      claim(
-        eq,
-        "Operand of free must have zero pointer offset",
-        goto_assertions::POINTER_SAFETY);
+      claim(eq, "Operand of free must have zero pointer offset");
 
       // Check if we are not freeing an dynamic object allocated using alloca
       for(auto const &a : allocad)
@@ -333,26 +313,18 @@ void goto_symext::symex_free(const expr2tc &expr)
         {
           expr2tc noteq = notequal2tc(alloc_obj, item.object);
           g.guard_expr(noteq);
-          claim(
-            noteq,
-            "dereference failure: invalid pointer freed",
-            goto_assertions::POINTER_SAFETY);
+          claim(noteq, "dereference failure: invalid pointer freed");
         }
       }
     }
   }
 
-  // Clear the alloc bit, and set the deallocated bit.
+  // Clear the alloc bit.
   type2tc sym_type =
     type2tc(new array_type2t(get_bool_type(), expr2tc(), true));
   expr2tc ptr_obj = pointer_object2tc(pointer_type2(), code.operand);
   dereference(ptr_obj, dereferencet::READ);
 
-  symbol2tc dealloc_sym(sym_type, deallocd_arr_name);
-  index2tc dealloc_index_expr(get_bool_type(), dealloc_sym, ptr_obj);
-  expr2tc truth = gen_true_expr();
-  symex_assign(code_assign2tc(dealloc_index_expr, truth), true);
-
   symbol2tc valid_sym(sym_type, valid_ptr_arr_name);
   index2tc valid_index_expr(get_bool_type(), valid_sym, ptr_obj);
   expr2tc falsity = gen_false_expr();
@@ -470,8 +442,7 @@ void goto_symext::intrinsic_switch_to(
   const expr2tc &num = call.operands[0];
   if(!is_constant_int2t(num))
   {
-    msg.error(
-      fmt::format("Can't switch to non-constant thread id no\n{}", *num));
+    log_error("Can't switch to non-constant thread id no\n{}", *num);
     abort();
   }
 
@@ -523,7 +494,7 @@ void goto_symext::intrinsic_set_thread_data(
 
   if(!is_constant_int2t(threadid))
   {
-    msg.error("__ESBMC_set_start_data received nonconstant thread id");
+    log_error("__ESBMC_set_start_data received nonconstant thread id");
     abort();
   }
   unsigned int tid = to_constant_int2t(threadid).value.to_uint64();
@@ -544,7 +515,7 @@ void goto_symext::intrinsic_get_thread_data(
 
   if(!is_constant_int2t(threadid))
   {
-    msg.error("__ESBMC_get_start_data received nonconstant thread id");
+    log_error("__ESBMC_get_start_data received nonconstant thread id");
     abort();
   }
 
@@ -565,7 +536,7 @@ void goto_symext::intrinsic_spawn_thread(
     (k_induction || inductive_step) &&
     !options.get_bool_option("disable-inductive-step"))
   {
-    msg.warning(
+    log_warning(
       "WARNING: k-induction does not support concurrency yet. "
       "Disabling inductive step");
 
@@ -586,14 +557,13 @@ void goto_symext::intrinsic_spawn_thread(
     art.goto_functions.function_map.find(symname);
   if(it == art.goto_functions.function_map.end())
   {
-    msg.error(
-      fmt::format("Spawning thread \"{}{}", symname, "\": symbol not found"));
+    log_error("Spawning thread \"{}\": symbol not found", symname);
     abort();
   }
 
   if(!it->second.body_available)
   {
-    msg.error(fmt::format("Spawning thread \"{}{}", symname, "\": no body"));
+    log_error("Spawning thread \"{}\": no body", symname);
     abort();
   }
 
@@ -636,7 +606,7 @@ void goto_symext::intrinsic_get_thread_state(
 
   if(!is_constant_int2t(threadid))
   {
-    msg.error("__ESBMC_get_thread_state received nonconstant thread id");
+    log_error("__ESBMC_get_thread_state received nonconstant thread id");
     abort();
   }
 
@@ -699,7 +669,7 @@ void goto_symext::intrinsic_register_monitor(
 
   if(!is_constant_int2t(threadid))
   {
-    msg.error("__ESBMC_register_monitor received nonconstant thread id");
+    log_error("__ESBMC_register_monitor received nonconstant thread id");
     abort();
   }
 
@@ -760,378 +730,18 @@ void goto_symext::symex_va_arg(const expr2tc &lhs, const sideeffect2t &code)
   symex_assign(code_assign2tc(lhs, va_rhs), true);
 }
 
-// Computes the equivalent object value when considering a memset operation on it
-expr2tc gen_byte_expression_byte_update(
-  const type2tc &type,
-  const expr2tc &src,
-  const expr2tc &value,
-  const size_t num_of_bytes,
-  const size_t offset)
-{
-  // Sadly, our simplifier can not typecast from value operations
-  // safely. We can however :)
-  auto new_src = src;
-  auto new_type = type;
-
-  auto found_constant = false;
-  auto optimized = src->simplify();
-  if(optimized)
-  {
-    found_constant = is_typecast2t(optimized) &&
-                     is_constant_int2t(to_typecast2t(optimized).from);
-    if(found_constant)
-    {
-      new_src = to_typecast2t(optimized).from;
-      new_type = get_int64_type();
-    }
-  }
-
-  expr2tc result = new_src;
-  auto value_downcast = typecast2tc(get_uint8_type(), value);
-
-  constant_int2tc off(get_int32_type(), BigInt(offset));
-  for(size_t counter = 0; counter < num_of_bytes; counter++)
-  {
-    constant_int2tc increment(get_int32_type(), BigInt(counter));
-    result = byte_update2tc(
-      new_type,
-      result,
-      add2tc(off->type, off, increment),
-      value_downcast,
-      false);
-  }
-
-  if(found_constant)
-    result = typecast2tc(type, result);
-
-  auto simplified = result->simplify();
-  if(simplified)
-    return simplified;
-
-  return result;
-}
-
-// Computes the equivalent object value when considering a memset operation on it
-expr2tc gen_byte_expression(
-  const type2tc &type,
-  const expr2tc &src,
-  const expr2tc &value,
-  const size_t num_of_bytes,
-  const size_t offset)
-{
-  /**
-   * The idea of this expression is to compute the object value
-   * in the case where every byte `value` was set set up until num_of_bytes
-   * 
-   * @warning this function does not add any pointer/memory/bounds check!
-   *          they should be added before calling this function!
-   * 
-   * In summary, there are two main computations here:
-   * 
-   * A. Generate the byte representation, this is mostly through
-   *    the `result` expression. The expression is initialized with zero
-   *    and then, until the num_of_bytes is reached it will do a full byte
-   *    left-shift followed by an bitor operation with the byte value:
-   * 
-   *    Example, for a integer(4 bytes) with memset using 3 bytes and value 0xF1
-   * 
-   *    step 1: 0x00000000 -- left-shift 8 -- 0x00000000 -- bitor -- 0x000000F1
-   *    step 2: 0x000000F1 -- left-shift 8 -- 0x0000F100 -- bitor -- 0x0000F1F1
-   *    step 3: 0x0000F1F1 -- left-shift 8 -- 0x00F1F100 -- bitor -- 0x00F1F1F1
-   *    
-   *    Since we only want 3 bytes, the initialized object value would be 0x00F1F1F1
-   * 
-   * B. Generate a mask of the bits that were not set, this is done because skipped bits
-   *    need to be returned back. The computation of this is simple, we initialize every
-   *    bit that was changed by the byte-representation computation with a 1. Which is then
-   *    negated to be applied with an bitand in the original value:
-   * 
-   *    Back to the example in A, we had the byte-representation of  0x00F1F1F1. If the
-   *    original value was 0xA2A2A2A2, then we would have the following mask:
-   *    
-   *    step 1: 0x00000000 -- set-bits -- 0x000000FF
-   *    step 2: 0x000000FF -- set-bits -- 0x0000FFFF
-   *    step 3: 0x0000FFFF -- set-bits -- 0x00FFFFFF
-   * 
-   *   So, 0x00FFFFFF is the mask for all bits changed. We can negate it to: 0xFF000000
-   *   
-   *   Then, we can apply it to the original source value with bitand
-   * 
-   *   0xA2A2A2A2 AND 0xFF000000 --> 0xA2000000
-   * 
-   * Finally, we get the result from A and B and unify them through a bitor
-   *   
-   *  0xA2000000 OR 0x00F1F1F1 --> 0xA2F1F1F1
-   * 
-   * Note about offsets: To handle them, we apply left shifts to the remaining offset after
-   * the computation of the object-value and initial mask representation
-   * 
-   */
-
-  if(is_pointer_type(type))
-    return gen_byte_expression_byte_update(
-      type, src, value, num_of_bytes, offset);
-  expr2tc result = gen_zero(type);
-  auto value_downcast = typecast2tc(get_uint8_type(), value);
-  auto value_upcast = typecast2tc(
-    type,
-    value_downcast); // so smt_conv will complain about the width of the type
-
-  expr2tc mask = gen_zero(type);
-
-  auto eight = constant_int2tc(int_type2(), BigInt((int)8));
-  auto one = constant_int2tc(int_type2(), BigInt((int)1));
-  for(unsigned i = 0; i < num_of_bytes; i++)
-  {
-    result = shl2tc(type, result, eight);
-    result = bitor2tc(type, result, value_upcast);
-
-    for(int m = 0; m < 8; m++)
-    {
-      mask = shl2tc(type, mask, one);
-      mask = bitor2tc(type, mask, one);
-    }
-  }
-
-  // Do the rest of the offset!
-  for(unsigned i = 0; i < offset; i++)
-  {
-    result = shl2tc(type, result, eight);
-    mask = shl2tc(type, mask, eight);
-  }
-
-  mask = bitnot2tc(type, mask);
-  mask = bitand2tc(type, src, mask);
-  result = bitor2tc(type, result, mask);
-
-  auto simplified = result->simplify();
-  if(simplified)
-    return simplified;
-
-  return result;
-}
-
-inline expr2tc gen_value_by_byte(
-  const type2tc &type,
-  const expr2tc &src,
-  const expr2tc &value,
-  const size_t num_of_bytes,
-  const size_t offset)
-{
-  /**
-   * @brief Construct a new object, initializing it with the memset equivalent
-   *
-   * There are a few corner cases here:
-   * 
-   * 1 - Primitives: these are simple: just generate the byte_expression directly
-   * 2 - Arrays: these are ok: just keep generating byte_expression for each member
-   *        until a limit has arrived. Dynamic memory is dealt here.
-   * 3 - Structs/Union: these are the hardest as we have to take the alignment into
-   *        account when dealing with it. Hopefully the clang-frontend already give it
-   *        to us.
-   * 
-   */
-
-  // I am not sure if bitwise operations are valid for floats
-  if(is_floatbv_type(type) || is_fixedbv_type(type))
-    return expr2tc();
-
-  if(is_array_type(type))
-  {
-    /*
-     * Very straighforward, get the total number_of_bytes and keep subtracting until
-     * the end
-     */
-
-    constant_array2tc result = gen_zero(type);
-
-    auto base_size = type_byte_size(to_array_type(type).subtype).to_uint64();
-
-    auto bytes_left = num_of_bytes;
-    auto offset_left = offset;
-
-    for(unsigned i = 0; i < result->datatype_members.size(); i++)
-    {
-      BigInt position(i);
-      index2tc local_member(
-        to_array_type(type).subtype,
-        src,
-        constant_int2tc(get_uint32_type(), position));
-      // Skip offsets
-      if(offset_left >= base_size)
-      {
-        result->datatype_members[i] = local_member;
-        offset_left -= base_size;
-      }
-      else
-      {
-        assert(offset_left < base_size);
-        auto bytes_to_write = bytes_left < base_size ? bytes_left : base_size;
-        result->datatype_members[i] = gen_value_by_byte(
-          to_array_type(type).subtype,
-          local_member,
-          value,
-          bytes_to_write,
-          offset_left);
-        bytes_left =
-          bytes_left <= base_size ? 0 : bytes_left - (base_size - offset_left);
-        offset_left = offset_left <= base_size ? 0 : offset_left - base_size;
-        assert(offset_left == 0);
-      }
-    }
-
-    return result;
-  }
-
-  if(is_struct_type(type))
-  {
-    /** Similar to array, however get the size of
-     * each component
-     */
-    constant_struct2tc result = gen_zero(type);
-
-    auto bytes_left = num_of_bytes;
-    auto offset_left = offset;
-
-    for(unsigned i = 0; i < result->datatype_members.size(); i++)
-    {
-      auto name = to_struct_type(type).member_names[i];
-      member2tc local_member(to_struct_type(type).members[i], src, name);
-
-      // Since it is a symbol, lets start from the old value
-      if(is_pointer_type(to_struct_type(type).members[i]))
-        result->datatype_members[i] = local_member;
-
-      auto current_member_type = result->datatype_members[i]->type;
-
-      auto current_member_size =
-        type_byte_size(current_member_type).to_uint64();
-
-      // Skip offsets
-      if(offset_left >= current_member_size)
-      {
-        result->datatype_members[i] = local_member;
-        offset_left -= current_member_size;
-      }
-      else
-      {
-        assert(offset_left < current_member_size);
-        auto bytes_to_write =
-          bytes_left < current_member_size ? bytes_left : current_member_size;
-
-        result->datatype_members[i] = gen_value_by_byte(
-          current_member_type,
-          local_member,
-          value,
-          bytes_to_write,
-          offset_left);
-
-        if(!result->datatype_members[i])
-          return expr2tc();
-
-        bytes_left = bytes_left < current_member_size
-                       ? 0
-                       : bytes_left - (current_member_size - offset_left);
-        offset_left = offset_left <= current_member_size
-                        ? 0
-                        : offset_left - current_member_size;
-        assert(offset_left == 0);
-      }
-    }
-    return result;
-  }
-
-  if(is_union_type(type))
-  {
-    /**
-     * Unions are not nice, let's go through every member
-     * and get the biggest one! And then use it directly
-     * 
-     * @warning there is a semantic difference on this when
-     * compared to c:@F@__memset_impl. While this function
-     * will yield the same result as `clang` would, ESBMC
-     * will handle the dereference (in the __memset_impl)
-     * using the first member, which can lead to overflows.
-     * See GitHub Issue #639
-     * 
-     */
-    constant_union2tc result = gen_zero(type);
-
-    auto union_total_size = type_byte_size(type).to_uint64();
-    // Let's find a member with the biggest size
-    int selected_member_index;
-
-    for(unsigned i = 0; i < to_union_type(type).members.size(); i++)
-    {
-      if(
-        type_byte_size(to_union_type(type).members[i]).to_uint64() ==
-        union_total_size)
-      {
-        selected_member_index = i;
-        break;
-      }
-    }
-
-    auto name = to_union_type(type).member_names[selected_member_index];
-    auto member_type = to_union_type(type).members[selected_member_index];
-    member2tc member(member_type, src, name);
-
-    //result->init_field = name;
-    result->datatype_members[0] =
-      gen_value_by_byte(member_type, member, value, num_of_bytes, offset);
-    return result;
-  }
-
-  // Found a primitive! Just apply the function
-  return gen_byte_expression(type, src, value, num_of_bytes, offset);
-}
-
 void goto_symext::intrinsic_memset(
   reachability_treet &art,
   const code_function_call2t &func_call)
 {
-  /**
-     * @brief This function will try to initialize the object pointed by
-     * the address in a smarter way, minimizing the number of assignments.
-     * This is intend to optimize the behaviour of a memset operation:
-     * 
-     * memset(void* ptr, int value, size_t num_of_bytes)
-     * 
-     * - ptr can point to anything. We have to add checks!
-     * - value is interpreted as a uchar.
-     * - num_of_bytes must be known. If it is nondet, we will bump the call
-     * 
-     * In plain C, the objective of a call such as:
-     * 
-     * int a;
-     * memset(&a, value, num)
-     * 
-     * Would generate something as:
-     *      
-     * int temp = 0;
-     * for(int i = 0; i < num; i++) temp = byte | (temp << 8);
-     * a = temp;
-     * 
-     * This is just a simplification for understanding though. During the
-     * instrumentation size checks will be added, and also, the original
-     * bytes from `a` that were not overwritten must be mantained! 
-     * Arrays will need to be added up to an nth element.
-     * 
-     * In ESBMC though, we have 2 main methods of dealing with memory objects:
-     * 
-     * A. Heap objects, which are valid/invalid. They are the easiest to deal
-     *    with, as the dereference will actually return a big array of char to us.
-     *    For this case, we can just overwrite the members directly with the value
-     * 
-     * B. Stack objects, which are typed. It will be hard, this will require operations
-     *    which depends on the base type and also on padding.
-     * 
-     */
-
-  // 1. Check for the functions parameters and do the deref and processing!
-
   assert(func_call.operands.size() == 3 && "Wrong memset signature");
   auto &ex_state = art.get_cur_state();
+  expr2tc ptr = func_call.operands[0];
+  expr2tc value = func_call.operands[1];
+  expr2tc size = func_call.operands[2];
+  std::map<type2tc, std::list<std::pair<type2tc, unsigned int>>> ref_types;
+
+  // This can be a conditional intrinsic
   if(ex_state.cur_state->guard.is_false())
     return;
 
@@ -1152,181 +762,246 @@ void goto_symext::intrinsic_memset(
     return;
   };
 
-  /* Get the arguments
-     * arg0: ptr to object
-     * arg1: int for the new byte value
-     * arg2: number of bytes to be set */
-  expr2tc arg0 = func_call.operands[0];
-  expr2tc arg1 = func_call.operands[1];
-  expr2tc arg2 = func_call.operands[2];
-
-  msg.debug("[memset] started call");
-
-  // Checks where arg0 points to
-  internal_deref_items.clear();
-  dereference2tc deref(get_empty_type(), arg0);
-  dereference(deref, dereferencet::INTERNAL);
-
-  /* Preconditions for the optimization:
-     * A: It should point to someplace
-     * B: byte itself should be renamed properly 
-     * C: Number of bytes cannot be symbolic 
-     * D: This is a simplification. So don't run with --no-simplify */
-  cur_state->rename(arg1);
-  cur_state->rename(arg2);
-  if(
-    !internal_deref_items.size() || !arg1 || !arg2 || is_symbol2t(arg2) ||
-    options.get_bool_option("no-simplify"))
+  // Skip if the operand is not zero. Because honestly, there's very little
+  // point.
+  cur_state->rename(value);
+  if(!is_constant_int2t(value) || to_constant_int2t(value).value != 0)
   {
-    /* Not sure what to do here, let's rely
-       * on the default implementation then */
-    msg.debug("[memset] Couldn't optimize memset due to precondition");
     bump_call();
     return;
   }
 
-  auto simplified = arg2->simplify();
-  if(simplified)
-    arg2 = simplified;
+  // Work out what the ptr points at.
+  internal_deref_items.clear();
+  dereference2tc deref(get_empty_type(), ptr);
+  dereference(deref, dereferencet::INTERNAL);
 
-  if(!is_constant_int2t(arg2))
+  // Work out here whether we can construct an assignment for each thing
+  // pointed at by the ptr.
+  cur_state->rename(size);
+  bool can_construct = true;
+  for(const auto &item : internal_deref_items)
   {
-    msg.debug("[memset] TODO: simplifier issues :/");
-    bump_call();
-    return;
-  }
+    const expr2tc &offs = item.offset;
 
-  auto number_of_bytes = to_constant_int2t(arg2).as_ulong();
-
-  // If no byte was changed... we are finished
-
-  // Where are we pointing to?
-  for(auto &item : internal_deref_items)
-  {
-    auto guard = ex_state.cur_state->guard;
-    auto item_object = item.object;
-    auto item_offset = item.offset;
-    guard.add(item.guard);
-
-    cur_state->rename(item_object);
-    cur_state->rename(item_offset);
-
-    /* Pre-requisites locally:
-       * item_object must be something!
-       * item_offset must be something! */
-    if(!item_object || !item_offset)
+    int tmpsize;
+    try
     {
-      msg.debug("[memset] Couldn't get item_object/item_offset");
-      bump_call();
-      return;
+      tmpsize = type_byte_size(item.object->type).to_int64();
+    }
+    catch(const array_type2t::dyn_sized_array_excp &e)
+    {
+      tmpsize = -1;
+    }
+    catch(const array_type2t::inf_sized_array_excp &e)
+    {
+      tmpsize = -1;
     }
 
-    auto offset_simplified = item_offset->simplify();
-    if(offset_simplified)
-      item_offset = offset_simplified;
-
-    // We can't optimize symbolic offsets :/
-    if(is_symbol2t(item_offset))
+    if(
+      is_constant_int2t(offs) && to_constant_int2t(offs).value == 0 &&
+      is_constant_int2t(size) && to_constant_int2t(size).value == tmpsize)
+    {
+      continue;
+    }
+    else if(
+      !is_constant_int2t(offs) && is_constant_int2t(size) &&
+      to_constant_int2t(size).value == tmpsize)
     {
-      msg.debug(fmt::format(
-        "[memset] Item offset is symbolic: {}",
-        to_symbol2t(item_offset).get_symbol_name()));
-      bump_call();
-      return;
+      continue;
     }
 
-    // TODO: Why (X*Y)/Y is not X?
-    if(is_div2t(item_offset))
+    // Alternately, we might be memsetting a field within a struct. Don't allow
+    // setting more than one field at a time, unaligned access, or the like.
+    // If you're setting a random run of bytes within a struct, best to use
+    // the C implementation.
+    if(is_struct_type(item.object->type) && is_constant_int2t(size))
     {
-      auto as_div = to_div2t(item_offset);
-      if(is_mul2t(as_div.side_1) && is_constant_int2t(as_div.side_2))
-      {
-        auto as_mul = to_mul2t(as_div.side_1);
-        if(
-          is_constant_int2t(as_mul.side_2) &&
-          (to_constant_int2t(as_mul.side_2).as_ulong() ==
-           to_constant_int2t(as_div.side_2).as_ulong()))
+      unsigned int sz = to_constant_int2t(size).value.to_uint64();
+      ref_types.insert(std::make_pair(
+        item.object->type, std::list<std::pair<type2tc, unsigned int>>()));
+
+      std::function<bool(const type2tc &, unsigned int)> right_sized_field;
+      right_sized_field = [item, sz, &right_sized_field, &ref_types](
+                            const type2tc &strct, unsigned int offs) -> bool {
+        const struct_type2t &sref = to_struct_type(strct);
+        bool retval = false;
+        unsigned int i = 0;
+        for(const auto &elem : sref.members)
         {
-          // if side_1 of mult is a pointer_offset, then it is just zero
-          if(is_pointer_offset2t(as_mul.side_1))
+          // Is this this field?
+          unsigned int fieldsize = type_byte_size(elem).to_uint64();
+          if(fieldsize == sz)
           {
-            msg.debug("[memset] TODO: some simplifications are missing");
-            item_offset = constant_int2tc(get_uint64_type(), BigInt(0));
+            unsigned int new_offs = offs;
+            new_offs += member_offset(strct, sref.member_names[i]).to_uint64();
+            ref_types[item.object->type].push_back(
+              std::make_pair(elem, new_offs));
+            retval = true;
           }
+
+          // Or in a struct in this field?
+          if(is_struct_type(elem))
+          {
+            unsigned int new_offs = offs;
+            new_offs += member_offset(strct, sref.member_names[i]).to_uint64();
+            if(right_sized_field(elem, new_offs))
+              retval = true;
+          }
+
+          i++;
         }
-      }
-    }
 
-    if(!is_constant_int2t(item_offset))
-    {
-      /* If we reached here, item_offset is not symbolic
-       * and we don't know what the actual value of it is...
-       *
-       * For now bum_call later expand our simplifier
-       */
-      msg.debug(
-        "[memset] TODO: some simplifications are missing, bumping call");
-      bump_call();
-      return;
+        return retval;
+      };
+
+      // Is there at least one field the same size
+      if(right_sized_field(item.object->type, 0))
+        continue;
     }
 
-    auto number_of_offset = to_constant_int2t(item_offset).value.to_uint64();
-    auto type_size = type_byte_size(item_object->type).to_uint64();
+    can_construct = false;
+  }
 
-    if(is_code_type(item_object->type))
+  if(can_construct)
+  {
+    for(const auto &item : internal_deref_items)
     {
-      auto error_msg =
-        fmt::format("dereference failure: trying to deref a ptr code");
+      const expr2tc &offs = item.offset;
+      expr2tc val = gen_zero(item.object->type);
+      guardt curguard(cur_state->guard);
+      curguard.add(item.guard);
 
-      auto false_expr = gen_false_expr();
-      guard.guard_expr(false_expr);
-      claim(false_expr, error_msg, goto_assertions::POINTER_SAFETY);
-      continue;
-    }
+      int tmpsize;
+      try
+      {
+        tmpsize = type_byte_size(item.object->type).to_int64();
+      }
+      catch(const array_type2t::dyn_sized_array_excp &e)
+      {
+        tmpsize = -1;
+      }
+      catch(const array_type2t::inf_sized_array_excp &e)
+      {
+        tmpsize = -1;
+      }
 
-    auto is_out_bounds = ((type_size - number_of_offset) < number_of_bytes) ||
-                         (number_of_offset > type_size);
-    if(
-      is_out_bounds && !options.get_bool_option("no-pointer-check") &&
-      !options.get_bool_option("no-bounds-check"))
-    {
-      auto error_msg = fmt::format(
-        "dereference failure: memset of memory segment of size {} with {} "
-        "bytes",
-        type_size - number_of_offset,
-        number_of_bytes);
-
-      guard.add(gen_false_expr());
-      claim(gen_false_expr(), error_msg, goto_assertions::POINTER_SAFETY);
-      continue;
-    }
+      if(is_constant_int2t(offs) && to_constant_int2t(offs).value == 0)
+      {
+        symex_assign(code_assign2tc(item.object, val), false, curguard);
+      }
+      else if(
+        !is_constant_int2t(offs) && is_constant_int2t(size) &&
+        to_constant_int2t(size).value == tmpsize)
+      {
+        // It's a memset where the size is such that the only valid offset is
+        // zero.
+        symex_assign(code_assign2tc(item.object, val), false, curguard);
+        expr2tc eq = equality2tc(offs, gen_zero(offs->type));
+        curguard.guard_expr(eq);
+        if(!options.get_bool_option("no-pointer-check"))
+          claim(eq, "Memset of full-object-size must have zero offset");
+      }
+      else if(is_struct_type(item.object->type) && is_constant_int2t(size))
+      {
+        // Misery time: rather than re-building the build-reference-to logic,
+        // use it here. The memset'd size might correspond to a large number
+        // of incompatible types though: so we might need to _try_ to build
+        // references to a lot of them.
+        std::list<std::tuple<type2tc, expr2tc, expr2tc>> out_list;
+        std::list<std::pair<type2tc, unsigned int>> in_list;
+        auto it = ref_types.find(item.object->type);
+        assert(it != ref_types.end());
+        in_list = it->second;
+
+        // We now have a list of types and offsets we might resolve to.
+        symex_dereference_statet sds(*this, *cur_state);
+        dereferencet dereference(ns, new_context, options, sds);
+        dereference.set_block_assertions();
+        for(const auto &cur_type : in_list)
+        {
+          expr2tc value = item.object;
+          expr2tc this_offs = gen_ulong(cur_type.second);
+
+          if(is_array_type(cur_type.first))
+          {
+            // Build a reference to the first elem.
+            const array_type2t &arrtype = to_array_type(cur_type.first);
+            // Converting offset into bits here
+            expr2tc new_offset =
+              mul2tc(this_offs->type, this_offs, gen_ulong(8));
+            simplify(new_offset);
+
+            dereference.build_reference_rec(
+              value, new_offset, arrtype.subtype, curguard, dereferencet::READ);
+          }
+          else
+          {
+            // Converting offset into bits here
+            expr2tc new_offset =
+              mul2tc(this_offs->type, this_offs, gen_ulong(8));
+            simplify(new_offset);
 
-    auto new_object = gen_value_by_byte(
-      item_object->type, item_object, arg1, number_of_bytes, number_of_offset);
+            dereference.build_reference_rec(
+              value, new_offset, cur_type.first, curguard, dereferencet::READ);
+          }
 
-    // Where we able to optimize it? If not... bump call
-    if(!new_object)
-    {
-      msg.debug("[memset] gen_value_by_byte failed");
-      bump_call();
-      return;
+          out_list.push_back(std::make_tuple(cur_type.first, value, this_offs));
+          // XXX: what if we generate an address of a stitched expr?
+        }
+
+        // OK, we now have a list of references we might point at. Assert that
+        // we actually point at one of them.
+        expr2tc or_accuml = gen_false_expr();
+        for(const auto &ref : out_list)
+        {
+          const expr2tc &this_offs = std::get<2>(ref);
+          pointer_offset2tc ptroffs(this_offs->type, ptr);
+          equality2tc eq(this_offs, ptroffs);
+          or_accuml = or2tc(or_accuml, eq);
+        }
+
+        curguard.guard_expr(or_accuml);
+        if(!options.get_bool_option("no-pointer-check"))
+          claim(
+            or_accuml,
+            "Unaligned, cross-field or other non-field-based memset?");
+        for(const auto &ref : out_list)
+        {
+          guardt newguard(curguard);
+          pointer_offset2tc ptroffs(std::get<2>(ref)->type, ptr);
+          equality2tc eq(std::get<2>(ref), ptroffs);
+          newguard.add(eq);
+
+          expr2tc target = std::get<1>(ref);
+          if(is_array_type(std::get<0>(ref)))
+          {
+            // Actually, the deref'd operand is now an array.
+            assert(is_index2t(target));
+            const index2t &idx = to_index2t(target);
+            target = idx.source_value;
+          }
+
+          expr2tc zero = gen_zero(std::get<0>(ref));
+          symex_assign(code_assign2tc(target, zero), false, newguard);
+        }
+      }
+      else
+      {
+        log_error("Logic mismatch in memset intrinsic");
+        abort();
+      }
     }
-    // 4. Assign the new object
-    symex_assign(code_assign2tc(item.object, new_object), false, guard);
+
+    // Construct assignment to return value
+    expr2tc ret_ref = func_call.ret;
+    dereference(ret_ref, dereferencet::READ);
+    symex_assign(code_assign2tc(ret_ref, ptr), false, cur_state->guard);
   }
-  // Lastly, let's add a NULL ptr check
-  if(!options.get_bool_option("no-pointer-check"))
+  else
   {
-    symbol2tc null_sym(arg0->type, "NULL");
-    same_object2tc obj(arg0, null_sym);
-    not2tc null_check(same_object2tc(arg0, null_sym));
-    ex_state.cur_state->guard.guard_expr(null_check);
-    claim(null_check, " dereference failure: NULL pointer", goto_assertions::POINTER_SAFETY);
+    bump_call();
   }
-
-  expr2tc ret_ref = func_call.ret;
-  dereference(ret_ref, dereferencet::READ);
-  symex_assign(code_assign2tc(ret_ref, arg0), false, cur_state->guard);
 }
 
 void goto_symext::intrinsic_get_object_size(
diff --git a/src/goto-symex/dynamic_allocation.cpp b/src/goto-symex/dynamic_allocation.cpp
index 393fb5963..4b9af68d7 100644
--- a/src/goto-symex/dynamic_allocation.cpp
+++ b/src/goto-symex/dynamic_allocation.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Symbolic Execution
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <goto-symex/dynamic_allocation.h>
 #include <goto-symex/goto_symex.h>
@@ -24,25 +16,27 @@ void goto_symext::default_replace_dynamic_allocation(expr2tc &expr)
 
   if(is_valid_object2t(expr))
   {
+    /* alloc */
     // replace with CPROVER_alloc[POINTER_OBJECT(...)]
     const valid_object2t &obj = to_valid_object2t(expr);
 
     pointer_object2tc obj_expr(pointer_type2(), obj.value);
 
     expr2tc alloc_arr_2;
-    migrate_expr(symbol_expr(ns.lookup(valid_ptr_arr_name)), alloc_arr_2);
+    migrate_expr(symbol_expr(*ns.lookup(valid_ptr_arr_name)), alloc_arr_2);
 
     index2tc index_expr(get_bool_type(), alloc_arr_2, obj_expr);
     expr = index_expr;
   }
   else if(is_invalid_pointer2t(expr))
   {
+    /* (!valid /\ dynamic) \/ invalid */
     const invalid_pointer2t &ptr = to_invalid_pointer2t(expr);
 
     pointer_object2tc obj_expr(pointer_type2(), ptr.ptr_obj);
 
     expr2tc alloc_arr_2;
-    migrate_expr(symbol_expr(ns.lookup(valid_ptr_arr_name)), alloc_arr_2);
+    migrate_expr(symbol_expr(*ns.lookup(valid_ptr_arr_name)), alloc_arr_2);
 
     index2tc index_expr(get_bool_type(), alloc_arr_2, obj_expr);
     not2tc notindex(index_expr);
@@ -55,7 +49,7 @@ void goto_symext::default_replace_dynamic_allocation(expr2tc &expr)
     // objects.
 
     expr2tc sym_2;
-    migrate_expr(symbol_expr(ns.lookup(dyn_info_arr_name)), sym_2);
+    migrate_expr(symbol_expr(*ns.lookup(dyn_info_arr_name)), sym_2);
 
     pointer_object2tc ptr_obj(pointer_type2(), ptr.ptr_obj);
     index2tc is_dyn(get_bool_type(), sym_2, ptr_obj);
@@ -65,7 +59,6 @@ void goto_symext::default_replace_dynamic_allocation(expr2tc &expr)
     type2tc ptr_type = type2tc(new pointer_type2t(get_empty_type()));
     symbol2tc invalid_object(ptr_type, "INVALID");
     equality2tc isinvalid(ptr.ptr_obj, invalid_object);
-    not2tc notinvalid(isinvalid);
 
     and2tc is_not_bad_ptr(notindex, is_dyn);
     or2tc is_valid_ptr(is_not_bad_ptr, isinvalid);
@@ -74,16 +67,22 @@ void goto_symext::default_replace_dynamic_allocation(expr2tc &expr)
   }
   else if(is_deallocated_obj2t(expr))
   {
+    /* !alloc */
     // replace with CPROVER_alloc[POINTER_OBJECT(...)]
     const deallocated_obj2t &obj = to_deallocated_obj2t(expr);
 
     pointer_object2tc obj_expr(pointer_type2(), obj.value);
 
     expr2tc alloc_arr_2;
-    migrate_expr(symbol_expr(ns.lookup(deallocd_arr_name)), alloc_arr_2);
-
-    index2tc index_expr(get_bool_type(), alloc_arr_2, obj_expr);
-    expr = index_expr;
+    migrate_expr(symbol_expr(*ns.lookup(valid_ptr_arr_name)), alloc_arr_2);
+
+    if(is_symbol2t(obj.value))
+      expr = index2tc(get_bool_type(), alloc_arr_2, obj_expr);
+    else
+    {
+      index2tc index_expr(get_bool_type(), alloc_arr_2, obj_expr);
+      expr = not2tc(index_expr);
+    }
   }
   else if(is_dynamic_size2t(expr))
   {
@@ -94,7 +93,7 @@ void goto_symext::default_replace_dynamic_allocation(expr2tc &expr)
     pointer_object2tc obj_expr(pointer_type2(), size.value);
 
     expr2tc alloc_arr_2;
-    migrate_expr(symbol_expr(ns.lookup(alloc_size_arr_name)), alloc_arr_2);
+    migrate_expr(symbol_expr(*ns.lookup(alloc_size_arr_name)), alloc_arr_2);
 
     index2tc index_expr(uint_type2(), alloc_arr_2, obj_expr);
     expr = index_expr;
diff --git a/src/goto-symex/dynamic_allocation.h b/src/goto-symex/dynamic_allocation.h
index f8274c01b..084af9241 100644
--- a/src/goto-symex/dynamic_allocation.h
+++ b/src/goto-symex/dynamic_allocation.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Symbolic Execution
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_DYNAMIC_ALLOCATION_H
 #define CPROVER_DYNAMIC_ALLOCATION_H
 
diff --git a/src/goto-symex/execution_state.cpp b/src/goto-symex/execution_state.cpp
index db8760f99..77c9e4401 100644
--- a/src/goto-symex/execution_state.cpp
+++ b/src/goto-symex/execution_state.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-   Module:
-
-   Author: Lucas Cordeiro, lcc08r@ecs.soton.ac.uk
-
-\*******************************************************************/
-
 #include <goto-symex/execution_state.h>
 #include <goto-symex/reachability_tree.h>
 #include <langapi/language_ui.h>
@@ -34,19 +26,11 @@ execution_statet::execution_statet(
   std::shared_ptr<symex_targett> _target,
   contextt &context,
   std::shared_ptr<ex_state_level2t> l2init,
-  optionst &options,
-  const messaget &message_handler)
-  : goto_symext(
-      ns,
-      context,
-      goto_functions,
-      std::move(_target),
-      options,
-      message_handler),
+  optionst &options)
+  : goto_symext(ns, context, goto_functions, std::move(_target), options),
     owning_rt(art),
     state_level2(std::move(l2init)),
-    global_value_set(ns, message_handler),
-    message_handler(message_handler)
+    global_value_set(ns)
 {
   art1 = owning_rt;
   CS_number = 0;
@@ -65,14 +49,14 @@ execution_statet::execution_statet(
     goto_functions.function_map.find("__ESBMC_main");
   if(it == goto_functions.function_map.end())
   {
-    msg.error("main symbol not found; please set an entry point");
+    log_error("main symbol not found; please set an entry point");
     abort();
   }
 
   const goto_programt *goto_program = &(it->second.body);
 
   // Initialize initial thread state
-  goto_symex_statet state(*state_level2, global_value_set, ns, msg);
+  goto_symex_statet state(*state_level2, global_value_set, ns);
   state.initialize(
     (*goto_program).instructions.begin(),
     (*goto_program).instructions.end(),
@@ -124,8 +108,7 @@ execution_statet::execution_statet(const execution_statet &ex)
     owning_rt(ex.owning_rt),
     state_level2(
       std::dynamic_pointer_cast<ex_state_level2t>(ex.state_level2->clone())),
-    global_value_set(ex.global_value_set),
-    message_handler(ex.message_handler)
+    global_value_set(ex.global_value_set)
 {
   *this = ex;
 
@@ -134,7 +117,7 @@ execution_statet::execution_statet(const execution_statet &ex)
   std::vector<goto_symex_statet>::const_iterator it;
   for(it = ex.threads_state.begin(); it != ex.threads_state.end(); it++)
   {
-    goto_symex_statet state(*it, *state_level2, global_value_set, msg);
+    goto_symex_statet state(*it, *state_level2, global_value_set);
     threads_state.push_back(state);
   }
 
@@ -224,11 +207,11 @@ void execution_statet::symex_step(reachability_treet &art)
 #if !(defined(__arm__) || defined(__aarch64__))
     __asm__("int $3");
 #else
-    msg.error("Can't trap on ARM, sorry");
+    log_error("Can't trap on ARM, sorry");
     abort();
 #endif
 #else
-    msg.error("Can't trap on windows, sorry");
+    log_error("Can't trap on windows, sorry");
     abort();
 #endif
   }
@@ -248,15 +231,15 @@ void execution_statet::symex_step(reachability_treet &art)
 
   if(options.get_bool_option("show-symex-value-sets"))
   {
-    msg.status("");
+    log_status("");
     state.value_set.dump();
   }
 
   if(symex_trace || options.get_bool_option("show-symex-value-sets"))
   {
     std::ostringstream oss;
-    state.source.pc->output_instruction(ns, "", oss, msg, false);
-    msg.result(oss.str());
+    state.source.pc->output_instruction(ns, "", oss, false);
+    log_result("{}", oss.str());
   }
 
   switch(instruction.type)
@@ -324,14 +307,11 @@ void execution_statet::symex_assign(
     analyze_assign(code);
 }
 
-void execution_statet::claim(
-  const expr2tc &expr,
-  const std::string &msg,
-  goto_assertions::goto_assertion_mode mode)
+void execution_statet::claim(const expr2tc &expr, const std::string &msg)
 {
   pre_goto_guard = guardt();
 
-  goto_symext::claim(expr, msg, mode);
+  goto_symext::claim(expr, msg);
 
   if(threads_state.size() >= thread_cswitch_threshold)
     analyze_read(expr);
@@ -506,7 +486,7 @@ void execution_statet::preserve_last_paths()
   // Add the current path to the set of paths to be preserved. Don't do this
   // if the current guard is false, though.
   if(!ls.guard.is_false() || !is_cur_state_guard_false(ls.guard.as_expr()))
-    pp.push_back(std::make_pair(ls.source.pc, goto_statet(ls, msg)));
+    pp.push_back(std::make_pair(ls.source.pc, goto_statet(ls)));
 
   // Now then -- was it a goto? And did we actually branch to it? Detect this
   // by examining how the guard has changed: if there's no change, then the
@@ -633,12 +613,12 @@ void execution_statet::restore_last_paths()
       options.get_bool_option("no-goto-merge") &&
       cur_state->top().goto_state_map[loc].size() != 0)
     {
-      msg.error(
+      log_error(
         "There are goto statements that shouldn't be merged at this point");
       abort();
     }
     // Create a fresh new goto_statet to be merged in at the target insn
-    cur_state->top().goto_state_map[loc].emplace_back(*cur_state, msg);
+    cur_state->top().goto_state_map[loc].emplace_back(*cur_state);
     // Get ref to it
     auto &new_gs = *cur_state->top().goto_state_map[loc].begin();
 
@@ -732,7 +712,7 @@ void execution_statet::execute_guard()
 
 unsigned int execution_statet::add_thread(const goto_programt *prog)
 {
-  goto_symex_statet new_state(*state_level2, global_value_set, ns, msg);
+  goto_symex_statet new_state(*state_level2, global_value_set, ns);
   new_state.initialize(
     prog->instructions.begin(),
     prog->instructions.end(),
@@ -779,7 +759,7 @@ unsigned int execution_statet::add_thread(const goto_programt *prog)
   // While we've recorded the new thread as starting in the designated program,
   // it might not run immediately, thus must have it's path preserved:
   preserved_paths[thread_nr].push_back(std::make_pair(
-    prog->instructions.begin(), goto_statet(threads_state[thread_nr], msg)));
+    prog->instructions.begin(), goto_statet(threads_state[thread_nr])));
 
   return threads_state.size() - 1; // thread ID, zero based
 }
@@ -845,8 +825,8 @@ void execution_statet::get_expr_globals(
                 i2string(get_active_state().top().level1.thread_id))
       return;
 
-    const symbolt *symbol;
-    if(ns.lookup(name, symbol))
+    const symbolt *symbol = ns.lookup(name);
+    if(!symbol)
       return;
 
     if(
@@ -1133,7 +1113,7 @@ void execution_statet::print_stack_traces(unsigned int indent) const
         << "\n";
     it->print_stack_trace(indent + 2, oss);
     oss << "\n";
-    msg.status(oss.str());
+    log_status("{}", oss.str());
   }
 }
 
@@ -1143,7 +1123,7 @@ void execution_statet::switch_to_monitor()
   {
     if(!mon_thread_warning)
     {
-      msg.error(
+      log_error(
         "Switching to ended monitor; you need to increase its "
         "context or prefix bound");
 
@@ -1276,15 +1256,14 @@ std::shared_ptr<execution_statet> schedule_execution_statet::clone() const
 
 void schedule_execution_statet::claim(
   const expr2tc &expr,
-  const std::string &msg,
-  goto_assertions::goto_assertion_mode)
+  const std::string &msg)
 {
   unsigned int tmp_total, tmp_remaining;
 
   tmp_total = total_claims;
   tmp_remaining = remaining_claims;
 
-  execution_statet::claim(expr, msg, goto_assertions::OTHER);
+  execution_statet::claim(expr, msg);
 
   tmp_total = total_claims - tmp_total;
   tmp_remaining = remaining_claims - tmp_remaining;
@@ -1329,22 +1308,20 @@ crypto_hash
 execution_statet::state_hashing_level2t::generate_l2_state_hash() const
 {
   unsigned int total;
+  size_t hash_sz = sizeof(crypto_hash::hash);
 
-  uint8_t *data = (uint8_t *)alloca(
-    current_hashes.size() * CRYPTO_HASH_SIZE * sizeof(uint8_t));
+  uint8_t *data =
+    (uint8_t *)alloca(current_hashes.size() * hash_sz * sizeof(uint8_t));
 
   total = 0;
   for(const auto &current_hashe : current_hashes)
   {
-    memcpy(
-      &data[total * CRYPTO_HASH_SIZE],
-      current_hashe.second.hash,
-      CRYPTO_HASH_SIZE);
+    memcpy(&data[total * hash_sz], current_hashe.second.hash, hash_sz);
     total++;
   }
 
   crypto_hash c;
-  c.ingest(data, total * CRYPTO_HASH_SIZE);
+  c.ingest(data, total * hash_sz);
   c.fin();
   return c;
 }
diff --git a/src/goto-symex/execution_state.h b/src/goto-symex/execution_state.h
index 2cc989a64..190d3a58e 100644
--- a/src/goto-symex/execution_state.h
+++ b/src/goto-symex/execution_state.h
@@ -1,12 +1,3 @@
-/*******************************************************************\
-
-   Module:
-
-   Author: Ben YIU, yspb1g08@ecs.soton.ac.uk Lucas Cordeiro,
-     lcc08r@ecs.soton.ac.uk
-
-\*******************************************************************/
-
 #ifndef EXECUTION_STATE_H_
 #define EXECUTION_STATE_H_
 
@@ -21,7 +12,7 @@
 #include <map>
 #include <set>
 #include <irep2/irep2.h>
-#include <util/message/message.h>
+#include <util/message.h>
 #include <util/std_expr.h>
 
 class reachability_treet;
@@ -70,8 +61,7 @@ public:
    *  @param _target Symex target to receive assigns/asserts/etc in trace.
    *  @param context Context we'll be working in.
    *  @param l2init Initial level2t state (blank).
-   *  @param options Options we're going to operate with.
-   *  @param message_handler Message object to collect errors/warnings
+   *  @param options Options we're going to operate with.s
    */
   execution_statet(
     const goto_functionst &goto_functions,
@@ -80,8 +70,7 @@ public:
     std::shared_ptr<symex_targett> _target,
     contextt &context,
     std::shared_ptr<ex_state_level2t> l2init,
-    optionst &options,
-    const messaget &message_handler);
+    optionst &options);
 
   /**
    *  Default copy constructor.
@@ -169,8 +158,7 @@ public:
   {
     if(tid >= thread_start_data.size())
     {
-      msg.error(
-        fmt::format("Setting thread data for nonexistant thread {}", tid));
+      log_error("Setting thread data for nonexistant thread {}", tid);
       abort();
     }
 
@@ -182,8 +170,7 @@ public:
   {
     if(tid >= thread_start_data.size())
     {
-      msg.error(
-        fmt::format("Setting thread data for nonexistant thread {}", tid));
+      log_error("Setting thread data for nonexistant thread {}", tid);
       abort();
     }
 
@@ -232,10 +219,7 @@ public:
    *  @param expr Expression that we're asserting is true.
    *  @param msg Textual message explaining this assertion.
    */
-  void claim(
-    const expr2tc &expr,
-    const std::string &msg,
-    goto_assertions::goto_assertion_mode) override;
+  void claim(const expr2tc &expr, const std::string &msg) override;
 
   /**
    *  Perform a jump across GOTO code.
@@ -563,8 +547,6 @@ public:
   bool mon_from_tid;
   /** Have we warned of an ended monitor thread already?. */
   bool mon_thread_warning;
-  /** Message handler object */
-  const messaget &message_handler;
   /** Minimum number of threads to exist to consider a context switch.
    *  In certain special cases, such as LTL checking, various pieces of
    *  code and information are bunged into seperate threads which aren't
@@ -632,8 +614,7 @@ public:
     reachability_treet *art,
     std::shared_ptr<symex_targett> _target,
     contextt &context,
-    optionst &options,
-    const messaget &_message_handler)
+    optionst &options)
     : execution_statet(
         goto_functions,
         ns,
@@ -644,8 +625,7 @@ public:
           ? std::shared_ptr<state_hashing_level2t>(
               new state_hashing_level2t(*this))
           : std::shared_ptr<ex_state_level2t>(new ex_state_level2t(*this)),
-        options,
-        _message_handler){};
+        options){};
 
   dfs_execution_statet(const dfs_execution_statet &ref) = default;
   std::shared_ptr<execution_statet> clone() const override;
@@ -669,8 +649,7 @@ public:
     contextt &context,
     optionst &options,
     unsigned int *ptotal_claims,
-    unsigned int *premaining_claims,
-    const messaget &_message_handler)
+    unsigned int *premaining_claims)
     : execution_statet(
         goto_functions,
         ns,
@@ -678,8 +657,7 @@ public:
         std::move(_target),
         context,
         std::shared_ptr<ex_state_level2t>(new ex_state_level2t(*this)),
-        options,
-        _message_handler)
+        options)
   {
     this->ptotal_claims = ptotal_claims;
     this->premaining_claims = premaining_claims;
@@ -690,10 +668,7 @@ public:
   schedule_execution_statet(const schedule_execution_statet &ref) = default;
   std::shared_ptr<execution_statet> clone() const override;
   ~schedule_execution_statet() override;
-  void claim(
-    const expr2tc &expr,
-    const std::string &msg,
-    goto_assertions::goto_assertion_mode) override;
+  void claim(const expr2tc &expr, const std::string &msg) override;
 
   unsigned int *ptotal_claims;
   unsigned int *premaining_claims;
diff --git a/src/goto-symex/goto_symex.h b/src/goto-symex/goto_symex.h
index d1e32e149..2babb8cf9 100644
--- a/src/goto-symex/goto_symex.h
+++ b/src/goto-symex/goto_symex.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Symbolic Execution
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_SYMEX_GOTO_SYMEX_H
 #define CPROVER_GOTO_SYMEX_GOTO_SYMEX_H
 
@@ -49,8 +41,7 @@ public:
     contextt &_new_context,
     const goto_functionst &goto_functions,
     std::shared_ptr<symex_targett> _target,
-    optionst &opts,
-    const messaget &msg);
+    optionst &opts);
   goto_symext(const goto_symext &sym);
   goto_symext &operator=(const goto_symext &sym);
 
@@ -239,10 +230,7 @@ protected:
    *  @param expr Expression that must always be true.
    *  @param msg Textual message explaining assertion.
    */
-  virtual void claim(
-    const expr2tc &expr,
-    const std::string &msg,
-    goto_assertions::goto_assertion_mode mode);
+  virtual void claim(const expr2tc &expr, const std::string &msg);
 
   /**
    *  Perform an assertion.
@@ -816,8 +804,7 @@ protected:
    *  These irep_idts contain the names of the arrays being used to store data
    *  modelling what pointers are active, which are freed, and so forth. They
    *  can change between C and C++, unfortunately. */
-  irep_idt valid_ptr_arr_name, alloc_size_arr_name, deallocd_arr_name,
-    dyn_info_arr_name;
+  irep_idt valid_ptr_arr_name, alloc_size_arr_name, dyn_info_arr_name;
   /** List of all allocated objects.
    *  Used to track what we should level memory-leak-assertions against when the
    *  program execution has finished */
@@ -885,18 +872,6 @@ protected:
    *  the dereference code and the caller, who will inspect the contents after
    *  a call to dereference (in INTERNAL mode) completes. */
   std::list<dereference_callbackt::internal_item> internal_deref_items;
-  /**
-   * Check whether assertions are enabled in the current step
-   */
-  bool assertions_enabled_step = true; 
-
-  /**
-   * Check which assertions are enabled in the current step
-   */
-  goto_assertions::goto_assertion_mode assertion_mode =
-    goto_assertions::ALL_MODES;
-
-  const messaget &msg;
 
   friend void build_goto_symex_classes();
 };
diff --git a/src/goto-symex/goto_symex_state.cpp b/src/goto-symex/goto_symex_state.cpp
index b6b043aa8..d5399da13 100644
--- a/src/goto-symex/goto_symex_state.cpp
+++ b/src/goto-symex/goto_symex_state.cpp
@@ -1,12 +1,3 @@
-/*******************************************************************\
-
-Module: Symbolic Execution
-
-Author: Daniel Kroening, kroening@kroening.com
-		Lucas Cordeiro, lcc08r@ecs.soton.ac.uk
-
-\*******************************************************************/
-
 #include <cassert>
 #include <goto-symex/execution_state.h>
 #include <goto-symex/goto_symex.h>
@@ -22,9 +13,8 @@ Author: Daniel Kroening, kroening@kroening.com
 goto_symex_statet::goto_symex_statet(
   renaming::level2t &l2,
   value_sett &vs,
-  const namespacet &_ns,
-  const messaget &msg)
-  : level2(l2), value_set(vs), ns(_ns), msg(msg)
+  const namespacet &_ns)
+  : level2(l2), value_set(vs), ns(_ns)
 {
   use_value_set = true;
   num_instructions = 0;
@@ -35,9 +25,8 @@ goto_symex_statet::goto_symex_statet(
 goto_symex_statet::goto_symex_statet(
   const goto_symex_statet &state,
   renaming::level2t &l2,
-  value_sett &vs,
-  const messaget &msg)
-  : level2(l2), value_set(vs), ns(state.ns), msg(msg)
+  value_sett &vs)
+  : level2(l2), value_set(vs), ns(state.ns)
 {
   *this = state;
 }
@@ -209,7 +198,7 @@ void goto_symex_statet::assignment(expr2tc &lhs, const expr2tc &rhs)
   {
     // update value sets
     expr2tc l1_rhs = rhs; // rhs is const; Rename into new container.
-    level2.get_original_name(l1_rhs, msg);
+    level2.get_original_name(l1_rhs);
 
     value_set.assign(l1_lhs, l1_rhs);
   }
@@ -389,8 +378,8 @@ void goto_symex_statet::get_original_name(expr2tc &expr) const
 
   if(is_symbol2t(expr))
   {
-    level2.get_original_name(expr, msg);
-    top().level1.get_original_name(expr, msg);
+    level2.get_original_name(expr);
+    top().level1.get_original_name(expr);
   }
 }
 
@@ -429,7 +418,7 @@ void goto_symex_statet::print_stack_trace(unsigned int indent, std::ostream &os)
   {
     os << spaces << "Next instruction to be executed:"
        << "\n";
-    source.pc->output_instruction(ns, "", os, msg);
+    source.pc->output_instruction(ns, "", os);
   }
 }
 
diff --git a/src/goto-symex/goto_symex_state.h b/src/goto-symex/goto_symex_state.h
index 04711c8d6..ac1b3b8cd 100644
--- a/src/goto-symex/goto_symex_state.h
+++ b/src/goto-symex/goto_symex_state.h
@@ -1,12 +1,3 @@
-/*******************************************************************\
-
-   Module: Symbolic Execution
-
-   Author: Daniel Kroening, kroening@kroening.com Lucas Cordeiro,
-     lcc08r@ecs.soton.ac.uk
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_SYMEX_GOTO_SYMEX_STATE_H
 #define CPROVER_GOTO_SYMEX_GOTO_SYMEX_STATE_H
 
@@ -55,8 +46,7 @@ public:
   goto_symex_statet(
     renaming::level2t &l2,
     value_sett &vs,
-    const namespacet &_ns,
-    const messaget &msg);
+    const namespacet &_ns);
 
   /**
    *  Copy constructor.
@@ -71,8 +61,7 @@ public:
   goto_symex_statet(
     const goto_symex_statet &state,
     renaming::level2t &l2,
-    value_sett &vs,
-    const messaget &msg);
+    value_sett &vs);
 
   goto_symex_statet(goto_symex_statet const &) = default;
 
@@ -109,15 +98,14 @@ public:
     unsigned int thread_id;
     variable_name_sett local_variables;
 
-    explicit goto_statet(const goto_symex_statet &s, const messaget &msg)
+    explicit goto_statet(const goto_symex_statet &s)
       : num_instructions(s.num_instructions),
         level2_ptr(s.level2.clone()),
         level2(*level2_ptr),
         value_set(s.value_set),
         guard(s.guard),
         thread_id(s.source.thread_nr),
-        local_variables(s.top().local_variables),
-        msg(msg)
+        local_variables(s.top().local_variables)
     {
     }
 
@@ -128,8 +116,7 @@ public:
         value_set(s.value_set),
         guard(s.guard),
         thread_id(s.thread_id),
-        local_variables(s.local_variables),
-        msg(s.msg)
+        local_variables(s.local_variables)
     {
     }
 
@@ -142,7 +129,6 @@ public:
     ~goto_statet() = default;
 
   protected:
-    const messaget &msg;
   };
 
   /**
@@ -478,7 +464,6 @@ public:
 
   /** Namespace to work with. */
   const namespacet &ns;
-  const messaget &msg;
 
   /** Map of what pointer values have been realloc'd, and what their new
    *  realloc number is. No need for special consideration when merging states
diff --git a/src/goto-symex/goto_trace.cpp b/src/goto-symex/goto_trace.cpp
index 878fdaec1..c2e8f5158 100644
--- a/src/goto-symex/goto_trace.cpp
+++ b/src/goto-symex/goto_trace.cpp
@@ -1,13 +1,3 @@
-/*******************************************************************\
-
-   Module: Traces of GOTO Programs
-
-   Author: Daniel Kroening
-
-   Date: July 2005
-
-\*******************************************************************/
-
 #include <cassert>
 #include <cstring>
 #include <goto-symex/goto_trace.h>
@@ -20,34 +10,22 @@
 #include <util/arith_tools.h>
 #include <util/std_types.h>
 #include <ostream>
-#include <util/message/default_message.h>
-
-extern std::string verification_file;
 
-void goto_tracet::output(
-  const class namespacet &ns,
-  std::ostream &out,
-  const messaget &msg) const
+void goto_tracet::output(const class namespacet &ns, std::ostream &out) const
 {
   for(const auto &step : steps)
-    step.output(ns, out, msg);
+    step.output(ns, out);
 }
 
 void goto_trace_stept::dump() const
 {
-  default_message msg;
   std::ostringstream oss;
-  output(*migrate_namespace_lookup, oss, msg);
-  msg.debug(oss.str());
+  output(*migrate_namespace_lookup, oss);
+  log_debug("{}", oss.str());
 }
 
-void goto_trace_stept::output(
-  const namespacet &ns,
-  std::ostream &out,
-  const messaget &msg) const
+void goto_trace_stept::output(const namespacet &ns, std::ostream &out) const
 {
-  out << "*** ";
-
   switch(type)
   {
   case goto_trace_stept::ASSERT:
@@ -100,7 +78,7 @@ void goto_trace_stept::output(
     else
       identifier = to_symbol2t(lhs).get_symbol_name();
 
-    out << "  " << identifier << " = " << from_expr(ns, identifier, value, msg)
+    out << "  " << identifier << " = " << from_expr(ns, identifier, value)
         << "\n";
   }
   else if(pc->is_assert())
@@ -114,7 +92,7 @@ void goto_trace_stept::output(
 
       if(!comment.empty())
         out << "  " << comment << "\n";
-      out << "  " << from_expr(ns, "", pc->guard, msg) << "\n";
+      out << "  " << from_expr(ns, "", pc->guard) << "\n";
       out << "\n";
     }
   }
@@ -126,15 +104,14 @@ void counterexample_value(
   std::ostream &out,
   const namespacet &ns,
   const expr2tc &lhs,
-  const expr2tc &value,
-  const messaget &msg)
+  const expr2tc &value)
 {
-  out << "  " << from_expr(ns, "", lhs, msg);
+  out << "  " << from_expr(ns, "", lhs);
   if(is_nil_expr(value))
     out << "(assignment removed)";
   else
   {
-    out << " = " << from_expr(ns, "", value, msg);
+    out << " = " << from_expr(ns, "", value);
 
     // Don't print the bit-vector if we're running on integer/real mode
     if(is_constant_expr(value) && !config.options.get_bool_option("ir"))
@@ -179,8 +156,7 @@ void counterexample_value(
 void show_goto_trace_gui(
   std::ostream &out,
   const namespacet &ns,
-  const goto_tracet &goto_trace,
-  const messaget &msg)
+  const goto_tracet &goto_trace)
 {
   locationt previous_location;
 
@@ -207,11 +183,11 @@ void show_goto_trace_gui(
       else
         identifier = to_symbol2t(step.lhs).get_symbol_name();
 
-      std::string value_string = from_expr(ns, identifier, step.value, msg);
+      std::string value_string = from_expr(ns, identifier, step.value);
 
-      const symbolt *symbol;
+      const symbolt *symbol = ns.lookup(identifier);
       irep_idt base_name;
-      if(!ns.lookup(identifier, symbol))
+      if(symbol)
         base_name = symbol->name;
 
       out << "TRACE"
@@ -265,11 +241,12 @@ void show_state_header(
 void violation_graphml_goto_trace(
   optionst &options,
   const namespacet &ns,
-  const goto_tracet &goto_trace,
-  const messaget &msg)
+  const goto_tracet &goto_trace)
 {
   grapht graph(grapht::VIOLATION);
-  graph.verified_file = verification_file;
+  graph.verified_file = options.get_option("input-file");
+
+  log_status("Generating Violation Witness for: {}", graph.verified_file);
 
   edget *first_edge = &graph.edges.at(0);
   nodet *prev_node = first_edge->to_node;
@@ -290,7 +267,7 @@ void violation_graphml_goto_trace(
         edget violation_edge(prev_node, violation_node);
         violation_edge.thread_id = std::to_string(step.thread_nr);
         violation_edge.start_line = get_line_number(
-          verification_file,
+          graph.verified_file,
           std::atoi(step.pc->location.get_line().c_str()),
           options);
 
@@ -308,7 +285,7 @@ void violation_graphml_goto_trace(
         step.pc->is_assign() || step.pc->is_return() ||
         (step.pc->is_other() && is_nil_expr(step.lhs)))
       {
-        std::string assignment = get_formated_assignment(ns, step, msg);
+        std::string assignment = get_formated_assignment(ns, step);
 
         graph.check_create_new_thread(step.thread_nr, prev_node);
         prev_node = graph.edges.back().to_node;
@@ -317,7 +294,7 @@ void violation_graphml_goto_trace(
         new_edge.thread_id = std::to_string(step.thread_nr);
         new_edge.assumption = assignment;
         new_edge.start_line = get_line_number(
-          verification_file,
+          graph.verified_file,
           std::atoi(step.pc->location.get_line().c_str()),
           options);
 
@@ -338,11 +315,11 @@ void violation_graphml_goto_trace(
 void correctness_graphml_goto_trace(
   optionst &options,
   const namespacet &ns,
-  const goto_tracet &goto_trace,
-  const messaget &msg)
+  const goto_tracet &goto_trace)
 {
   grapht graph(grapht::CORRECTNESS);
-  graph.verified_file = verification_file;
+  graph.verified_file = options.get_option("input-file");
+  log_status("Generating Correctness Witness for: {}", graph.verified_file);
 
   edget *first_edge = &graph.edges.at(0);
   nodet *prev_node = first_edge->to_node;
@@ -351,12 +328,12 @@ void correctness_graphml_goto_trace(
   {
     /* checking restrictions for correctness GraphML */
     if(
-      (!(is_valid_witness_step(ns, step, msg))) ||
+      (!(is_valid_witness_step(ns, step))) ||
       (!(step.is_assume() || step.is_assert())))
       continue;
 
     std::string invariant = get_invariant(
-      verification_file,
+      graph.verified_file,
       std::atoi(step.pc->location.get_line().c_str()),
       options);
 
@@ -367,7 +344,7 @@ void correctness_graphml_goto_trace(
     edget *new_edge = new edget();
     std::string function = step.pc->location.get_function().c_str();
     new_edge->start_line = get_line_number(
-      verification_file,
+      graph.verified_file,
       std::atoi(step.pc->location.get_line().c_str()),
       options);
     new_node->invariant = invariant;
@@ -385,8 +362,7 @@ void correctness_graphml_goto_trace(
 void show_goto_trace(
   std::ostream &out,
   const namespacet &ns,
-  const goto_tracet &goto_trace,
-  const messaget &msg)
+  const goto_tracet &goto_trace)
 {
   unsigned prev_step_nr = 0;
   bool first_step = true;
@@ -406,7 +382,7 @@ void show_goto_trace(
         out << "  " << step.comment << "\n";
 
         if(step.pc->is_assert())
-          out << "  " << from_expr(ns, "", step.pc->guard, msg) << "\n";
+          out << "  " << from_expr(ns, "", step.pc->guard) << "\n";
 
         // Having printed a property violation, don't print more steps.
         return;
@@ -424,7 +400,7 @@ void show_goto_trace(
           prev_step_nr = step.step_nr;
           show_state_header(out, step, step.pc->location, step.step_nr);
         }
-        counterexample_value(out, ns, step.lhs, step.value, msg);
+        counterexample_value(out, ns, step.lhs, step.value);
       }
       break;
 
@@ -439,7 +415,7 @@ void show_goto_trace(
 
     case goto_trace_stept::RENUMBER:
       out << "Renumbered pointer to ";
-      counterexample_value(out, ns, step.lhs, step.value, msg);
+      counterexample_value(out, ns, step.lhs, step.value);
       break;
 
     case goto_trace_stept::ASSUME:
diff --git a/src/goto-symex/goto_trace.h b/src/goto-symex/goto_trace.h
index d6f3b3732..780744784 100644
--- a/src/goto-symex/goto_trace.h
+++ b/src/goto-symex/goto_trace.h
@@ -1,13 +1,3 @@
-/*******************************************************************\
-
-Module: Traces of GOTO Programs
-
-Author: Daniel Kroening
-
-Date: July 2005
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_SYMEX_GOTO_TRACE_H
 #define CPROVER_GOTO_SYMEX_GOTO_TRACE_H
 
@@ -88,10 +78,7 @@ public:
   std::string format_string;
   std::list<expr2tc> output_args;
 
-  void output(
-    const class namespacet &ns,
-    std::ostream &out,
-    const messaget &msg) const;
+  void output(const class namespacet &ns, std::ostream &out) const;
   void dump() const;
 
   goto_trace_stept() : step_nr(0), thread_nr(0), guard(false)
@@ -113,35 +100,28 @@ public:
     steps.clear();
   }
 
-  void output(
-    const class namespacet &ns,
-    std::ostream &out,
-    const messaget &msg) const;
+  void output(const class namespacet &ns, std::ostream &out) const;
 };
 
 void show_goto_trace_gui(
   std::ostream &out,
   const namespacet &ns,
-  const goto_tracet &goto_trace,
-  const messaget &msg);
+  const goto_tracet &goto_trace);
 
 void show_goto_trace(
   std::ostream &out,
   const namespacet &ns,
-  const goto_tracet &goto_trace,
-  const messaget &msg);
+  const goto_tracet &goto_trace);
 
 void violation_graphml_goto_trace(
   optionst &options,
   const namespacet &ns,
-  const goto_tracet &goto_trace,
-  const messaget &msg);
+  const goto_tracet &goto_trace);
 
 void correctness_graphml_goto_trace(
   optionst &options,
   const namespacet &ns,
-  const goto_tracet &goto_trace,
-  const messaget &msg);
+  const goto_tracet &goto_trace);
 
 void generate_goto_trace_in_correctness_graphml_format(
   std::string &witness_output,
@@ -154,7 +134,6 @@ void counterexample_value(
   std::ostream &out,
   const namespacet &ns,
   const expr2tc &identifier,
-  const expr2tc &value,
-  const messaget &msg);
+  const expr2tc &value);
 
 #endif
diff --git a/src/goto-symex/printf_formatter.cpp b/src/goto-symex/printf_formatter.cpp
index b1f0c6c21..ae91adb34 100644
--- a/src/goto-symex/printf_formatter.cpp
+++ b/src/goto-symex/printf_formatter.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: printf Formatting
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <goto-symex/printf_formatter.h>
 #include <sstream>
 #include <util/c_types.h>
diff --git a/src/goto-symex/printf_formatter.h b/src/goto-symex/printf_formatter.h
index 90d5c19aa..bc84dcebb 100644
--- a/src/goto-symex/printf_formatter.h
+++ b/src/goto-symex/printf_formatter.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: printf Formatting
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_PRINTF_FORMATTER
 #define CPROVER_PRINTF_FORMATTER
 
diff --git a/src/goto-symex/reachability_tree.cpp b/src/goto-symex/reachability_tree.cpp
index a6999bd3e..a4242831f 100644
--- a/src/goto-symex/reachability_tree.cpp
+++ b/src/goto-symex/reachability_tree.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Lucas Cordeiro, lcc08r@ecs.soton.ac.uk
-
-\*******************************************************************/
-
 /* Byte order includes, for context switch checkpoint files */
 #ifndef _WIN32
 #include <arpa/inet.h>
@@ -21,7 +13,7 @@ Author: Lucas Cordeiro, lcc08r@ecs.soton.ac.uk
 #include <util/crypto_hash.h>
 #include <util/expr_util.h>
 #include <util/i2string.h>
-#include <util/message/message.h>
+#include <util/message.h>
 #include <util/std_expr.h>
 
 reachability_treet::reachability_treet(
@@ -29,13 +21,11 @@ reachability_treet::reachability_treet(
   const namespacet &ns,
   optionst &opts,
   std::shared_ptr<symex_targett> target,
-  contextt &context,
-  const messaget &_message_handler)
+  contextt &context)
   : goto_functions(goto_functions),
     permanent_context(context),
     ns(ns),
-    options(opts),
-    message_handler(_message_handler)
+    options(opts)
 {
   // Put a few useful symbols in the symbol table.
   symbolt sym;
@@ -76,20 +66,13 @@ void reachability_treet::setup_for_new_explore()
       permanent_context,
       options,
       &schedule_total_claims,
-      &schedule_remaining_claims,
-      message_handler));
+      &schedule_remaining_claims));
   }
   else
   {
     targ = target_template->clone();
     s = reinterpret_cast<execution_statet *>(new dfs_execution_statet(
-      goto_functions,
-      ns,
-      this,
-      targ,
-      permanent_context,
-      options,
-      message_handler));
+      goto_functions, ns, this, targ, permanent_context, options));
     schedule_target = nullptr;
   }
 
@@ -206,8 +189,7 @@ reachability_treet::decide_ileave_direction(execution_statet &ex_state)
 
   if(interactive_ileaves && tid != user_tid)
   {
-    message_handler.error(
-      "Ileave code selected different thread from user choice");
+    log_error("Ileave code selected different thread from user choice");
     abort();
   }
 
@@ -341,19 +323,16 @@ reachability_treet::dfs_position::dfs_position(const reachability_treet &rt)
   ileaves = 0;  // Can use this depending on a future refactor.
 }
 
-reachability_treet::dfs_position::dfs_position(
-  const std::string &&filename,
-  const messaget &msg)
+reachability_treet::dfs_position::dfs_position(const std::string &&filename)
 {
-  read_from_file(std::move(filename), msg);
+  read_from_file(std::move(filename));
 }
 
 const uint32_t reachability_treet::dfs_position::file_magic =
   0x4543484B; //'ECHK'
 
 bool reachability_treet::dfs_position::write_to_file(
-  const std::string &&filename,
-  const messaget &msg) const
+  const std::string &&filename) const
 {
   uint8_t buffer[8192];
   reachability_treet::dfs_position::file_hdr hdr;
@@ -366,7 +345,7 @@ bool reachability_treet::dfs_position::write_to_file(
   f = fopen(filename.c_str(), "wb");
   if(f == nullptr)
   {
-    msg.error("Couldn't open checkpoint output file");
+    log_error("Couldn't open checkpoint output file");
     return true;
   }
 
@@ -414,14 +393,13 @@ bool reachability_treet::dfs_position::write_to_file(
   return false;
 
 fail:
-  msg.error("Write error writing checkpoint file");
+  log_error("Write error writing checkpoint file");
   fclose(f);
   return true;
 }
 
 bool reachability_treet::dfs_position::read_from_file(
-  const std::string &&filename,
-  const messaget &msg)
+  const std::string &&filename)
 {
   reachability_treet::dfs_position::file_hdr hdr;
   reachability_treet::dfs_position::file_entry entry;
@@ -432,7 +410,7 @@ bool reachability_treet::dfs_position::read_from_file(
   f = fopen(filename.c_str(), "rb");
   if(f == nullptr)
   {
-    msg.error("Couldn't open checkpoint input file");
+    log_error("Couldn't open checkpoint input file");
     return true;
   }
 
@@ -441,7 +419,7 @@ bool reachability_treet::dfs_position::read_from_file(
 
   if(hdr.magic != htonl(file_magic))
   {
-    msg.error("Magic number indicates that this isn't a checkpoint file");
+    log_error("Magic number indicates that this isn't a checkpoint file");
     fclose(f);
     return true;
   }
@@ -459,7 +437,7 @@ bool reachability_treet::dfs_position::read_from_file(
     assert(state.num_threads < 65536);
     if(state.cur_thread >= state.num_threads)
     {
-      msg.error("Inconsistent checkpoint data");
+      log_error("Inconsistent checkpoint data");
       fclose(f);
       return true;
     }
@@ -482,7 +460,7 @@ bool reachability_treet::dfs_position::read_from_file(
   return false;
 
 fail:
-  msg.error("Read error on checkpoint file");
+  log_error("Read error on checkpoint file");
   fclose(f);
   return true;
 }
@@ -492,10 +470,10 @@ void reachability_treet::print_ileave_trace() const
   std::list<std::shared_ptr<execution_statet>>::const_iterator it;
   int i = 0;
 
-  message_handler.status("Context switch trace for interleaving:");
+  log_status("Context switch trace for interleaving:");
   for(it = execution_states.begin(); it != execution_states.end(); it++, i++)
   {
-    message_handler.status(fmt::format("Context switch point {}", i));
+    log_status("Context switch point {}", i);
     (*it)->print_stack_traces(4);
   }
 }
@@ -507,29 +485,28 @@ bool reachability_treet::check_thread_viable(unsigned int tid, bool quiet) const
   if(ex.DFS_traversed.at(tid) == true)
   {
     if(!quiet)
-      message_handler.status(
-        "Thread unschedulable as it's already been explored");
+      log_status("Thread unschedulable as it's already been explored");
     return false;
   }
 
   if(ex.threads_state.at(tid).call_stack.empty())
   {
     if(!quiet)
-      message_handler.status("Thread unschedulable due to empty call stack");
+      log_status("Thread unschedulable due to empty call stack");
     return false;
   }
 
   if(ex.threads_state.at(tid).thread_ended)
   {
     if(!quiet)
-      message_handler.status("That thread has ended");
+      log_status("That thread has ended");
     return false;
   }
 
 #if 0
   if (por && !ex.is_thread_mpor_schedulable(tid)) {
     if (!quiet)
-      message_handler.status("Thread unschedulable due to POR");
+      log_status("Thread unschedulable due to POR");
     return false;
   }
 #endif
@@ -537,7 +514,7 @@ bool reachability_treet::check_thread_viable(unsigned int tid, bool quiet) const
   if(ex.tid_is_set && ex.monitor_tid == tid)
   {
     if(!quiet)
-      message_handler.status("Can't context switch to a monitor thread");
+      log_status("Can't context switch to a monitor thread");
     return false;
   }
 
@@ -670,7 +647,7 @@ bool reachability_treet::restore_from_dfs_state(void *)
 
     if (get_cur_state().threads_state.size() != it->num_threads)
 {
-msg.error("Unexpected number of threads when reexploring checkpoint");
+log_error("Unexpected number of threads when reexploring checkpoint");
 abort();
 }
 
@@ -684,7 +661,7 @@ abort();
 #if 0
     if (get_cur_state().get_active_state().source.pc->location_number !=
         it->location_number) {
-msg.error("Interleave at unexpected location when restoring checkpoint").
+log_error("Interleave at unexpected location when restoring checkpoint").
 abort();
 }
 #endif
@@ -698,7 +675,7 @@ void reachability_treet::save_checkpoint(const std::string &&) const
 #if 0
   reachability_treet::dfs_position pos(*this);
   if (pos.write_to_file(fname))
-    message_handler.error("Couldn't save checkpoint; continuing" << "\n");
+    log_error("Couldn't save checkpoint; continuing");
 #endif
 
   abort();
diff --git a/src/goto-symex/reachability_tree.h b/src/goto-symex/reachability_tree.h
index adcba47ae..1212fefb4 100644
--- a/src/goto-symex/reachability_tree.h
+++ b/src/goto-symex/reachability_tree.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Lucas Cordeiro, lcc08r@ecs.soton.ac.uk
-
-\*******************************************************************/
-
 #ifndef REACHABILITY_TREE_H_
 #define REACHABILITY_TREE_H_
 
@@ -19,7 +11,7 @@ Author: Lucas Cordeiro, lcc08r@ecs.soton.ac.uk
 #include <unordered_map>
 #include <unordered_set>
 #include <util/crypto_hash.h>
-#include <util/message/message.h>
+#include <util/message.h>
 #include <util/options.h>
 
 /**
@@ -69,15 +61,13 @@ public:
    *  @param ns Namespace to operate in
    *  @param target Target to listen in on assigns/asserts/assumes. Is cloned.
    *  @param context Context to operate in.
-   *  @param message_handler Message object for symex errors/warnings/info
    */
   reachability_treet(
     goto_functionst &goto_functions,
     const namespacet &ns,
     optionst &opts,
     std::shared_ptr<symex_targett> target,
-    contextt &context,
-    const messaget &message_handler);
+    contextt &context);
 
   /**
    *  Default destructor.
@@ -253,11 +243,11 @@ public:
   {
   public:
     dfs_position(const reachability_treet &rt);
-    dfs_position(const std::string &&filename, const messaget &msg);
-    bool write_to_file(const std::string &&filename, const messaget &msg) const;
+    dfs_position(const std::string &&filename);
+    bool write_to_file(const std::string &&filename) const;
 
   protected:
-    bool read_from_file(const std::string &&filename, const messaget &msg);
+    bool read_from_file(const std::string &&filename);
 
   public:
     struct dfs_state
@@ -360,8 +350,6 @@ protected:
   bool por;
   /** Set of state hashes we've discovered */
   std::set<crypto_hash> hit_hashes;
-  /** Message handler reference. */
-  const messaget &message_handler;
   /** Flag as to whether we're picking interleaving directions explicitly.
    *  Corresponds to the --interactive-ileaves option. */
   bool interactive_ileaves;
diff --git a/src/goto-symex/reachability_tree_cin.cpp b/src/goto-symex/reachability_tree_cin.cpp
index 2b6fd2d17..df93f46b3 100644
--- a/src/goto-symex/reachability_tree_cin.cpp
+++ b/src/goto-symex/reachability_tree_cin.cpp
@@ -8,8 +8,7 @@ int reachability_treet::get_ileave_direction_from_user() const
   unsigned int tid;
 
   if(get_cur_state().get_active_state().guard.is_false())
-    message_handler.status(
-      "This trace's guard is false; it will not be evaulated.");
+    log_status("This trace's guard is false; it will not be evaluated.");
 
   // First of all, are there actually any valid context switch targets?
   for(tid = 0; tid < get_cur_state().threads_state.size(); tid++)
@@ -22,16 +21,15 @@ int reachability_treet::get_ileave_direction_from_user() const
   if(tid == get_cur_state().threads_state.size())
     return get_cur_state().threads_state.size();
 
-  message_handler.status(
-    "Context switch point encountered; please select a thread to run");
-  message_handler.status("Current thread states:");
+  log_status("Context switch point encountered; please select a thread to run");
+  log_status("Current thread states:");
   execution_states.back()->print_stack_traces(4);
 
-  while(message_handler.status("Input: "), std::getline(std::cin, input))
+  while(log_status("Input: "), std::getline(std::cin, input))
   {
     if(input == "b")
     {
-      message_handler.status("Back unimplemented");
+      log_status("Back unimplemented");
     }
     else if(input == "q")
     {
@@ -49,11 +47,11 @@ int reachability_treet::get_ileave_direction_from_user() const
       tid = strtol(start, &end, 10);
       if(start == end)
       {
-        message_handler.status("Not a valid input");
+        log_status("Not a valid input");
       }
       else if(tid >= get_cur_state().threads_state.size())
       {
-        message_handler.status("Number out of range");
+        log_status("Number out of range");
       }
       else
       {
@@ -65,7 +63,7 @@ int reachability_treet::get_ileave_direction_from_user() const
 
   if(std::cin.eof())
   {
-    message_handler.status("");
+    log_status("");
     exit(1);
   }
 
diff --git a/src/goto-symex/renaming.cpp b/src/goto-symex/renaming.cpp
index eb5cea3ed..ebc9e99d9 100644
--- a/src/goto-symex/renaming.cpp
+++ b/src/goto-symex/renaming.cpp
@@ -1,10 +1,9 @@
 #include <goto-symex/renaming.h>
 #include <langapi/language_util.h>
 #include <irep2/irep2.h>
+#include <util/message.h>
 #include <util/migrate.h>
 #include <util/prefix.h>
-#include <util/message/format.h>
-#include <util/message/default_message.h>
 
 unsigned renaming::level2t::current_number(const expr2tc &symbol) const
 {
@@ -201,15 +200,13 @@ void renaming::level2t::coveredinbees(
 
 void renaming::renaming_levelt::get_original_name(
   expr2tc &expr,
-  symbol2t::renaming_level lev,
-  const messaget &msg)
+  symbol2t::renaming_level lev)
 {
   if(is_nil_expr(expr))
     return;
 
-  expr->Foreach_operand([&lev, &msg](expr2tc &e) {
-    renaming_levelt::get_original_name(e, lev, msg);
-  });
+  expr->Foreach_operand(
+    [&lev](expr2tc &e) { renaming_levelt::get_original_name(e, lev); });
 
   if(!is_symbol2t(expr))
     return;
@@ -247,19 +244,19 @@ void renaming::renaming_levelt::get_original_name(
     return;
 
   default:
-    msg.error(fmt::format("get_original_nameing to invalid level {}", lev));
+    log_error("get_original_nameing to invalid level {}", lev);
     abort();
   }
 }
 
-void renaming::level1t::print(std::ostream &out, const messaget &) const
+void renaming::level1t::print(std::ostream &out) const
 {
   for(const auto &current_name : current_names)
     out << current_name.first.base_name << " --> "
         << "thread " << thread_id << " count " << current_name.second << "\n";
 }
 
-void renaming::level2t::print(std::ostream &out, const messaget &msg) const
+void renaming::level2t::print(std::ostream &out) const
 {
   for(const auto &current_name : current_names)
   {
@@ -274,7 +271,7 @@ void renaming::level2t::print(std::ostream &out, const messaget &msg) const
     if(!is_nil_expr(current_name.second.constant))
     {
       out << from_expr(
-               *migrate_namespace_lookup, "", current_name.second.constant, msg)
+               *migrate_namespace_lookup, "", current_name.second.constant)
           << "\n";
     }
     else
@@ -288,10 +285,9 @@ void renaming::level2t::print(std::ostream &out, const messaget &msg) const
 
 void renaming::level2t::dump() const
 {
-  default_message msg;
   std::ostringstream oss;
-  print(oss, msg);
-  msg.debug(oss.str());
+  print(oss);
+  log_debug("{}", oss.str());
 }
 
 void renaming::level2t::make_assignment(
diff --git a/src/goto-symex/renaming.h b/src/goto-symex/renaming.h
index 4a014ace3..fdabda06c 100644
--- a/src/goto-symex/renaming.h
+++ b/src/goto-symex/renaming.h
@@ -15,7 +15,7 @@ namespace renaming
 struct renaming_levelt
 {
 public:
-  virtual void get_original_name(expr2tc &expr, const messaget &msg) const = 0;
+  virtual void get_original_name(expr2tc &expr) const = 0;
   virtual void rename(expr2tc &expr) = 0;
   virtual void remove(const expr2tc &symbol) = 0;
 
@@ -25,10 +25,7 @@ public:
   //  protected:
   //  XXX: should leave protected enabled, but g++ 5.4 on ubuntu 16.04 does not
   //  appear to honour the following friend directive?
-  static void get_original_name(
-    expr2tc &expr,
-    symbol2t::renaming_level lev,
-    const messaget &msg);
+  static void get_original_name(expr2tc &expr, symbol2t::renaming_level lev);
   friend void build_goto_symex_classes();
 };
 
@@ -116,9 +113,9 @@ public:
     frameno = frame;
   }
 
-  void get_original_name(expr2tc &expr, const messaget &msg) const override
+  void get_original_name(expr2tc &expr) const override
   {
-    renaming_levelt::get_original_name(expr, symbol2t::level0, msg);
+    renaming_levelt::get_original_name(expr, symbol2t::level0);
   }
 
   unsigned int current_number(const irep_idt &name) const;
@@ -126,7 +123,7 @@ public:
   level1t() = default;
   ~level1t() override = default;
 
-  virtual void print(std::ostream &out, const messaget &msg) const;
+  virtual void print(std::ostream &out) const;
 };
 
 // level 2 -- SSA
@@ -244,9 +241,9 @@ public:
     current_names.erase(rec);
   }
 
-  void get_original_name(expr2tc &expr, const messaget &msg) const override
+  void get_original_name(expr2tc &expr) const override
   {
-    renaming_levelt::get_original_name(expr, symbol2t::level1, msg);
+    renaming_levelt::get_original_name(expr, symbol2t::level1);
   }
 
   struct valuet
@@ -282,7 +279,7 @@ public:
   ~level2t() override = default;
   virtual std::shared_ptr<level2t> clone() const = 0;
 
-  virtual void print(std::ostream &out, const messaget &msg) const;
+  virtual void print(std::ostream &out) const;
   virtual void dump() const;
 
   friend void build_goto_symex_classes();
diff --git a/src/goto-symex/slice.cpp b/src/goto-symex/slice.cpp
index 1ef2a95cc..d6b2ed7a6 100644
--- a/src/goto-symex/slice.cpp
+++ b/src/goto-symex/slice.cpp
@@ -1,44 +1,147 @@
-/*******************************************************************\
-
-Module: Slicer for symex traces
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <goto-symex/slice.h>
 
-symex_slicet::symex_slicet(
-  bool assume,
-  std::unordered_set<std::string> ignored_symbols)
-  : ignored(0),
-    slice_assumes(assume),
-    ignored_symbols(ignored_symbols),
-    add_to_deps([this](const symbol2t &s) -> bool {
-      return depends.insert(s.get_symbol_name()).second;
-    })
+namespace
+{
+/**
+ * @brief Class for the symex-slicer, this slicer is to be executed
+ * on SSA formula in order to remove every symbol that does not depends
+ * on it
+ *
+ * It works by constructing a symbol dependency list by transversing
+ * the SSA formula in reverse order. If any assume, assignment, or renumber
+ * step does not belong into this dependency, then it will be ignored.
+ */
+class symex_slicet
+{
+public:
+  explicit symex_slicet(bool assume);
+
+  /**
+   * Iterate over all steps of the \eq in REVERSE order,
+   * getting symbol dependencies. If an
+   * assignment, renumber or assume does not contain one
+   * of the dependency symbols, then it will be ignored.
+   *
+   * @param eq symex formula to be sliced
+   */
+  void slice(std::shared_ptr<symex_target_equationt> &eq);
+
+  /**
+   * Holds the symbols the current equation depends on.
+   */
+  std::unordered_set<std::string> depends;
+
+  BigInt ignored; /// tracks how many steps were sliced
+
+protected:
+  bool slice_assumes;
+
+  /**
+   * Recursively explores the operands of an expression \expr
+   * If a symbol is found, then it is added into the #depends
+   * member if `Add` is true, otherwise returns true.
+   *
+   * @param expr expression to extract every symbol
+   * @return true if at least one symbol was found
+   */
+  template <bool Add>
+  bool get_symbols(const expr2tc &expr);
+
+  /**
+   * Helper function, it is used to select specialization will
+   * be used, i.e. assume, assignment or renumber
+   *
+   * Note 1: ASSERTS are not sliced, only their symbols are added
+   * into the #depends
+   *
+   * Note 2: Similar to ASSERTS, if 'slice-assumes' option is
+   * is not enabled. Then only its symbols are added into the
+   * #depends
+   *
+   * TODO: All slice specialization can be converted into a lambda
+   *
+   * @param SSA_step any kind of SSA expression
+   */
+  void slice(symex_target_equationt::SSA_stept &SSA_step);
+
+  /**
+   * Remove unneeded assumes from the formula
+   *
+   * Check if the Assume cond symbol is in the #depends, if
+   * it is not then mark the \SSA_Step as ignored.
+   *
+   * If the assume cond is in the #depends, then add its guards
+   * and cond into the #depends
+   *
+   * Note 1: All the conditions operands are going to be added
+   * into the #depends. This makes that the condition itself as
+   * a "reverse taint"
+   *
+   * TODO: What happens if the ASSUME would result in false?
+   *
+   * @param SSA_step an assume step
+   */
+  void slice_assume(symex_target_equationt::SSA_stept &SSA_step);
+
+  /**
+   * Remove unneeded assignments from the formula
+   *
+   * Check if the LHS symbol is in the #depends, if
+   * it is not then mark the \SSA_Step as ignored.
+   *
+   * If the assume cond is in the #depends, then add its guards
+   * and cond into the #depends
+   *
+   * @param SSA_step an assignment step
+   */
+  void slice_assignment(symex_target_equationt::SSA_stept &SSA_step);
+
+  /**
+   * Remove unneeded renumbers from the formula
+   *
+   * Check if the LHS symbol is in the #depends, if
+   * it is not then mark the \SSA_Step as ignored.
+   *
+   * If the assume cond is in the #depends, then add its guards
+   * and cond into the #depends
+   *
+   * @param SSA_step an renumber step
+   */
+  void slice_renumber(symex_target_equationt::SSA_stept &SSA_step);
+};
+
+} /* end anonymous namespace */
+
+symex_slicet::symex_slicet(bool assume) : ignored(0), slice_assumes(assume)
 {
 }
 
-bool symex_slicet::get_symbols(
-  const expr2tc &expr,
-  std::function<bool(const symbol2t &)> fn)
+static bool no_slice(const symbol2t &sym)
 {
-  bool res = false;
+  return config.no_slice_names.count(sym.thename.as_string()) ||
+         config.no_slice_ids.count(sym.get_symbol_name());
+}
 
+template <bool Add>
+bool symex_slicet::get_symbols(const expr2tc &expr)
+{
+  bool res = false;
   // Recursively look if any of the operands has a inner symbol
-  expr->foreach_operand([this, &fn, &res](const expr2tc &e) {
+  expr->foreach_operand([this, &res](const expr2tc &e) {
     if(!is_nil_expr(e))
-      res = get_symbols(e, fn) || res;
+      res |= get_symbols<Add>(e);
     return res;
   });
 
   if(!is_symbol2t(expr))
     return res;
 
-  const symbol2t &tmp = to_symbol2t(expr);
-  // Add the symbol into de dependency list
-  return fn(tmp) || res;
+  const symbol2t &s = to_symbol2t(expr);
+  if constexpr(Add)
+    res |= depends.insert(s.get_symbol_name()).second;
+  else
+    res |= no_slice(s) || depends.find(s.get_symbol_name()) != depends.end();
+  return res;
 }
 
 void symex_slicet::slice(std::shared_ptr<symex_target_equationt> &eq)
@@ -57,8 +160,8 @@ void symex_slicet::slice(symex_target_equationt::SSA_stept &SSA_step)
   switch(SSA_step.type)
   {
   case goto_trace_stept::ASSERT:
-    get_symbols(SSA_step.guard, add_to_deps);
-    get_symbols(SSA_step.cond, add_to_deps);
+    get_symbols<true>(SSA_step.guard);
+    get_symbols<true>(SSA_step.cond);
     break;
 
   case goto_trace_stept::ASSUME:
@@ -66,8 +169,8 @@ void symex_slicet::slice(symex_target_equationt::SSA_stept &SSA_step)
       slice_assume(SSA_step);
     else
     {
-      get_symbols(SSA_step.guard, add_to_deps);
-      get_symbols(SSA_step.cond, add_to_deps);
+      get_symbols<true>(SSA_step.guard);
+      get_symbols<true>(SSA_step.cond);
     }
     break;
 
@@ -89,47 +192,44 @@ void symex_slicet::slice(symex_target_equationt::SSA_stept &SSA_step)
 
 void symex_slicet::slice_assume(symex_target_equationt::SSA_stept &SSA_step)
 {
-  // TODO: add an assert here
-  auto check_in_deps = [this](const symbol2t &s) -> bool {
-    return depends.find(s.get_symbol_name()) != depends.end();
-  };
-
-  if(!get_symbols(SSA_step.cond, check_in_deps))
+  if(!get_symbols<false>(SSA_step.cond))
   {
     // we don't really need it
     SSA_step.ignore = true;
     ++ignored;
+    if(is_symbol2t(SSA_step.cond))
+      log_debug(
+        "slice ignoring assume symbol {}",
+        to_symbol2t(SSA_step.cond).get_symbol_name());
+    else
+      log_debug("slide ignoring assume expression");
   }
   else
   {
     // If we need it, add the symbols to dependency
-    get_symbols(SSA_step.guard, add_to_deps);
-    get_symbols(SSA_step.cond, add_to_deps);
+    get_symbols<true>(SSA_step.guard);
+    get_symbols<true>(SSA_step.cond);
   }
 }
 
 void symex_slicet::slice_assignment(symex_target_equationt::SSA_stept &SSA_step)
 {
   assert(is_symbol2t(SSA_step.lhs));
-
   // TODO: create an option to ignore nondet symbols (test case generation)
 
-  auto check_in_deps = [this](const symbol2t &s) -> bool {
-    return (depends.find(s.get_symbol_name()) != depends.end()) ||
-           (ignored_symbols.find(s.thename.as_string()) !=
-            ignored_symbols.end());
-  };
-
-  if(!get_symbols(SSA_step.lhs, check_in_deps))
+  if(!get_symbols<false>(SSA_step.lhs))
   {
     // we don't really need it
     SSA_step.ignore = true;
     ++ignored;
+    log_debug(
+      "slice ignoring assignment to symbol {}",
+      to_symbol2t(SSA_step.lhs).get_symbol_name());
   }
   else
   {
-    get_symbols(SSA_step.guard, add_to_deps);
-    get_symbols(SSA_step.rhs, add_to_deps);
+    get_symbols<true>(SSA_step.guard);
+    get_symbols<true>(SSA_step.rhs);
 
     // Remove this symbol as we won't be seeing any references to it further
     // into the history.
@@ -141,31 +241,25 @@ void symex_slicet::slice_renumber(symex_target_equationt::SSA_stept &SSA_step)
 {
   assert(is_symbol2t(SSA_step.lhs));
 
-  auto check_in_deps = [this](const symbol2t &s) -> bool {
-    return depends.find(s.get_symbol_name()) != depends.end();
-  };
-
-  if(!get_symbols(SSA_step.lhs, check_in_deps))
+  if(!get_symbols<false>(SSA_step.lhs))
   {
     // we don't really need it
     SSA_step.ignore = true;
     ++ignored;
+    log_debug(
+      "slice ignoring renumbering symbol {}",
+      to_symbol2t(SSA_step.lhs).get_symbol_name());
   }
 
   // Don't collect the symbol; this insn has no effect on dependencies.
 }
 
-BigInt slicer::slice(
-  std::shared_ptr<symex_target_equationt> &eq,
-  bool slice_assumes,
-  std::unordered_set<std::string> ignored_symbols)
-{
-  symex_slicet symex_slice(slice_assumes, ignored_symbols);
-  symex_slice.slice(eq);
-  return symex_slice.ignored;
-}
-
-BigInt slicer::simple_slice(std::shared_ptr<symex_target_equationt> &eq)
+/**
+ * Naive slicer: slice every step after the last assertion
+ * @param eq symex formula to be sliced
+ * @return number of steps that were ignored
+ */
+static BigInt simple_slice(std::shared_ptr<symex_target_equationt> &eq)
 {
   BigInt ignored = 0;
 
@@ -192,3 +286,15 @@ BigInt slicer::simple_slice(std::shared_ptr<symex_target_equationt> &eq)
 
   return ignored;
 }
+
+BigInt slice(std::shared_ptr<symex_target_equationt> &eq)
+{
+  const optionst &opts = config.options;
+
+  if(opts.get_bool_option("no-slice"))
+    return simple_slice(eq);
+
+  symex_slicet symex_slice(opts.get_bool_option("slice-assumes"));
+  symex_slice.slice(eq);
+  return symex_slice.ignored;
+}
diff --git a/src/goto-symex/slice.h b/src/goto-symex/slice.h
index a95db7ad9..35e62672a 100644
--- a/src/goto-symex/slice.h
+++ b/src/goto-symex/slice.h
@@ -1,157 +1,23 @@
-/*******************************************************************\
-
-Module: Slicer for symex traces
-
-Author: Daniel Kroening, kroening@kroening.com
-
-Contributors:
- - Rafael S Menezes, 2022
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_SYMEX_SLICE_H
 #define CPROVER_GOTO_SYMEX_SLICE_H
 
-#include <goto-symex/renaming.h>
 #include <goto-symex/symex_target_equation.h>
-#include <unordered_set>
 
-namespace slicer
-{
 /**
- * Helper function to call the slicer
- * @param eq symex formula to be sliced
- * @param slice_assume whether assumes should be sliced
- * @param ignored_symbols list of symbols that cannot be sliced
- * @return number of steps that were ignored
- */
-BigInt slice(
-  std::shared_ptr<symex_target_equationt> &eq,
-  bool slice_assume,
-  std::unordered_set<std::string> ignored_symbols);
-
-/**
- * Naive slicer: slice every step after the last assertion
- * @param eq symex formula to be sliced
- * @return number of steps that were ignored
- */
-BigInt simple_slice(std::shared_ptr<symex_target_equationt> &eq);
-} // namespace slicer
-/**
- * @brief Class for the symex-slicer, this slicer is to be executed
- * on SSA formula in order to remove every symbol that does not depends
- * on it
+ * Marks SSA_steps to be ignored which have no effects on the target equation,
+ * according to the options set in the `config`.
+ *
+ * Notably, this function depends on the global `config`:
+ *  - "no-slice" in `options` -> perform only simple slicing: ignore everything
+ *    after the final assertion
+ *  - "slice-assumes" in `options` -> also perform slicing of assumption steps
+ *  - `config.no_slice_names` and `config.no_slice_ids` -> suppress slicing of
+ *    particular symbols in non-simple slicing mode.
  *
- * It works by constructing a symbol dependency list by transversing
- * the SSA formula in reverse order. If any assume, assignment, or renumber
- * step does not belong into this dependency, then it will be ignored.
+ * @param eq The target equation containing the SSA steps to perform program
+ *           slicing on.
+ * @return The number of ignored SSA steps due to this slicing.
  */
-class symex_slicet
-{
-public:
-  symex_slicet(bool assume, std::unordered_set<std::string> ignored_symbols);
-  /**
-   * Iterate over all steps of the \eq in REVERSE order,
-   * getting symbol dependencies. If an
-   * assignment, renumber or assume does not contain one
-   * of the dependency symbols, then it will be ignored.
-   *
-   * @param eq symex formula to be sliced
-   */
-  void slice(std::shared_ptr<symex_target_equationt> &eq);
-  // To show how many assignments were sliced
-  BigInt ignored;
-
-protected:
-  // Option to enable slicing of assumes
-  bool slice_assumes;
-  /**
-   * This type will be the one used to hold every symbol
-   * that the current equation depends on.
-   */
-  typedef std::unordered_set<std::string> symbol_sett;
-  symbol_sett depends;
-  const symbol_sett ignored_symbols;
-  // Anonymous function to add elements into #depends
-  std::function<bool(const symbol2t &)> add_to_deps;
-  // TODO: we probably don't need #add_to_deps
-  // TODO: In the implementation, there is also the #check_in_deps which we could remove
-
-  /**
-   * Recursively explores the operands of an expression \expr
-   * If a symbol is found, then it is added into the #depends
-   * member.
-   *
-   * TODO: We probably don't need to pass the \param
-   *
-   * @param expr expression to extract every symbol
-   * @param fn `add_to_depends` kind of function.
-   * @return true if at least one symbol was found
-   */
-  bool
-  get_symbols(const expr2tc &expr, std::function<bool(const symbol2t &)> fn);
-
-  /**
-   * Helper function, it is used to select specialization will
-   * be used, i.e. assume, assignment or renumber
-   *
-   * Note 1: ASSERTS are not sliced, only their symbols are added
-   * into the #depends
-   *
-   * Note 2: Similar to ASSERTS, if 'slice-assumes' option is
-   * is not enabled. Then only its symbols are added into the
-   * #depends
-   *
-   * TODO: All slice specialization can be converted into a lambda
-   *
-   * @param SSA_step any kind of SSA expression
-   */
-  void slice(symex_target_equationt::SSA_stept &SSA_step);
-
-  /**
-   * Remove unneeded assumes from the formula
-   *
-   * Check if the Assume cond symbol is in the #depends, if
-   * it is not then mark the \SSA_Step as ignored.
-   *
-   * If the assume cond is in the #depends, then add its guards
-   * and cond into the #depends
-   *
-   * Note 1: All the conditions operands are going to be added
-   * into the #depends. This makes that the condition itself as
-   * a "reverse taint"
-   *
-   * TODO: What happens if the ASSUME would result in false?
-   *
-   * @param SSA_step an assume step
-   */
-  void slice_assume(symex_target_equationt::SSA_stept &SSA_step);
-
-  /**
-   * Remove unneeded assignments from the formula
-   *
-   * Check if the LHS symbol is in the #depends, if
-   * it is not then mark the \SSA_Step as ignored.
-   *
-   * If the assume cond is in the #depends, then add its guards
-   * and cond into the #depends
-   *
-   * @param SSA_step an assignment step
-   */
-  void slice_assignment(symex_target_equationt::SSA_stept &SSA_step);
-
-  /**
-   * Remove unneeded renumbers from the formula
-   *
-   * Check if the LHS symbol is in the #depends, if
-   * it is not then mark the \SSA_Step as ignored.
-   *
-   * If the assume cond is in the #depends, then add its guards
-   * and cond into the #depends
-   *
-   * @param SSA_step an renumber step
-   */
-  void slice_renumber(symex_target_equationt::SSA_stept &SSA_step);
-};
+BigInt slice(std::shared_ptr<symex_target_equationt> &eq);
 
 #endif
diff --git a/src/goto-symex/symex_assign.cpp b/src/goto-symex/symex_assign.cpp
index 7c9eb374b..0c2ec29d3 100644
--- a/src/goto-symex/symex_assign.cpp
+++ b/src/goto-symex/symex_assign.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Symbolic Execution
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <goto-symex/dynamic_allocation.h>
 #include <goto-symex/execution_state.h>
@@ -24,8 +16,7 @@ goto_symext::goto_symext(
   contextt &_new_context,
   const goto_functionst &_goto_functions,
   std::shared_ptr<symex_targett> _target,
-  optionst &opts,
-  const messaget &msg)
+  optionst &opts)
   : options(opts),
     guard_identifier_s("goto_symex::guard"),
     first_loop(0),
@@ -52,8 +43,7 @@ goto_symext::goto_symext(
     k_induction(options.is_kind()),
     base_case(options.get_bool_option("base-case")),
     forward_condition(options.get_bool_option("forward-condition")),
-    inductive_step(options.get_bool_option("inductive-step")),
-    msg(msg)
+    inductive_step(options.get_bool_option("inductive-step"))
 {
   const std::string &set = options.get_option("unwindset");
   unsigned int length = set.length();
@@ -74,7 +64,6 @@ goto_symext::goto_symext(
 
   valid_ptr_arr_name = "c:@__ESBMC_alloc";
   alloc_size_arr_name = "c:@__ESBMC_alloc_size";
-  deallocd_arr_name = "c:@__ESBMC_deallocated";
   dyn_info_arr_name = "c:@__ESBMC_is_dynamic";
 
   symbolt sym;
@@ -90,8 +79,7 @@ goto_symext::goto_symext(const goto_symext &sym)
     new_context(sym.new_context),
     goto_functions(sym.goto_functions),
     last_throw(nullptr),
-    inside_unexpected(false),
-    msg(sym.msg)
+    inside_unexpected(false)
 {
   *this = sym;
 }
@@ -119,7 +107,6 @@ goto_symext &goto_symext::operator=(const goto_symext &sym)
 
   valid_ptr_arr_name = sym.valid_ptr_arr_name;
   alloc_size_arr_name = sym.alloc_size_arr_name;
-  deallocd_arr_name = sym.deallocd_arr_name;
   dyn_info_arr_name = sym.dyn_info_arr_name;
 
   dynamic_memory = sym.dynamic_memory;
@@ -266,13 +253,13 @@ void goto_symext::symex_assign_rec(
   {
     symex_assign_extract(lhs, full_lhs, rhs, full_rhs, guard, hidden);
   }
-  else if(is_lshr2t(lhs))
+  else if(is_bitand2t(lhs))
   {
     symex_assign_bitfield(lhs, full_lhs, rhs, full_rhs, guard, hidden);
   }
   else
   {
-    msg.error(fmt::format("assignment to {} not handled", get_expr_id(lhs)));
+    log_error("assignment to {} not handled", get_expr_id(lhs));
     abort();
   }
 }
@@ -670,42 +657,49 @@ void goto_symext::symex_assign_bitfield(
   guardt &guard,
   const bool hidden)
 {
-  // Here we expect the LHS to be an expression of the form
-  //   (expr_1 & expr_2) >> expr_3
-  //
-  // Here we basically convert an assignment of the form:
-  //   (val & mask) >> shft := rhs;
-  //
-  // to the form:
-  //   val := new_rhs;
-  //
-  // performing the following 3 steps:
-  //   (1) val := val & not(mask);
-  //   (2) new_val := new_val << shft;
-  //   (3) val := val | new_val;
-  //
-  // where the new LHS is either an index, a byte_extract or
-  // a concat which can be handled recursively
-
-  expr2tc left_side = to_lshr2t(lhs).side_1;
-  expr2tc shft_expr = to_lshr2t(lhs).side_2;
-
-  assert(is_bitand2t(left_side));
-
-  expr2tc value_expr = to_bitand2t(left_side).side_1;
-  expr2tc mask_expr = to_bitand2t(left_side).side_2;
-  expr2tc not_mask_expr = bitnot2tc(mask_expr->type, mask_expr);
-
-  // (1) Resetting the target bits first
-  expr2tc new_value_expr =
-    bitand2tc(value_expr->type, value_expr, not_mask_expr);
-  // (2) Aligning the RHS value with the target bits
-  expr2tc new_rhs = bitcast2tc(shft_expr->type, rhs);
-  new_rhs = shl2tc(new_rhs->type, new_rhs, shft_expr);
-  // (3) Updating the RHS with the remaining bits
-  new_rhs = bitor2tc(new_rhs->type, new_rhs, new_value_expr);
-
-  symex_assign_rec(value_expr, full_lhs, new_rhs, full_rhs, guard, hidden);
+  /* Expect to assign values to bitfields. Bitfield values are constructed
+   * by dereferencet::extract_bits_from_byte_array(), thus we handle this case:
+   *   lhs := rhs
+   * where
+   *   lhs = (rtype)(val >> shft) & mask
+   *   rtype = rhs->type
+   *
+   * Translate to
+   *   val := new_rhs
+   * where
+   *   new_rhs  = (vtype)val & neg_mask | rhs_shft
+   *   neg_mask = ~((vtype)mask << shft)
+   *   rhs_shft = (vtype)rhs << shft
+   *   vtype    = (unsignedbv of width matching val->type)
+   *
+   * The new LHS is either an index, a byte_extract or a concat which can be
+   * handled recursively
+   */
+
+  assert(is_bitand2t(lhs));
+  const expr2tc &cast_expr = to_bitand2t(lhs).side_1;
+  assert(is_typecast2t(cast_expr));
+  const expr2tc &shft_expr = to_typecast2t(cast_expr).from;
+  assert(is_lshr2t(shft_expr));
+  const expr2tc &val = to_lshr2t(shft_expr).side_1;
+  const expr2tc &shft = to_lshr2t(shft_expr).side_2;
+  const expr2tc &mask = to_bitand2t(lhs).side_2;
+
+  expr2tc neg_mask, rhs_shft, new_rhs;
+
+  neg_mask = typecast2tc(get_uint_type(val->type->get_width()), mask);
+  neg_mask = shl2tc(neg_mask->type, neg_mask, shft);
+  neg_mask = bitnot2tc(neg_mask->type, neg_mask);
+
+  rhs_shft = typecast2tc(neg_mask->type, rhs);
+  rhs_shft = shl2tc(rhs_shft->type, rhs_shft, shft);
+
+  new_rhs = typecast2tc(neg_mask->type, val);
+  new_rhs = bitand2tc(new_rhs->type, new_rhs, neg_mask);
+  new_rhs = bitor2tc(new_rhs->type, new_rhs, rhs_shft);
+  new_rhs = typecast2tc(val->type, new_rhs);
+
+  return symex_assign_rec(val, full_lhs, new_rhs, full_rhs, guard, hidden);
 }
 
 void goto_symext::replace_nondet(expr2tc &expr)
diff --git a/src/goto-symex/symex_catch.cpp b/src/goto-symex/symex_catch.cpp
index 0b864feac..c1fa70341 100644
--- a/src/goto-symex/symex_catch.cpp
+++ b/src/goto-symex/symex_catch.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Symbolic Execution
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <goto-symex/goto_symex.h>
 #include <irep2/irep2.h>
 #include <util/migrate.h>
@@ -73,12 +65,12 @@ bool goto_symext::symex_throw()
   last_throw = const_cast<goto_programt::instructiont *>(&instruction);
 
   // Log
-  std::ostringstream oss;
-  oss << "*** Exception thrown of type "
-      << exceptions_thrown.begin()->as_string() << " at file "
-      << instruction.location.file() << " line " << instruction.location.line()
-      << "\n";
-  msg.error(oss.str());
+  log_error(
+    "Exception thrown of type {} at file {} line {}",
+    exceptions_thrown.begin()->as_string(),
+    instruction.location.file(),
+    instruction.location.line());
+
   // We check before iterate over the throw list to save time:
   // If there is no catch, we return an error
   if(!stack_catch.size())
@@ -91,7 +83,7 @@ bool goto_symext::symex_throw()
         const std::string &msg = "Throwing an exception of type " +
                                  exceptions_thrown.begin()->as_string() +
                                  " but there is not catch for it.";
-        claim(gen_false_expr(), msg, goto_assertions::OTHER);
+        claim(gen_false_expr(), msg);
         return true;
       }
     }
@@ -191,7 +183,7 @@ bool goto_symext::symex_throw()
       const std::string &msg = "Throwing an exception of type " +
                                exceptions_thrown.begin()->as_string() +
                                " but there is not catch for it.";
-      claim(gen_false_expr(), msg, goto_assertions::OTHER);
+      claim(gen_false_expr(), msg);
       // Ensure no further execution along this path.
       cur_state->guard.make_false();
     }
@@ -200,13 +192,11 @@ bool goto_symext::symex_throw()
   }
 
   // Log
-  {
-    std::ostringstream oss;
-    oss << "*** Caught by catch(" << catch_name << ") at file "
-        << (*catch_insn)->location.file() << " line "
-        << (*catch_insn)->location.line() << "\n";
-    msg.status(oss.str());
-  }
+  log_status(
+    "Caught by catch({}) at file {} line {}",
+    catch_name,
+    (*catch_insn)->location.file(),
+    (*catch_insn)->location.line());
 
   return true;
 }
@@ -214,8 +204,8 @@ bool goto_symext::symex_throw()
 bool goto_symext::terminate_handler()
 {
   // We must look on the context if the user included exception lib
-  const symbolt *tmp;
-  bool is_included = ns.lookup("std::terminate()", tmp);
+  const symbolt *tmp = ns.lookup("std::terminate()");
+  bool is_included = !tmp;
 
   // If it do, we must call the terminate function:
   // It'll call the current function handler
@@ -247,8 +237,8 @@ bool goto_symext::unexpected_handler()
     return false;
 
   // We must look on the context if the user included exception lib
-  const symbolt *tmp;
-  bool is_included = ns.lookup("std::unexpected()", tmp);
+  const symbolt *tmp = ns.lookup("std::unexpected()");
+  bool is_included = !tmp;
 
   // If it do, we must call the unexpected function:
   // It'll call the current function handler
@@ -279,7 +269,7 @@ bool goto_symext::unexpected_handler()
 }
 
 void goto_symext::update_throw_target(
-  goto_symex_statet::exceptiont *except [[gnu::unused]],
+  goto_symex_statet::exceptiont *except [[maybe_unused]],
   goto_programt::const_targett target,
   const expr2tc &code)
 {
@@ -321,7 +311,7 @@ void goto_symext::update_throw_target(
       {
         statet::goto_state_listt &goto_state_list = i->goto_state_map[target];
 
-        goto_state_list.emplace_back(*cur_state, msg);
+        goto_state_list.emplace_back(*cur_state);
         cur_state->guard.make_false();
         break;
       }
@@ -358,7 +348,7 @@ int goto_symext::handle_throw_decl(
         for(const auto &s_it1 : except->throw_list_set)
           msg += "\n   - " + std::string(s_it1.c_str());
 
-        claim(gen_false_expr(), msg, goto_assertions::OTHER);
+        claim(gen_false_expr(), msg);
         return 0;
       }
 
@@ -392,7 +382,7 @@ bool goto_symext::handle_rethrow(
     }
 
     const std::string &msg = "Trying to re-throw without last exception.";
-    claim(gen_false_expr(), msg, goto_assertions::OTHER);
+    claim(gen_false_expr(), msg);
     return true;
   }
   return false;
diff --git a/src/goto-symex/symex_dereference.cpp b/src/goto-symex/symex_dereference.cpp
index 913188c56..1fc46c2b3 100644
--- a/src/goto-symex/symex_dereference.cpp
+++ b/src/goto-symex/symex_dereference.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Symbolic Execution of ANSI-C
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <goto-symex/goto_symex.h>
 #include <goto-symex/reachability_tree.h>
 #include <langapi/language_util.h>
@@ -14,14 +6,13 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <util/migrate.h>
 
 void symex_dereference_statet::dereference_failure(
-  const std::string &property [[gnu::unused]],
+  const std::string &property [[maybe_unused]],
   const std::string &msg,
   const guardt &guard)
 {
   expr2tc g = guard.as_expr();
   goto_symex.replace_dynamic_allocation(g);
-  goto_symex.claim(
-    not2tc(g), "dereference failure: " + msg, goto_assertions::POINTER_SAFETY);
+  goto_symex.claim(not2tc(g), "dereference failure: " + msg);
 }
 
 bool symex_dereference_statet::has_failed_symbol(
@@ -36,14 +27,19 @@ bool symex_dereference_statet::has_failed_symbol(
       to_symbol2t(expr).thename == "INVALID")
       return false;
 
-    const symbolt &ptr_symbol = goto_symex.ns.lookup(to_symbol2t(expr).thename);
+    const symbolt &ptr_symbol =
+      *goto_symex.ns.lookup(to_symbol2t(expr).thename);
 
     const irep_idt &failed_symbol = ptr_symbol.type.failed_symbol();
 
     if(failed_symbol == "")
       return false;
 
-    return !goto_symex.ns.lookup(failed_symbol, symbol);
+    const symbolt *s = goto_symex.ns.lookup(failed_symbol);
+    if(!s)
+      return false;
+    symbol = s;
+    return true;
   }
 
   return false;
@@ -173,17 +169,14 @@ void goto_symext::dereference(expr2tc &expr, dereferencet::modet mode)
 {
   symex_dereference_statet symex_dereference_state(*this, *cur_state);
 
-  dereferencet dereference(
-    ns, new_context, options, symex_dereference_state, msg);
+  dereferencet dereference(ns, new_context, options, symex_dereference_state);
 
   // needs to be renamed to level 1
   assert(!cur_state->call_stack.empty());
   cur_state->top().level1.rename(expr);
 
   guardt guard;
-  switch(mode)
-  {
-  case dereferencet::FREE:
+  if(is_free(mode))
   {
     expr2tc tmp = expr;
     while(is_typecast2t(tmp))
@@ -196,10 +189,7 @@ void goto_symext::dereference(expr2tc &expr, dereferencet::modet mode)
 
     dereference.dereference_expr(tmp, guard, dereferencet::FREE);
     expr = tmp;
-    break;
   }
-
-  default:
+  else
     dereference.dereference_expr(expr, guard, mode);
-  }
 }
diff --git a/src/goto-symex/symex_function.cpp b/src/goto-symex/symex_function.cpp
index b8f012fff..b4c4f024f 100644
--- a/src/goto-symex/symex_function.cpp
+++ b/src/goto-symex/symex_function.cpp
@@ -1,12 +1,3 @@
-/*******************************************************************\
-
-   Module: Symbolic Execution of ANSI-C
-
-   Author: Daniel Kroening, kroening@kroening.com Lucas Cordeiro,
-     lcc08r@ecs.soton.ac.uk
-
-\*******************************************************************/
-
 #include <algorithm>
 #include <cassert>
 #include <goto-symex/execution_state.h>
@@ -37,15 +28,14 @@ bool goto_symext::get_unwind_recursion(
       (k_induction || inductive_step) &&
       !options.get_bool_option("disable-inductive-step"))
     {
-      msg.warning(
-        "**** WARNING: k-induction does not support recursion yet. "
-        "Disabling inductive step");
+      log_warning(
+        "k-induction does not support recursion yet. Disabling inductive step");
 
       // Disable inductive step on recursion
       options.set_option("disable-inductive-step", true);
     }
 
-    const symbolt &symbol = ns.lookup(identifier);
+    const symbolt &symbol = *ns.lookup(identifier);
 
     std::string msg = "Unwinding recursion " + id2string(symbol.name) +
                       " iteration " + integer2string(unwind);
@@ -53,7 +43,7 @@ bool goto_symext::get_unwind_recursion(
     if(this_loop_max_unwind != 0)
       msg += " (" + integer2string(this_loop_max_unwind) + " max)";
 
-    this->msg.status(msg);
+    log_status("{}", msg);
   }
 
   return this_loop_max_unwind != 0 && unwind >= this_loop_max_unwind;
@@ -74,10 +64,7 @@ unsigned goto_symext::argument_assignments(
     // if you run out of actual arguments there was a mismatch
     if(it1 == arguments.end())
     {
-      claim(
-        gen_false_expr(),
-        "function call: not enough arguments",
-        goto_assertions::OTHER);
+      claim(gen_false_expr(), "function call: not enough arguments");
       return UINT_MAX;
     }
 
@@ -111,11 +98,11 @@ unsigned goto_symext::argument_assignments(
         }
         else
         {
-          std::ostringstream oss;
-          oss << "function call: argument \"" << id2string(identifier)
-              << "\" type mismatch: got " << get_type_id((*it1)->type)
-              << ", expected " << get_type_id(arg_type) << '\n';
-          msg.error(oss.str());
+          log_error(
+            "function call: argument \"{}\" type mismatch: got {}, expected {}",
+            id2string(identifier),
+            get_type_id((*it1)->type),
+            get_type_id(arg_type));
           abort();
         }
       }
@@ -156,7 +143,7 @@ unsigned goto_symext::argument_assignments(
 
       if(new_context.move(symbol))
       {
-        msg.error("Couldn't add new va_arg symbol");
+        log_error("Couldn't add new va_arg symbol");
         abort();
       }
       // 'Declare' the argument before assigning a value to it
@@ -201,14 +188,14 @@ void goto_symext::symex_function_call_code(const expr2tc &expr)
   {
     if(has_prefix(identifier.as_string(), "symex::invalid_object"))
     {
-      msg.warning("WARNING: function ptr call with no target, ");
+      log_warning("WARNING: function ptr call with no target, ");
       cur_state->source.pc++;
       return;
     }
 
-    msg.error(
-      "failed to find `" + get_pretty_name(identifier.as_string()) +
-      "' in function_map");
+    log_error(
+      "failed to find `{}' in function_map",
+      get_pretty_name(identifier.as_string()));
     abort();
   }
 
@@ -221,10 +208,7 @@ void goto_symext::symex_function_call_code(const expr2tc &expr)
   {
     if(!no_unwinding_assertions)
     {
-      claim(
-        gen_false_expr(),
-        "recursion unwinding assertion",
-        goto_assertions::OTHER);
+      claim(gen_false_expr(), "recursion unwinding assertion");
     }
     else
     {
@@ -240,9 +224,8 @@ void goto_symext::symex_function_call_code(const expr2tc &expr)
 
   if(!goto_function.body_available)
   {
-    msg.warning(fmt::format(
-      "**** WARNING: no body for function {}",
-      get_pretty_name(identifier.as_string())));
+    log_warning(
+      "no body for function {}", get_pretty_name(identifier.as_string()));
 
     /* TODO: if it is a C function with no prototype, assert/claim that all
      *       calls to this function have the same number of parameters and that
@@ -306,7 +289,7 @@ void goto_symext::symex_function_call_code(const expr2tc &expr)
 }
 
 static std::list<std::pair<guardt, symbol2tc>>
-get_function_list(const expr2tc &expr, const messaget &msg)
+get_function_list(const expr2tc &expr)
 {
   std::list<std::pair<guardt, symbol2tc>> l;
 
@@ -318,11 +301,11 @@ get_function_list(const expr2tc &expr, const messaget &msg)
     not2tc notguardexpr(guardexpr);
 
     // Get sub items, them iterate over adding the relevant guard
-    l1 = get_function_list(ifexpr.true_value, msg);
+    l1 = get_function_list(ifexpr.true_value);
     for(auto &it : l1)
       it.first.add(guardexpr);
 
-    l2 = get_function_list(ifexpr.false_value, msg);
+    l2 = get_function_list(ifexpr.false_value);
     for(auto &it : l2)
       it.first.add(notguardexpr);
 
@@ -340,12 +323,10 @@ get_function_list(const expr2tc &expr, const messaget &msg)
   }
 
   if(is_typecast2t(expr))
-    return get_function_list(to_typecast2t(expr).from, msg);
+    return get_function_list(to_typecast2t(expr).from);
 
-  msg.error(fmt::format(
-    "Unexpected irep id {} {}",
-    get_expr_id(expr),
-    " in function ptr dereference"));
+  log_error(
+    "Unexpected irep id {} in function ptr dereference", get_expr_id(expr));
   // So, the function may point at something invalid. If that's the case,
   // wait for a solve-time pointer validity assertion to detect that. Return
   // nothing to call right now.
@@ -363,10 +344,8 @@ void goto_symext::symex_function_call_deref(const expr2tc &expr)
   // merge.
   if(is_nil_expr(call.function))
   {
-    std::ostringstream oss;
-    oss << "Function pointer call with no targets; irep: ";
-    oss << call.pretty(0) << "\n";
-    msg.error(oss.str());
+    log_error(
+      "Function pointer call with no targets; irep: {}", call.pretty(0));
     abort();
   }
 
@@ -385,33 +364,36 @@ void goto_symext::symex_function_call_deref(const expr2tc &expr)
   {
     // Emit warning; perform no function call behaviour. Increment PC
     // XXX jmorse - no location information any more.
-    msg.status(fmt::format(
+    log_status(
       "No target candidate for function call {}",
-      from_expr(ns, "", call.function, msg)));
+      from_expr(ns, "", call.function));
     cur_state->source.pc++;
     return;
   }
 
-  std::list<std::pair<guardt, symbol2tc>> l = get_function_list(func_ptr, msg);
+  std::list<std::pair<guardt, symbol2tc>> l = get_function_list(func_ptr);
 
   /* Internal check that all symbols are actually of 'code' type (modulo the
    * guard) */
-  for(const auto &elem : l)
-  {
+  auto maybe_called_symbol_is_code [[maybe_unused]] = [this](const auto &elem) {
     const guardt &guard = elem.first;
     const symbol2tc &sym = elem.second;
     if(!guard.is_false() && !is_code_type(sym))
     {
-      bool known_internal_error = guard.is_true();
-      msg.print(
-        known_internal_error ? VerbosityLevel::Error : VerbosityLevel::Status,
-        fmt::format(
+      if(guard.is_true())
+      {
+        log_error(
           "non-code call target '{}' generated at {}",
-          sym->thename.as_string()));
-      if(known_internal_error)
-        abort();
+          sym->thename.as_string());
+        return false;
+      }
+
+      log_status(
+        "non-code call target '{}' generated at {}", sym->thename.as_string());
     }
-  }
+    return true;
+  };
+  assert(std::all_of(l.begin(), l.end(), maybe_called_symbol_is_code));
 
   // Store.
   for(auto &it : l)
@@ -424,8 +406,7 @@ void goto_symext::symex_function_call_deref(const expr2tc &expr)
 
     if(fit == goto_functions.function_map.end() || !fit->second.body_available)
     {
-      msg.warning(
-        fmt::format("**** WARNING: no body for function {}", pretty_name));
+      log_warning("no body for function {}", pretty_name);
 
       continue; // XXX, find out why this fires on SV-COMP 14 benchmark
       // 32_7a_cilled_true_linux-3.8-rc1-drivers--ata--pata_legacy.ko-main.cil.out.c
@@ -440,7 +421,7 @@ void goto_symext::symex_function_call_deref(const expr2tc &expr)
     cur_state->top().cur_function_ptr_targets.emplace_back(
       fit->second.body.instructions.begin(), it.second);
 
-    goto_state_list.emplace_back(*cur_state, msg);
+    goto_state_list.emplace_back(*cur_state);
     statet::goto_statet &new_state = goto_state_list.back();
     expr2tc guardexpr = it.first.as_expr();
     cur_state->rename(guardexpr);
@@ -473,7 +454,7 @@ bool goto_symext::run_next_function_ptr_target(bool first)
     statet::goto_state_listt &goto_state_list =
       cur_state->top()
         .goto_state_map[cur_state->top().function_ptr_combine_target];
-    goto_state_list.emplace_back(*cur_state, msg);
+    goto_state_list.emplace_back(*cur_state);
   }
 
   // Take one function ptr target out of the list and jump to it. A previously
@@ -584,7 +565,7 @@ bool goto_symext::make_return_assignment(expr2tc &assign, const expr2tc &code)
   }
   else if(!is_nil_expr(frame.return_value))
   {
-    msg.error("return with unexpected value");
+    log_error("return with unexpected value");
     abort();
   }
 
@@ -600,7 +581,7 @@ void goto_symext::symex_return(const expr2tc &code)
   statet::goto_state_listt &goto_state_list =
     cur_state->top().goto_state_map[cur_state->top().end_of_function];
 
-  goto_state_list.emplace_back(*cur_state, msg);
+  goto_state_list.emplace_back(*cur_state);
 
   // check whether the stack limit and return
   // value optimization have been activated.
@@ -610,8 +591,7 @@ void goto_symext::symex_return(const expr2tc &code)
       // check whether the stack size has been reached.
       claim(
         (cur_state->top().process_stack_size(e, stack_limit)),
-        "Stack limit property was violated",
-        goto_assertions::OTHER);
+        "Stack limit property was violated");
     });
   }
 
diff --git a/src/goto-symex/symex_goto.cpp b/src/goto-symex/symex_goto.cpp
index 23a305c79..776f94dcb 100644
--- a/src/goto-symex/symex_goto.cpp
+++ b/src/goto-symex/symex_goto.cpp
@@ -1,12 +1,3 @@
-/*******************************************************************\
-
-   Module: Symbolic Execution
-
-   Author: Daniel Kroening, kroening@kroening.com Lucas Cordeiro,
-     lcc08r@ecs.soton.ac.uk
-
-\*******************************************************************/
-
 #include <cassert>
 #include <fstream>
 #include <goto-symex/goto_symex.h>
@@ -154,7 +145,7 @@ void goto_symext::symex_goto(const expr2tc &old_guard)
   statet::goto_state_listt &goto_state_list =
     cur_state->top().goto_state_map[new_state_pc];
 
-  goto_state_list.emplace_back(*cur_state, msg);
+  goto_state_list.emplace_back(*cur_state);
 
   // adjust guards
   if(new_guard_true)
@@ -359,7 +350,7 @@ void goto_symext::phi_function(const statet::goto_statet &goto_state)
       continue;
 
     // changed!
-    const symbolt &symbol = ns.lookup(variable.base_name);
+    const symbolt &symbol = *ns.lookup(variable.base_name);
 
     type2tc type = migrate_type(symbol.type);
 
@@ -424,10 +415,7 @@ void goto_symext::loop_bound_exceeded(const expr2tc &guard)
   if(!no_unwinding_assertions)
   {
     // generate unwinding assertion
-    claim(
-      negated_cond,
-      "unwinding assertion loop " + id2string(loop_id),
-      goto_assertions::OTHER);
+    claim(negated_cond, "unwinding assertion loop " + id2string(loop_id));
   }
   else
   {
@@ -456,7 +444,7 @@ bool goto_symext::get_unwind(
     this_loop_max_unwind != 0 && unwind >= this_loop_max_unwind;
   if(!options.get_bool_option("quiet"))
   {
-    msg.status(fmt::format(
+    log_status(
       stop_unwind ? "Not unwinding "
                   : "Unwinding "
                     "loop {} {} {} {} {}",
@@ -464,7 +452,7 @@ bool goto_symext::get_unwind(
       " iteration ",
       integer2string(unwind),
       " ",
-      cur_state->source.pc->location.as_string()));
+      cur_state->source.pc->location.as_string());
   }
 
   return stop_unwind;
diff --git a/src/goto-symex/symex_main.cpp b/src/goto-symex/symex_main.cpp
index d449c02b1..9d004b157 100644
--- a/src/goto-symex/symex_main.cpp
+++ b/src/goto-symex/symex_main.cpp
@@ -1,12 +1,3 @@
-/*******************************************************************\
-
-   Module: Symbolic Execution
-
-   Author: Daniel Kroening, kroening@kroening.com Lucas Cordeiro,
-     lcc08r@ecs.soton.ac.uk
-
-\*******************************************************************/
-
 #include <cassert>
 #include <goto-symex/execution_state.h>
 #include <goto-symex/goto_symex.h>
@@ -47,23 +38,20 @@ bool goto_symext::check_incremental(const expr2tc &expr, const std::string &msg)
       // incremental verification succeeded
       return true;
     }
-    this->msg.status("Incremental verification returned unknown");
+    log_status("Incremental verification returned unknown");
     // incremental verification returned unknown
     return false;
   }
   catch(runtime_encoded_equationt::dual_unsat_exception &e)
   {
-    this->msg.error(
+    log_error(
       "This solver was unable to check this expression. Please try it with "
       "another solver");
   }
   return false;
 }
 
-void goto_symext::claim(
-  const expr2tc &claim_expr,
-  const std::string &msg,
-  goto_assertions::goto_assertion_mode mode)
+void goto_symext::claim(const expr2tc &claim_expr, const std::string &msg)
 {
   // Convert asserts in assumes, if it's not the last loop iteration
   // also, don't convert assertions added by the bidirectional search
@@ -77,13 +65,6 @@ void goto_symext::claim(
     }
   }
 
-  this->msg.debug(fmt::format(
-    "Adding Assertion. Intruction type: {}. Current mode: {}",
-    assertion_mode,
-    mode));
-  if(!goto_assertions::is_mode_enabled(assertion_mode, mode))
-    return;
-
   // Can happen when evaluating certain special intrinsics. Gulp.
   if(cur_state->guard.is_false())
     return;
@@ -354,11 +335,9 @@ void goto_symext::symex_step(reachability_treet &art)
     break;
 
   default:
-    std::ostringstream oss;
-    oss << "GOTO instruction type " << instruction.type;
-    oss << " not handled in goto_symext::symex_step"
-        << "\n";
-    msg.error(oss.str());
+    log_error(
+      "GOTO instruction type {} not handled in goto_symext::symex_step",
+      instruction.type);
     abort();
   }
 }
@@ -383,9 +362,8 @@ void goto_symext::symex_assert()
     return;
 
   // Don't convert if it's an user provided assertion and we're running in
-  // no assertion mode, forward condition or user called __ESBMC_disable
-  //const goto_programt::instructiont &instruction = *cur_state->source.pc;
-  if((cur_state->source.pc->location.user_provided() && no_assertions))
+  // no assertion mode or forward condition
+  if(cur_state->source.pc->location.user_provided() && no_assertions)
     return;
 
   std::string msg = cur_state->source.pc->location.comment().as_string();
@@ -400,7 +378,7 @@ void goto_symext::symex_assert()
   dereference(tmp, dereferencet::READ);
   replace_dynamic_allocation(tmp);
 
-  claim(tmp, msg, instruction.assert_mode);
+  claim(tmp, msg);
 }
 
 void goto_symext::run_intrinsic(
@@ -647,10 +625,10 @@ void goto_symext::run_intrinsic(
     // Already modelled in builtin_libs
     return;
   }
-  else if(has_prefix(symname, "c:@F@__ESBMC_init_var"))
+  else if(has_prefix(symname, "c:@F@__ESBMC_init_object"))
   {
     assert(
-      func_call.operands.size() == 1 && "Wrong __ESBMC_init_var signature");
+      func_call.operands.size() == 1 && "Wrong __ESBMC_init_object signature");
     auto &ex_state = art.get_cur_state();
     if(ex_state.cur_state->guard.is_false())
       return;
@@ -664,8 +642,8 @@ void goto_symext::run_intrinsic(
     for(const auto &item : internal_deref_items)
     {
       assert(
-        item.object->expr_id == expr2t::expr_ids::symbol_id &&
-        "__ESBMC_init_var only works for variables");
+        is_symbol2t(item.object) &&
+        "__ESBMC_init_object only works for variables");
 
       // Get the length of the type. This will propagate an exception for dynamic/infinite
       // sized arrays (as expected)
@@ -675,12 +653,13 @@ void goto_symext::run_intrinsic(
       }
       catch(array_type2t::dyn_sized_array_excp *e)
       {
-        msg.error("__ESBMC_init_var does not support VLAs");
+        log_error("__ESBMC_init_object does not support VLAs");
         abort();
       }
       catch(array_type2t::inf_sized_array_excp *e)
       {
-        msg.error("__ESBMC_init_var does not support infinite-length arrays");
+        log_error(
+          "__ESBMC_init_object does not support infinite-length arrays");
         abort();
       }
       expr2tc val = sideeffect2tc(
@@ -693,38 +672,17 @@ void goto_symext::run_intrinsic(
 
       symex_assign(code_assign2tc(item.object, val), false, cur_state->guard);
     }
-  }
-  else if(has_prefix(symname, "c:@F@__ESBMC_enable_assert_mode"))
-  {
-    expr2tc op1 = func_call.operands[0];
-    cur_state->rename(op1);
-    assert(is_constant_int2t(op1));
-    goto_assertions::enable_mode(
-      assertion_mode,
-      (goto_assertions::goto_assertion_mode)to_constant_int2t(op1)
-        .value.to_int64());
-    return;
-  }
-  else if(has_prefix(symname, "c:@F@__ESBMC_disable_assert_mode"))
-  {
-    expr2tc op1 = func_call.operands[0];
-    cur_state->rename(op1);
-    assert(is_constant_int2t(op1));
-    goto_assertions::disable_mode(
-      assertion_mode,
-      (goto_assertions::goto_assertion_mode)to_constant_int2t(op1)
-        .value.to_int64());
+
     return;
   }
   else
   {
-    std::ostringstream oss;
-    oss << "Function call to non-intrinsic prefixed with __ESBMC";
-    oss << " (fatal)\nThe name in question: " << symname;
-    oss << "\n(NB: the C spec reserves the __ prefix for the compiler"
-           " and environment)\n";
-
-    msg.error(oss.str());
+    log_error(
+      "Function call to non-intrinsic prefixed with __ESBMC (fatal)\n"
+      "The name in question: {}\n"
+      "(NB: the C spec reserves the __ prefix for the compiler and "
+      "environment)",
+      symname);
     abort();
   }
 }
diff --git a/src/goto-symex/symex_other.cpp b/src/goto-symex/symex_other.cpp
index f82dbab78..74e7462b7 100644
--- a/src/goto-symex/symex_other.cpp
+++ b/src/goto-symex/symex_other.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Symbolic Execution
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <goto-symex/goto_symex.h>
 #include <util/expr_util.h>
@@ -74,8 +66,7 @@ void goto_symext::symex_decl(const expr2tc code)
     // check whether the stack size has been reached.
     claim(
       (cur_state->top().process_stack_size(code2, stack_limit)),
-      "Stack limit property was violated when declaring " + pretty_name,
-      goto_assertions::OTHER);
+      "Stack limit property was violated when declaring " + pretty_name);
   }
 
   const code_decl2t &decl_code = to_code_decl2t(code2);
diff --git a/src/goto-symex/symex_stack.cpp b/src/goto-symex/symex_stack.cpp
index 811504877..c75b38cee 100644
--- a/src/goto-symex/symex_stack.cpp
+++ b/src/goto-symex/symex_stack.cpp
@@ -1,13 +1,3 @@
-/*******************************************************************\
-
-Module: Symbolic Execution - Stack tracking
-
-Authors: Rafael Menezes and Lucas Cordeiro
-
-Date: April 2020
-
-\*******************************************************************/
-
 #include <cassert>
 #include <goto-symex/goto_symex.h>
 #include <util/expr_util.h>
diff --git a/src/goto-symex/symex_target.cpp b/src/goto-symex/symex_target.cpp
index 7438327ca..f9d03f9ab 100644
--- a/src/goto-symex/symex_target.cpp
+++ b/src/goto-symex/symex_target.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Symbolic Execution
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <goto-symex/symex_target.h>
 
 bool operator<(const symex_targett::sourcet &a, const symex_targett::sourcet &b)
diff --git a/src/goto-symex/symex_target.h b/src/goto-symex/symex_target.h
index efd1bae03..b06059ee8 100644
--- a/src/goto-symex/symex_target.h
+++ b/src/goto-symex/symex_target.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Generate Equation using Symbolic Execution
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_SYMEX_SYMEX_TARGET_H
 #define CPROVER_GOTO_SYMEX_SYMEX_TARGET_H
 
diff --git a/src/goto-symex/symex_target_equation.cpp b/src/goto-symex/symex_target_equation.cpp
index 7f0d63beb..e8604c7f9 100644
--- a/src/goto-symex/symex_target_equation.cpp
+++ b/src/goto-symex/symex_target_equation.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Symbolic Execution
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <goto-symex/goto_symex.h>
 #include <goto-symex/goto_symex_state.h>
@@ -16,14 +8,12 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <irep2/irep2.h>
 #include <util/migrate.h>
 #include <util/std_expr.h>
-#include <util/message/default_message.h>
 
 void symex_target_equationt::debug_print_step(const SSA_stept &step) const
 {
-  default_message msg;
   std::ostringstream oss;
-  step.output(ns, oss, msg);
-  msg.debug(oss.str());
+  step.output(ns, oss);
+  log_debug("{}", oss.str());
 }
 
 void symex_target_equationt::assignment(
@@ -173,8 +163,8 @@ void symex_target_equationt::convert_internal_step(
   if(ssa_trace)
   {
     std::ostringstream oss;
-    step.output(ns, oss, msg);
-    msg.status(oss.str());
+    step.output(ns, oss);
+    log_status("{}", oss.str());
   }
 
   step.guard_ast = smt_conv.convert_ast(step.guard);
@@ -242,7 +232,7 @@ void symex_target_equationt::output(std::ostream &out) const
 {
   for(const auto &SSA_step : SSA_steps)
   {
-    SSA_step.output(ns, out, msg);
+    SSA_step.output(ns, out);
     out << "--------------"
         << "\n";
   }
@@ -253,22 +243,20 @@ void symex_target_equationt::short_output(std::ostream &out, bool show_ignored)
 {
   for(const auto &SSA_step : SSA_steps)
   {
-    SSA_step.short_output(ns, out, msg, show_ignored);
+    SSA_step.short_output(ns, out, show_ignored);
   }
 }
 
 void symex_target_equationt::SSA_stept::dump() const
 {
-  default_message msg;
   std::ostringstream oss;
-  output(*migrate_namespace_lookup, oss, msg);
-  msg.debug(oss.str());
+  output(*migrate_namespace_lookup, oss);
+  log_debug("{}", oss.str());
 }
 
 void symex_target_equationt::SSA_stept::output(
   const namespacet &ns,
-  std::ostream &out,
-  const messaget &msg) const
+  std::ostream &out) const
 {
   if(source.is_set)
   {
@@ -305,29 +293,27 @@ void symex_target_equationt::SSA_stept::output(
   }
 
   if(is_assert() || is_assume() || is_assignment())
-    out << from_expr(ns, "", migrate_expr_back(cond), msg) << "\n";
+    out << from_expr(ns, "", migrate_expr_back(cond)) << "\n";
 
   if(is_assert())
     out << comment << "\n";
 
   if(config.options.get_bool_option("ssa-guards"))
-    out << "Guard: " << from_expr(ns, "", migrate_expr_back(guard), msg)
-        << "\n";
+    out << "Guard: " << from_expr(ns, "", migrate_expr_back(guard)) << "\n";
 }
 
 void symex_target_equationt::SSA_stept::short_output(
   const namespacet &ns,
   std::ostream &out,
-  const messaget &msg,
   bool show_ignored) const
 {
   if((is_assignment() || is_assert() || is_assume()) && show_ignored == ignore)
   {
-    out << from_expr(ns, "", cond, msg) << "\n";
+    out << from_expr(ns, "", cond) << "\n";
   }
   else if(is_renumber())
   {
-    out << "renumber: " << from_expr(ns, "", lhs, msg) << "\n";
+    out << "renumber: " << from_expr(ns, "", lhs) << "\n";
   }
 }
 
@@ -368,12 +354,11 @@ void symex_target_equationt::check_for_duplicate_assigns() const
   {
     if(it->second != 1)
     {
-      msg.status(
-        fmt::format("Symbol \"{}\" appears {} times", it->first, it->second));
+      log_status("Symbol \"{}\" appears {} times", it->first, it->second);
     }
   }
 
-  msg.status(fmt::format("Checked {} insns", i));
+  log_status("Checked {} insns", i);
 }
 
 unsigned int symex_target_equationt::clear_assertions()
@@ -396,9 +381,8 @@ unsigned int symex_target_equationt::clear_assertions()
 
 runtime_encoded_equationt::runtime_encoded_equationt(
   const namespacet &_ns,
-  smt_convt &_conv,
-  const messaget &msg)
-  : symex_target_equationt(_ns, msg), conv(_conv)
+  smt_convt &_conv)
+  : symex_target_equationt(_ns), conv(_conv)
 {
   assert_vec_list.emplace_back();
   assumpt_chain.push_back(conv.convert_ast(gen_true_expr()));
@@ -534,7 +518,7 @@ tvt runtime_encoded_equationt::ask_solver_question(const expr2tc &question)
     res1 == smt_convt::P_ERROR || res1 == smt_convt::P_SMTLIB ||
     res2 == smt_convt::P_ERROR || res2 == smt_convt::P_SMTLIB)
   {
-    msg.error("Solver returned error while asking question");
+    log_error("Solver returned error while asking question");
     abort();
   }
   else if(res1 == smt_convt::P_SATISFIABLE && res2 == smt_convt::P_SATISFIABLE)
diff --git a/src/goto-symex/symex_target_equation.h b/src/goto-symex/symex_target_equation.h
index 771fbd07f..2a4089105 100644
--- a/src/goto-symex/symex_target_equation.h
+++ b/src/goto-symex/symex_target_equation.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Generate Equation using Symbolic Execution
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_BASIC_SYMEX_EQUATION_H
 #define CPROVER_BASIC_SYMEX_EQUATION_H
 
@@ -28,8 +20,7 @@ class symex_target_equationt : public symex_targett
 public:
   class SSA_stept;
 
-  symex_target_equationt(const namespacet &_ns, const messaget &msg)
-    : ns(_ns), msg(msg)
+  symex_target_equationt(const namespacet &_ns) : ns(_ns)
   {
     debug_print = config.options.get_bool_option("symex-ssa-trace");
     ssa_trace = config.options.get_bool_option("ssa-trace");
@@ -154,12 +145,10 @@ public:
     {
     }
 
-    void
-    output(const namespacet &ns, std::ostream &out, const messaget &msg) const;
+    void output(const namespacet &ns, std::ostream &out) const;
     void short_output(
       const namespacet &ns,
       std::ostream &out,
-      const messaget &msg,
       bool show_ignored = false) const;
     void dump() const;
   };
@@ -211,7 +200,7 @@ public:
 
 protected:
   const namespacet &ns;
-  const messaget &msg;
+
   bool debug_print;
   bool ssa_trace;
   bool ssa_smt_trace;
@@ -227,10 +216,7 @@ public:
   {
   };
 
-  runtime_encoded_equationt(
-    const namespacet &_ns,
-    smt_convt &conv,
-    const messaget &msg);
+  runtime_encoded_equationt(const namespacet &_ns, smt_convt &conv);
 
   void push_ctx() override;
   void pop_ctx() override;
diff --git a/src/goto-symex/symex_valid_object.cpp b/src/goto-symex/symex_valid_object.cpp
index 72667fe80..3e149d117 100644
--- a/src/goto-symex/symex_valid_object.cpp
+++ b/src/goto-symex/symex_valid_object.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Symbolic Execution
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <goto-symex/dynamic_allocation.h>
 #include <goto-symex/goto_symex.h>
 #include <util/std_expr.h>
@@ -54,7 +46,7 @@ void goto_symext::replace_dynamic_allocation(expr2tc &expr)
         expr2tc base_ident = *identifier;
         cur_state->get_original_name(base_ident);
 
-        const symbolt &symbol = ns.lookup(to_symbol2t(*identifier).thename);
+        const symbolt &symbol = *ns.lookup(to_symbol2t(*identifier).thename);
 
         // dynamic?
         if(symbol.type.dynamic())
diff --git a/src/goto-symex/witnesses.cpp b/src/goto-symex/witnesses.cpp
index 89e5d6f1b..ff75745d3 100644
--- a/src/goto-symex/witnesses.cpp
+++ b/src/goto-symex/witnesses.cpp
@@ -639,13 +639,12 @@ const std::regex
 void reformat_assignment_array(
   const namespacet &ns,
   const goto_trace_stept &step,
-  std::string &assignment,
-  const messaget &msg)
+  std::string &assignment)
 {
   std::regex re{R"(((-?[0-9]+(.[0-9]+)?)))"};
   using reg_itr = std::regex_token_iterator<std::string::iterator>;
   BigInt pos = 0;
-  std::string lhs = from_expr(ns, "", step.lhs, msg);
+  std::string lhs = from_expr(ns, "", step.lhs);
   std::string assignment_array = "";
   for(reg_itr it{assignment.begin(), assignment.end(), re, 1}, end{};
       it != end;)
@@ -665,12 +664,11 @@ const std::regex regex_structs(
 void reformat_assignment_structs(
   const namespacet &ns,
   const goto_trace_stept &step,
-  std::string &assignment,
-  const messaget &msg)
+  std::string &assignment)
 {
   std::regex re{R"((((.([a-zA-Z0-9_]+)=(-?[0-9]+(.[0-9]+)?))+)))"};
   using reg_itr = std::regex_token_iterator<std::string::iterator>;
-  std::string lhs = from_expr(ns, "", step.lhs, msg);
+  std::string lhs = from_expr(ns, "", step.lhs);
   std::string assignment_struct = "";
   for(reg_itr it{assignment.begin(), assignment.end(), re, 1}, end{};
       it != end;)
@@ -707,38 +705,33 @@ void check_replace_invalid_assignment(std::string &assignment)
 }
 
 /* */
-std::string get_formated_assignment(
-  const namespacet &ns,
-  const goto_trace_stept &step,
-  const messaget &msg)
+std::string
+get_formated_assignment(const namespacet &ns, const goto_trace_stept &step)
 {
   std::string assignment = "";
   if(
     !is_nil_expr(step.value) && is_constant_expr(step.value) &&
-    is_valid_witness_step(ns, step, msg))
+    is_valid_witness_step(ns, step))
   {
-    assignment += from_expr(ns, "", step.lhs, msg);
+    assignment += from_expr(ns, "", step.lhs);
     assignment += " = ";
-    assignment += from_expr(ns, "", step.value, msg);
+    assignment += from_expr(ns, "", step.value);
     assignment += ";";
 
     std::replace(assignment.begin(), assignment.end(), '$', '_');
     if(std::regex_match(assignment, regex_array))
-      reformat_assignment_array(ns, step, assignment, msg);
+      reformat_assignment_array(ns, step, assignment);
     else if(std::regex_match(assignment, regex_structs))
-      reformat_assignment_structs(ns, step, assignment, msg);
+      reformat_assignment_structs(ns, step, assignment);
     check_replace_invalid_assignment(assignment);
   }
   return assignment;
 }
 
 /* */
-bool is_valid_witness_step(
-  const namespacet &ns,
-  const goto_trace_stept &step,
-  const messaget &msg)
+bool is_valid_witness_step(const namespacet &ns, const goto_trace_stept &step)
 {
-  languagest languages(ns, "C", msg);
+  languagest languages(ns, language_idt::C);
   std::string lhsexpr;
   languages.from_expr(migrate_expr_back(step.lhs), lhsexpr);
   std::string location = step.pc->location.to_string();
@@ -751,10 +744,9 @@ bool is_valid_witness_step(
 /* */
 bool is_valid_witness_expr(
   const namespacet &ns,
-  const irep_container<expr2t> &exp,
-  const messaget &msg)
+  const irep_container<expr2t> &exp)
 {
-  languagest languages(ns, "C", msg);
+  languagest languages(ns, language_idt::C);
   std::string value;
   languages.from_expr(migrate_expr_back(exp), value);
   return (value.find("__ESBMC") & value.find("stdin") & value.find("stdout") &
diff --git a/src/goto-symex/witnesses.h b/src/goto-symex/witnesses.h
index 04969414e..6106ddf56 100644
--- a/src/goto-symex/witnesses.h
+++ b/src/goto-symex/witnesses.h
@@ -138,28 +138,22 @@ void create_node_node(nodet &node, xmlnodet &nodenode);
  * from the original program (i.e., internals and built-in
  * are excluded).
  */
-bool is_valid_witness_step(
-  const namespacet &ns,
-  const goto_trace_stept &step,
-  const messaget &msg);
+bool is_valid_witness_step(const namespacet &ns, const goto_trace_stept &step);
 
 /**
  * If the current step is an assignment, this function
  * will return the lhs and rhs formated in a way expected
  * by the assumption field.
  */
-std::string get_formated_assignment(
-  const namespacet &ns,
-  const goto_trace_stept &step,
-  const messaget &msg);
+std::string
+get_formated_assignment(const namespacet &ns, const goto_trace_stept &step);
 
 /**
  *
  */
 bool is_valid_witness_expr(
   const namespacet &ns,
-  const irep_container<expr2t> &exp,
-  const messaget &msg);
+  const irep_container<expr2t> &exp);
 
 /**
  *
diff --git a/src/goto-symex/xml_goto_trace.cpp b/src/goto-symex/xml_goto_trace.cpp
index 0798ea982..32d582e9a 100644
--- a/src/goto-symex/xml_goto_trace.cpp
+++ b/src/goto-symex/xml_goto_trace.cpp
@@ -1,13 +1,3 @@
-/*******************************************************************\
-
-Module: Traces of GOTO Programs
-
-Author: Daniel Kroening
-
-  Date: November 2005
-
-\*******************************************************************/
-
 #include <cassert>
 #include <goto-symex/printf_formatter.h>
 #include <goto-symex/xml_goto_trace.h>
@@ -15,11 +5,7 @@ Author: Daniel Kroening
 #include <util/i2string.h>
 #include <util/xml_irep.h>
 
-void convert(
-  const namespacet &ns,
-  const goto_tracet &goto_trace,
-  xmlt &xml,
-  const messaget &msg)
+void convert(const namespacet &ns, const goto_tracet &goto_trace, xmlt &xml)
 {
   xml = xmlt("goto_trace");
 
@@ -72,21 +58,20 @@ void convert(
 
       if(!is_nil_expr(step.value))
       {
-        value_string =
-          from_expr(ns, identifier, migrate_expr_back(step.value), msg);
+        value_string = from_expr(ns, identifier, migrate_expr_back(step.value));
         type_string =
-          from_type(ns, identifier, migrate_type_back(step.value->type), msg);
+          from_type(ns, identifier, migrate_type_back(step.value->type));
       }
 
-      const symbolt *symbol;
+      const symbolt *symbol = ns.lookup(identifier);
       irep_idt base_name, display_name;
 
-      if(!ns.lookup(identifier, symbol))
+      if(symbol)
       {
         base_name = symbol->name;
         display_name = symbol->name;
         if(type_string == "")
-          type_string = from_type(ns, identifier, symbol->type, msg);
+          type_string = from_type(ns, identifier, symbol->type);
 
         xml_assignment.new_element("mode").data =
           xmlt::escape(id2string(symbol->mode));
diff --git a/src/goto-symex/xml_goto_trace.h b/src/goto-symex/xml_goto_trace.h
index 2a434bef3..1fecd0d06 100644
--- a/src/goto-symex/xml_goto_trace.h
+++ b/src/goto-symex/xml_goto_trace.h
@@ -1,13 +1,3 @@
-/*******************************************************************\
-
-Module: Traces of GOTO Programs
-
-Author: Daniel Kroening
-
-Date: November 2005
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_SYMEX_XML_GOTO_TRACE_H
 #define CPROVER_GOTO_SYMEX_XML_GOTO_TRACE_H
 
diff --git a/src/irep2/irep2_expr.cpp b/src/irep2/irep2_expr.cpp
index 91de85944..77202c708 100644
--- a/src/irep2/irep2_expr.cpp
+++ b/src/irep2/irep2_expr.cpp
@@ -8,8 +8,6 @@
 #include <irep2/irep2_utils.h>
 #include <util/migrate.h>
 #include <util/std_types.h>
-#include <util/message/format.h>
-#include <util/message/default_message.h>
 
 static const char *expr_names[] = {
   "constant_int",
@@ -259,8 +257,7 @@ std::string expr2t::pretty(unsigned int indent) const
 
 void expr2t::dump() const
 {
-  default_message msg;
-  msg.debug(pretty(0));
+  log_debug("{}", pretty(0));
 }
 
 template <>
@@ -367,8 +364,8 @@ static void assert_type_compat_for_with(const type2tc &a, const type2tc &b)
   else if(is_code_type(a))
   {
     assert(is_code_type(b));
-    const code_type2t &at [[gnu::unused]] = to_code_type(a);
-    const code_type2t &bt [[gnu::unused]] = to_code_type(b);
+    const code_type2t &at [[maybe_unused]] = to_code_type(a);
+    const code_type2t &bt [[maybe_unused]] = to_code_type(b);
     assert(at.arguments == bt.arguments);
     assert(at.ret_type == bt.ret_type);
     /* don't compare argument names, they could be empty on one side */
diff --git a/src/irep2/irep2_expr.h b/src/irep2/irep2_expr.h
index b885f2e49..6492fa075 100644
--- a/src/irep2/irep2_expr.h
+++ b/src/irep2/irep2_expr.h
@@ -114,6 +114,31 @@ public:
   typedef esbmct::expr2t_traits<datatype_members_field> traits;
 };
 
+class constant_union_data : public constant_datatype_data
+{
+public:
+  constant_union_data(
+    const type2tc &t,
+    expr2t::expr_ids id,
+    irep_idt init_field,
+    std::vector<expr2tc> m)
+    : constant_datatype_data(t, id, std::move(m)), init_field(init_field)
+  {
+  }
+  constant_union_data(const constant_union_data &) = default;
+
+  irep_idt init_field;
+
+  // Type mangling:
+  typedef esbmct::field_traits<
+    irep_idt,
+    constant_union_data,
+    &constant_union_data::init_field>
+    init_field_field;
+  typedef esbmct::expr2t_traits<datatype_members_field, init_field_field>
+    traits;
+};
+
 class constant_bool_data : public constant2t
 {
 public:
@@ -496,6 +521,7 @@ public:
         p1 || (is_bv_type(t) == is_bv_type(v2->type) &&
                t->get_width() == v2->type->get_width()));
     }
+    // TODO: Add consistency checks for vectors
 #endif
   }
   arith_2ops(const arith_2ops &ref) = default;
@@ -1353,24 +1379,6 @@ public:
   typedef esbmct::expr2t_traits_notype<exception_list_field> traits;
 };
 
-class concat_data : public expr2t
-{
-public:
-  concat_data(const type2tc &t, expr2t::expr_ids id, std::vector<expr2tc> d)
-    : expr2t(t, id), data_items(std::move(d))
-  {
-  }
-  concat_data(const concat_data &ref) = default;
-
-  std::vector<expr2tc> data_items;
-
-  // Type mangling:
-  typedef esbmct::
-    field_traits<std::vector<expr2tc>, concat_data, &concat_data::data_items>
-      data_items_field;
-  typedef esbmct::expr2t_traits<data_items_field> traits;
-};
-
 class extract_data : public expr2t
 {
 public:
@@ -1463,7 +1471,7 @@ irep_typedefs(constant_int, constant_int_data);
 irep_typedefs(constant_fixedbv, constant_fixedbv_data);
 irep_typedefs(constant_floatbv, constant_floatbv_data);
 irep_typedefs(constant_struct, constant_datatype_data);
-irep_typedefs(constant_union, constant_datatype_data);
+irep_typedefs(constant_union, constant_union_data);
 irep_typedefs(constant_array, constant_datatype_data);
 irep_typedefs(constant_vector, constant_datatype_data);
 irep_typedefs(constant_bool, constant_bool_data);
@@ -1718,10 +1726,13 @@ public:
    *  @param type Type of this structure, presumably a union_type2t
    *  @param members Vector of member values that make up this union.
    */
-  constant_union2t(const type2tc &type, const std::vector<expr2tc> &members)
-    : constant_union_expr_methods(type, constant_union_id, members)
+  constant_union2t(
+    const type2tc &type,
+    irep_idt init_field,
+    const std::vector<expr2tc> &members)
+    : constant_union_expr_methods(type, constant_union_id, init_field, members)
   {
-
+    assert(is_union_type(type));
   }
   constant_union2t(const constant_union2t &ref) = default;
 
@@ -1817,6 +1828,11 @@ public:
     unsigned int node = 0)
     : symbol_expr_methods(type, symbol_id, init, lev, l1, l2, trd, node)
   {
+    /* At some point in the past, symbols named "NULL" and "0" were equivalent.
+     * The symbol called "0" should no longer be created for uniformity reasons.
+     * Confirm that here, since support for it has been removed from smt_convt.
+     * No other reason to disallow "0" as a symbol. */
+    assert(init != "0");
   }
 
   symbol2t(const symbol2t &ref) = default;
@@ -1930,7 +1946,7 @@ public:
   bitcast2t(const type2tc &type, const expr2tc &from)
     : bitcast_expr_methods(type, bitcast_id, from)
   {
-    //assert(type->get_width() == from->type->get_width());
+    assert(type->get_width() == from->type->get_width());
   }
 
   bitcast2t(const bitcast2t &ref) = default;
@@ -2767,7 +2783,7 @@ public:
   }
   byte_extract2t(const byte_extract2t &ref) = default;
 
-  //expr2tc do_simplify() const override;
+  expr2tc do_simplify() const override;
 
   static std::string field_names[esbmct::num_type_fields];
 };
@@ -2879,6 +2895,9 @@ public:
   index2t(const type2tc &type, const expr2tc &source, const expr2tc &index)
     : index_expr_methods(type, index_id, source, index)
   {
+    assert(
+      is_array_type(source) || is_string_type(source) ||
+      is_vector_type(source));
   }
   index2t(const index2t &ref) = default;
 
@@ -3510,6 +3529,7 @@ public:
   static std::string field_names[esbmct::num_type_fields];
 };
 
+/** @extends bit_2ops */
 class concat2t : public concat_expr_methods
 {
 public:
diff --git a/src/irep2/irep2_meta_templates.h b/src/irep2/irep2_meta_templates.h
index 269cf59a0..64a661d5c 100644
--- a/src/irep2/irep2_meta_templates.h
+++ b/src/irep2/irep2_meta_templates.h
@@ -12,8 +12,6 @@
 #include <irep2/irep2_templates.h>
 #include <util/migrate.h>
 #include <util/std_types.h>
-#include <util/message/format.h>
-#include <util/message/default_message.h>
 
 namespace esbmct
 {
diff --git a/src/irep2/irep2_template_utils.h b/src/irep2/irep2_template_utils.h
index 65eb46496..bd354d18a 100644
--- a/src/irep2/irep2_template_utils.h
+++ b/src/irep2/irep2_template_utils.h
@@ -9,8 +9,6 @@
 #include <irep2/irep2_utils.h>
 #include <util/migrate.h>
 #include <util/std_types.h>
-#include <util/message/format.h>
-#include <util/message/default_message.h>
 
 std::string type_to_string(const bool &thebool, int);
 
diff --git a/src/irep2/irep2_templates.h b/src/irep2/irep2_templates.h
index 3217bd653..2b868bdd6 100644
--- a/src/irep2/irep2_templates.h
+++ b/src/irep2/irep2_templates.h
@@ -10,8 +10,6 @@
 #include <irep2/irep2_template_utils.h>
 #include <util/migrate.h>
 #include <util/std_types.h>
-#include <util/message/format.h>
-#include <util/message/default_message.h>
 
 template <typename T>
 class register_irep_methods;
diff --git a/src/irep2/irep2_type.cpp b/src/irep2/irep2_type.cpp
index 046c10912..77a751021 100644
--- a/src/irep2/irep2_type.cpp
+++ b/src/irep2/irep2_type.cpp
@@ -6,10 +6,10 @@
 #include <irep2/irep2_type.h>
 #include <irep2/irep2_expr.h>
 #include <irep2/irep2_utils.h>
+#include <util/message.h>
+#include <util/message/format.h>
 #include <util/migrate.h>
 #include <util/std_types.h>
-#include <util/message/format.h>
-#include <util/message/default_message.h>
 
 /*************************** Base type2t definitions **************************/
 
@@ -106,8 +106,7 @@ std::string type2t::pretty(unsigned int indent) const
 
 void type2t::dump() const
 {
-  default_message msg;
-  msg.debug(pretty(0));
+  log_debug("{}", pretty(0));
 }
 
 size_t type2t::crc() const
@@ -174,209 +173,6 @@ unsigned int vector_type2t::get_width() const
   return num_elems * sub_width;
 }
 
-expr2tc vector_type2t::distribute_operation(
-  std::function<expr2tc(type2tc, expr2tc, expr2tc)> func,
-  expr2tc op1,
-  expr2tc op2)
-{
-  /*
-   * If both op1 and op2 are vectors the resulting value
-   * would be the operation over each member
-   *
-   * Example:
-   *
-   * op1 = {1,2,3,4}
-   * op2 = {1,1,1,1}
-   * func = add
-   *
-   * This would result in:
-   *
-   * { add(op1[0], op2[0]), add(op1[1], op2[1]), ...}
-   * {2,3,4,5}
-   */
-  if(is_constant_vector2t(op1) && is_constant_vector2t(op2))
-  {
-    constant_vector2tc vec1(op1);
-    constant_vector2tc vec2(op2);
-    for(size_t i = 0; i < vec1->datatype_members.size(); i++)
-    {
-      auto &A = vec1->datatype_members[i];
-      auto &B = vec2->datatype_members[i];
-      auto new_op = func(A->type, A, B);
-      vec1->datatype_members[i] = new_op;
-    }
-    return vec1;
-  }
-  /*
-   * If only one of the operator is a vector, then the result
-   * would extract each value of the vector and apply the value to
-   * the other operator
-   *
-   * Example:
-   *
-   * op1 = {1,2,3,4}
-   * op2 = 1
-   * func = add
-   *
-   * This would result in:
-   *
-   * { add(op1[0], 1), add(op1[1], 1), ...}
-   * {2,3,4,5}
-   */
-  else
-  {
-    bool is_op1_vec = is_constant_vector2t(op1);
-    expr2tc c = !is_op1_vec ? op1 : op2;
-    constant_vector2tc vector(is_op1_vec ? op1 : op2);
-    for(auto &datatype_member : vector->datatype_members)
-    {
-      auto &op = datatype_member;
-      auto e1 = is_op1_vec ? op : c;
-      auto e2 = is_op1_vec ? c : op;
-      auto new_op = func(op->type, e1, e2);
-      datatype_member = new_op->do_simplify();
-    }
-    return vector;
-  }
-}
-
-expr2tc vector_type2t::distribute_operation(
-  expr2t::expr_ids id,
-  expr2tc op1,
-  expr2tc op2,
-  expr2tc rm)
-{
-#ifndef NDEBUG
-  assert(is_vector_type(op1) || (op2 && is_vector_type(op2)));
-#endif
-  auto is_op1_vector = is_vector_type(op1);
-  auto vector_length = is_op1_vector ? to_vector_type(op1->type).array_size
-                                     : to_vector_type(op2->type).array_size;
-  assert(is_constant_int2t(vector_length));
-
-  auto vector_subtype = is_op1_vector ? to_vector_type(op1->type).subtype
-                                      : to_vector_type(op2->type).subtype;
-  auto result = is_op1_vector ? gen_zero(op1->type) : gen_zero(op2->type);
-
-  /*
-   * If both op1 and op2 are vectors the resulting value
-   * would be the operation over each member
-   *
-   * Example:
-   *
-   * op1 = {1,2,3,4}
-   * op2 = {1,1,1,1}
-   * func = add
-   *
-   * This would result in:
-   *
-   * { add(op1[0], op2[0]), add(op1[1], op2[1]), ...}
-   * {2,3,4,5}
-   */
-
-  /*
-   * If only one of the operator is a vector, then the result
-   * would extract each value of the vector and apply the value to
-   * the other operator
-   *
-   * Example:
-   *
-   * op1 = {1,2,3,4}
-   * op2 = 1
-   * func = add
-   *
-   * This would result in:
-   *
-   * { add(op1[0], 1), add(op1[1], 1), ...}
-   * {2,3,4,5}
-   */
-  for(size_t i = 0; i < to_constant_int2t(vector_length).as_ulong(); i++)
-  {
-    BigInt position(i);
-
-    expr2tc local_op1 = op1;
-    if(is_vector_type(op1->type))
-    {
-      local_op1 = index2tc(
-        to_vector_type(op1->type).subtype,
-        op1,
-        constant_int2tc(get_uint32_type(), position));
-    }
-
-    expr2tc local_op2 = op2;
-    if(op2 && is_vector_type(op2->type))
-    {
-      local_op2 = index2tc(
-        to_vector_type(op1->type).subtype,
-        op2,
-        constant_int2tc(get_uint32_type(), position));
-    }
-
-    expr2tc to_add;
-    switch(id)
-    {
-    case expr2t::neg_id:
-      to_add = neg2tc(to_vector_type(op1->type).subtype, local_op1);
-      break;
-    case expr2t::bitnot_id:
-      to_add = bitnot2tc(to_vector_type(op1->type).subtype, local_op1);
-      break;
-    case expr2t::sub_id:
-      to_add = sub2tc(to_vector_type(op1->type).subtype, local_op1, local_op2);
-      break;
-    case expr2t::mul_id:
-      to_add = mul2tc(to_vector_type(op1->type).subtype, local_op1, local_op2);
-      break;
-    case expr2t::div_id:
-      to_add = div2tc(to_vector_type(op1->type).subtype, local_op1, local_op2);
-      break;
-    case expr2t::modulus_id:
-      to_add =
-        modulus2tc(to_vector_type(op1->type).subtype, local_op1, local_op2);
-      break;
-    case expr2t::add_id:
-      to_add = add2tc(to_vector_type(op1->type).subtype, local_op1, local_op2);
-      break;
-    case expr2t::shl_id:
-      to_add = shl2tc(to_vector_type(op1->type).subtype, local_op1, local_op2);
-      break;
-    case expr2t::bitxor_id:
-      to_add =
-        bitxor2tc(to_vector_type(op1->type).subtype, local_op1, local_op2);
-      break;
-    case expr2t::bitor_id:
-      to_add =
-        bitor2tc(to_vector_type(op1->type).subtype, local_op1, local_op2);
-      break;
-    case expr2t::bitand_id:
-      to_add =
-        bitand2tc(to_vector_type(op1->type).subtype, local_op1, local_op2);
-      break;
-    case expr2t::ieee_add_id:
-      to_add = ieee_add2tc(
-        to_vector_type(op1->type).subtype, local_op1, local_op2, rm);
-      break;
-    case expr2t::ieee_div_id:
-      to_add = ieee_div2tc(
-        to_vector_type(op1->type).subtype, local_op1, local_op2, rm);
-      break;
-    case expr2t::ieee_sub_id:
-      to_add = ieee_sub2tc(
-        to_vector_type(op1->type).subtype, local_op1, local_op2, rm);
-      break;
-    case expr2t::ieee_mul_id:
-      to_add = ieee_mul2tc(
-        to_vector_type(op1->type).subtype, local_op1, local_op2, rm);
-      break;
-    default:
-      assert(0 && "Unsupported operation for Vector");
-      abort();
-    }
-    to_constant_vector2t(result).datatype_members[i] = to_add;
-  }
-  return result;
-}
-
 unsigned int pointer_type2t::get_width() const
 {
   return config.ansi_c.pointer_width;
@@ -480,23 +276,19 @@ unsigned int struct_union_data::get_component_number(const irep_idt &comp) const
 
   if(!count)
   {
-    assert(
-      0 &&
-      fmt::format(
-        "Looking up index of nonexistant member \"{}\" in struct/union \"{}\"",
-        comp,
-        name)
-        .c_str());
+    log_error(
+      "Looking up index of nonexistant member \"{}\" in struct/union \"{}\"",
+      comp,
+      name);
+    abort();
   }
   else if(count > 1)
   {
-    assert(
-      0 &&
-      fmt::format(
-        "Name \"{}\" matches more than one member\" in struct/union \"{}\"",
-        comp,
-        name)
-        .c_str());
+    log_error(
+      "Name \"{}\" matches more than one member\" in struct/union \"{}\"",
+      comp,
+      name);
+    abort();
   }
 
   abort();
diff --git a/src/irep2/irep2_type.h b/src/irep2/irep2_type.h
index a9c948bd2..a5f840037 100644
--- a/src/irep2/irep2_type.h
+++ b/src/irep2/irep2_type.h
@@ -609,35 +609,6 @@ public:
   vector_type2t(const vector_type2t &ref) = default;
   unsigned int get_width() const override;
   static std::string field_names[esbmct::num_type_fields];
-  /**
-   * @brief Distribute the functor `func` over op1 and op2
-   * at least one of those must be a vector
-   *
-   * @param func the functor operation e.g add, sub, mul
-   * @param op1 the first operand
-   * @param op2 the second operand
-   * @return expr2tc with the resulting vector
-   */
-  static expr2tc distribute_operation(
-    std::function<expr2tc(type2tc, expr2tc, expr2tc)> func,
-    expr2tc op1,
-    expr2tc op2);
-
-  /**
-   * @brief Distribute the functor `func` over op1 and op2
-   * at least one of those must be a vector
-   *
-   * @param airth_id the id for the operation
-   * @param op1 the first operand
-   * @param op2 the second operand
-   * @param rm rounding mode (for ieee)
-   * @return expr2tc with the resulting vector
-   */
-  static expr2tc distribute_operation(
-    expr2t::expr_ids id,
-    expr2tc op1,
-    expr2tc op2 = expr2tc(),
-    expr2tc rm = expr2tc());
 };
 
 /** Pointer type.
diff --git a/src/irep2/irep2_utils.h b/src/irep2/irep2_utils.h
index d14e26486..258624efa 100644
--- a/src/irep2/irep2_utils.h
+++ b/src/irep2/irep2_utils.h
@@ -2,10 +2,10 @@
 #define UTIL_IREP2_UTILS_H_
 
 #include <util/c_types.h>
-#include <util/message/default_message.h>
-#include <util/message/format.h>
+
 #include <irep2/irep2_expr.h>
 #include <util/migrate.h>
+#include <util/message.h>
 
 std::string indent_str_irep2(unsigned int indent);
 
@@ -334,7 +334,7 @@ inline expr2tc gen_zero(const type2tc &type, bool array_as_array_of = false)
   }
 
   case type2t::pointer_id:
-    return symbol2tc(pointer_type2(), "NULL");
+    return symbol2tc(type, "NULL");
 
   case type2t::struct_id:
   {
@@ -351,19 +351,18 @@ inline expr2tc gen_zero(const type2tc &type, bool array_as_array_of = false)
   {
     auto union_type = to_union_type(type);
 
-    std::vector<expr2tc> members;
-    for(auto const &member_type : union_type.members)
-      members.push_back(gen_zero(member_type, array_as_array_of));
+    assert(!union_type.members.empty());
+    std::vector<expr2tc> members = {
+      gen_zero(union_type.members.front(), array_as_array_of)};
 
-    return constant_union2tc(type, members);
+    return constant_union2tc(type, union_type.member_names.front(), members);
   }
 
   default:
     break;
   }
 
-  default_message msg;
-  msg.error(fmt::format("Can't generate zero for type {}", get_type_id(type)));
+  log_error("Can't generate zero for type {}", get_type_id(type));
   abort();
 }
 
@@ -396,9 +395,225 @@ inline expr2tc gen_one(const type2tc &type)
     break;
   }
 
-  default_message msg;
-  msg.error(fmt::format("Can't generate one for type {}", get_type_id(type)));
+  log_error("Can't generate one for type {}", get_type_id(type));
   abort();
 }
 
+/**
+   * @brief Distribute the functor `func` over op1 and op2
+   * at least one of those must be a vector
+   * 
+   * Here, if one of the operands is `nil` then func must
+   * support an operation between the vector subtype and nil
+   *
+   * @param func the functor operation e.g add, sub, mul
+   * @param op1 the first operand
+   * @param op2 the second operand
+   * @return expr2tc with the resulting vector
+   */
+template <typename Func>
+inline expr2tc distribute_vector_operation(Func func, expr2tc op1, expr2tc op2)
+{
+  assert(is_constant_vector2t(op1) || is_constant_vector2t(op2));
+  /*
+   * If both op1 and op2 are vectors the resulting value
+   * would be the operation over each member
+   *
+   * Example:
+   *
+   * op1 = {1,2,3,4}
+   * op2 = {1,1,1,1}
+   * func = add
+   *
+   * This would result in:
+   *
+   * { add(op1[0], op2[0]), add(op1[1], op2[1]), ...}
+   * {2,3,4,5}
+   */
+  if(is_constant_vector2t(op1) && is_constant_vector2t(op2))
+  {
+    constant_vector2tc vec1(op1);
+    constant_vector2tc vec2(op2);
+    for(size_t i = 0; i < vec1->datatype_members.size(); i++)
+    {
+      auto &A = vec1->datatype_members[i];
+      auto &B = vec2->datatype_members[i];
+      auto new_op = func(A->type, A, B);
+      vec1->datatype_members[i] = new_op;
+    }
+    return vec1;
+  }
+  /*
+   * If only one of the operator is a vector, then the result
+   * would extract each value of the vector and apply the value to
+   * the other operator
+   *
+   * Example:
+   *
+   * op1 = {1,2,3,4}
+   * op2 = 1
+   * func = add
+   *
+   * This would result in:
+   *
+   * { add(op1[0], 1), add(op1[1], 1), ...}
+   * {2,3,4,5}
+   */
+  else
+  {
+    bool is_op1_vec = is_constant_vector2t(op1);
+    expr2tc c = !is_op1_vec ? op1 : op2;
+    constant_vector2tc vector(is_op1_vec ? op1 : op2);
+    for(auto &datatype_member : vector->datatype_members)
+    {
+      auto &op = datatype_member;
+      auto e1 = is_op1_vec ? op : c;
+      auto e2 = is_op1_vec ? c : op;
+      auto new_op = func(op->type, e1, e2);
+      datatype_member = new_op->do_simplify();
+    }
+    return vector;
+  }
+}
+
+/**
+   * @brief Distribute a function between one or two operands,
+   * at least one of those must be a vector
+   *
+   * @param id the id for the operation
+   * @param op1 the first operand
+   * @param op2 the second operand
+   * @param rm rounding mode (for ieee)
+   * @return expr2tc with the resulting vector
+   */
+inline expr2tc distribute_vector_operation(
+  expr2t::expr_ids id,
+  expr2tc op1,
+  expr2tc op2 = expr2tc(),
+  expr2tc rm = expr2tc())
+{
+#ifndef NDEBUG
+  assert(is_vector_type(op1) || (op2 && is_vector_type(op2)));
+#endif
+  auto is_op1_vector = is_vector_type(op1);
+  auto vector_length = is_op1_vector ? to_vector_type(op1->type).array_size
+                                     : to_vector_type(op2->type).array_size;
+  assert(is_constant_int2t(vector_length));
+
+  auto vector_subtype = is_op1_vector ? to_vector_type(op1->type).subtype
+                                      : to_vector_type(op2->type).subtype;
+  auto result = is_op1_vector ? gen_zero(op1->type) : gen_zero(op2->type);
+
+  /*
+   * If both op1 and op2 are vectors the resulting value
+   * would be the operation over each member
+   *
+   * Example:
+   *
+   * op1 = {1,2,3,4}
+   * op2 = {1,1,1,1}
+   * func = add
+   *
+   * This would result in:
+   *
+   * { add(op1[0], op2[0]), add(op1[1], op2[1]), ...}
+   * {2,3,4,5}
+   */
+
+  /*
+   * If only one of the operator is a vector, then the result
+   * would extract each value of the vector and apply the value to
+   * the other operator
+   *
+   * Example:
+   *
+   * op1 = {1,2,3,4}
+   * op2 = 1
+   * func = add
+   *
+   * This would result in:
+   *
+   * { add(op1[0], 1), add(op1[1], 1), ...}
+   * {2,3,4,5}
+   */
+  for(size_t i = 0; i < to_constant_int2t(vector_length).as_ulong(); i++)
+  {
+    BigInt position(i);
+    type2tc vector_type =
+      to_vector_type(is_vector_type(op1->type) ? op1->type : op2->type).subtype;
+    expr2tc local_op1 = op1;
+    if(is_vector_type(op1->type))
+    {
+      local_op1 = index2tc(
+        to_vector_type(op1->type).subtype,
+        op1,
+        constant_int2tc(get_uint32_type(), position));
+    }
+
+    expr2tc local_op2 = op2;
+    if(op2 && is_vector_type(op2->type))
+    {
+      local_op2 = index2tc(
+        to_vector_type(op2->type).subtype,
+        op2,
+        constant_int2tc(get_uint32_type(), position));
+    }
+
+    expr2tc to_add;
+    switch(id)
+    {
+    case expr2t::neg_id:
+      to_add = neg2tc(vector_type, local_op1);
+      break;
+    case expr2t::bitnot_id:
+      to_add = bitnot2tc(vector_type, local_op1);
+      break;
+    case expr2t::sub_id:
+      to_add = sub2tc(vector_type, local_op1, local_op2);
+      break;
+    case expr2t::mul_id:
+      to_add = mul2tc(vector_type, local_op1, local_op2);
+      break;
+    case expr2t::div_id:
+      to_add = div2tc(vector_type, local_op1, local_op2);
+      break;
+    case expr2t::modulus_id:
+      to_add = modulus2tc(vector_type, local_op1, local_op2);
+      break;
+    case expr2t::add_id:
+      to_add = add2tc(vector_type, local_op1, local_op2);
+      break;
+    case expr2t::shl_id:
+      to_add = shl2tc(vector_type, local_op1, local_op2);
+      break;
+    case expr2t::bitxor_id:
+      to_add = bitxor2tc(vector_type, local_op1, local_op2);
+      break;
+    case expr2t::bitor_id:
+      to_add = bitor2tc(vector_type, local_op1, local_op2);
+      break;
+    case expr2t::bitand_id:
+      to_add = bitand2tc(vector_type, local_op1, local_op2);
+      break;
+    case expr2t::ieee_add_id:
+      to_add = ieee_add2tc(vector_type, local_op1, local_op2, rm);
+      break;
+    case expr2t::ieee_div_id:
+      to_add = ieee_div2tc(vector_type, local_op1, local_op2, rm);
+      break;
+    case expr2t::ieee_sub_id:
+      to_add = ieee_sub2tc(vector_type, local_op1, local_op2, rm);
+      break;
+    case expr2t::ieee_mul_id:
+      to_add = ieee_mul2tc(vector_type, local_op1, local_op2, rm);
+      break;
+    default:
+      assert(0 && "Unsupported operation for Vector");
+      abort();
+    }
+    to_constant_vector2t(result).datatype_members[i] = to_add;
+  }
+  return result;
+}
+
 #endif /* UTIL_IREP2_UTILS_H_ */
diff --git a/src/irep2/templates/irep2_templates.cpp b/src/irep2/templates/irep2_templates.cpp
index 00188355f..a95dd2f90 100644
--- a/src/irep2/templates/irep2_templates.cpp
+++ b/src/irep2/templates/irep2_templates.cpp
@@ -47,7 +47,7 @@ std::string constant_floatbv2t::field_names[esbmct::num_type_fields] =
 std::string constant_struct2t::field_names[esbmct::num_type_fields] =
   {"members", "", "", "", ""};
 std::string constant_union2t::field_names[esbmct::num_type_fields] =
-  {"members", "", "", "", ""};
+  {"members", "init_field", "", "", ""};
 std::string constant_bool2t::field_names[esbmct::num_type_fields] =
   {"value", "", "", "", ""};
 std::string constant_array2t::field_names[esbmct::num_type_fields] =
diff --git a/src/irep2/templates/irep2_templates_expr_data.cpp b/src/irep2/templates/irep2_templates_expr_data.cpp
index 9af17f351..5408ed7d5 100644
--- a/src/irep2/templates/irep2_templates_expr_data.cpp
+++ b/src/irep2/templates/irep2_templates_expr_data.cpp
@@ -4,7 +4,7 @@ expr_typedefs1(constant_int, constant_int_data);
 expr_typedefs1(constant_fixedbv, constant_fixedbv_data);
 expr_typedefs1(constant_floatbv, constant_floatbv_data);
 expr_typedefs1(constant_struct, constant_datatype_data);
-expr_typedefs2(constant_union, constant_datatype_data);
+expr_typedefs2(constant_union, constant_union_data);
 expr_typedefs1(constant_array, constant_datatype_data);
 expr_typedefs1(constant_vector, constant_datatype_data);
 expr_typedefs1(constant_bool, constant_bool_data);
diff --git a/src/jimple-frontend/AST/CMakeLists.txt b/src/jimple-frontend/AST/CMakeLists.txt
new file mode 100644
index 000000000..30785bc0e
--- /dev/null
+++ b/src/jimple-frontend/AST/CMakeLists.txt
@@ -0,0 +1,12 @@
+add_library(jimple_ast
+        jimple_file.cpp
+        jimple_modifiers.cpp
+        jimple_method.cpp
+        jimple_class_field.cpp
+        jimple_type.cpp
+        jimple_method_body.cpp
+        jimple_declaration.cpp
+        jimple_statement.cpp
+        jimple_expr.cpp)
+
+target_link_libraries(jimple_ast nlohmann_json::nlohmann_json fmt::fmt)
diff --git a/src/jimple-frontend/AST/jimple_ast.h b/src/jimple-frontend/AST/jimple_ast.h
new file mode 100644
index 000000000..2989a3c82
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_ast.h
@@ -0,0 +1,216 @@
+#ifndef ESBMC_JIMPLE_AST_H
+#define ESBMC_JIMPLE_AST_H
+
+#include <util/expr.h>
+#include <util/context.h>
+#include <util/std_types.h>
+#include <util/c_types.h>
+#include <nlohmann/json.hpp>
+
+// For json parsing
+using json = nlohmann::json;
+
+/**
+ * @brief Base interface for Jimple AST
+ */
+class jimple_ast
+{
+public:
+  /**
+   * @brief Prints the contents into the
+   * the stdout.
+   */
+  void dump() const
+  {
+    log_debug("{}", this->to_string());
+  }
+
+  /**
+   * @brief Initializes the current instance by parsing
+   * a JSON
+   *
+   * @param json The json object relative to the structure
+   */
+  virtual void from_json(const json &) = 0;
+
+  /**
+   * @brief Converts the object into a string
+   *
+   * @return a human readable string of the object
+   */
+  virtual std::string to_string() const = 0;
+
+protected:
+  /**
+   * @brief creates a symbol with the default characteristics
+   *
+   * TODO: Right now, we are setting it as C mode. In time, we
+   * should convert it to Jimple.
+   * By using C mode, we don't have to worry about typecast and
+   * primitives for now.
+   *
+   * We still need to create every intrinsic type and variable for JVM
+   *
+   * @return an initialized symbolt
+   */
+  static symbolt create_jimple_symbolt(
+    const typet &t,
+    const std::string &module,
+    const std::string &name,
+    const std::string &id,
+    const std::string function_name = "")
+  {
+    symbolt symbol;
+    symbol.mode = "C";
+    symbol.module = module;
+    symbol.location = std::move(get_location(module, function_name));
+    symbol.type = std::move(t);
+    symbol.name = name;
+    symbol.id = id;
+    return symbol;
+  }
+
+  /**
+   * @brief Create a temporary variable to be used
+   *
+   * @param t type of the variable
+   * @param class_name class package to the variable
+   * @param function_name function where the variable is going to be created
+   * @return symbolt
+   */
+  static symbolt get_temp_symbol(
+    const typet &t,
+    const std::string &class_name,
+    const std::string &function_name)
+  {
+    static unsigned int counter = 0;
+
+    std::string id, name;
+    id = get_symbol_name(
+      class_name,
+      function_name,
+      "return_value$tmp$" + std::to_string(counter++));
+    name = "return_value$tmp$";
+    name += counter;
+    auto tmp_symbol =
+      create_jimple_symbolt(t, class_name, name, id, function_name);
+
+    tmp_symbol.lvalue = true;
+    tmp_symbol.static_lifetime = false;
+    tmp_symbol.is_extern = false;
+    tmp_symbol.file_local = true;
+    return tmp_symbol;
+  }
+
+  /**
+   * @brief Get the allocation function symbol
+   *
+   * This is going to be the function to be called
+   * for `new` and `newarray` calls
+   *
+   * @return symbolt
+   */
+  static symbolt get_allocation_function()
+  {
+    std::string allocation_function = "malloc";
+    code_typet code_type;
+    code_type.return_type() = pointer_typet(empty_typet());
+    code_type.arguments().push_back(uint_type());
+    symbolt symbol;
+    symbol.mode = "C";
+    symbol.type = code_type;
+    symbol.name = allocation_function;
+    symbol.id = allocation_function;
+    symbol.is_extern = false;
+    symbol.file_local = false;
+    return symbol;
+  }
+
+  /**
+   * @brief Get the esbmc_get_object_size symbol
+   *
+   * This is going to be the function to be called
+   * for `lengthof`
+   *
+   * @return symbolt
+   */
+  static symbolt get_lengthof_function()
+  {
+    std::string func = "__ESBMC_get_object_size";
+    code_typet code_type;
+    code_type.return_type() = uint_type();
+    code_type.arguments().push_back(pointer_typet(empty_typet()));
+    symbolt symbol;
+    symbol.mode = "C";
+    symbol.type = code_type;
+    symbol.name = func;
+    symbol.id = func;
+    symbol.is_extern = false;
+    symbol.file_local = false;
+    return symbol;
+  }
+
+  /**
+   * @brief Get the unique method name
+   *
+   * This is the full id for the method,
+   *
+   * In jimple this will mean `class_name:function_name`
+   *
+   * @param class_name
+   * @param function_name
+   * @return std::string
+   */
+  static std::string
+  get_method_name(std::string class_name, std::string function_name)
+  {
+    std::ostringstream oss;
+    oss << class_name << ":" << function_name;
+    return oss.str();
+  }
+
+  /**
+   * @brief Get the symbol name id
+   *
+   * Note: Jimple is already in SSA form
+   *
+   * @param class_name
+   * @param function_name
+   * @param symbol
+   * @return std::string
+   */
+  static std::string get_symbol_name(
+    std::string class_name,
+    std::string function_name,
+    std::string symbol)
+  {
+    std::ostringstream oss;
+    oss << get_method_name(class_name, function_name) << "@" << symbol;
+    return oss.str();
+  }
+
+  /**
+   * @brief initialize a location for the symbol
+   *
+   * @return the location of a symbol (file, class, function)
+   */
+  static locationt
+  get_location(const std::string &module, const std::string function_name = "")
+  {
+    locationt l;
+    l.set_file(module + ".jimple");
+    if(!function_name.empty())
+      l.set_function(function_name);
+    return l;
+  }
+
+public:
+  /// instruction location
+  int line_location = -1;
+};
+
+// These functions are used by nlohmann::json. Making it easier to
+// parse the JSON file. Avoid using them directly.
+void from_json(const json &j, jimple_ast &p);
+void to_json(json &, const jimple_ast &);
+#endif //ESBMC_JIMPLE_AST_H
diff --git a/src/jimple-frontend/AST/jimple_class_field.cpp b/src/jimple-frontend/AST/jimple_class_field.cpp
new file mode 100644
index 000000000..826b6ac50
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_class_field.cpp
@@ -0,0 +1,36 @@
+#include <jimple-frontend/AST/jimple_class_member.h>
+#include <util/std_code.h>
+#include <util/expr_util.h>
+
+exprt jimple_class_field::to_exprt(
+  contextt &ctx,
+  const std::string &,
+  const std::string &) const
+{
+  // Dummy will be return expression. It will just hold the type
+  exprt dummy;
+  typet t = type.to_typet(ctx);
+  std::string id;
+  id = "tag-" + name;
+  struct_union_typet::componentt comp(id, name, t);
+  return comp;
+}
+
+void jimple_class_field::from_json(const json &j)
+{
+  // Method modifiers
+  modifiers = j.at("modifiers").get<jimple_modifiers>();
+  // Method type
+  j.at("type").get_to(type);
+  // Method Name
+  j.at("name").get_to(this->name);
+}
+std::string jimple_class_field::to_string() const
+{
+  std::ostringstream oss;
+  oss << "Class Field"
+      << "\n\tName: " << this->name << "\n\t" << this->type.to_string()
+      << "\n\t" << this->modifiers.to_string();
+
+  return oss.str();
+}
diff --git a/src/jimple-frontend/AST/jimple_class_member.h b/src/jimple-frontend/AST/jimple_class_member.h
new file mode 100644
index 000000000..d2c8023da
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_class_member.h
@@ -0,0 +1,91 @@
+#ifndef ESBMC_JIMPLE_CLASS_MEMBER_H
+#define ESBMC_JIMPLE_CLASS_MEMBER_H
+
+#include <jimple-frontend/AST/jimple_ast.h>
+#include <jimple-frontend/AST/jimple_modifiers.h>
+#include <jimple-frontend/AST/jimple_type.h>
+#include <jimple-frontend/AST/jimple_method_body.h>
+
+#include <string>
+
+/**
+ * @brief This class will hold any member of a Jimple File
+ *
+ * This can be any attributes or methods that are inside the file
+ */
+class jimple_class_member : public jimple_ast
+{
+public:
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &file_name) const = 0;
+};
+
+/**
+ * @brief A class (or interface) field of a Jimple file
+ *
+ * example:
+ *
+ * class Foo {
+ *
+ *   public int a;
+ * }
+ *
+ */
+class jimple_class_field : public jimple_class_member
+{
+public:
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override;
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &file_name) const override;
+
+  std::string name;
+  jimple_modifiers modifiers;
+  jimple_type type;
+};
+
+// TODO: class_definition
+
+/**
+ * @brief A class (or interface) method of a Jimple file
+ *
+ * example:
+ *
+ * class Foo {
+ *   public void jimple_method {
+ *      do_stuff();
+ *   }
+ * }
+ *
+ */
+class jimple_method : public jimple_class_member
+{
+public:
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override;
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &file_name) const override;
+
+  std::string name;
+  jimple_modifiers modifiers;
+  std::string throws;
+  jimple_type type;
+  std::shared_ptr<jimple_method_body> body;
+  std::vector<std::shared_ptr<jimple_type>> parameters;
+
+protected:
+  // We need an unique name for each function
+  std::string get_hash_name() const
+  {
+    // TODO: use some hashing to also use the types
+    int add = modifiers.is_static() ? 0 : 1;
+    return std::to_string(parameters.size() + add);
+  }
+};
+#endif //ESBMC_JIMPLE_CLASS_MEMBER_H
diff --git a/src/jimple-frontend/AST/jimple_declaration.cpp b/src/jimple-frontend/AST/jimple_declaration.cpp
new file mode 100644
index 000000000..bb41e56bb
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_declaration.cpp
@@ -0,0 +1,40 @@
+#include <jimple-frontend/AST/jimple_declaration.h>
+
+exprt jimple_declaration::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  typet t = this->type.to_typet(ctx);
+
+  std::string id, name;
+  id = get_symbol_name(class_name, function_name, this->name);
+  name = this->name;
+
+  auto symbol = create_jimple_symbolt(t, class_name, name, id, function_name);
+
+  symbol.lvalue = true;
+  symbol.static_lifetime = false;
+  symbol.is_extern = false;
+  symbol.file_local = true;
+
+  symbolt &added_symbol = *ctx.move_symbol_to_context(symbol);
+  code_declt decl(symbol_expr(added_symbol));
+  decl.location() = get_location(class_name, function_name);
+  return decl;
+}
+
+std::string jimple_declaration::to_string() const
+{
+  std::ostringstream oss;
+  oss << "Declaration: ";
+  oss << " " << this->name;
+  oss << " | " << type.to_string();
+
+  return oss.str();
+}
+void jimple_declaration::from_json(const json &j)
+{
+  j.at("name").get_to(this->name);
+  j.at("type").get_to(this->type);
+}
diff --git a/src/jimple-frontend/AST/jimple_declaration.h b/src/jimple-frontend/AST/jimple_declaration.h
new file mode 100644
index 000000000..4e125f85c
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_declaration.h
@@ -0,0 +1,29 @@
+#ifndef ESBMC_JIMPLE_DECLARATION_H
+#define ESBMC_JIMPLE_DECLARATION_H
+
+#include <jimple-frontend/AST/jimple_method_body.h>
+#include <jimple-frontend/AST/jimple_type.h>
+
+/**
+ * @brief Class to hold declaration statements in Jimple
+ *
+ * - int foo;
+ * - java.lang.String r0;
+ * - etc...
+ *
+ */
+class jimple_declaration : public jimple_method_field
+{
+public:
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override;
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+
+  jimple_type type;
+  std::string name;
+};
+
+#endif //ESBMC_JIMPLE_DECLARATION_H
diff --git a/src/jimple-frontend/AST/jimple_expr.cpp b/src/jimple-frontend/AST/jimple_expr.cpp
new file mode 100644
index 000000000..373ad4962
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_expr.cpp
@@ -0,0 +1,598 @@
+#include <jimple-frontend/AST/jimple_expr.h>
+#include <util/arith_tools.h>
+#include <util/c_typecast.h>
+#include <util/c_types.h>
+#include <util/expr_util.h>
+#include <util/std_code.h>
+#include <util/std_expr.h>
+
+void jimple_constant::from_json(const json &j)
+{
+  j.at("value").get_to(value);
+}
+
+exprt jimple_constant::to_exprt(
+  contextt &,
+  const std::string &,
+  const std::string &) const
+{
+  auto as_number = std::stoi(value);
+  return constant_exprt(
+    integer2binary(as_number, 10), integer2string(as_number), int_type());
+};
+
+void jimple_symbol::from_json(const json &j)
+{
+  j.at("value").get_to(var_name);
+}
+
+exprt jimple_symbol::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  // 1. Look over the local scope
+  auto symbol_name = get_symbol_name(class_name, function_name, var_name);
+  symbolt &s = *ctx.find_symbol(symbol_name);
+
+  // TODO:
+  // 2. Look over the class scope
+  // 3. Look over the global scope (possibly don't need)
+
+  return symbol_expr(s);
+};
+
+std::shared_ptr<jimple_expr> jimple_expr::get_expression(const json &j)
+{
+  std::string expr_type;
+  if(!j.contains("expr_type"))
+  {
+    jimple_constant c;
+    c.setValue("0");
+    return std::make_shared<jimple_constant>(c);
+  }
+
+  j.at("expr_type").get_to(expr_type);
+
+  // TODO: hashmap, the standard is not stable enough yet
+  // It is still a work in progress in the parser: https://github.com/rafaelsamenezes/jimple_parser
+  if(expr_type == "constant")
+  {
+    jimple_constant c;
+    c.from_json(j);
+    return std::make_shared<jimple_constant>(c);
+  }
+
+  if(expr_type == "string_constant")
+  {
+    jimple_constant c;
+    return std::make_shared<jimple_constant>(c);
+  }
+
+  if(expr_type == "class_reference")
+  {
+    jimple_constant c("-1");
+    return std::make_shared<jimple_constant>(c);
+  }
+
+  if(expr_type == "symbol")
+  {
+    jimple_symbol c;
+    c.from_json(j);
+    return std::make_shared<jimple_symbol>(c);
+  }
+
+  if(expr_type == "static_invoke")
+  {
+    jimple_expr_invoke c;
+    c.from_json(j);
+    return std::make_shared<jimple_expr_invoke>(c);
+  }
+
+  if(expr_type == "virtual_invoke")
+  {
+    jimple_virtual_invoke c;
+    c.from_json(j);
+    return std::make_shared<jimple_virtual_invoke>(c);
+  }
+
+  if(expr_type == "binop")
+  {
+    jimple_binop c;
+    c.from_json(j);
+    return std::make_shared<jimple_binop>(c);
+  }
+
+  if(expr_type == "cast")
+  {
+    jimple_cast c;
+    c.from_json(j);
+    return std::make_shared<jimple_cast>(c);
+  }
+
+  if(expr_type == "lengthof")
+  {
+    jimple_lengthof c;
+    c.from_json(j);
+    return std::make_shared<jimple_lengthof>(c);
+  }
+
+  if(expr_type == "newarray")
+  {
+    jimple_newarray c;
+    c.from_json(j);
+    return std::make_shared<jimple_newarray>(c);
+  }
+
+  if(expr_type == "new")
+  {
+    jimple_new c;
+    c.from_json(j);
+    return std::make_shared<jimple_new>(c);
+  }
+
+  if(expr_type == "array_index")
+  {
+    jimple_deref c;
+    c.from_json(j);
+    return std::make_shared<jimple_deref>(c);
+  }
+
+  if(expr_type == "nondet")
+  {
+    jimple_nondet c;
+    return std::make_shared<jimple_nondet>(c);
+  }
+
+  if(expr_type == "static_member")
+  {
+    jimple_static_member c;
+    c.from_json(j.at("signature"));
+    return std::make_shared<jimple_static_member>(c);
+  }
+
+  if(expr_type == "local_member")
+  {
+    jimple_virtual_member c;
+    c.from_json(j);
+    return std::make_shared<jimple_virtual_member>(c);
+  }
+
+  log_error("Unexpected expr type: {}", expr_type);
+  abort();
+}
+
+void jimple_binop::from_json(const json &j)
+{
+  j.at("operator").get_to(binop);
+  // TODO, make hashmap for each operator
+  if(binop == "==")
+    binop = "=";
+  lhs = get_expression(j.at("lhs"));
+  rhs = get_expression(j.at("rhs"));
+}
+
+exprt jimple_binop::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  auto lhs_expr = lhs->to_exprt(ctx, class_name, function_name);
+  return gen_binary(
+    binop,
+    lhs_expr.type(),
+    lhs_expr,
+    rhs->to_exprt(ctx, class_name, function_name));
+};
+
+void jimple_cast::from_json(const json &j)
+{
+  jimple_type type;
+  j.at("to").get_to(type);
+  to = std::make_shared<jimple_type>(type);
+  from = get_expression(j.at("from"));
+}
+
+exprt jimple_cast::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  auto from_expr = from->to_exprt(ctx, class_name, function_name);
+  c_typecastt c_typecast(ctx);
+
+  c_typecast.implicit_typecast(from_expr, to->to_typet(ctx));
+  return from_expr;
+};
+
+void jimple_lengthof::from_json(const json &j)
+{
+  from = get_expression(j.at("expression"));
+}
+
+exprt jimple_lengthof::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  auto expr = from->to_exprt(ctx, class_name, function_name);
+
+  // Create a function call for allocation
+  code_function_callt call;
+  auto alloca_symbol = get_lengthof_function();
+
+  symbolt &added_symbol = *ctx.move_symbol_to_context(alloca_symbol);
+
+  call.function() = symbol_expr(added_symbol);
+
+  call.arguments().push_back(expr);
+
+  // Create a sideffect call to represent the allocation
+  side_effect_expr_function_callt sideeffect;
+  sideeffect.function() = call.function();
+  sideeffect.arguments() = call.arguments();
+  sideeffect.location() = call.location();
+  sideeffect.type() =
+    static_cast<const typet &>(call.function().type().return_type());
+  return sideeffect;
+};
+
+void jimple_newarray::from_json(const json &j)
+{
+  size = get_expression(j.at("size"));
+  jimple_type t;
+  j.at("type").get_to(t);
+  type = std::make_shared<jimple_type>(t);
+}
+
+void jimple_new::from_json(const json &j)
+{
+  size = std::make_shared<jimple_constant>("1");
+  jimple_type t;
+  j.at("type").get_to(t);
+  type = std::make_shared<jimple_type>(t);
+}
+
+void jimple_expr_invoke::from_json(const json &j)
+{
+  lhs = nil_exprt();
+  j.at("base_class").get_to(base_class);
+  j.at("method").get_to(method);
+  for(auto x : j.at("parameters"))
+  {
+    parameters.push_back(std::move(jimple_expr::get_expression(x)));
+  }
+  method += "_" + get_hash_name();
+
+  // TODO: Move intrinsics to backend
+  if(base_class == "java.lang.Integer" && method == "valueOf_1")
+  {
+    log_debug("Got an intrinsic call to valueOf int");
+    is_intrinsic_method = true;
+  }
+}
+
+exprt jimple_expr_invoke::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  // TODO: Move intrinsics to backend
+  if(base_class == "kotlin.jvm.internal.Intrinsics")
+  {
+    code_skipt skip;
+    return skip;
+  }
+
+  // TODO: Move intrinsics to backend
+  if(base_class == "java.lang.Runtime")
+  {
+    code_skipt skip;
+    return skip;
+  }
+
+  // TODO: Move intrinsics to backend
+  if(base_class == "java.lang.Integer" && method == "valueOf_1")
+    // This would be called with valueOf(2), valueOf(42), etc...
+    return parameters[0]->to_exprt(ctx, class_name, function_name);
+
+  if(is_nondet_call())
+  {
+    jimple_nondet nondet(method);
+    return nondet.to_exprt(ctx, class_name, function_name);
+  }
+
+  code_blockt block;
+  code_function_callt call;
+
+  std::ostringstream oss;
+  oss << base_class << ":" << method;
+
+  auto symbol = ctx.find_symbol(oss.str());
+  if(!symbol)
+  {
+    log_error("Could not find symbol {}", oss.str());
+    abort();
+  }
+  call.function() = symbol_expr(*symbol);
+  if(!lhs.is_nil())
+    call.lhs() = lhs;
+
+  for(long unsigned int i = 0; i < parameters.size(); i++)
+  {
+    // Just adding the arguments should be enough to set the parameters
+    auto parameter_expr =
+      parameters[i]->to_exprt(ctx, class_name, function_name);
+    call.arguments().push_back(parameter_expr);
+    // Hack, manually adding parameters, this should be done at symex
+    std::ostringstream oss;
+    oss << "@parameter" << i;
+    auto temp = get_symbol_name(base_class, method, oss.str());
+    symbolt &added_symbol = *ctx.find_symbol(temp);
+    code_assignt assign(symbol_expr(added_symbol), parameter_expr);
+    block.operands().push_back(assign);
+  }
+  block.operands().push_back(call);
+  return block;
+}
+
+void jimple_virtual_invoke::from_json(const json &j)
+{
+  lhs = nil_exprt();
+  j.at("base_class").get_to(base_class);
+  j.at("method").get_to(method);
+  j.at("name").get_to(variable);
+  for(auto x : j.at("parameters"))
+  {
+    parameters.push_back(std::move(jimple_expr::get_expression(x)));
+  }
+  method += "_" + get_hash_name();
+}
+
+exprt jimple_virtual_invoke::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  // TODO: Move intrinsics to backend
+  if(base_class == "kotlin.jvm.internal.Intrinsics")
+  {
+    code_skipt skip;
+    return skip;
+  }
+
+  // TODO: Move intrinsics to backend
+  if(base_class == "java.lang.Runtime")
+  {
+    code_skipt skip;
+    return skip;
+  }
+
+  // TODO: Move intrinsics to backend
+  if(base_class == "java.lang.Class")
+  {
+    code_skipt skip;
+    return skip;
+  }
+
+  if(is_nondet_call())
+  {
+    jimple_nondet nondet(method);
+    return nondet.to_exprt(ctx, class_name, function_name);
+  }
+
+  code_blockt block;
+  code_function_callt call;
+
+  std::ostringstream oss;
+  oss << base_class << ":" << method;
+
+  auto symbol = ctx.find_symbol(oss.str());
+  call.function() = symbol_expr(*symbol);
+  if(!lhs.is_nil())
+  {
+    call.lhs() = lhs;
+  }
+
+  if(variable != "")
+  {
+    // Let's add @THIS
+    auto this_expression =
+      jimple_symbol(variable).to_exprt(ctx, class_name, function_name);
+    call.arguments().push_back(this_expression);
+    auto temp = get_symbol_name(base_class, method, "@this");
+    symbolt &added_symbol = *ctx.find_symbol(temp);
+    code_assignt assign(symbol_expr(added_symbol), this_expression);
+    block.operands().push_back(assign);
+  }
+
+  for(long unsigned int i = 0; i < parameters.size(); i++)
+  {
+    // Just adding the arguments should be enough to set the parameters
+    auto parameter_expr =
+      parameters[i]->to_exprt(ctx, class_name, function_name);
+    call.arguments().push_back(parameter_expr);
+    // Hack, manually adding parameters, this should be done at symex
+    std::ostringstream oss;
+    oss << "@parameter" << i;
+    auto temp = get_symbol_name(base_class, method, oss.str());
+    symbolt &added_symbol = *ctx.find_symbol(temp);
+    code_assignt assign(symbol_expr(added_symbol), parameter_expr);
+    block.operands().push_back(assign);
+  }
+  block.operands().push_back(call);
+  return block;
+}
+
+exprt jimple_newarray::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  auto base_type = type->to_typet(ctx);
+  auto tmp_symbol =
+    get_temp_symbol(pointer_typet(base_type), class_name, function_name);
+  symbolt &tmp_added_symbol = *ctx.move_symbol_to_context(tmp_symbol);
+
+  // get alloc type and size
+  typet alloc_type = base_type.is_pointer() ? base_type.subtype() : base_type;
+  exprt alloc_size = size->to_exprt(ctx, class_name, function_name);
+
+  if(alloc_size.is_nil())
+    alloc_size = from_integer(1, uint_type());
+
+  if(alloc_type.is_nil())
+    alloc_type = char_type();
+
+  // Create a function call for allocation
+  code_function_callt call;
+  auto alloca_symbol = get_allocation_function();
+
+  symbolt &added_symbol = *ctx.move_symbol_to_context(alloca_symbol);
+
+  call.function() = symbol_expr(added_symbol);
+
+  // LHS of call is the tmp var
+  call.lhs() = symbol_expr(tmp_added_symbol);
+  int type_width = 64;
+  if(!(base_type.is_pointer() && base_type.subtype().is_pointer()))
+  {
+    auto to_convert =
+      base_type.is_pointer() ? base_type.subtype().width() : base_type.width();
+
+    type_width = std::stoi(to_convert.as_string()); // we want bytes
+  }
+
+  auto new_expr = exprt("*", uint_type());
+  auto base_size = constant_exprt(
+    integer2binary(type_width, 10), integer2string(type_width), uint_type());
+  new_expr.move_to_operands(alloc_size, base_size);
+
+  call.arguments().push_back(new_expr);
+
+  // Create a sideffect call to represent the allocation
+  side_effect_expr_function_callt sideeffect;
+  sideeffect.function() = call.function();
+  sideeffect.arguments() = call.arguments();
+  sideeffect.location() = call.location();
+  sideeffect.type() =
+    static_cast<const typet &>(call.function().type().return_type());
+  return sideeffect;
+};
+
+void jimple_deref::from_json(const json &j)
+{
+  base = get_expression(j.at("base"));
+  index = get_expression(j.at("index"));
+}
+
+exprt jimple_deref::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  auto arr = base->to_exprt(ctx, class_name, function_name);
+  auto i = index->to_exprt(ctx, class_name, function_name);
+  auto index = index_exprt(arr, i, arr.type().subtype());
+  exprt &array_expr = index.op0();
+
+  exprt addition("+", array_expr.type());
+  addition.operands().swap(index.operands());
+
+  index.move_to_operands(addition);
+  index.id("dereference");
+  index.type() = array_expr.type().subtype();
+
+  return index;
+};
+
+exprt jimple_nondet::to_exprt(
+  contextt &,
+  const std::string &,
+  const std::string &) const
+{
+  auto type = int_type(); // TODO: hashmap here!
+  exprt rhs = exprt("sideeffect", type);
+  rhs.statement("nondet");
+
+  return rhs;
+};
+
+void jimple_static_member::from_json(const json &j)
+{
+  j.at("base_class").get_to(from);
+  j.at("member").get_to(field);
+  jimple_type t;
+  j.at("type").get_to(t);
+  type = std::make_shared<jimple_type>(t);
+}
+
+exprt jimple_static_member::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  auto result = gen_zero(type->to_typet(ctx));
+  // HACK: For now I will set some intrinsics directly (this should go to SYMEX)
+  if(from == "kotlin._Assertions" && field == "ENABLED")
+  {
+    result.make_true();
+    return result;
+  }
+
+  if(from == "Main" && field == "$assertionsDisabled")
+  {
+    result.make_false();
+    return result;
+  }
+
+  // TODO: Needs OOP members
+
+  // 1. Look over the local scope
+  auto symbol_name = get_symbol_name(class_name, function_name, from);
+  symbolt &s = *ctx.find_symbol(symbol_name);
+  member_exprt op(symbol_expr(s), "tag-" + field, s.type);
+  exprt &base = op.struct_op();
+  if(base.type().is_pointer())
+  {
+    exprt deref("dereference");
+    deref.type() = base.type().subtype();
+    deref.move_to_operands(base);
+    base.swap(deref);
+  }
+  return op;
+};
+
+void jimple_virtual_member::from_json(const json &j)
+{
+  j.at("variable").get_to(variable);
+  j.at("signature").at("base_class").get_to(from);
+  j.at("signature").at("member").get_to(field);
+  jimple_type t;
+  j.at("signature").at("type").get_to(t);
+  type = std::make_shared<jimple_type>(t);
+}
+
+exprt jimple_virtual_member::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  auto result = gen_zero(type->to_typet(ctx));
+  auto struct_type = (*ctx.find_symbol("tag-" + from)).type;
+
+  // 1. Look over the local scope
+  auto symbol_name = get_symbol_name(class_name, function_name, variable);
+  symbolt &s = *ctx.find_symbol(symbol_name);
+  member_exprt op(symbol_expr(s), "tag-" + field, type->to_typet(ctx));
+  exprt &base = op.struct_op();
+  if(base.type().is_pointer())
+  {
+    exprt deref("dereference");
+    deref.type() = base.type().subtype();
+    deref.move_to_operands(base);
+    base.swap(deref);
+  }
+
+  return op;
+};
diff --git a/src/jimple-frontend/AST/jimple_expr.h b/src/jimple-frontend/AST/jimple_expr.h
new file mode 100644
index 000000000..f784d2bd9
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_expr.h
@@ -0,0 +1,441 @@
+#include <jimple-frontend/AST/jimple_ast.h>
+#include <jimple-frontend/AST/jimple_type.h>
+
+#pragma once
+
+/**
+ * @brief Base interface to hold jimple expressions
+ *
+ */
+class jimple_expr : public jimple_ast
+{
+public:
+  virtual exprt
+  to_exprt(contextt &, const std::string &, const std::string &) const
+  {
+    exprt val("at_identifier");
+    return val;
+  };
+
+  /**
+   * @brief Recursively explores and initializes a jimple_expression
+   *
+   * Jimple expressions can be unary (e.g. cast) or binary (e.g. addition),
+   * however, the operands can be other expressions. For example, it is valid
+   * to do a cast over a math operation: `(int) 1 + 1` in Jimple, this should be
+   * parsed as:
+   *
+   * - cast:
+   *   - to: int
+   *   - from:
+   *     - binop: +
+   *       - op1: 1
+   *       - op2: 1
+   *
+   * This function will do that
+   * @param j
+   * @return std::shared_ptr<jimple_expr>
+   */
+  static std::shared_ptr<jimple_expr> get_expression(const json &j);
+};
+
+/**
+ * @brief A number constant (in decimal)
+ *
+ * Example: 3, 42, 1, -1, etc...
+ *
+ */
+class jimple_constant : public jimple_expr
+{
+public:
+  jimple_constant() = default;
+  explicit jimple_constant(const std::string &value) : value(value)
+  {
+  }
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override
+  {
+    return value;
+  }
+
+  virtual void setValue(const std::string &v)
+  {
+    value = v;
+  }
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+
+  std::string value;
+};
+
+/**
+ * @brief The value of a symbol (variable)
+ *
+ * E.g
+ *
+ * int a = 3;
+ *
+ * When an expression such as: `1 + a`, it should
+ * evaluate to 4
+ *
+ */
+class jimple_symbol : public jimple_expr
+{
+public:
+  jimple_symbol() = default;
+  explicit jimple_symbol(std::string name) : var_name(name)
+  {
+  }
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override
+  {
+    return var_name;
+  }
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+
+  const std::string &getVarName() const
+  {
+    return var_name;
+  }
+
+protected:
+  std::string var_name;
+};
+
+/**
+ * @brief A binary operation
+ *
+ * E.g. +, -, *, /, ==, !=, etc
+ *
+ */
+class jimple_binop : public jimple_expr
+{
+public:
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override
+  {
+    return "Jimple BinOP";
+  }
+
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+
+  std::string binop;
+  std::shared_ptr<jimple_expr> lhs;
+  std::shared_ptr<jimple_expr> rhs;
+};
+
+/**
+ * @brief A cast operation
+ *
+ * E.g. (int)
+ */
+class jimple_cast : public jimple_expr
+{
+public:
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override
+  {
+    return "Jimple Cast";
+  }
+
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+
+  std::string var_name;
+  std::shared_ptr<jimple_expr> from;
+  std::shared_ptr<jimple_type> to;
+};
+
+/**
+ * @brief Get the number of elements of an array (not bits/bytes)
+ *
+ * int arr[3];
+ * lengthof(arr) = 3
+ */
+class jimple_lengthof : public jimple_expr
+{
+public:
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override
+  {
+    return "Jimple Lengthof";
+  }
+
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+
+  std::shared_ptr<jimple_expr> from;
+};
+
+/**
+ * @brief Allocates a new array (dynamic)
+ *
+ * e.g.
+ *
+ * int arr[];
+ * arr = new int(3);
+ */
+class jimple_newarray : public jimple_expr
+{
+public:
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override
+  {
+    return "Jimple New array";
+  }
+
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+
+  std::shared_ptr<jimple_type> type;
+  std::shared_ptr<jimple_expr> size;
+};
+
+/**
+ * @brief The result of a function call
+ *
+ * int a = foo();
+ *
+ */
+class jimple_expr_invoke : public jimple_expr
+{
+public:
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override
+  {
+    return "Jimple Invoke";
+  }
+
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+
+  std::string base_class;
+  std::string method;
+  exprt lhs;
+  std::vector<std::shared_ptr<jimple_expr>> parameters;
+
+  void set_lhs(exprt expr)
+  {
+    lhs = expr;
+  }
+
+  bool is_nondet_call() const
+  {
+    return base_class == "org.sosy_lab.sv_benchmarks.Verifier";
+  }
+
+  bool is_intrinsic_method = false;
+
+protected:
+  // We need an unique name for each function
+  std::string get_hash_name() const
+  {
+    return std::to_string(parameters.size());
+  }
+};
+
+/**
+ * @brief The result of a function call
+ *
+ * int a = foo();
+ *
+ */
+class jimple_virtual_invoke : public jimple_expr
+{
+public:
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override
+  {
+    return "Jimple Virtual Invoke";
+  }
+
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+
+  std::string base_class;
+  std::string method;
+  exprt lhs;
+  std::string variable;
+  std::vector<std::shared_ptr<jimple_expr>> parameters;
+
+  void set_lhs(exprt expr)
+  {
+    lhs = expr;
+  }
+
+  bool is_nondet_call() const
+  {
+    return base_class == "java.util.Random";
+  }
+
+protected:
+  // We need an unique name for each function
+  std::string get_hash_name() const
+  {
+    return std::to_string(parameters.size() + 1);
+  }
+};
+
+/**
+ * @brief Allocates a type
+ *
+ * Note: this is not a constructor! The constructor is called through
+ * an invoke_stmt.
+ *
+ * Example:
+ *
+ * CustomClass c;
+ * c = new CustomClass()
+ *
+ * v v v v v
+ *
+ * CustomClass *c;
+ * c = alloca(sizeof(CustomClass)) // JIMPLE_NEW
+ * c.<init>() // the inner constructor
+ *
+ */
+class jimple_new : public jimple_newarray
+{
+public:
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override
+  {
+    return "Jimple New";
+  }
+};
+
+/**
+ * @brief Access of arrays
+ *
+ * Since in Jimple arrays are treated as pointers
+ * this is a pointer arithmetic expression
+ *
+ * arr[4] // JIMPLE_DEREF
+ *
+ */
+class jimple_deref : public jimple_expr
+{
+public:
+  jimple_deref() = default;
+  jimple_deref(
+    std::shared_ptr<jimple_expr> index,
+    std::shared_ptr<jimple_expr> base)
+    : index(index), base(base)
+  {
+  }
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override
+  {
+    return "Jimple Deref";
+  }
+
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+
+  std::shared_ptr<jimple_expr> index;
+  std::shared_ptr<jimple_expr> base;
+};
+
+/**
+ * @brief Nondet call (This in an extension)
+ *
+ */
+class jimple_nondet : public jimple_expr
+{
+public:
+  jimple_nondet() = default;
+  explicit jimple_nondet(std::string mode) : mode(mode)
+  {
+  }
+  virtual std::string to_string() const override
+  {
+    return "Jimple Nondet";
+  }
+  virtual void from_json(const json &) override
+  {
+    assert("This class shouldn't be used from Jimple directly");
+    abort();
+  }
+
+  const std::string mode; // Int, char, long, etc... e.g. Random().nextInt()
+  //std::string bound;
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+};
+
+/**
+ * @brief A static member of object/class
+ *
+ * class Foo { static int a; }
+ *
+ * Foo f = ...;
+ * int a = F.a; // F.a (or Foo.a) is a static member access
+ *
+ */
+class jimple_static_member : public jimple_expr
+{
+public:
+  virtual std::string to_string() const override
+  {
+    return "Jimple Static Member";
+  }
+  virtual void from_json(const json &j) override;
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+
+  std::string from;
+  std::string field;
+  std::shared_ptr<jimple_type> type;
+};
+
+/**
+ * @brief A virtual member of object
+ *
+ * class Foo { int a; }
+ *
+ * Foo f = ...;
+ * int a = F.a; // F.a is a virtual member access
+ *
+ */
+class jimple_virtual_member : public jimple_expr
+{
+public:
+  virtual std::string to_string() const override
+  {
+    return "Jimple Virtual Member";
+  }
+  virtual void from_json(const json &j) override;
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+
+  std::string variable;
+  std::string from;
+  std::string field;
+  std::shared_ptr<jimple_type> type;
+};
diff --git a/src/jimple-frontend/AST/jimple_file.cpp b/src/jimple-frontend/AST/jimple_file.cpp
new file mode 100644
index 000000000..dbfc80f6c
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_file.cpp
@@ -0,0 +1,170 @@
+#include <map>
+#include <fstream>
+#include <jimple-frontend/AST/jimple_file.h>
+
+#include <util/std_code.h>
+#include <util/expr_util.h>
+
+// (De)-Serialization helpers (from jimple_ast.h)
+void to_json(json &, const jimple_ast &)
+{
+  // Don't care
+}
+
+void from_json(const json &j, jimple_ast &p)
+{
+  p.from_json(j);
+}
+
+std::string jimple_file::to_string() const
+{
+  std::ostringstream oss;
+  oss << "Jimple File:\n"
+      << "\t"
+      << "Name: " << this->class_name << "\n\t"
+      << "Mode: " << to_string(this->mode) << "\n\t"
+      << "Extends: " << this->extends << "\n\t"
+      << "Implements: " << this->implements << "\n\t"
+      << this->modifiers.to_string();
+
+  oss << "\n\n";
+  for(auto &x : body)
+  {
+    oss << x->to_string();
+    oss << "\n\n";
+  }
+
+  return oss.str();
+}
+
+void jimple_file::from_json(const json &j)
+{
+  // Get ClassName
+  j.at("name").get_to(this->class_name);
+
+  std::string t;
+  j.at("object").get_to(t);
+  this->mode = from_string(t);
+
+  if(j.contains("implements"))
+    j.at("implements").get_to(this->implements);
+  else
+    this->implements = "(No implements)";
+
+  if(j.contains("extends"))
+    j.at("extends").get_to(this->extends);
+  else
+    this->implements = "(No extends)";
+
+  modifiers = j.at("modifiers").get<jimple_modifiers>();
+
+  auto filebody = j.at("content");
+  for(auto &x : filebody)
+  {
+    // TODO: Here is where to add support for signatures
+    auto content_type = x.at("object").get<std::string>();
+    std::shared_ptr<jimple_class_member> to_add;
+    if(content_type == "Method")
+    {
+      jimple_method m;
+      x.get_to(m);
+      to_add = std::make_shared<jimple_method>(m);
+    }
+    else if(content_type == "Field")
+    {
+      jimple_class_field m;
+      x.get_to(m);
+      to_add = std::make_shared<jimple_class_field>(m);
+    }
+    else
+    {
+      log_error("Unsupported object: {}", content_type);
+      abort();
+    }
+    body.push_back(to_add);
+  }
+}
+
+inline jimple_file::file_type
+jimple_file::from_string(const std::string &name) const
+{
+  return from_map.at(name);
+}
+
+inline std::string
+jimple_file::to_string(const jimple_file::file_type &ft) const
+{
+  return to_map.at(ft);
+}
+void jimple_file::load_file(const std::string &path)
+{
+  std::ifstream i(path);
+  json j;
+  i >> j;
+
+  from_json(j);
+}
+
+exprt jimple_file::to_exprt(contextt &ctx) const
+{
+  /*
+   * A class is just a type, this method will just register
+   * its type and return a code_skipt.
+   *
+   * However, the list of symbols are going to be updated with
+   * the static functions and variables, and constructor */
+
+  exprt e = code_skipt();
+
+  std::string id, name;
+  id = "tag-" + this->class_name;
+  name = this->class_name;
+
+  // Check if class already exists
+  if(ctx.find_symbol(id) != nullptr)
+    throw "Duplicated class name";
+
+  struct_typet t;
+  t.tag(name);
+
+  auto symbol = create_jimple_symbolt(t, name, name, id);
+  std::string symbol_name = symbol.id.as_string();
+
+  // A class/interface is a type
+  symbol.is_type = true;
+
+  // Add symbol into the context
+  ctx.move_symbol_to_context(symbol);
+  symbolt *added_symbol = ctx.find_symbol(symbol_name);
+
+  // Add class/interface members
+  auto total_size = 0;
+  for(auto const &field : body)
+  {
+    if(std::dynamic_pointer_cast<jimple_class_field>(field))
+    {
+      struct_typet::componentt comp;
+      exprt &tmp = comp;
+      tmp = field->to_exprt(ctx, name, name);
+      comp.swap(tmp);
+      t.components().push_back(comp);
+      total_size += std::stoi(comp.type().width().as_string());
+    }
+  }
+
+  // Here is where we add the inherited fields
+
+  // Finally, the structure is ready. Lets add it
+  t.set("width", total_size);
+  added_symbol->type = t;
+
+  // Add the methods and definitions
+  for(auto const &field : body)
+  {
+    if(!std::dynamic_pointer_cast<jimple_class_field>(field))
+    {
+      field->to_exprt(ctx, name, name);
+    }
+  }
+  return e;
+}
diff --git a/src/jimple-frontend/AST/jimple_file.h b/src/jimple-frontend/AST/jimple_file.h
new file mode 100644
index 000000000..adb3a60e6
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_file.h
@@ -0,0 +1,78 @@
+#ifndef ESBMC_JIMPLE_FILE_H
+#define ESBMC_JIMPLE_FILE_H
+
+#include <jimple-frontend/AST/jimple_ast.h>
+#include <jimple-frontend/AST/jimple_modifiers.h>
+#include <jimple-frontend/AST/jimple_class_member.h>
+#include <util/expr.h>
+
+/**
+ * @brief Main AST for Class/Interface
+ *
+ * Every Jimple file contains at most one Class/Interface, this class
+ * will represent this.
+ *
+ * The file can:
+ * - extend (or implement) another Class/Interface
+ * - contain modifiers: public/private/static/etc...
+ *   (see jimple_modifiers.hpp)
+ * - contain methods and attributes.
+ *
+ * Notes:
+ * - Java/Kotlin have support for inner classes. When compiled into bytecode
+ *   each class has its own .class file. For example, an inner class Bar
+ *   inside the Foo class will generate both Foo.class and Foo$Bar.class.
+ */
+class jimple_file : public jimple_ast
+{
+public:
+  // overrides
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override;
+
+  /**
+   * @brief initializes the object with a file
+   *
+   * @param path A path to a .jimple file
+   */
+  void load_file(const std::string &path);
+
+  // A file can be a class or interface
+  enum class file_type
+  {
+    Class,
+    Interface
+  };
+
+  // Get the file_type using a string
+  file_type from_string(const std::string &name) const;
+
+  // Convert file_type into a string
+  std::string to_string(const file_type &ft) const;
+
+  /**
+   * @brief convert the object into a exprt
+   */
+  virtual exprt to_exprt(contextt &ctx) const;
+
+  bool is_interface() const
+  {
+    return mode == file_type::Interface;
+  }
+  file_type mode;
+  std::string class_name;
+  std::string extends;
+  std::string implements;
+  jimple_modifiers modifiers;
+  std::vector<std::shared_ptr<jimple_class_member>> body;
+
+private:
+  std::map<std::string, file_type> from_map = {
+    {"Class", file_type::Class},
+    {"Interface", file_type::Interface}};
+
+  std::map<file_type, std::string> to_map = {
+    {file_type::Class, "Class"},
+    {file_type::Interface, "Interface"}};
+};
+#endif //ESBMC_JIMPLE_FILE_H
diff --git a/src/jimple-frontend/AST/jimple_method.cpp b/src/jimple-frontend/AST/jimple_method.cpp
new file mode 100644
index 000000000..c06844428
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_method.cpp
@@ -0,0 +1,141 @@
+#include <jimple-frontend/AST/jimple_class_member.h>
+#include <util/std_code.h>
+#include <util/expr_util.h>
+
+exprt jimple_method::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &) const
+{
+  // Dummy will be return expression. It will just hold the type
+  exprt dummy;
+  code_typet method_type;
+  typet inner_type;
+  inner_type = type.to_typet(ctx);
+  method_type.return_type() = inner_type;
+
+  auto id = get_method_name(class_name, name);
+  auto symbol = create_jimple_symbolt(method_type, class_name, name, id);
+
+  std::string symbol_name = symbol.id.as_string();
+
+  symbol.lvalue = true;
+  symbol.is_extern = false;
+  symbol.file_local = true;
+
+  ctx.move_symbol_to_context(symbol);
+  symbolt &added_symbol = *ctx.find_symbol(symbol_name);
+
+  // In jimple, every non-static method has access to @this
+  // In future, I will add this as a paremeter to the function call
+  if(!modifiers.is_static())
+  {
+    auto this_type = int_type(); // TODO: support the struct type
+    std::string param_id, param_name;
+
+    std::ostringstream oss;
+    oss << "@this";
+    auto temp = get_symbol_name(class_name, name, oss.str());
+    param_id = temp;
+    param_name = oss.str();
+
+    auto param_symbol =
+      create_jimple_symbolt(this_type, class_name, param_name, param_id, id);
+    param_symbol.lvalue = true;
+    param_symbol.is_parameter = true;
+    param_symbol.file_local = true;
+
+    ctx.move_symbol_to_context(param_symbol);
+
+    code_typet::argumentt param;
+    param.type() = this_type;
+    param.cmt_base_name(param_name);
+    param.cmt_identifier(param_id);
+    method_type.arguments().push_back(param);
+  }
+
+  // In Jimple, every parameter is named as @parameter#
+  for(long unsigned int i = 0; i < parameters.size(); i++)
+  {
+    auto param_type = parameters[i]->to_typet(ctx);
+
+    code_typet::argumentt param;
+
+    std::string param_id, param_name;
+
+    std::ostringstream oss;
+    oss << "@parameter" << i;
+    auto temp = get_symbol_name(class_name, name, oss.str());
+    param_id = temp;
+    param_name = oss.str();
+    param = code_typet::argumentt();
+    param.type() = param_type;
+    param.cmt_base_name(param_name);
+    param.cmt_identifier(param_id);
+
+    auto param_symbol =
+      create_jimple_symbolt(param_type, class_name, param_name, param_id, id);
+    param_symbol.lvalue = true;
+    param_symbol.is_parameter = true;
+    param_symbol.file_local = true;
+
+    ctx.move_symbol_to_context(param_symbol);
+    method_type.arguments().push_back(param);
+  }
+
+  // Apparently, if the type has no arguments, we assume ellipsis
+  if(!method_type.arguments().size())
+    method_type.make_ellipsis();
+
+  added_symbol.type = method_type;
+  added_symbol.value = body->to_exprt(ctx, class_name, this->name);
+
+  return dummy;
+}
+
+void jimple_method::from_json(const json &j)
+{
+  // Method modifiers
+  modifiers = j.at("modifiers").get<jimple_modifiers>();
+
+  // Method type
+  j.at("type").get_to(type);
+
+  for(auto x : j.at("parameters"))
+  {
+    jimple_type t;
+    x.get_to(t);
+    parameters.push_back(std::make_shared<jimple_type>(t));
+  }
+
+  // Method Name
+  j.at("name").get_to(this->name);
+  name +=
+    "_" +
+    get_hash_name(); // to handle polymorphism, the method will have an uuid based on its type and arguments
+  try
+  {
+    j.at("throws").get_to(this->throws);
+  }
+  catch(std::exception &e)
+  {
+    this->throws = "(No throw)";
+  }
+
+  // TODO: Empty body
+  auto j_body = j.at("content");
+  auto values = j_body.get<jimple_full_method_body>();
+  this->body = std::make_shared<jimple_full_method_body>(values);
+}
+std::string jimple_method::to_string() const
+{
+  std::ostringstream oss;
+  oss << "Class Method"
+      << "\n\tName: " << this->name << "\n\t" << this->type.to_string()
+      << "\n\t" << this->modifiers.to_string() << "\n\tParameters: "
+      << "[]" //TODO: this->parameters
+      << "\n\tThrows: " << this->throws
+      << "\n\tBody : " << this->body->to_string();
+
+  return oss.str();
+}
diff --git a/src/jimple-frontend/AST/jimple_method_body.cpp b/src/jimple-frontend/AST/jimple_method_body.cpp
new file mode 100644
index 000000000..92ae06748
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_method_body.cpp
@@ -0,0 +1,168 @@
+#include <jimple-frontend/AST/jimple_method_body.h>
+#include <jimple-frontend/AST/jimple_declaration.h>
+#include <jimple-frontend/AST/jimple_statement.h>
+#include <memory>
+#include <util/std_code.h>
+#include <util/expr_util.h>
+
+exprt jimple_full_method_body::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  /* This is a function body, so we create a `code_blockt` and
+     * populate it with all its statements (`this->members`) */
+  code_blockt block;
+
+  // For each Jimple Statement
+  for(auto const &stmt : this->members)
+  {
+    // Generate the equivalent exprt of the jimple statement
+    auto expression = stmt->to_exprt(ctx, class_name, function_name);
+
+    // Get a location for the class and this function
+    auto l = jimple_ast::get_location(class_name, function_name);
+
+    // If the original line is known, then we set it
+    if(stmt->line_location != -1)
+      l.set_line(stmt->line_location);
+
+    expression.location() = l;
+
+    // Add the expression into the block
+    block.operands().push_back(expression);
+  }
+
+  return block;
+}
+
+void jimple_full_method_body::from_json(const json &stmts)
+{
+  /* In Jimple, locations are set through attributes and it
+     * applied to every instruction after it:
+     *
+     *  \* 2  \*  <--- Comment
+     *  a = 3;
+     *  b = 4;
+     *
+     * This means that both statements came from line 2.
+     * To solve this, we threat the location as a Statement.
+     */
+  int inner_location = -1;
+  for(auto &stmt : stmts)
+  {
+    std::shared_ptr<jimple_method_field> to_add;
+
+    auto mode = stmt.at("object").get<std::string>();
+    // I think that this is the best way without
+    // adding some crazy function pointer.
+    switch(from_map[mode])
+    {
+    case statement::Declaration:
+    {
+      jimple_declaration d;
+      stmt.get_to(d);
+      to_add = std::make_shared<jimple_declaration>(d);
+      break;
+    }
+    case statement::Location:
+    {
+      /*
+         * After parsing the Jimple, the JSON will parse
+         * the location as a string and set it to the
+         * inner location (see comment above about inner_location)
+         */
+      std::string location_str;
+      stmt.at("line").get_to(location_str);
+      inner_location = std::stoi(location_str);
+      // Location is not a real statement, continue to the next.
+      continue;
+    }
+    case statement::Identity:
+    {
+      jimple_identity s;
+      stmt.at("statement").at("identity").get_to(s);
+      to_add = std::make_shared<jimple_identity>(s);
+      break;
+    }
+    case statement::StaticInvoke:
+    {
+      jimple_invoke s;
+      stmt.get_to(s);
+      to_add = std::make_shared<jimple_invoke>(s);
+      break;
+    }
+    case statement::VirtualInvoke:
+    {
+      jimple_invoke s;
+      stmt.get_to(s);
+      to_add = std::make_shared<jimple_invoke>(s);
+      break;
+    }
+    case statement::SpecialInvoke:
+    {
+      jimple_invoke s;
+      stmt.get_to(s);
+      to_add = std::make_shared<jimple_invoke>(s);
+      break;
+    }
+    case statement::Return:
+    {
+      jimple_return s;
+      stmt.get_to(s);
+      to_add = std::make_shared<jimple_return>(s);
+      break;
+    }
+    case statement::Label:
+    {
+      jimple_label s;
+      stmt.get_to(s);
+      to_add = std::make_shared<jimple_label>(s);
+      break;
+    }
+    case statement::Goto:
+    {
+      jimple_goto s;
+      stmt.get_to(s);
+      to_add = std::make_shared<jimple_goto>(s);
+      break;
+    }
+    case statement::Assignment:
+    {
+      jimple_assignment s;
+      stmt.get_to(s);
+      to_add = std::make_shared<jimple_assignment>(s);
+      break;
+    }
+    case statement::Throw:
+    {
+      jimple_throw s;
+      stmt.get_to(s);
+      to_add = std::make_shared<jimple_throw>(s);
+      break;
+    }
+    case statement::If:
+    {
+      jimple_if s;
+      stmt.get_to(s);
+      to_add = std::make_shared<jimple_if>(s);
+      break;
+    }
+    default:
+      log_error("Unknown type {}", stmt);
+      abort();
+    }
+
+    to_add->line_location = inner_location;
+    members.push_back(std::move(to_add));
+  }
+}
+std::string jimple_full_method_body::to_string() const
+{
+  std::ostringstream oss;
+  for(auto &x : members)
+  {
+    oss << "\n\t\t" << x->to_string();
+  }
+  return oss.str();
+}
diff --git a/src/jimple-frontend/AST/jimple_method_body.h b/src/jimple-frontend/AST/jimple_method_body.h
new file mode 100644
index 000000000..25ff3cf21
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_method_body.h
@@ -0,0 +1,111 @@
+#ifndef ESBMC_JIMPLE_METHOD_BODY_H
+#define ESBMC_JIMPLE_METHOD_BODY_H
+
+#include <jimple-frontend/AST/jimple_ast.h>
+#include <util/std_code.h>
+
+/**
+ * @brief A Jimple method declaration
+ *
+ * Something such as: public void foo() { }
+ */
+class jimple_method_body : public jimple_ast
+{
+public:
+  virtual exprt
+  to_exprt(contextt &, const std::string &, const std::string &) const
+  {
+    exprt dummy;
+    return dummy;
+  }
+};
+
+/**
+ * @brief The contents of a Jimple method
+ *
+ * This can be statements or declarations
+ */
+class jimple_method_field : public jimple_ast
+{
+public:
+  virtual exprt
+  to_exprt(contextt &, const std::string &, const std::string &) const
+  {
+    code_skipt dummy;
+    return dummy;
+  }
+};
+
+/**
+ * @brief A Jimple method definition
+ *
+ * Something such as: public void foo();
+ */
+class jimple_empty_method_body : public jimple_method_body
+{
+};
+
+/**
+ * @brief A Jimple method definition
+ *
+ * Something such as: public void foo() { }
+ */
+class jimple_full_method_body : public jimple_method_body
+{
+public:
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override;
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+
+  enum class statement
+  {
+    Assignment, // A = 42
+    Identity, // @this, @parameter0, @parameter1, ...; This will be removed as it can solved directly in the frontend
+    StaticInvoke, // foo() (where foo is a static function)
+    SpecialInvoke, // Special methods of the class: constructors/static-constructor
+    VirtualInvoke, // A.foo() (where A is an object)
+    Return,        // return; return 42;
+    Label,         // 1:, 2:; (GOTO labels)
+    Goto,          // goto 1;
+    If,            // if <expr> goto <Label>
+    Declaration,   // int a;
+    Throw,         // throw <expr>
+    Location       // Extra, reffers to the line number
+  };
+
+  std::vector<std::shared_ptr<jimple_method_field>> members;
+
+private:
+  std::map<std::string, statement> from_map = {
+    {"Variable", statement::Declaration},
+    {"identity", statement::Identity},
+    {"StaticInvoke", statement::StaticInvoke},
+    {"SpecialInvoke", statement::SpecialInvoke},
+    {"VirtualInvoke", statement::VirtualInvoke},
+    {"Return", statement::Return},
+    {"Label", statement::Label},
+    {"Goto", statement::Goto},
+    {"SetVariable", statement::Assignment},
+    {"If", statement::If},
+    {"Throw", statement::Throw},
+    {"Location", statement::Location}};
+
+  std::map<statement, std::string> to_map = {
+    {statement::Identity, "Identity"},
+    {statement::StaticInvoke, "StaticInvoke"},
+    {statement::SpecialInvoke, "SpecialInvoke"},
+    {statement::VirtualInvoke, "VirtualInvoke"},
+    {statement::Return, "Return"},
+    {statement::Label, "Label"},
+    {statement::Goto, "Goto"},
+    {statement::Assignment, "Assignment"},
+    {statement::If, "If"},
+    {statement::Declaration, "Declaration"},
+    {statement::Throw, "Throw"},
+    {statement::Location, "Location"}};
+};
+
+#endif //ESBMC_JIMPLE_METHOD_BODY_H
diff --git a/src/jimple-frontend/AST/jimple_modifiers.cpp b/src/jimple-frontend/AST/jimple_modifiers.cpp
new file mode 100644
index 000000000..c8932ddd0
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_modifiers.cpp
@@ -0,0 +1,33 @@
+#include <jimple-frontend/AST/jimple_modifiers.h>
+void jimple_modifiers::from_json(const json &j)
+{
+  auto modifiers_list = j.get<std::vector<std::string>>();
+  for(auto &modifier : modifiers_list)
+  {
+    this->modifiers.push_back(from_string(modifier));
+  }
+}
+
+jimple_modifiers::modifier
+jimple_modifiers::from_string(const std::string &name) const
+{
+  return from_map.at(name);
+}
+std::string
+jimple_modifiers::to_string(const jimple_modifiers::modifier &ft) const
+{
+  return to_map.at(ft);
+}
+std::string jimple_modifiers::to_string() const
+{
+  std::ostringstream oss;
+
+  oss << "Modifiers: ||";
+  for(auto &modifier : this->modifiers)
+  {
+    oss << " " << to_string(modifier) << " |";
+  }
+  oss << "|";
+
+  return oss.str();
+}
diff --git a/src/jimple-frontend/AST/jimple_modifiers.h b/src/jimple-frontend/AST/jimple_modifiers.h
new file mode 100644
index 000000000..9b8d225b3
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_modifiers.h
@@ -0,0 +1,101 @@
+#ifndef ESBMC_JIMPLE_MODIFIERS_H
+#define ESBMC_JIMPLE_MODIFIERS_H
+
+#include <jimple-frontend/AST/jimple_ast.h>
+
+/**
+ * @brief AST parsing for modifiers
+ *
+ * This should hold every modifier e.g. final, private
+ * and etc...
+ *
+ * We will probably only care for Static and Native thought
+ */
+class jimple_modifiers : public jimple_ast
+{
+public:
+  // overrides
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override;
+
+  enum class modifier
+  {
+    Abstract,
+    Final,
+    Native, // C/C++ calls through JNI
+    Public,
+    Protected,
+    Private,
+    Static,
+    Synchronized,
+    Transient,
+    Volatile,
+    StrictFp,
+    Enum,
+    Annotation
+  };
+  virtual modifier from_string(const std::string &name) const;
+  virtual std::string to_string(const modifier &ft) const;
+
+  bool contains(modifier other) const
+  {
+    return std::find(modifiers.begin(), modifiers.end(), other) !=
+           modifiers.end();
+  }
+
+  bool is_static() const
+  {
+    return contains(modifier::Static);
+  }
+
+  bool is_public() const
+  {
+    return contains(modifier::Public);
+  }
+
+  bool is_private() const
+  {
+    return contains(modifier::Private);
+  }
+
+  modifier at(const int i) const
+  {
+    return modifiers[i];
+  }
+
+protected:
+  std::vector<modifier> modifiers;
+
+private:
+  std::map<std::string, modifier> from_map = {
+    {"abstract", modifier::Abstract},
+    {"final", modifier::Final},
+    {"native", modifier::Native},
+    {"public", modifier::Public},
+    {"protected", modifier::Protected},
+    {"private", modifier::Private},
+    {"static", modifier::Static},
+    {"synchronized", modifier::Synchronized},
+    {"transient", modifier::Transient},
+    {"volatile", modifier::Volatile},
+    {"strictFp", modifier::StrictFp},
+    {"enum", modifier::Enum},
+    {"annotation", modifier::Annotation}};
+
+  std::map<modifier, std::string> to_map = {
+    {modifier::Abstract, "Abstract"},
+    {modifier::Final, "Final"},
+    {modifier::Native, "Native"},
+    {modifier::Public, "Public"},
+    {modifier::Protected, "Protected"},
+    {modifier::Private, "Private"},
+    {modifier::Static, "Static"},
+    {modifier::Synchronized, "Synchronized"},
+    {modifier::Transient, "Transient"},
+    {modifier::Volatile, "Volatile"},
+    {modifier::StrictFp, "StrictFp"},
+    {modifier::Enum, "Enum"},
+    {modifier::Annotation, "Annotation"}};
+};
+
+#endif //ESBMC_JIMPLE_MODIFIERS_H
diff --git a/src/jimple-frontend/AST/jimple_statement.cpp b/src/jimple-frontend/AST/jimple_statement.cpp
new file mode 100644
index 000000000..2852060e9
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_statement.cpp
@@ -0,0 +1,443 @@
+#include <util/std_code.h>
+#include <util/std_expr.h>
+#include <util/std_types.h>
+#include <jimple-frontend/AST/jimple_statement.h>
+#include <util/arith_tools.h>
+#include "util/c_typecast.h"
+
+void jimple_identity::from_json(const json &j)
+{
+  j.at("identifier").get_to(at_identifier);
+  j.at("name").get_to(local_name);
+  j.at("type").get_to(type);
+}
+
+exprt jimple_identity::to_exprt(
+  contextt &ctx,
+  const std::string &,
+  const std::string &) const
+{
+  // TODO: Symbol-table / Typecast
+  exprt val("at_identifier");
+  symbolt &added_symbol = *ctx.find_symbol(local_name);
+  symbolt rhs;
+  rhs.name = "@" + at_identifier;
+  rhs.id = "@" + at_identifier;
+  code_assignt assign(symbol_expr(added_symbol), symbol_expr(rhs));
+  return assign;
+}
+std::string jimple_identity::to_string() const
+{
+  std::ostringstream oss;
+  oss << "Identity:  " << this->local_name << " = @" << at_identifier << " | "
+      << type.to_string();
+  return oss.str();
+}
+
+exprt jimple_return::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  // TODO: jimple return with support to other returns
+  typet return_type = empty_typet();
+  code_returnt ret_expr;
+  if(expr)
+  {
+    auto return_value = expr->to_exprt(ctx, class_name, function_name);
+    ret_expr.op0() = return_value;
+  }
+  // TODO: jimple return should support values
+  return ret_expr;
+}
+
+std::string jimple_return::to_string() const
+{
+  return "Return: (Nothing)";
+}
+void jimple_return::from_json(const json &j)
+{
+  if(j.contains("value"))
+    expr = jimple_expr::get_expression(j.at("value"));
+}
+std::string jimple_label::to_string() const
+{
+  std::ostringstream oss;
+  oss << "Label: " << this->label;
+  for(auto member : this->members->members)
+    oss << "\n\t\t\t" << member->to_string();
+  return oss.str();
+}
+
+exprt jimple_label::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  // TODO: DRY (clang-c-converter)
+  code_labelt c_label;
+  c_label.set_label(label);
+
+  code_blockt block;
+  for(auto member : members->members)
+  {
+    block.operands().push_back(
+      std::move(member->to_exprt(ctx, class_name, function_name)));
+  }
+  c_label.code() = to_code(block);
+
+  return c_label;
+}
+
+void jimple_goto::from_json(const json &j)
+{
+  j.at("goto").get_to(label);
+}
+
+std::string jimple_goto::to_string() const
+{
+  std::ostringstream oss;
+  oss << "Goto: " << this->label;
+  return oss.str();
+}
+
+exprt jimple_goto::to_exprt(
+  contextt &,
+  const std::string &,
+  const std::string &) const
+{
+  code_gotot code_goto;
+  code_goto.set_destination(label);
+  return code_goto;
+}
+
+void jimple_label::from_json(const json &j)
+{
+  j.at("label_id").get_to(label);
+  jimple_full_method_body b;
+  b.from_json(j.at("content"));
+  members = std::make_shared<jimple_full_method_body>(b);
+}
+
+std::string jimple_assignment::to_string() const
+{
+  std::ostringstream oss;
+  oss << "Assignment: " << lhs->to_string() << " = " << rhs->to_string();
+  return oss.str();
+}
+
+void jimple_assignment::from_json(const json &j)
+{
+  lhs = jimple_expr::get_expression(j.at("lhs"));
+  rhs = jimple_expr::get_expression(j.at("rhs"));
+}
+
+exprt jimple_assignment::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  //TODO: Remove this hack
+  if(is_skip)
+  {
+    code_skipt skip;
+    return skip;
+  }
+
+  auto lhs_handle = lhs->to_exprt(ctx, class_name, function_name);
+
+  auto dyn_expr = std::dynamic_pointer_cast<jimple_expr_invoke>(rhs);
+  if(dyn_expr && !dyn_expr->is_nondet_call() && !dyn_expr->is_intrinsic_method)
+  {
+    dyn_expr->set_lhs(lhs_handle);
+    return rhs->to_exprt(ctx, class_name, function_name);
+  }
+
+  auto dyn2_expr = std::dynamic_pointer_cast<jimple_virtual_invoke>(rhs);
+  if(dyn2_expr && !dyn2_expr->is_nondet_call())
+  {
+    dyn2_expr->set_lhs(lhs_handle);
+    return rhs->to_exprt(ctx, class_name, function_name);
+  }
+
+  auto from_expr = rhs->to_exprt(ctx, class_name, function_name);
+  c_typecastt c_typecast(ctx);
+  c_typecast.implicit_typecast(from_expr, lhs_handle.type());
+
+  code_assignt assign(lhs_handle, from_expr);
+  return assign;
+}
+
+/*
+std::string jimple_assignment_deref::to_string() const
+{
+  std::ostringstream oss;
+  oss << "Assignment: " << variable << "[" << pos->to_string()
+      << "]  = " << expr->to_string();
+  return oss.str();
+}
+
+void jimple_assignment_deref::from_json(const json &j)
+{
+  j.at("name").get_to(variable);
+  expr = jimple_expr::get_expression(j.at("value"));
+  pos = jimple_expr::get_expression(j.at("pos"));
+}
+
+exprt jimple_assignment_deref::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  jimple_symbol s(variable);
+
+  jimple_deref d(pos, std::make_shared<jimple_symbol>(s));
+
+  code_assignt assign(
+    d.to_exprt(ctx, class_name, function_name),
+    expr->to_exprt(ctx, class_name, function_name));
+  return assign;
+}
+
+std::string jimple_assignment_field::to_string() const
+{
+  std::ostringstream oss;
+  oss << "Assignment: " << variable << "->" << field << " = " << expr->to_string();
+  return oss.str();
+}
+
+void jimple_assignment_field::from_json(const json &j)
+{
+  j.at("name").get_to(variable);
+  j.at("field").get_to(field);
+  expr = jimple_expr::get_expression(j.at("value"));
+}
+
+exprt jimple_assignment_field::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+    // 1. Look over the local scope
+  auto symbol_name = get_symbol_name(class_name, function_name, variable);
+  symbolt &s = *ctx.find_symbol(symbol_name);
+  member_exprt op(symbol_expr(s), "tag-" + field, s.type);
+  exprt &base = op.struct_op();
+  if(base.type().is_pointer())
+  {
+    exprt deref("dereference");
+    deref.type() = base.type().subtype();
+    deref.move_to_operands(base);
+    base.swap(deref);
+  }
+
+  code_assignt assign(
+    op,
+    expr->to_exprt(ctx, class_name, function_name));
+  return assign;
+}
+*/
+
+std::string jimple_if::to_string() const
+{
+  std::ostringstream oss;
+  oss << "If: " << cond->to_string() << " THEN GOTO " << label;
+  return oss.str();
+}
+
+void jimple_if::from_json(const json &j)
+{
+  cond = jimple_expr::get_expression(j.at("expression"));
+  j.at("goto").get_to(label);
+}
+
+exprt jimple_if::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  code_gotot code_goto;
+  code_goto.set_destination(label);
+
+  auto condition = cond->to_exprt(ctx, class_name, function_name);
+  codet if_expr("ifthenelse");
+  if_expr.copy_to_operands(condition, code_goto);
+
+  return if_expr;
+}
+
+std::string jimple_assertion::to_string() const
+{
+  std::ostringstream oss;
+  oss << "Assertion: " << variable << " = " << value;
+  return oss.str();
+}
+
+void jimple_assertion::from_json(const json &j)
+{
+  j.at("equals").at("symbol").get_to(variable);
+  j.at("equals").at("value").get_to(value);
+}
+
+exprt jimple_assertion::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  code_function_callt call;
+
+  std::ostringstream oss;
+  oss << class_name << ":" << function_name << "@" << variable;
+
+  // TODO: move this from here
+  std::string id, name;
+  id = "__ESBMC_assert";
+  name = "__ESBMC_assert";
+
+  auto symbol =
+    create_jimple_symbolt(code_typet(), class_name, name, id, function_name);
+
+  symbolt &added_symbol = *ctx.move_symbol_to_context(symbol);
+
+  call.function() = symbol_expr(added_symbol);
+
+  symbolt &test = *ctx.find_symbol(oss.str());
+  int as_number = std::stoi(value);
+  exprt value_operand = from_integer(as_number, int_type());
+
+  equality_exprt ge(symbol_expr(test), value_operand);
+  not_exprt qwe(ge);
+  call.arguments().push_back(qwe);
+
+  array_of_exprt arr;
+  // TODO: Create binop operation between symbol and value
+  return call;
+}
+
+std::string jimple_invoke::to_string() const
+{
+  std::ostringstream oss;
+  oss << "Invoke: " << method;
+  return oss.str();
+}
+
+void jimple_invoke::from_json(const json &j)
+{
+  j.at("base_class").get_to(base_class);
+  j.at("method").get_to(method);
+  if(j.contains("variable"))
+    j.at("variable").get_to(variable);
+  for(auto x : j.at("parameters"))
+  {
+    parameters.push_back(std::move(jimple_expr::get_expression(x)));
+  }
+  method += "_" + get_hash_name();
+}
+
+exprt jimple_invoke::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  // TODO: Move intrinsics to backend
+  if(base_class == "kotlin.jvm.internal.Intrinsics")
+  {
+    code_skipt skip;
+    return skip;
+  }
+
+  // TODO: Move intrinsics to backend
+  if(base_class == "java.lang.Runtime")
+  {
+    code_skipt skip;
+    return skip;
+  }
+
+  // Don't care for the default object constructor
+  if(base_class == "java.lang.Object")
+  {
+    code_skipt skip;
+    return skip;
+  }
+
+  // Don't care for Random
+  if(base_class == "java.util.Random")
+  {
+    code_skipt skip;
+    return skip;
+  }
+
+  // Don't care for Random
+  if(base_class == "java.lang.String")
+  {
+    code_skipt skip;
+    return skip;
+  }
+
+  if(base_class == "java.lang.AssertionError")
+  {
+    code_skipt skip;
+    return skip;
+  }
+
+  code_blockt block;
+  code_function_callt call;
+
+  std::ostringstream oss;
+  oss << base_class << ":" << method;
+  auto symbol = ctx.find_symbol(oss.str());
+  call.function() = symbol_expr(*symbol);
+
+  if(variable != "")
+  {
+    // Let's add @THIS
+    auto this_expression =
+      jimple_symbol(variable).to_exprt(ctx, class_name, function_name);
+    call.arguments().push_back(this_expression);
+    auto temp = get_symbol_name(base_class, method, "@this");
+    symbolt &added_symbol = *ctx.find_symbol(temp);
+    code_assignt assign(symbol_expr(added_symbol), this_expression);
+    block.operands().push_back(assign);
+  }
+
+  for(unsigned long int i = 0; i < parameters.size(); i++)
+  {
+    // Just adding the arguments should be enough to set the parameters
+    auto parameter_expr =
+      parameters[i]->to_exprt(ctx, class_name, function_name);
+    call.arguments().push_back(parameter_expr);
+    // Hack, manually adding parameters
+    std::ostringstream oss;
+    oss << "@parameter" << i;
+    auto temp = get_symbol_name(base_class, method, oss.str());
+    symbolt &added_symbol = *ctx.find_symbol(temp);
+    code_assignt assign(symbol_expr(added_symbol), parameter_expr);
+    block.operands().push_back(assign);
+  }
+  block.operands().push_back(call);
+  return block;
+}
+
+std::string jimple_throw::to_string() const
+{
+  std::ostringstream oss;
+  oss << "Throw: " << expr->to_string();
+  return oss.str();
+}
+
+void jimple_throw::from_json(const json &j)
+{
+  expr = jimple_expr::get_expression(j.at("expr"));
+}
+
+exprt jimple_throw::to_exprt(
+  contextt &ctx,
+  const std::string &class_name,
+  const std::string &function_name) const
+{
+  codet p = codet("cpp-throw");
+  //TODO: throw
+  auto to_add = expr->to_exprt(ctx, class_name, function_name);
+  p.move_to_operands(to_add);
+  return p;
+}
diff --git a/src/jimple-frontend/AST/jimple_statement.h b/src/jimple-frontend/AST/jimple_statement.h
new file mode 100644
index 000000000..5b8b64dba
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_statement.h
@@ -0,0 +1,187 @@
+#ifndef ESBMC_JIMPLE_STATEMENT_H
+#define ESBMC_JIMPLE_STATEMENT_H
+
+#include <jimple-frontend/AST/jimple_method_body.h>
+#include <jimple-frontend/AST/jimple_type.h>
+#include <jimple-frontend/AST/jimple_expr.h>
+
+/**
+ * @brief Base class for Jimple Statements.
+ */
+class jimple_statement : public jimple_method_field
+{
+};
+
+// THIS IS STILL A TODO FROM THE STANDARD
+class jimple_identity : public jimple_statement
+{
+public:
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override;
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+
+  std::string local_name;
+  std::string at_identifier;
+  jimple_type type;
+};
+
+/**
+ * @brief A function call
+ *
+ * foo(42);
+ */
+class jimple_invoke : public jimple_statement
+{
+public:
+  virtual std::string to_string() const override;
+  virtual void from_json(const json &j) override;
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+
+  // We need an unique name for each function
+  std::string get_hash_name() const
+  {
+    // TODO: use some hashing to also use the types
+    // TODO: DRY
+    auto increment = variable != "" ? 1 : 0;
+    return std::to_string(parameters.size() + increment);
+  }
+  std::string base_class;
+  std::string method;
+  std::string variable =
+    ""; // TODO: Specialization jimple_invoke and jimple_virtual_invoke!!!
+  std::vector<std::shared_ptr<jimple_expr>> parameters;
+};
+
+/**
+ * @brief Return statement
+ *
+ * return 42;
+ */
+class jimple_return : public jimple_statement
+{
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+  virtual std::string to_string() const override;
+  virtual void from_json(const json &j) override;
+  std::shared_ptr<jimple_expr> expr;
+};
+
+/**
+ * @brief A GOTO label
+ *
+ * label1:
+ *    ...
+ */
+class jimple_label : public jimple_statement
+{
+public:
+  virtual std::string to_string() const override;
+  virtual void from_json(const json &j) override;
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+
+  std::string label;
+  std::shared_ptr<jimple_full_method_body> members;
+};
+
+/**
+ * @brief Goto statement
+ *
+ * goto label1;
+ */
+class jimple_goto : public jimple_statement
+{
+public:
+  virtual std::string to_string() const override;
+  virtual void from_json(const json &j) override;
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+
+  std::string label;
+};
+
+/**
+ * @brief An assignment statement
+ *
+ * a = 42;
+ */
+class jimple_assignment : public jimple_statement
+{
+public:
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+  virtual std::string to_string() const override;
+  virtual void from_json(const json &j) override;
+
+  std::shared_ptr<jimple_expr> lhs;
+  std::shared_ptr<jimple_expr> rhs;
+  bool is_skip = false;
+};
+
+// For debug
+class jimple_assertion : public jimple_statement
+{
+public:
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+  virtual std::string to_string() const override;
+  virtual void from_json(const json &j) override;
+
+  std::string variable;
+  std::string value;
+};
+
+/**
+ * @brief An IF statement
+ *
+ * if 2 > 4 goto label3;
+ */
+class jimple_if : public jimple_statement
+{
+public:
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+  virtual std::string to_string() const override;
+  virtual void from_json(const json &j) override;
+
+  std::shared_ptr<jimple_expr> cond;
+  std::string label;
+};
+
+/**
+ * @brief A throw statement
+ *
+ * throw 0;
+ *
+ */
+class jimple_throw : public jimple_statement
+{
+  virtual exprt to_exprt(
+    contextt &ctx,
+    const std::string &class_name,
+    const std::string &function_name) const override;
+  virtual std::string to_string() const override;
+  virtual void from_json(const json &j) override;
+
+  std::shared_ptr<jimple_expr> expr;
+};
+
+#endif //ESBMC_JIMPLE_STATEMENT_H
diff --git a/src/jimple-frontend/AST/jimple_type.cpp b/src/jimple-frontend/AST/jimple_type.cpp
new file mode 100644
index 000000000..dc7c1b2f1
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_type.cpp
@@ -0,0 +1,44 @@
+#include <jimple-frontend/AST/jimple_type.h>
+
+void jimple_type::from_json(const json &j)
+{
+  j.at("identifier").get_to(name);
+  j.at("dimensions").get_to(dimensions);
+
+  bt = from_map.count(name) != 0 ? from_map[name] : BASE_TYPES::OTHER;
+}
+
+typet jimple_type::get_base_type(const contextt &ctx) const
+{
+  switch(bt)
+  {
+  case BASE_TYPES::INT:
+    return int_type();
+
+  case BASE_TYPES::BOOLEAN:
+    return bool_type();
+
+  case BASE_TYPES::_VOID:
+    return empty_typet();
+
+  default:
+    auto symbol = ctx.find_symbol("tag-" + name);
+    if(symbol == nullptr)
+      throw "Type not found: " + name;
+    return pointer_typet(symbol->type);
+  }
+}
+
+typet jimple_type::to_typet(const contextt &ctx) const
+{
+  if(is_array())
+    return get_arr_type(ctx);
+  return get_base_type(ctx);
+}
+
+std::string jimple_type::to_string() const
+{
+  std::ostringstream oss;
+  oss << "Type: " << name << " [" << dimensions << "]";
+  return oss.str();
+}
diff --git a/src/jimple-frontend/AST/jimple_type.h b/src/jimple-frontend/AST/jimple_type.h
new file mode 100644
index 000000000..eec7f1032
--- /dev/null
+++ b/src/jimple-frontend/AST/jimple_type.h
@@ -0,0 +1,73 @@
+#ifndef ESBMC_JIMPLE_TYPE_H
+#define ESBMC_JIMPLE_TYPE_H
+
+#include <jimple-frontend/AST/jimple_ast.h>
+#include <util/std_code.h>
+#include <util/c_types.h>
+#include <util/expr_util.h>
+
+// TODO: Specialize this class
+class jimple_type : public jimple_ast
+{
+public:
+  virtual void from_json(const json &j) override;
+  virtual std::string to_string() const override;
+  virtual typet to_typet(const contextt &ctx) const;
+
+  bool is_array() const
+  {
+    return dimensions > 0;
+  }
+
+  std::string name; // e.g. int[][][][][] => name = int
+  short dimensions; // e.g. int[][][][][] => dimensions = 5
+
+protected:
+  typet get_base_type(const contextt &ctx) const;
+  typet get_builtin_type() const;
+
+  typet get_arr_type(const contextt &ctx) const
+  {
+    typet base = get_base_type(ctx);
+    typet ptr_type = pointer_typet(base);
+    for(int i = 1; i < dimensions; i++)
+      ptr_type = pointer_typet(ptr_type);
+
+    return ptr_type;
+  }
+
+private:
+  enum class BASE_TYPES
+  {
+    INT,
+    BOOLEAN,
+    _VOID,
+    OTHER
+  };
+  BASE_TYPES bt;
+  std::map<std::string, BASE_TYPES> from_map = {
+    /* Basic JVM types  */
+    {"int", BASE_TYPES::INT},
+    {"byte", BASE_TYPES::INT},
+    {"char", BASE_TYPES::INT},
+    {"short", BASE_TYPES::INT},
+    {"boolean", BASE_TYPES::INT},
+    {"long", BASE_TYPES::INT},
+    {"float", BASE_TYPES::INT},
+    {"double", BASE_TYPES::INT},
+    {"void", BASE_TYPES::_VOID},
+    /* Basic Java classes that can work as primitive types */
+    {"java.lang.Integer", BASE_TYPES::INT},
+    {"java.util.Random",
+     BASE_TYPES::
+       INT}, // We dont really care about the initialization of this mode
+    {"java.lang.String", BASE_TYPES::INT}, // TODO: handle this properly
+    /* TODO: these are hacks and should be moved into an intrinsics class */
+    {"Main", BASE_TYPES::INT},                     // TODO: handle this properly
+    {"java.lang.AssertionError", BASE_TYPES::INT}, // TODO: handle this properly
+    {"java.lang.Runtime", BASE_TYPES::INT},        // TODO: handle this properly
+    {"java.lang.Class", BASE_TYPES::INT},          // TODO: handle this properly
+    {"__other", BASE_TYPES::OTHER}};
+};
+
+#endif //ESBMC_JIMPLE_TYPE_H
diff --git a/src/jimple-frontend/CMakeLists.txt b/src/jimple-frontend/CMakeLists.txt
new file mode 100644
index 000000000..14812d77f
--- /dev/null
+++ b/src/jimple-frontend/CMakeLists.txt
@@ -0,0 +1,15 @@
+add_subdirectory(AST)
+add_library(jimple
+        jimple-language.cpp
+        jimple-parser.cpp
+        jimple-typecheck.cpp
+        jimple-converter.cpp)
+
+# Boost is needed by anything that touches irep2
+target_include_directories(jimple
+        PUBLIC ${Boost_INCLUDE_DIRS})
+
+target_include_directories(jimple_ast
+        PUBLIC ${Boost_INCLUDE_DIRS})
+
+target_link_libraries(jimple clibs jimple_ast ${Boost_LIBRARIES} fmt::fmt nlohmann_json::nlohmann_json)
diff --git a/src/jimple-frontend/jimple-converter.cpp b/src/jimple-frontend/jimple-converter.cpp
new file mode 100644
index 000000000..a44f3ed60
--- /dev/null
+++ b/src/jimple-frontend/jimple-converter.cpp
@@ -0,0 +1,7 @@
+#include <jimple-frontend/jimple-converter.h>
+
+bool jimple_converter::convert()
+{
+  AST.to_exprt(context);
+  return false;
+}
diff --git a/src/jimple-frontend/jimple-converter.h b/src/jimple-frontend/jimple-converter.h
new file mode 100644
index 000000000..edff68dcc
--- /dev/null
+++ b/src/jimple-frontend/jimple-converter.h
@@ -0,0 +1,19 @@
+#ifndef ESBMC_JIMPLE_CONVERTER_H
+#define ESBMC_JIMPLE_CONVERTER_H
+
+#include <jimple-frontend/jimple-language.h>
+class jimple_converter
+{
+public:
+  jimple_converter(contextt &_context, jimple_file &_ASTs)
+    : context(_context), AST(_ASTs)
+  {
+  }
+  bool convert();
+
+protected:
+  contextt &context;
+  const jimple_file &AST;
+};
+
+#endif //ESBMC_JIMPLE_CONVERTER_H
diff --git a/src/jimple-frontend/jimple-language.cpp b/src/jimple-frontend/jimple-language.cpp
new file mode 100644
index 000000000..2d3c6cf9e
--- /dev/null
+++ b/src/jimple-frontend/jimple-language.cpp
@@ -0,0 +1,196 @@
+#include <assert.h>
+#include <jimple-frontend/jimple-language.h>
+
+#include <c2goto/cprover_library.h>
+
+languaget *new_jimple_language()
+{
+  return new jimple_languaget;
+}
+
+bool jimple_languaget::final(contextt &context)
+{
+  log_status("Adding cprover library");
+  add_cprover_library(context);
+
+  add_intrinsics(context);
+  log_status("Adding __ESBMC_main");
+  setup_main(context);
+  return false;
+}
+
+bool jimple_languaget::from_type(
+  const typet &,
+  std::string &,
+  const namespacet &)
+{
+  // TODO
+  assert(!"Not implemented yet");
+  return false;
+}
+
+bool jimple_languaget::from_expr(
+  const exprt &,
+  std::string &,
+  const namespacet &)
+{
+  // TODO
+  assert(!"Not implemented yet");
+  return false;
+}
+
+static inline void init_variable(codet &dest, const symbolt &sym)
+{
+  const exprt &value = sym.value;
+
+  if(value.is_nil())
+    return;
+
+  assert(!value.type().is_code());
+
+  exprt symbol("symbol", sym.type);
+  symbol.identifier(sym.id);
+
+  code_assignt code(symbol, sym.value);
+  code.location() = sym.location;
+
+  dest.move_to_operands(code);
+}
+
+static inline void static_lifetime_init(const contextt &context, codet &dest)
+{
+  dest = code_blockt();
+
+  // Do assignments based on "value".
+  context.foreach_operand_in_order([&dest](const symbolt &s) {
+    if(s.static_lifetime)
+      init_variable(dest, s);
+  });
+
+  // call designated "initialization" functions
+  context.foreach_operand_in_order([&dest](const symbolt &s) {
+    if(s.type.initialization() && s.type.is_code())
+    {
+      code_function_callt function_call;
+      function_call.function() = symbol_expr(s);
+      dest.move_to_operands(function_call);
+    }
+  });
+}
+
+static void
+add_global_static_variable(contextt &ctx, const typet t, std::string name)
+{
+  // TODO: Maybe they should be part of Jimple context?
+  std::string id = "c:@" + name;
+  symbolt symbol;
+  symbol.mode = "C";
+  symbol.type = std::move(t);
+  symbol.name = name;
+  symbol.id = id;
+
+  symbol.lvalue = true;
+  symbol.static_lifetime = true;
+  symbol.is_extern = false;
+  symbol.file_local = false;
+  symbol.value = gen_zero(t, true);
+  symbol.value.zero_initializer(true);
+
+  symbolt &added_symbol = *ctx.move_symbol_to_context(symbol);
+  code_declt decl(symbol_expr(added_symbol));
+}
+
+void jimple_languaget::add_intrinsics(contextt &context)
+{
+  auto type1 = array_typet(bool_type(), exprt("infinity"));
+  add_global_static_variable(context, type1, "__ESBMC_alloc");
+  add_global_static_variable(context, type1, "__ESBMC_deallocated");
+  add_global_static_variable(context, type1, "__ESBMC_is_dynamic");
+
+  auto type2 = array_typet(uint_type(), exprt("infinity"));
+  add_global_static_variable(context, type2, "__ESBMC_alloc_size");
+
+  add_global_static_variable(context, int_type(), "__ESBMC_rounding_mode");
+}
+
+void jimple_languaget::setup_main(contextt &context)
+{
+  irep_idt main_symbol;
+
+  std::string main =
+    (config.main != "") ? config.main : "main_0"; // main(String[])
+
+  // find main symbol
+  std::list<irep_idt> matches;
+
+  forall_symbol_base_map(it, context.symbol_base_map, main)
+  {
+    // look it up
+    symbolt *s = context.find_symbol(it->second);
+
+    if(s == nullptr)
+      continue;
+
+    if(s->type.is_code())
+      matches.push_back(it->second);
+  }
+  if(matches.empty())
+    abort();
+
+  main_symbol = matches.front();
+
+  // look it up
+  symbolt *s = context.find_symbol(main_symbol);
+  if(s == nullptr)
+  {
+    log_error("No main method");
+    abort();
+    return; // give up, no main
+  }
+
+  const symbolt &symbol = *s;
+  // check if it has a body
+  if(symbol.value.is_nil())
+  {
+    log_error("Empty body for main");
+    abort();
+  }
+
+  codet init_code;
+  static_lifetime_init(context, init_code);
+
+  init_code.make_block();
+
+  // build call to function
+
+  code_function_callt call;
+  call.function() = symbol_expr(symbol);
+
+  const code_typet::argumentst &arguments =
+    to_code_type(symbol.type).arguments();
+
+  call.arguments().resize(
+    arguments.size(), static_cast<const exprt &>(get_nil_irep()));
+
+  // TODO: Add Threads?
+  init_code.move_to_operands(call);
+
+  // add "main"
+  symbolt new_symbol;
+
+  code_typet main_type;
+  main_type.return_type() = empty_typet();
+
+  new_symbol.id = "__ESBMC_main";
+  new_symbol.name = "__ESBMC_main";
+  new_symbol.type.swap(main_type);
+  new_symbol.value.swap(init_code);
+
+  if(context.move(new_symbol))
+  {
+    log_error("main already defined by another language module");
+    return;
+  }
+
+  return;
+}
diff --git a/src/jimple-frontend/jimple-language.h b/src/jimple-frontend/jimple-language.h
new file mode 100644
index 000000000..564a3b7a1
--- /dev/null
+++ b/src/jimple-frontend/jimple-language.h
@@ -0,0 +1,42 @@
+#pragma once
+
+#include <langapi/mode.h>
+#include <util/language.h>
+#include <jimple-frontend/AST/jimple_file.h>
+
+class jimple_languaget : public languaget
+{
+public:
+  bool parse(const std::string &path) override;
+
+  bool final(contextt &context) override;
+
+  // AST -> GOTO
+  bool typecheck(contextt &context, const std::string &module) override;
+
+  std::string id() const override
+  {
+    return "jimple_lang";
+  }
+
+  void add_intrinsics(contextt &context);
+
+  void setup_main(contextt &context);
+
+  void show_parse(std::ostream &out) override;
+
+  // conversion from expression into string
+  bool from_expr(const exprt &expr, std::string &code, const namespacet &ns)
+    override;
+
+  // conversion from type into string
+  bool from_type(const typet &type, std::string &code, const namespacet &ns)
+    override;
+
+  virtual languaget *new_language() const override
+  {
+    return new jimple_languaget;
+  }
+
+  jimple_file root;
+};
diff --git a/src/jimple-frontend/jimple-parser.cpp b/src/jimple-frontend/jimple-parser.cpp
new file mode 100644
index 000000000..b074448de
--- /dev/null
+++ b/src/jimple-frontend/jimple-parser.cpp
@@ -0,0 +1,25 @@
+#include <fstream>
+#include <jimple-frontend/AST/jimple_file.h>
+#include <jimple-frontend/jimple-language.h>
+
+void jimple_languaget::show_parse(std::ostream &out)
+{
+  out << root.to_string();
+}
+
+bool jimple_languaget::parse(const std::string &path)
+{
+  log_debug("Parsing: {}", path);
+  try
+  {
+    root.load_file(path);
+  }
+
+  catch(std::exception &e)
+  {
+    log_error("{}", e.what());
+    return true;
+  }
+
+  return false;
+}
diff --git a/src/jimple-frontend/jimple-typecheck.cpp b/src/jimple-frontend/jimple-typecheck.cpp
new file mode 100644
index 000000000..6bbe12457
--- /dev/null
+++ b/src/jimple-frontend/jimple-typecheck.cpp
@@ -0,0 +1,17 @@
+#include <jimple-frontend/jimple-language.h>
+#include <jimple-frontend/jimple-converter.h>
+
+bool jimple_languaget::typecheck(contextt &context, const std::string &)
+{
+  log_status("Converting Jimple module {} to GOTO", root.class_name);
+
+  contextt new_context;
+  jimple_converter converter(context, root);
+  if(converter.convert())
+  {
+    log_error("Failed to convert module {}", root.class_name);
+    return true;
+  }
+
+  return false;
+}
diff --git a/src/langapi/CMakeLists.txt b/src/langapi/CMakeLists.txt
index 6ddb67974..730c8ab4b 100644
--- a/src/langapi/CMakeLists.txt
+++ b/src/langapi/CMakeLists.txt
@@ -1,4 +1,5 @@
 add_library(langapi mode.cpp language_ui.cpp languages.cpp language_util.cpp)
 target_include_directories(langapi
     PRIVATE ${Boost_INCLUDE_DIRS}
-)
\ No newline at end of file
+)
+target_link_libraries(langapi PUBLIC fmt::fmt)
\ No newline at end of file
diff --git a/src/langapi/language_ui.cpp b/src/langapi/language_ui.cpp
index 811352f30..88dec9f9a 100644
--- a/src/langapi/language_ui.cpp
+++ b/src/langapi/language_ui.cpp
@@ -1,20 +1,12 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@cs.cmu.edu
-
-\*******************************************************************/
-
 #include <fstream>
 #include <langapi/language_ui.h>
 #include <langapi/mode.h>
 #include <memory>
 #include <util/i2string.h>
+#include <util/message.h>
 #include <util/show_symbol_table.h>
 
-language_uit::language_uit(const cmdlinet &__cmdline, messaget &msg)
-  : language_files(msg), context(msg), _cmdline(__cmdline), msg(msg)
+language_uit::language_uit(const cmdlinet &__cmdline) : _cmdline(__cmdline)
 {
 }
 
@@ -31,11 +23,12 @@ bool language_uit::parse()
 
 bool language_uit::parse(const std::string &filename)
 {
-  int mode = get_mode_filename(filename);
+  language_idt lang = language_id_by_path(filename);
+  int mode = get_mode(lang);
 
   if(mode < 0)
   {
-    msg.error("failed to figure out type of file", filename);
+    log_error("failed to figure out type of file", filename);
     return true;
   }
 
@@ -44,16 +37,18 @@ bool language_uit::parse(const std::string &filename)
     mode = get_old_frontend_mode(mode);
     if(mode == -1)
     {
-      msg.error("old-frontend was not built on this version of ESBMC");
+      log_error("old-frontend was not built on this version of ESBMC");
       return true;
     }
   }
 
+  config.language = lang;
+
   // Check that it opens
   std::ifstream infile(filename.c_str());
   if(!infile)
   {
-    msg.error("failed to open input file", filename);
+    log_error("failed to open input file", filename);
     return true;
   }
 
@@ -66,19 +61,19 @@ bool language_uit::parse(const std::string &filename)
 
   language_filet &lf = result.first->second;
   lf.filename = filename;
-  lf.language = mode_table[mode].new_language(msg);
+  lf.language = mode_table[mode].new_language();
   languaget &language = *lf.language;
 
-  msg.status("Parsing", filename);
+  log_status("Parsing", filename);
 
 #ifdef ENABLE_SOLIDITY_FRONTEND
-  if(mode == get_mode("Solidity AST"))
+  if(mode == get_mode(language_idt::SOLIDITY))
   {
     language.set_func_name(_cmdline.vm["function"].as<std::string>());
 
     if(config.options.get_option("contract") == "")
     {
-      msg.error("Please set the smart contract source file.");
+      log_error("Please set the smart contract source file.");
       return true;
     }
     else
@@ -88,9 +83,9 @@ bool language_uit::parse(const std::string &filename)
   }
 #endif
 
-  if(language.parse(filename, msg))
+  if(language.parse(filename))
   {
-    msg.error("PARSING ERROR");
+    log_error("PARSING ERROR");
     return true;
   }
 
@@ -101,11 +96,11 @@ bool language_uit::parse(const std::string &filename)
 
 bool language_uit::typecheck()
 {
-  msg.status("Converting");
+  log_status("Converting");
 
   if(language_files.typecheck(context))
   {
-    msg.error("CONVERSION ERROR");
+    log_error("CONVERSION ERROR");
     return true;
   }
 
@@ -116,7 +111,7 @@ bool language_uit::final()
 {
   if(language_files.final(context))
   {
-    msg.error("CONVERSION ERROR");
+    log_error("CONVERSION ERROR");
     return true;
   }
 
@@ -129,10 +124,10 @@ void language_uit::show_symbol_table()
 
 void language_uit::show_symbol_table_xml_ui()
 {
-  msg.error("cannot show symbol table in this format");
+  log_error("cannot show symbol table in this format");
 }
 
 void language_uit::show_symbol_table_plain(std::ostream &out)
 {
-  ::show_symbol_table_plain(namespacet(context), out, msg);
+  ::show_symbol_table_plain(namespacet(context), out);
 }
diff --git a/src/langapi/language_ui.h b/src/langapi/language_ui.h
index d00a138f3..41f67ce26 100644
--- a/src/langapi/language_ui.h
+++ b/src/langapi/language_ui.h
@@ -1,17 +1,8 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@cs.cmu.edu
-
-\*******************************************************************/
-
 #ifndef CPROVER_LANGUAGE_UI_H
 #define CPROVER_LANGUAGE_UI_H
 
 #include <util/language.h>
 #include <util/language_file.h>
-#include <util/message/message.h>
 #include <util/parseoptions.h>
 
 class language_uit
@@ -20,7 +11,7 @@ public:
   language_filest language_files;
   contextt context;
 
-  language_uit(const cmdlinet &__cmdline, messaget &msg);
+  language_uit(const cmdlinet &__cmdline);
   virtual ~language_uit() = default;
 
   virtual bool parse();
@@ -39,7 +30,6 @@ public:
 
 protected:
   const cmdlinet &_cmdline;
-  messaget &msg;
 };
 
 #endif
diff --git a/src/langapi/language_util.cpp b/src/langapi/language_util.cpp
index e92b861d7..b906e0a1a 100644
--- a/src/langapi/language_util.cpp
+++ b/src/langapi/language_util.cpp
@@ -1,20 +1,9 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@cs.cmu.edu
-
-\*******************************************************************/
-
 #include <langapi/language_util.h>
 #include <langapi/mode.h>
 #include <memory>
 
-std::string from_expr(
-  const namespacet &ns,
-  const irep_idt &identifier,
-  const exprt &expr,
-  const messaget &msg)
+std::string
+from_expr(const namespacet &ns, const irep_idt &identifier, const exprt &expr)
 {
   int mode;
 
@@ -22,9 +11,9 @@ std::string from_expr(
     mode = 0;
   else
   {
-    const symbolt *symbol;
+    const symbolt *symbol = ns.lookup(identifier);
 
-    if(ns.lookup(identifier, symbol))
+    if(!symbol)
       mode = 0;
     else if(symbol->mode == "")
       mode = 0;
@@ -37,17 +26,14 @@ std::string from_expr(
     }
   }
 
-  std::unique_ptr<languaget> p(mode_table[mode].new_language(msg));
+  std::unique_ptr<languaget> p(mode_table[mode].new_language());
   std::string result;
   p->from_expr(expr, result, ns);
   return result;
 }
 
-std::string from_type(
-  const namespacet &ns,
-  const irep_idt &identifier,
-  const typet &type,
-  const messaget &msg)
+std::string
+from_type(const namespacet &ns, const irep_idt &identifier, const typet &type)
 {
   int mode;
 
@@ -55,9 +41,9 @@ std::string from_type(
     mode = 0;
   else
   {
-    const symbolt *symbol;
+    const symbolt *symbol = ns.lookup(identifier);
 
-    if(ns.lookup(identifier, symbol))
+    if(!symbol)
       mode = 0;
     else if(symbol->mode == "")
       mode = 0;
@@ -70,20 +56,20 @@ std::string from_type(
     }
   }
 
-  std::unique_ptr<languaget> p(mode_table[mode].new_language(msg));
+  std::unique_ptr<languaget> p(mode_table[mode].new_language());
   std::string result;
   p->from_type(type, result, ns);
   return result;
 }
 
-std::string from_expr(const exprt &expr, const messaget &msg)
+std::string from_expr(const exprt &expr)
 {
-  contextt context(msg);
-  return from_expr(namespacet(context), "", expr, msg);
+  contextt context;
+  return from_expr(namespacet(context), "", expr);
 }
 
-std::string from_type(const typet &type, const messaget &msg)
+std::string from_type(const typet &type)
 {
-  contextt context(msg);
-  return from_type(namespacet(context), "", type, msg);
+  contextt context;
+  return from_type(namespacet(context), "", type);
 }
diff --git a/src/langapi/language_util.h b/src/langapi/language_util.h
index 5f8775432..b55975ec8 100644
--- a/src/langapi/language_util.h
+++ b/src/langapi/language_util.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@cs.cmu.edu
-
-\*******************************************************************/
-
 #ifndef CPROVER_LANGUAGE_UTIL_H
 #define CPROVER_LANGUAGE_UTIL_H
 
@@ -14,48 +6,36 @@ Author: Daniel Kroening, kroening@cs.cmu.edu
 #include <util/migrate.h>
 #include <util/namespace.h>
 
-std::string from_expr(
-  const namespacet &ns,
-  const irep_idt &identifier,
-  const exprt &exprt,
-  const messaget &msg);
-
-inline std::string from_expr(
-  const namespacet &ns,
-  const irep_idt &identifier,
-  const expr2tc &expr,
-  const messaget &msg)
+std::string
+from_expr(const namespacet &ns, const irep_idt &identifier, const exprt &exprt);
+
+inline std::string
+from_expr(const namespacet &ns, const irep_idt &identifier, const expr2tc &expr)
 {
-  return from_expr(ns, identifier, migrate_expr_back(expr), msg);
+  return from_expr(ns, identifier, migrate_expr_back(expr));
 }
 
-std::string from_expr(const exprt &expr, const messaget &msg);
+std::string from_expr(const exprt &expr);
 
-inline std::string from_expr(const expr2tc &expr, const messaget &msg)
+inline std::string from_expr(const expr2tc &expr)
 {
-  return from_expr(migrate_expr_back(expr), msg);
+  return from_expr(migrate_expr_back(expr));
 }
 
-std::string from_type(
-  const namespacet &ns,
-  const irep_idt &identifier,
-  const typet &type,
-  const messaget &msg);
-
-inline std::string from_type(
-  const namespacet &ns,
-  const irep_idt &identifier,
-  const type2tc &type,
-  const messaget &msg)
+std::string
+from_type(const namespacet &ns, const irep_idt &identifier, const typet &type);
+
+inline std::string
+from_type(const namespacet &ns, const irep_idt &identifier, const type2tc &type)
 {
-  return from_type(ns, identifier, migrate_type_back(type), msg);
+  return from_type(ns, identifier, migrate_type_back(type));
 }
 
-std::string from_type(const typet &type, const messaget &msg);
+std::string from_type(const typet &type);
 
-inline std::string from_type(const type2tc &type, const messaget &msg)
+inline std::string from_type(const type2tc &type)
 {
-  return from_type(migrate_type_back(type), msg);
+  return from_type(migrate_type_back(type));
 }
 
 #endif
diff --git a/src/langapi/languages.cpp b/src/langapi/languages.cpp
index 1ea7375c5..1bee80374 100644
--- a/src/langapi/languages.cpp
+++ b/src/langapi/languages.cpp
@@ -1,21 +1,9 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@cs.cmu.edu
-
-\*******************************************************************/
-
 #include <langapi/languages.h>
 #include <langapi/mode.h>
 
-languagest::languagest(
-  const namespacet &_ns,
-  const char *mode,
-  const messaget &msg)
-  : ns(_ns), msg(msg)
+languagest::languagest(const namespacet &_ns, language_idt lang) : ns(_ns)
 {
-  language = new_language(mode, msg);
+  language = new_language(lang);
 }
 
 languagest::~languagest()
diff --git a/src/langapi/languages.h b/src/langapi/languages.h
index f8e57b789..0943a592a 100644
--- a/src/langapi/languages.h
+++ b/src/langapi/languages.h
@@ -1,14 +1,7 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@cs.cmu.edu
-
-\*******************************************************************/
-
 #ifndef CPROVER_LANGUAGES_H
 #define CPROVER_LANGUAGES_H
 
+#include <langapi/mode.h>
 #include <util/language.h>
 
 class languagest
@@ -28,13 +21,12 @@ public:
 
   // constructor / destructor
 
-  languagest(const namespacet &_ns, const char *mode, const messaget &msg);
+  languagest(const namespacet &_ns, language_idt lang);
   virtual ~languagest();
 
 protected:
   const namespacet &ns;
   languaget *language;
-  const messaget &msg;
 };
 
 #endif
diff --git a/src/langapi/mode.cpp b/src/langapi/mode.cpp
index 5e9ea6482..18c99332d 100644
--- a/src/langapi/mode.cpp
+++ b/src/langapi/mode.cpp
@@ -1,41 +1,112 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@cs.cmu.edu
-
-\*******************************************************************/
-
+#include <cassert>
 #include <cstring>
 #include <langapi/mode.h>
 
-const char *extensions_ansi_c[] = {"c", "i", nullptr};
+static const char *const extensions_ansi_c[] = {"c", "i", nullptr};
 
 #ifdef _WIN32
-const char *extensions_cpp[] = {"cpp", "cc", "ipp", "cxx", NULL};
+static const char *const extensions_cpp[] = {"cpp", "cc", "ipp", "cxx", NULL};
 #else
-const char *extensions_cpp[] = {"cpp", "cc", "ipp", "C", "cxx", nullptr};
+static const char *const extensions_cpp[] =
+  {"cpp", "cc", "ipp", "C", "cxx", nullptr};
 #endif
 
-const char *extensions_sol_ast[] = {"solast", nullptr};
+static const char *const extensions_sol_ast[] = {"solast", nullptr};
+static const char *extensions_jimple[] = {"jimple", nullptr};
+static const language_desct language_desc_C = {"C", extensions_ansi_c};
+static const language_desct language_desc_CPP = {"C++", extensions_cpp};
+static const language_desct language_desc_Solidity = {
+  "Solidity",
+  extensions_sol_ast};
+static const language_desct language_desc_Jimple = {
+  "Jimple",
+  extensions_jimple};
+
+const struct language_desct *language_desc(language_idt id)
+{
+  switch(id)
+  {
+  case language_idt::NONE:
+    break;
+  case language_idt::C:
+    return &language_desc_C;
+  case language_idt::CPP:
+    return &language_desc_CPP;
+  case language_idt::SOLIDITY:
+    return &language_desc_Solidity;
+  case language_idt::JIMPLE:
+    return &language_desc_Jimple;
+  }
+  return nullptr;
+}
+
+language_idt language_id_by_name(const std::string &name)
+{
+  for(int i = 0;; i++)
+  {
+    language_idt lid = static_cast<language_idt>(i);
+    const language_desct *desc = language_desc(lid);
+    if(!desc)
+      return language_idt::NONE;
+    if(desc->name == name)
+      return lid;
+  }
+}
 
-int get_mode(const std::string &str)
+language_idt language_id_by_ext(const std::string &ext)
+{
+  for(int i = 0;; i++)
+  {
+    language_idt lid = static_cast<language_idt>(i);
+    const language_desct *desc = language_desc(lid);
+    if(!desc)
+      return language_idt::NONE;
+    for(const char *const *e = desc->filename_extensions; *e; e++)
+      if(*e == ext)
+        return lid;
+  }
+}
+
+language_idt language_id_by_path(const std::string &path)
+{
+  const char *ext = strrchr(path.c_str(), '.');
+
+  if(ext == nullptr)
+    return language_idt::NONE;
+
+  std::string extension = ext + 1;
+
+  if(extension == "")
+    return language_idt::NONE;
+
+  return language_id_by_ext(extension);
+}
+
+int get_mode(language_idt lang)
 {
-  unsigned i;
+  assert(language_desc(lang));
 
-  for(i = 0; mode_table[i].name != nullptr; i++)
-    if(str == mode_table[i].name)
+  for(int i = 0; mode_table[i].new_language; i++)
+    if(lang == mode_table[i].language_id)
       return i;
 
   return -1;
 }
 
+int get_mode(const std::string &str)
+{
+  language_idt id = language_id_by_name(str);
+  if(id == language_idt::NONE)
+    return -1;
+
+  return get_mode(id);
+}
+
 int get_old_frontend_mode(int current_mode)
 {
-  unsigned i;
-  std::string expected(mode_table[current_mode++].name);
-  for(i = current_mode; mode_table[i].name != nullptr; i++)
-    if(expected == mode_table[i].name)
+  language_idt expected = mode_table[current_mode].language_id;
+  for(int i = current_mode + 1; mode_table[i].new_language; i++)
+    if(expected == mode_table[i].language_id)
       return i;
 
   return -1;
@@ -43,26 +114,14 @@ int get_old_frontend_mode(int current_mode)
 
 int get_mode_filename(const std::string &filename)
 {
-  const char *ext = strrchr(filename.c_str(), '.');
-
-  if(ext == nullptr)
+  language_idt id = language_id_by_path(filename);
+  if(id == language_idt::NONE)
     return -1;
 
-  std::string extension = ext + 1;
-
-  if(extension == "")
-    return -1;
-
-  int mode;
-  for(mode = 0; mode_table[mode].name != nullptr; mode++)
-    for(unsigned i = 0; mode_table[mode].extensions[i] != nullptr; i++)
-      if(mode_table[mode].extensions[i] == extension)
-        return mode;
-
-  return -1;
+  return get_mode(id);
 }
 
-languaget *new_language(const char *mode, const messaget &msg)
+languaget *new_language(language_idt lang)
 {
-  return (*mode_table[get_mode(mode)].new_language)(msg);
+  return mode_table[get_mode(lang)].new_language();
 }
diff --git a/src/langapi/mode.h b/src/langapi/mode.h
index 5341e0272..726eae298 100644
--- a/src/langapi/mode.h
+++ b/src/langapi/mode.h
@@ -1,23 +1,37 @@
-/*******************************************************************\
+#ifndef CPROVER_MODE_H
+#define CPROVER_MODE_H
 
-Module:
+#include <string>
 
-Author: Daniel Kroening, kroening@cs.cmu.edu
+/* forward declarations */
+class languaget;
 
-\*******************************************************************/
+enum class language_idt : int
+{
+  NONE = -1,
+  C,
+  CPP,
+  SOLIDITY,
+  JIMPLE
+};
 
-#ifndef CPROVER_MODE_H
-#define CPROVER_MODE_H
+struct language_desct
+{
+  const char *name;
+  const char *const *filename_extensions;
+};
 
-#include <util/language.h>
+const language_desct *language_desc(language_idt id);
+language_idt language_id_by_name(const std::string &name);
+language_idt language_id_by_ext(const std::string &ext);
+language_idt language_id_by_path(const std::string &path);
 
 // Table recording details about language modes
 
 struct mode_table_et
 {
-  const char *name;
-  languaget *(*new_language)(const messaget &msg);
-  const char **extensions;
+  language_idt language_id;
+  languaget *(*new_language)();
 };
 
 // List of language modes that are going to be supported in the final tool.
@@ -25,49 +39,49 @@ struct mode_table_et
 
 extern const mode_table_et mode_table[];
 
-extern const char *extensions_ansi_c[];
-extern const char *extensions_cpp[];
-extern const char *extensions_sol_ast[];
-
-languaget *new_clang_c_language(const messaget &msg);
-languaget *new_clang_cpp_language(const messaget &msg);
-languaget *new_ansi_c_language(const messaget &msg);
-languaget *new_cpp_language(const messaget &msg);
-languaget *new_solidity_language(const messaget &msg);
+languaget *new_clang_c_language();
+languaget *new_clang_cpp_language();
+languaget *new_jimple_language();
+languaget *new_ansi_c_language();
+languaget *new_cpp_language();
+languaget *new_solidity_language();
 
 // List of language entries, one can put in the mode table:
-#define LANGAPI_HAVE_MODE_CLANG_C                                              \
+#define LANGAPI_MODE_CLANG_C                                                   \
   {                                                                            \
-    "C", &new_clang_c_language, extensions_ansi_c                              \
+    language_idt::C, &new_clang_c_language                                     \
   }
-#define LANGAPI_HAVE_MODE_CLANG_CPP                                            \
+#define LANGAPI_MODE_CLANG_CPP                                                 \
   {                                                                            \
-    "C", &new_clang_cpp_language, extensions_cpp                               \
+    language_idt::CPP, &new_clang_cpp_language                                 \
   }
-#define LANGAPI_HAVE_MODE_SOLAST                                               \
+#define LANGAPI_MODE_SOLAST                                                    \
   {                                                                            \
-    "Solidity AST", &new_solidity_language, extensions_sol_ast                 \
+    language_idt::SOLIDITY, &new_solidity_language                             \
   }
-#define LANGAPI_HAVE_MODE_C                                                    \
+#define LANGAPI_MODE_C                                                         \
   {                                                                            \
-    "C", &new_ansi_c_language, extensions_ansi_c                               \
+    language_idt::C, &new_ansi_c_language                                      \
   }
-#define LANGAPI_HAVE_MODE_CPP                                                  \
+#define LANGAPI_MODE_CPP                                                       \
   {                                                                            \
-    "C++", &new_cpp_language, extensions_cpp                                   \
+    language_idt::CPP, &new_cpp_language                                       \
   }
-#define LANGAPI_HAVE_MODE_END                                                  \
+#define LANGAPI_MODE_JIMPLE                                                    \
   {                                                                            \
-    NULL, NULL, NULL                                                           \
+    language_idt::JIMPLE, &new_jimple_language                                 \
   }
 
+#define LANGAPI_MODE_END                                                       \
+  {                                                                            \
+    language_idt::NONE, NULL                                                   \
+  }
+
+int get_mode(language_idt lang);
 int get_mode(const std::string &str);
 int get_mode_filename(const std::string &filename);
 int get_old_frontend_mode(int current_mode);
 
-languaget *new_language(const char *mode, const messaget &msg);
-
-#define MODE_C "C"
-#define MODE_CPP "C++"
+languaget *new_language(language_idt lang);
 
 #endif
diff --git a/src/pointer-analysis/dereference.cpp b/src/pointer-analysis/dereference.cpp
index 4d38bd6db..4abed7d24 100644
--- a/src/pointer-analysis/dereference.cpp
+++ b/src/pointer-analysis/dereference.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Symbolic Execution of ANSI-C
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <langapi/language_util.h>
 #include <pointer-analysis/dereference.h>
@@ -22,6 +14,7 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <util/expr_util.h>
 #include <util/i2string.h>
 #include <irep2/irep2.h>
+#include <util/message/format.h>
 #include <util/migrate.h>
 #include <util/prefix.h>
 #include <util/pretty.h>
@@ -171,8 +164,20 @@ void dereferencet::dereference_expr(expr2tc &expr, guardt &guard, modet mode)
     break;
 
   case expr2t::dereference_id:
-    dereference_deref(expr, guard, mode);
+  {
+    /* Interpret an actual dereference expression. First dereferences the
+     * pointer expression, then dereferences the pointer itself, and stores the
+     * result in 'expr'. */
+    assert(is_dereference2t(expr));
+    dereference2t &deref = to_dereference2t(expr);
+    // first make sure there are no dereferences in there
+    dereference_expr(deref.value, guard, dereferencet::READ);
+
+    expr2tc tmp_obj = deref.value;
+    expr2tc result = dereference(tmp_obj, deref.type, guard, mode, expr2tc());
+    expr = result;
     break;
+  }
 
   case expr2t::index_id:
   case expr2t::member_id:
@@ -180,10 +185,7 @@ void dereferencet::dereference_expr(expr2tc &expr, guardt &guard, modet mode)
     // The result of this expression should be scalar: we're transitioning
     // from a scalar result to a nonscalar result.
 
-    std::list<expr2tc> scalar_step_list;
-    expr2tc res =
-      dereference_expr_nonscalar(expr, guard, mode, scalar_step_list);
-    assert(scalar_step_list.size() == 0); // Should finish empty.
+    expr2tc res = dereference_expr_nonscalar(expr, guard, mode, expr);
 
     // If a dereference successfully occurred, replace expr at this level.
     // XXX -- explain this better.
@@ -338,136 +340,90 @@ void dereferencet::dereference_addrof_expr(
   dereference_expr(expr, guard, mode);
 }
 
-void dereferencet::dereference_deref(expr2tc &expr, guardt &guard, modet mode)
+static bool is_aligned_member(const expr2tc &expr)
 {
-  if(is_dereference2t(expr))
-  {
-    dereference2t &deref = to_dereference2t(expr);
-    // first make sure there are no dereferences in there
-    dereference_expr(deref.value, guard, dereferencet::READ);
+  if(!is_member2t(expr))
+    return false;
 
-    expr2tc tmp_obj = deref.value;
-    expr2tc result = dereference(tmp_obj, deref.type, guard, mode, expr2tc());
-    expr = result;
-  }
-  else
-  {
-    // This is an index applied to a pointer, which is essentially a dereference
-    // with an offset.
-    assert(is_index2t(expr) && is_pointer_type(to_index2t(expr).source_value));
-    std::list<expr2tc> scalar_step_list;
-    assert(
-      (is_scalar_type(expr) || is_code_type(expr)) &&
-      "Can't dereference to a nonscalar type");
-    index2t &idx = to_index2t(expr);
+  const expr2tc &structure = to_member2t(expr).source_value;
+  auto *ty = static_cast<const struct_union_data *>(structure->type.get());
 
-    // first make sure there are no dereferences in there
-    dereference_expr(idx.index, guard, dereferencet::READ);
-    dereference_expr(idx.source_value, guard, mode);
+  /* non-packed structures have all members aligned */
+  if(!ty->packed)
+    return true;
 
-    add2tc tmp(idx.source_value->type, idx.source_value, idx.index);
-    // Result discarded.
-    expr = dereference(tmp, tmp->type, guard, mode, expr2tc());
-  }
+  /* Very (too?) conservative approach: all members of packed structures are to
+   * be accessed in a known-unaligned way. Note, that's not true for GCC/Clang:
+   * if they can prove some member is always aligned, they'll use the faster
+   * instructions on aligned pointers. */
+  return false;
 }
 
 expr2tc dereferencet::dereference_expr_nonscalar(
   expr2tc &expr,
   guardt &guard,
   modet mode,
-  std::list<expr2tc> &scalar_step_list)
+  const expr2tc &base)
 {
   if(is_dereference2t(expr))
   {
+    /* The first expression we're called with is index2t, member2t or non-scalar
+     * if2t. Thus, expr differs from base. */
+    assert(expr != base);
+
+    // Check that either the base type that these steps are applied to matches
+    // the type of the object we're wrapping in these steps. It's a type error
+    // if there isn't a match.
+    type2tc base_of_steps_type = ns.follow(expr->type);
+    if(!dereference_type_compare(expr, base_of_steps_type))
+    {
+      // The base types are incompatible.
+      bad_base_type_failure(
+        guard, get_type_id(*expr->type), get_type_id(*base_of_steps_type));
+      return expr2tc();
+    }
+
     // Determine offset accumulated to this point (in bits)
-    expr2tc size_check_expr = expr;
-    wrap_in_scalar_step_list(size_check_expr, &scalar_step_list, guard);
-    expr2tc offset_to_scalar = compute_pointer_offset_bits(size_check_expr);
+    expr2tc offset_to_scalar = compute_pointer_offset_bits(base);
     simplify(offset_to_scalar);
 
     dereference2t &deref = to_dereference2t(expr);
     // first make sure there are no dereferences in there
     dereference_expr(deref.value, guard, dereferencet::READ);
 
-    const type2tc &to_type = scalar_step_list.back()->type;
-
-    expr2tc result =
-      dereference(deref.value, to_type, guard, mode, offset_to_scalar);
-    return result;
-  }
-
-  if(is_index2t(expr) && is_pointer_type(to_index2t(expr).source_value))
-  {
-    index2t &index = to_index2t(expr);
-
-    // Determine offset accumulated to this point (computed in bytes)
-    expr2tc size_check_expr = expr;
-    wrap_in_scalar_step_list(size_check_expr, &scalar_step_list, guard);
-    expr2tc offset_to_scalar = compute_pointer_offset_bits(size_check_expr);
-    simplify(offset_to_scalar);
-
-    // first make sure there are no dereferences in there
-    dereference_expr(index.source_value, guard, dereferencet::READ);
-    dereference_expr(index.index, guard, dereferencet::READ);
-
-    add2tc tmp(index.source_value->type, index.source_value, index.index);
-
-    const type2tc &to_type = scalar_step_list.back()->type;
-
-    expr2tc result = dereference(tmp, to_type, guard, mode, offset_to_scalar);
-    return result;
+    return dereference(deref.value, base->type, guard, mode, offset_to_scalar);
   }
 
   if(is_typecast2t(expr))
   {
     // Just blast straight through
     return dereference_expr_nonscalar(
-      to_typecast2t(expr).from, guard, mode, scalar_step_list);
+      to_typecast2t(expr).from, guard, mode, base);
   }
 
   if(is_member2t(expr))
   {
-    scalar_step_list.push_front(expr);
-    expr2tc res = dereference_expr_nonscalar(
-      to_member2t(expr).source_value, guard, mode, scalar_step_list);
-    scalar_step_list.pop_front();
-    return res;
+    member2t &member = to_member2t(expr);
+    expr2tc &structure = member.source_value;
+    if(
+      !options.get_bool_option("no-align-check") && !mode.unaligned &&
+      !is_aligned_member(expr))
+    {
+      auto *t = static_cast<const struct_union_data *>(structure->type.get());
+      log_warning(
+        "WARNING: not checking alignment for access to packed {} {}",
+        get_type_id(*structure->type),
+        t->name.as_string());
+      mode.unaligned = true;
+    }
+    return dereference_expr_nonscalar(structure, guard, mode, base);
   }
 
   if(is_index2t(expr))
   {
-    dereference_expr(to_index2t(expr).index, guard, dereferencet::READ);
-    scalar_step_list.push_front(expr);
-    expr2tc res = dereference_expr_nonscalar(
-      to_index2t(expr).source_value, guard, mode, scalar_step_list);
-    scalar_step_list.pop_front();
-    return res;
-  }
-
-  if(is_if2t(expr) && !is_scalar_type(expr))
-  {
-    guardt g1 = guard, g2 = guard;
-    if2t &theif = to_if2t(expr);
-    g1.add(theif.cond);
-    g2.add(not2tc(theif.cond));
-
-    scalar_step_list.push_front(theif.true_value);
-    expr2tc res1 =
-      dereference_expr_nonscalar(theif.true_value, g1, mode, scalar_step_list);
-    scalar_step_list.pop_front();
-
-    scalar_step_list.push_front(theif.false_value);
-    expr2tc res2 =
-      dereference_expr_nonscalar(theif.false_value, g2, mode, scalar_step_list);
-    scalar_step_list.pop_front();
-
-    if(is_nil_expr(res1))
-      res1 = theif.true_value;
-    if(is_nil_expr(res2))
-      res2 = theif.true_value;
-
-    expr2tc fin = if2tc(res1->type, theif.cond, res1, res2);
-    return fin;
+    index2t &index = to_index2t(expr);
+    dereference_expr(index.index, guard, dereferencet::READ);
+    return dereference_expr_nonscalar(index.source_value, guard, mode, base);
   }
 
   if(is_constant_union2t(expr))
@@ -477,12 +433,9 @@ expr2tc dereferencet::dereference_expr_nonscalar(
      * expressions should have a single initializer expression, see also the
      * comment for constant_union2t in <irep2/itep2_expr.h>. */
     assert(u.datatype_members.size() == 1);
-    assert(mode != WRITE);
-    scalar_step_list.push_front(expr);
-    expr2tc res = dereference_expr_nonscalar(
-      u.datatype_members.front(), guard, mode, scalar_step_list);
-    scalar_step_list.pop_front();
-    return res;
+    assert(!is_write(mode));
+    return dereference_expr_nonscalar(
+      u.datatype_members.front(), guard, mode, base);
   }
 
   // there should be no sudden transition back to scalars, except through
@@ -516,44 +469,59 @@ expr2tc dereferencet::dereference(
     src = typecast2tc(type2tc(new pointer_type2t(get_empty_type())), src);
 
   type2tc type = to_type;
+
   // collect objects dest may point to
   value_setst::valuest points_to_set;
+
   dereference_callback.get_value_set(src, points_to_set);
 
   // now build big case split
   // only "good" objects
 
-  if(is_struct_type(type))
-  {
-    msg.warning("FAM dereference!");
-  }
+  /* If the value-set contains unknown or invalid, we cannot be sure it contains
+   * all possible values and we have to add a fallback symbol in case all guards
+   * evaluate to false. On the other hand when it is exhaustive, we only need to
+   * encode (n-1) guards for the n values in the if-then-else chain below. This
+   * is done by leaving 'value' initially empty.
+   *
+   * XXX fbrausse: get_value_set() should compute this information */
+  bool known_exhaustive = true;
+  for(const expr2tc &target : points_to_set)
+    known_exhaustive &= !(is_unknown2t(target) || is_invalid2t(target));
 
   expr2tc value;
+  if(!known_exhaustive)
+    value = make_failed_symbol(type);
 
-  for(value_setst::valuest::const_iterator it = points_to_set.begin();
-      it != points_to_set.end();
-      it++)
+  for(const expr2tc &target : points_to_set)
   {
     expr2tc new_value, pointer_guard;
 
     new_value = build_reference_to(
-      *it, mode, src, type, guard, lexical_offset, pointer_guard);
+      target, mode, src, type, guard, lexical_offset, pointer_guard);
+
+    if(is_nil_expr(new_value))
+      continue;
+
+    assert(!is_nil_expr(pointer_guard));
 
-    if(!is_nil_expr(new_value))
+    if(!dereference_type_compare(new_value, type))
     {
-      if(is_nil_expr(value))
-      {
-        value = new_value;
-      }
-      else
-      {
-        // Chain a big if-then-else case.
-        value = if2tc(type, pointer_guard, new_value, value);
-      }
+      guardt new_guard(guard);
+      new_guard.add(pointer_guard);
+      bad_base_type_failure(
+        new_guard, get_type_id(*type), get_type_id(*new_value->type));
+      continue;
     }
+
+    // Chain a big if-then-else case.
+    if(is_nil_expr(value))
+      value = new_value;
+    else
+      value = if2tc(type, pointer_guard, new_value, value);
   }
 
-  if(mode == INTERNAL)
+  if(is_internal(mode))
   {
     // Deposit internal values with the caller, then clear.
     dereference_callback.dump_internal_state(internal_items);
@@ -561,9 +529,9 @@ expr2tc dereferencet::dereference(
   }
   else if(is_nil_expr(value))
   {
-    // Dereference failed entirely; various assertions will explode later down
-    // the line. To make this a valid formula though, return a failed symbol,
-    // so that this assignment gets a well typed free value.
+    /* Fallback if dereference failes entirely: to make this a valid formula,
+     * return a failed symbol, so that this assignment gets a well typed free
+     * value. */
     value = make_failed_symbol(type);
   }
 
@@ -572,20 +540,7 @@ expr2tc dereferencet::dereference(
 
 expr2tc dereferencet::make_failed_symbol(const type2tc &out_type)
 {
-  type2tc the_type;
-
-  if(is_union_type(out_type))
-  {
-    // Instead, create a byte array, all unions are now reduced to byte arrays.
-    BigInt size = type_byte_size(out_type);
-    type2tc array_type(
-      new array_type2t(get_uint8_type(), gen_ulong(size.to_uint64()), false));
-    the_type = array_type;
-  }
-  else
-  {
-    the_type = out_type;
-  }
+  type2tc the_type = out_type;
 
   // else, do new symbol
   symbolt symbol;
@@ -629,6 +584,9 @@ bool dereferencet::dereference_type_compare(
     }
   }
 
+  if(is_code_type(object) && is_code_type(dereference_type))
+    return true;
+
   // check for struct prefixes
 
   type2tc ot_base(object_type), dt_base(dereference_type);
@@ -672,7 +630,7 @@ expr2tc dereferencet::build_reference_to(
 
   if(!is_object_descriptor2t(what))
   {
-    msg.error(fmt::format("unknown points-to: {}", get_expr_id(what)));
+    log_error("unknown points-to: {}", get_expr_id(what));
     abort();
   }
 
@@ -681,7 +639,7 @@ expr2tc dereferencet::build_reference_to(
   const expr2tc &root_object = o.get_root_object();
   const expr2tc &object = o.object;
 
-  if(is_null_object2t(root_object) && mode != FREE && mode != INTERNAL)
+  if(is_null_object2t(root_object) && !is_free(mode) && !is_internal(mode))
   {
     type2tc nullptrtype = type2tc(new pointer_type2t(type));
     symbol2tc null_ptr(nullptrtype, "NULL");
@@ -697,7 +655,7 @@ expr2tc dereferencet::build_reference_to(
     // solver will only get confused.
     return value;
   }
-  if(is_null_object2t(root_object) && (mode == FREE || mode == INTERNAL))
+  if(is_null_object2t(root_object) && (is_free(mode) || is_internal(mode)))
   {
     // Freeing NULL is completely legit according to C
     return value;
@@ -717,7 +675,7 @@ expr2tc dereferencet::build_reference_to(
   valid_check(object, tmp_guard, mode);
 
   // Don't do anything further if we're freeing things
-  if(mode == FREE)
+  if(is_free(mode))
     return expr2tc();
 
   // Value set tracking emits objects with some cruft built on top of them.
@@ -759,7 +717,7 @@ expr2tc dereferencet::build_reference_to(
   // If we're in internal mode, collect all of our data into one struct, insert
   // it into the list of internal data, and then bail. The caller does not want
   // to have a reference built at all.
-  if(mode == INTERNAL)
+  if(is_internal(mode))
   {
     dereference_callbackt::internal_item internal;
     internal.object = value;
@@ -782,7 +740,7 @@ expr2tc dereferencet::build_reference_to(
   }
   else
   {
-    check_data_obj_access(value, final_offset, type, tmp_guard);
+    check_data_obj_access(value, final_offset, type, tmp_guard, mode);
   }
 
   simplify(final_offset);
@@ -802,7 +760,7 @@ void dereferencet::deref_invalid_ptr(
   const guardt &guard,
   modet mode)
 {
-  if(mode == INTERNAL)
+  if(is_internal(mode))
     // The caller just wants a list of references -- ensuring that the correct
     // assertions fire is a problem for something or someone else
     return;
@@ -814,7 +772,7 @@ void dereferencet::deref_invalid_ptr(
   std::string foo;
 
   // Adjust error message and test depending on the context
-  if(mode == FREE)
+  if(is_free(mode))
   {
     // You're allowed to free NULL.
     symbol2tc null_ptr(type2tc(new pointer_type2t(get_empty_type())), "NULL");
@@ -844,7 +802,7 @@ enum target_flags
   flag_src_scalar = 0,
   flag_src_array = 1,
   flag_src_struct = 2,
-  // Union sources are now illegal
+  flag_src_union = 3,
 
   flag_dst_scalar = 0,
   flag_dst_array = 4,
@@ -881,36 +839,28 @@ void dereferencet::build_reference_rec(
     flags |= flag_dst_scalar;
   else if(is_array_type(type) || is_string_type(type))
   {
-    std::ostringstream oss;
-    oss << "Can't construct rvalue reference to array type during dereference";
-    oss << "\n";
-    oss << "(It isn't allowed by C anyway)";
-    oss << "\n";
-    msg.error(oss.str());
+    log_error(
+      "Can't construct rvalue reference to array type during dereference\n"
+      "(It isn't allowed by C anyway)\n");
     abort();
   }
   else
   {
-    msg.error(
-      fmt::format("Unrecognized dest type during dereference\n{}", *type));
+    log_error("Unrecognized dest type during dereference\n{}", *type);
     abort();
   }
 
   if(is_struct_type(value))
     flags |= flag_src_struct;
   else if(is_union_type(value))
-  {
-    msg.error("Dereference target of type union is now illegal");
-    abort();
-  }
+    flags |= flag_src_union;
   else if(is_scalar_type(value))
     flags |= flag_src_scalar;
   else if(is_array_type(value) || is_string_type(value))
     flags |= flag_src_array;
   else
   {
-    msg.error(fmt::format(
-      "Unrecognized src type during dereference\n{}", *value->type));
+    log_error("Unrecognized src type during dereference\n{}", *value->type);
     abort();
   }
 
@@ -1002,9 +952,43 @@ void dereferencet::build_reference_rec(
     construct_struct_ref_from_dyn_offset(value, offset, type, guard, mode);
     break;
 
+  case flag_src_union | flag_dst_union | flag_is_const_offs:
+    construct_struct_ref_from_const_offset(value, offset, type, guard);
+    break;
+  case flag_src_union | flag_dst_union | flag_is_dyn_offs:
+    construct_struct_ref_from_dyn_offset(value, offset, type, guard, mode);
+    break;
+
+  // All union-src situations are currently approximations
+  case flag_src_union | flag_dst_scalar | flag_is_const_offs:
+  case flag_src_union | flag_dst_struct | flag_is_const_offs:
+  case flag_src_union | flag_dst_scalar | flag_is_dyn_offs:
+  case flag_src_union | flag_dst_struct | flag_is_dyn_offs:
+  {
+    const union_type2t &uni_type = to_union_type(value->type);
+    assert(uni_type.members.size() != 0);
+    BigInt union_total_size = type_byte_size(value->type);
+    // Let's find a member with the biggest size
+    size_t selected_member_index = SIZE_MAX;
+    for(size_t i = 0; i < uni_type.members.size(); i++)
+      if(type_byte_size(uni_type.members[i]) == union_total_size)
+      {
+        selected_member_index = i;
+        break;
+      }
+    assert(selected_member_index < SIZE_MAX);
+
+    value = member2tc(
+      uni_type.members[selected_member_index],
+      value,
+      uni_type.member_names[selected_member_index]);
+    build_reference_rec(value, offset, type, guard, mode, alignment);
+    break;
+  }
+
   // No scope for constructing references to arrays
   default:
-    msg.error("Unrecognized input to build_reference_rec");
+    log_error("Unrecognized input to build_reference_rec");
     abort();
   }
 }
@@ -1094,27 +1078,22 @@ void dereferencet::construct_from_array(
     unsigned int num_bytes = compute_num_bytes_to_extract(
       replaced_dyn_offset, type_byte_size_bits(type).to_uint64());
 
-    if(!num_bytes)
-    {
-      msg.warning("FAM detected, extracting the entire array on deref");
-      // Are we handling a FAM? Extract everything
-      num_bytes = compute_num_bytes_to_extract(
-        offset, type_byte_size_bits(value->type).to_uint64());
-    }
-
     // Converting offset to bytes for byte extracting
     expr2tc offset_bytes = div2tc(offset->type, offset, gen_ulong(8));
     simplify(offset_bytes);
 
     // Extracting and stitching bytes together
-    expr2tc *bytes = extract_bytes_from_array(value, num_bytes, offset_bytes);
-    stitch_together_from_byte_array(value, num_bytes, bytes);
-    delete[] bytes;
+    value = stitch_together_from_byte_array(
+      num_bytes, extract_bytes_from_array(value, num_bytes, offset_bytes));
+
+    expr2tc offset_bits = modulus2tc(offset->type, offset, gen_ulong(8));
+    simplify(offset_bits);
 
     // Extracting bits from the produced bv
-    extract_bits_from_byte_array(
-      value, offset, type_byte_size_bits(type).to_uint64());
-    value = bitcast2tc(type, value);
+    value = bitcast2tc(
+      type,
+      extract_bits_from_byte_array(
+        value, offset_bits, type_byte_size_bits(type).to_uint64()));
   }
 }
 
@@ -1165,13 +1144,16 @@ void dereferencet::construct_from_const_offset(
   simplify(offset_bytes);
 
   // Extracting and stitching bytes together
-  expr2tc *bytes = extract_bytes_from_scalar(value, num_bytes, offset_bytes);
-  stitch_together_from_byte_array(value, num_bytes, bytes);
-  delete[] bytes;
+  value = stitch_together_from_byte_array(
+    num_bytes, extract_bytes_from_scalar(value, num_bytes, offset_bytes));
+
+  expr2tc offset_bits = modulus2tc(offset->type, offset, gen_ulong(8));
+  simplify(offset_bits);
+
+  value = extract_bits_from_byte_array(
+    value, offset_bits, type_byte_size_bits(type).to_uint64());
 
   // Extracting bits from the produced bv
-  extract_bits_from_byte_array(
-    value, offset, type_byte_size_bits(type).to_uint64());
   value = bitcast2tc(type, value);
 }
 
@@ -1203,49 +1185,6 @@ void dereferencet::construct_from_const_struct_offset(
       // is supposed to point at.
       // If user is seeking a reference to this substruct, a different method
       // should have been called (construct_struct_ref_from_const_offset).
-      if(is_array_type(it))
-      {
-        // Array of size 0 in a struct, means FAM
-        msg.warning("FAM in deref");
-        // TODO: Check for allignment.
-        // GET THE VALUES
-        expr2tc memb = member2tc(it, value, struct_type.member_names[i]);
-        constant_int2tc new_offs(pointer_type2(), int_offset - m_offs);
-
-        /* CAN WE CHECK FOR OVER READS?
-         *
-         * Global initializations are not handled by the goto_check
-         * code, here we try to get the size of the value assigned for
-         * it
-        */
-        if(is_symbol2t(value) && mode == READ)
-        {
-          auto fam = ns.lookup(to_symbol2t(value).thename);
-          //assert(fam.is_struct());
-          auto last_operand =
-            to_array_type(fam.value.operands().back().type()).size();
-          BigInt size(
-            to_constant_expr(last_operand).get_value().as_string().c_str(), 2);
-          auto limit = size * type->get_width();
-          if((new_offs->value + type->get_width()) > limit)
-          {
-            dereference_failure(
-              "pointer dereference",
-              fmt::format(
-                "Invalid read from FAM with offset {}. FAM contains {} "
-                "elements",
-                new_offs->value / type->get_width(),
-                size),
-              guard);
-          }
-        }
-
-        // Extract.
-        build_reference_rec(memb, new_offs, type, guard, mode);
-        value = memb;
-
-        return;
-      }
       assert(is_struct_type(it));
       assert(!is_struct_type(type));
       i++;
@@ -1259,14 +1198,14 @@ void dereferencet::construct_from_const_struct_offset(
       // middle. Which might be an error -- reading from it definitely is,
       // but we might write to it in the course of memset.
       value = expr2tc();
-      if(mode == WRITE)
+      if(is_write(mode))
       {
         // This write goes to an invalid symbol, but no assertion is encoded,
         // so it's entirely safe.
       }
       else
       {
-        assert(mode == READ);
+        assert(is_read(mode));
         // Oh dear. Encode a failure assertion.
         dereference_failure(
           "pointer dereference",
@@ -1370,29 +1309,6 @@ void dereferencet::construct_from_dyn_struct_offset(
     // Compute some kind of guard
     BigInt field_size = type_byte_size_bits(it);
 
-    // This breaks FAM
-    // Lets compute field size manually for fam :)
-    if(
-      is_array_type(it) &&
-      (to_array_type(it).array_size->expr_id != expr2t::constant_int_id ||
-       !to_array_type(it).get_width()))
-    {
-      auto fam = ns.lookup(to_symbol2t(value).thename);
-      auto last_operand =
-        to_array_type(fam.value.operands().back().type()).size();
-      BigInt quantity(
-        to_constant_expr(last_operand).get_value().as_string().c_str(), 2);
-      auto base_type_width = type_byte_size_bits(to_array_type(it).subtype);
-      field_size = quantity * base_type_width;
-
-      msg.debug(fmt::format(
-        "Adding field size: {}, quantity: {}, base_type: {}, offs: {}",
-        field_size,
-        quantity,
-        base_type_width,
-        offs));
-    }
-
     // Round up to word size
     expr2tc field_offset = constant_int2tc(offset->type, offs);
     expr2tc field_top = constant_int2tc(offset->type, offs + field_size);
@@ -1402,13 +1318,6 @@ void dereferencet::construct_from_dyn_struct_offset(
     expr2tc field = member2tc(it, value, struct_type.member_names[i]);
     expr2tc new_offset = sub2tc(offset->type, offset, field_offset);
     simplify(new_offset);
-    
-    // Round up to word size
-    //expr2tc field_offs = constant_int2tc(offset->type, offs);
-    //expr2tc field_top = constant_int2tc(offset->type, offs + field_size);
-    //expr2tc lower_bound = greaterthanequal2tc(bits_offset, field_offs);
-    //expr2tc upper_bound = lessthan2tc(bits_offset, field_top);
-    //expr2tc field_guard = and2tc(lower_bound, upper_bound);
 
     if(is_struct_type(it))
     {
@@ -1434,7 +1343,8 @@ void dereferencet::construct_from_dyn_struct_offset(
       // resolve to a failed deref symbol.
     }
     else if(
-      alignment >= config.ansi_c.word_size )
+      alignment >= config.ansi_c.word_size &&
+      it->get_width() == type->get_width())
     {
       // This is fully aligned, just pull it out and possibly cast,
       // XXX endian?
@@ -1500,12 +1410,11 @@ void dereferencet::construct_from_dyn_offset(
   simplify(offset_bytes);
 
   // Extracting and stitching bytes together
-  expr2tc *bytes = extract_bytes_from_scalar(value, num_bytes, offset_bytes);
-  stitch_together_from_byte_array(value, num_bytes, bytes);
-  delete[] bytes;
+  value = stitch_together_from_byte_array(
+    num_bytes, extract_bytes_from_scalar(value, num_bytes, offset_bytes));
 
   // Extracting bits from the produced bv
-  extract_bits_from_byte_array(
+  value = extract_bits_from_byte_array(
     value, offset, type_byte_size_bits(type).to_uint64());
   value = bitcast2tc(type, value);
 }
@@ -1572,11 +1481,12 @@ void dereferencet::construct_struct_ref_from_const_offset_array(
   unsigned int struct_offset = intref.value.to_uint64();
   for(const type2tc &target_type : structtype.members)
   {
-    unsigned n_bits = type_byte_size_bits(target_type).to_uint64();
     expr2tc target;
     if(is_array_type(target_type))
+    {
       target = stitch_together_from_byte_array(
-        target_type, (n_bits + 7) / 8, value, gen_ulong(struct_offset), guard);
+        target_type, value, gen_ulong(struct_offset), guard);
+    }
     else
     {
       target = value; // The byte array;
@@ -1584,7 +1494,7 @@ void dereferencet::construct_struct_ref_from_const_offset_array(
         target, gen_ulong(struct_offset), target_type, guard, mode);
     }
     fields.push_back(target);
-    struct_offset += n_bits;
+    struct_offset += type_byte_size_bits(target_type).to_uint64();
   }
 
   // We now have a vector of fields reconstructed from the byte array
@@ -1602,7 +1512,7 @@ void dereferencet::construct_struct_ref_from_const_offset(
   const constant_int2t &intref = to_constant_int2t(offs);
   BigInt type_size = type_byte_size_bits(type);
 
-  if(is_struct_type(value->type) )
+  if(is_struct_type(value->type) || is_union_type(value->type))
   {
     // Right. In this situation, there are several possibilities. First, if the
     // offset is zero, and the struct type is compatible, we've succeeded.
@@ -1620,12 +1530,11 @@ void dereferencet::construct_struct_ref_from_const_offset(
     // (but compatible check already gets that;), arrays of structs; and other
     // crazy inside structs.
 
-    const struct_type2t &struct_type = to_struct_type(value->type);
+    auto *data = static_cast<const struct_union_data *>(value->type.get());
     unsigned int i = 0;
-    for(auto const &it : struct_type.members)
+    for(auto const &it : data->members)
     {
-      BigInt offs =
-        member_offset_bits(value->type, struct_type.member_names[i]);
+      BigInt offs = member_offset_bits(value->type, data->member_names[i]);
       BigInt size = type_byte_size_bits(it);
 
       if(
@@ -1649,8 +1558,7 @@ void dereferencet::construct_struct_ref_from_const_offset(
         // menace. Recurse to continue our checks.
         BigInt new_offs = intref.value - offs;
         expr2tc offs_expr = gen_ulong(new_offs.to_uint64());
-        value = member2tc(it, value, struct_type.member_names[i]);
-
+        value = member2tc(it, value, data->member_names[i]);
 
         construct_struct_ref_from_const_offset(value, offs_expr, type, guard);
         return;
@@ -1665,11 +1573,9 @@ void dereferencet::construct_struct_ref_from_const_offset(
       "Memory model", "Object accessed with illegal offset", guard);
     return;
   }
-  std::ostringstream oss;
-  oss << "Unexpectedly " << get_type_id(value->type) << " type'd";
-  oss << " argument to construct_struct_ref"
-      << "\n";
-  msg.error(oss.str());
+  log_error(
+    "Unexpectedly {} type'd argument to construct_struct_ref",
+    get_type_id(value->type));
   abort();
 }
 
@@ -1900,7 +1806,7 @@ void dereferencet::alignment_failure(
     dereference_failure("Pointer alignment", error_name, guard);
 }
 
-expr2tc *dereferencet::extract_bytes_from_array(
+std::vector<expr2tc> dereferencet::extract_bytes_from_array(
   const expr2tc &array,
   unsigned int num_bytes,
   const expr2tc &offset)
@@ -1923,10 +1829,12 @@ expr2tc *dereferencet::extract_bytes_from_array(
     subtype = get_uint8_type(); //XXX signedness of chars
   }
 
+  bool is_big_endian =
+    config.ansi_c.endianess == configt::ansi_ct::IS_BIG_ENDIAN;
 
   // Calculating how many bytes are occupied by each array index
   unsigned int bytes_per_index = subtype->get_width() / 8;
-  expr2tc *exprs = new expr2tc[num_bytes];
+  std::vector<expr2tc> exprs(num_bytes);
   // Calculating the array index based on the given byte offset
   expr2tc accuml_offs =
     div2tc(offset->type, offset, gen_ulong(bytes_per_index));
@@ -1956,7 +1864,7 @@ expr2tc *dereferencet::extract_bytes_from_array(
   return exprs;
 }
 
-expr2tc *dereferencet::extract_bytes_from_scalar(
+std::vector<expr2tc> dereferencet::extract_bytes_from_scalar(
   const expr2tc &object,
   unsigned int num_bytes,
   const expr2tc &offset)
@@ -1965,7 +1873,7 @@ expr2tc *dereferencet::extract_bytes_from_scalar(
 
   const type2tc &bytetype = get_uint8_type();
 
-  expr2tc *bytes = new expr2tc[num_bytes];
+  std::vector<expr2tc> bytes(num_bytes);
 
   // Don't produce a byte update of a byte.
   if(is_bv_type(object) && num_bytes == 1 && object->type->get_width() == 8)
@@ -1994,20 +1902,18 @@ expr2tc *dereferencet::extract_bytes_from_scalar(
     simplify(accuml_offs);
   }
 
-  for(unsigned int i = 0; i < num_bytes; i++)
+  for(auto &byte : bytes)
   {
-    bytes[i] =
-      byte_extract2tc(bytetype, new_object, accuml_offs, is_big_endian);
+    byte = byte_extract2tc(bytetype, new_object, accuml_offs, is_big_endian);
     accuml_offs = add2tc(offset->type, accuml_offs, gen_ulong(1));
   }
 
   return bytes;
 }
 
-void dereferencet::stitch_together_from_byte_array(
-  expr2tc &value,
+expr2tc dereferencet::stitch_together_from_byte_array(
   unsigned int num_bytes,
-  const expr2tc *bytes)
+  const std::vector<expr2tc> &bytes)
 {
   assert(num_bytes != 0);
 
@@ -2035,23 +1941,56 @@ void dereferencet::stitch_together_from_byte_array(
     }
   }
 
-  value = accuml;
+  return accuml;
 }
 
 expr2tc dereferencet::stitch_together_from_byte_array(
   const type2tc &type,
-  unsigned int num_bytes,
   const expr2tc &byte_array,
-  const expr2tc &offset,
+  expr2tc offset_bits,
   const guardt & /* guard */)
 {
-  assert(num_bytes != 0);
+  /* TODO: check array bounds, (alignment?) */
+  assert(is_array_type(byte_array));
+  assert(to_array_type(byte_array->type).subtype->get_width() == 8);
 
-  expr2tc *bytes = extract_bytes_from_array(byte_array, num_bytes, offset);
-  expr2tc result;
-  stitch_together_from_byte_array(result, num_bytes, bytes);
-  delete[] bytes;
-  return bitcast2tc(type, result);
+  /* Is the value to be constructed also a byte-array? */
+  if(is_array_type(type) && is_constant_int2t(offset_bits))
+  {
+    const array_type2t &ret_type = to_array_type(type);
+    const array_type2t &arr_type = to_array_type(byte_array->type);
+    /* of known and matching size and zero offset? */
+    if(
+      is_constant_int2t(arr_type.array_size) &&
+      is_constant_int2t(ret_type.array_size) &&
+      to_constant_int2t(offset_bits).value == 0 &&
+      arr_type.subtype == ret_type.subtype &&
+      to_constant_int2t(arr_type.array_size).value ==
+        to_constant_int2t(ret_type.array_size).value)
+      return byte_array;
+  }
+
+  expr2tc offset_bytes = div2tc(offset_bits->type, offset_bits, gen_ulong(8));
+  simplify(offset_bytes);
+
+  BigInt num_bits = type_byte_size_bits(type);
+  assert(num_bits.is_uint64());
+  uint64_t num_bits64 = num_bits.to_uint64();
+  assert(num_bits64 <= ULONG_MAX);
+  unsigned int num_bytes =
+    compute_num_bytes_to_extract(offset_bits, num_bits64);
+
+  offset_bits = modulus2tc(offset_bits->type, offset_bits, gen_ulong(8));
+  simplify(offset_bits);
+
+  return bitcast2tc(
+    type,
+    extract_bits_from_byte_array(
+      stitch_together_from_byte_array(
+        num_bytes,
+        extract_bytes_from_array(byte_array, num_bytes, offset_bytes)),
+      offset_bits,
+      num_bits64));
 }
 
 void dereferencet::valid_check(
@@ -2065,7 +2004,7 @@ void dereferencet::valid_check(
   {
     // always valid, but can't write
 
-    if(mode == WRITE)
+    if(is_write(mode))
     {
       dereference_failure(
         "pointer dereference", "write access to string constant", guard);
@@ -2084,12 +2023,12 @@ void dereferencet::valid_check(
          to_symbol2t(symbol).thename.as_string(), "symex::invalid_object"))
     {
       // This is an invalid object; if we're in read or write mode, that's an error.
-      if(mode == READ || mode == WRITE)
+      if(is_read(mode) || is_write(mode))
         dereference_failure("pointer dereference", "invalid pointer", guard);
       return;
     }
 
-    const symbolt &sym = ns.lookup(to_symbol2t(symbol).thename);
+    const symbolt &sym = *ns.lookup(to_symbol2t(symbol).thename);
     if(has_prefix(sym.id.as_string(), "symex_dynamic::"))
     {
       // Assert thtat it hasn't (nondeterministically) been invalidated.
@@ -2100,14 +2039,14 @@ void dereferencet::valid_check(
       guardt tmp_guard(guard);
       tmp_guard.add(not_valid_expr);
 
-      std::string foo = (mode == FREE) ? "invalidated dynamic object freed"
-                                       : "invalidated dynamic object";
+      std::string foo = is_free(mode) ? "invalidated dynamic object freed"
+                                      : "invalidated dynamic object";
       dereference_failure("pointer dereference", foo, tmp_guard);
     }
     else
     {
       // Not dynamic; if we're in free mode, that's an error.
-      if(mode == FREE)
+      if(is_free(mode))
       {
         dereference_failure(
           "pointer dereference", "free() of non-dynamic memory", guard);
@@ -2149,7 +2088,7 @@ void dereferencet::bounds_check(
   if(
     !is_constant_array2t(expr) &&
     has_prefix(
-      ns.lookup(to_symbol2t(expr).thename).id.as_string(), "symex_dynamic::"))
+      ns.lookup(to_symbol2t(expr).thename)->id.as_string(), "symex_dynamic::"))
   {
     // Construct a dynamic_size irep.
     address_of2tc addrof(expr->type, expr);
@@ -2203,41 +2142,6 @@ void dereferencet::bounds_check(
   dereference_failure("array bounds", "array bounds violated", tmp_guard1);
 }
 
-void dereferencet::wrap_in_scalar_step_list(
-  expr2tc &value,
-  std::list<expr2tc> *scalar_step_list,
-  const guardt &guard)
-{
-  // Check that either the base type that these steps are applied to matches
-  // the type of the object we're wrapping in these steps. It's a type error
-  // if there isn't a match.
-  type2tc base_of_steps_type =
-    (*scalar_step_list->front()->get_sub_expr(0))->type;
-  base_of_steps_type = ns.follow(base_of_steps_type);
-
-  if(dereference_type_compare(value, base_of_steps_type))
-  {
-    // We can just reconstruct this.
-    expr2tc accuml = value;
-    for(std::list<expr2tc>::const_iterator it = scalar_step_list->begin();
-        it != scalar_step_list->end();
-        it++)
-    {
-      expr2tc tmp = *it;
-      *tmp->get_sub_expr_nc(0) = accuml;
-      accuml = tmp;
-    }
-    value = accuml;
-  }
-  else
-  {
-    // We can't reconstruct this. The base types are incompatible.
-    bad_base_type_failure(
-      guard, get_type_id(*value->type), get_type_id(*base_of_steps_type));
-    value = expr2tc();
-  }
-}
-
 bool dereferencet::check_code_access(
   expr2tc &value,
   const expr2tc &offset,
@@ -2261,7 +2165,7 @@ bool dereferencet::check_code_access(
     return false;
   }
 
-  if(mode != READ)
+  if(!is_read(mode))
   {
     dereference_failure(
       "Code separation", "Program code accessed in write or free mode", guard);
@@ -2286,7 +2190,8 @@ void dereferencet::check_data_obj_access(
   const expr2tc &value,
   const expr2tc &src_offset,
   const type2tc &type,
-  const guardt &guard)
+  const guardt &guard,
+  modet mode)
 {
   assert(!is_array_type(value));
 
@@ -2304,32 +2209,6 @@ void dereferencet::check_data_obj_access(
   add2tc add(access_sz_e->type, offset, access_sz_e);
   greaterthan2tc gt(add, data_sz_e);
 
-  // Check for FAM struct
-  if(is_struct_type(value->type))
-  {
-    // Here we are checking for a dynamic index of a FAM!
-    auto &v = to_struct_type(value->type);
-    auto last = v.members.back();
-    if(is_array_type(last) && !to_array_type(last).get_width())
-    {
-      msg.debug("FAM in obj access");
-      if(is_symbol2t(value))
-      {
-        auto fam = ns.lookup(to_symbol2t(value).thename);
-        // Is FAM pointing to a static object?
-        if(!has_prefix(fam.id.as_string(), "symex_dynamic::"))
-        {
-          msg.debug("Skipping FAM check on obj access");
-          return;
-        }
-        else
-        {
-          msg.debug("Dynamic memory for FAM");
-        }
-      }
-    }
-  }
-
   if(!options.get_bool_option("no-bounds-check"))
   {
     guardt tmp_guard = guard;
@@ -2338,8 +2217,10 @@ void dereferencet::check_data_obj_access(
       "pointer dereference", "Access to object out of bounds", tmp_guard);
   }
 
-  // Also, if if it's a scalar, check that the access being made is aligned.
-  if(is_scalar_type(type))
+  /* Also, if if it's a scalar and the access is not performed in an unaligned
+   * manner (e.g. for __attribute__((packed)) structures),
+   * check that the access being made is aligned. */
+  if(is_scalar_type(type) && !mode.unaligned)
     check_alignment(access_sz, std::move(offset), guard);
 }
 
@@ -2413,9 +2294,9 @@ unsigned int dereferencet::compute_num_bytes_to_extract(
   return num_bytes;
 }
 
-void dereferencet::extract_bits_from_byte_array(
-  expr2tc &value,
-  expr2tc offset,
+expr2tc dereferencet::extract_bits_from_byte_array(
+  const expr2tc &value,
+  const expr2tc &offset,
   unsigned long num_bits)
 {
   // Extract the target bits using bitwise AND
@@ -2430,6 +2311,7 @@ void dereferencet::extract_bits_from_byte_array(
   //          the number of full bytes converted to bits)
   //   rtype = unsignedbv type of width equal to num_bits
 
+  type2tc rtype = get_uint_type(num_bits);
 
   if(is_constant_int2t(offset))
   {
@@ -2437,7 +2319,7 @@ void dereferencet::extract_bits_from_byte_array(
     if(
       (num_bits % 8 == 0) &&
       (to_constant_int2t(offset).value.to_uint64() % 8 == 0))
-      return;
+      return value->type == rtype ? value : typecast2tc(rtype, value);
   }
   else
   {
@@ -2445,20 +2327,20 @@ void dereferencet::extract_bits_from_byte_array(
     // but the number of bits to be extracted is a multiple of 8,
     // we are just going to return the value
     if(num_bits % 8 == 0)
-      return;
+      return value->type == rtype ? value : typecast2tc(rtype, value);
   }
 
   expr2tc shft_expr = modulus2tc(offset->type, offset, gen_ulong(8));
-  shft_expr = bitcast2tc(value->type, shft_expr);
   simplify(shft_expr);
 
-  expr2tc mask_expr = gen_ulong(1);
-  mask_expr = shl2tc(mask_expr->type, mask_expr, gen_ulong(num_bits));
-  mask_expr = sub2tc(mask_expr->type, mask_expr, gen_ulong(1));
-  mask_expr = shl2tc(mask_expr->type, mask_expr, shft_expr);
-  mask_expr = bitcast2tc(value->type, mask_expr);
-  simplify(mask_expr);
+  expr2tc mask_expr = constant_int2tc(rtype, (BigInt(1) << num_bits) - 1);
 
-  value = bitand2tc(value->type, value, mask_expr);
-  value = lshr2tc(value->type, value, shft_expr);
+  assert(num_bits <= UINT_MAX);
+
+  expr2tc result;
+  result = lshr2tc(value->type, value, shft_expr);
+  result = typecast2tc(rtype, result);
+  result = bitand2tc(rtype, result, mask_expr);
+  simplify(result);
+  return result;
 }
diff --git a/src/pointer-analysis/dereference.h b/src/pointer-analysis/dereference.h
index a250951bb..7df79d73e 100644
--- a/src/pointer-analysis/dereference.h
+++ b/src/pointer-analysis/dereference.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Pointer Dereferencing
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_POINTER_ANALYSIS_DEREFERENCE_H
 #define CPROVER_POINTER_ANALYSIS_DEREFERENCE_H
 
@@ -136,7 +128,7 @@ public:
    *  optimisation expansion in the future, it isn't currently used by anything.
    *  @param expr An expression to be renamed
    */
-  virtual void rename(expr2tc &expr [[gnu::unused]])
+  virtual void rename(expr2tc &expr [[maybe_unused]])
   {
   }
 
@@ -148,7 +140,7 @@ public:
   };
 
   virtual void dump_internal_state(const std::list<struct internal_item> &data
-                                   [[gnu::unused]])
+                                   [[maybe_unused]])
   {
   }
 
@@ -183,14 +175,12 @@ public:
     const namespacet &_ns,
     contextt &_new_context,
     const optionst &_options,
-    dereference_callbackt &_dereference_callback,
-    const messaget &msg)
+    dereference_callbackt &_dereference_callback)
     : ns(_ns),
       new_context(_new_context),
       options(_options),
       dereference_callback(_dereference_callback),
-      block_assertions(false),
-      msg(msg)
+      block_assertions(false)
   {
     is_big_endian =
       (config.ansi_c.endianess == configt::ansi_ct::IS_BIG_ENDIAN);
@@ -199,13 +189,53 @@ public:
   virtual ~dereferencet() = default;
 
   /** The different ways in which a pointer may be accessed. */
-  typedef enum
+  struct modet
   {
-    READ,     /// The result of the expression is only read.
-    WRITE,    /// The result of the expression will be written to.
-    FREE,     /// The referred to object will be freed.
-    INTERNAL, /// Calling code only wants the internal value-set data.
-  } modet;
+    enum : unsigned
+    {
+      READ,     /// The result of the expression is only read.
+      WRITE,    /// The result of the expression will be written to.
+      FREE,     /// The referred to object will be freed.
+      INTERNAL, /// Calling code only wants the internal value-set data.
+    } op : 2;
+
+    /**
+     * Whether the access is performed in a non-standard, known-unaligned way
+     * as for, e.g., structures annotated with `__attribute__((packed))`.
+     */
+    unsigned unaligned : 1;
+
+    /* Intentionally provide no comparison operators in order to avoid counter-
+     * intuitive results when comparing, e.g., an unaligned mode with one of
+     * the (!unaligned) dereferencet::(READ|WRITE|FREE|INTERNAL) constants.
+     *
+     * For that the below predicates exist. */
+
+    friend bool is_read(const modet &m)
+    {
+      return m.op == READ;
+    }
+
+    friend bool is_write(const modet &m)
+    {
+      return m.op == WRITE;
+    }
+
+    friend bool is_free(const modet &m)
+    {
+      return m.op == FREE;
+    }
+
+    friend bool is_internal(const modet &m)
+    {
+      return m.op == INTERNAL;
+    }
+  };
+
+  static const constexpr modet READ = {modet::READ, false};
+  static const constexpr modet WRITE = {modet::WRITE, false};
+  static const constexpr modet FREE = {modet::FREE, false};
+  static const constexpr modet INTERNAL = {modet::INTERNAL, false};
 
   /** Take an expression and dereference it.
    *  This will descend through the whole of the expression given, and
@@ -257,7 +287,6 @@ private:
   std::list<dereference_callbackt::internal_item> internal_items;
   /** Flag for discarding all assertions encoded. */
   bool block_assertions;
-  const messaget &msg;
 
   /** Interpret an expression that modifies the guard. i.e., an 'if' or a
    *  piece of logic that can be short-circuited.
@@ -277,33 +306,36 @@ private:
   virtual void
   dereference_addrof_expr(expr2tc &expr, guardt &guard, modet mode);
 
-  /** Interpret an actual dereference (or pointer-index) expression. First
-   *  dereferences the pointer expression, then dereferences the pointer itself,
-   *  and stores the result in 'expr'.
-   *  @param expr The expression we're going to be dereferencing.
-   *  @param guard Guard of this expression being evaluated.
-   *  @param mode The manner iin which the result of this deref is accessed.
-   */
-  virtual void dereference_deref(expr2tc &expr, guardt &guard, modet mode);
-
   /** Interpret an expression that accesses a nonscalar type. This means that
    *  it's an index or member (or some other glue expr) on top of a dereference
-   *  that evaluates to an array or struct. This code collects all of these
-   *  expressions into a list, and supplies it to other dereference code, so
-   *  that we can directly build a reference to the field this expr wants. This
-   *  means that we don't have to build any intermediate struct or array
-   *  references, which is beneficial.
-   *  @param dest The expression that we're dereferencing.
+   *  that evaluates to an array or struct. This code tracks all of these
+   *  index/member expressions, and supplies it to other dereference code, so
+   *  that we can directly build a reference to the field this expr wants by
+   *  the offset selected by the `base` expression. This means that we don't
+   *  have to build any intermediate struct or array references, which is
+   *  beneficial.
+   *
+   *  Note that `expr` is modified in order to remove dereferences such as for
+   *  `array[*ptr]`. On success the result of the member/index chain `base` with
+   *  a dereference at the end is returned. Otherwise the empty expr2tc() is
+   *  returned to indicate that there was no dereference at the end of the
+   *  index/member chain.
+   *
+   *  A dereference at the end of the chain may be performed with
+   *  `mode.unaligned` set even if `mode` as passed to this function does not
+   *  have it. This happens in case `expr` refers to a member of a packed
+   *  structure.
+   *
+   *  @param expr The expression that we're resolving dereferences in.
    *  @param guard Guard of this expression being evaluated.
-   *  @param mode The manner iin which the result of this deref is accessed.
-   *  @param scalar_step_list A list in which we're accumulating the exprs used
-   *         to build a scalar access to an aggregate type.
+   *  @param mode The manner in which the result of this deref is accessed.
+   *  @param base The expression matching the initial `expr` in this recursion.
    */
   virtual expr2tc dereference_expr_nonscalar(
-    expr2tc &dest,
+    expr2tc &expr,
     guardt &guard,
     modet mode,
-    std::list<expr2tc> &scalar_step_list);
+    const expr2tc &base);
 
   /** Check whether an (aggregate) type is compatible with the desired
    *  dereference type. This looks at various things, such as whether the given
@@ -371,27 +403,21 @@ private:
     const type2tc &type,
     const guardt &guard);
   void valid_check(const expr2tc &expr, const guardt &guard, modet mode);
-  expr2tc* extract_bytes_from_array(
+  std::vector<expr2tc> extract_bytes_from_array(
     const expr2tc &array,
     unsigned int bytes,
     const expr2tc &offset);
-  expr2tc* extract_bytes_from_scalar(
+  std::vector<expr2tc> extract_bytes_from_scalar(
     const expr2tc &object,
     unsigned int bytes,
     const expr2tc &offset);
-  void stitch_together_from_byte_array(
-    expr2tc &value,
+  expr2tc stitch_together_from_byte_array(
     unsigned int num_bytes,
-    const expr2tc *bytes);
+    const std::vector<expr2tc> &bytes);
   expr2tc stitch_together_from_byte_array(
     const type2tc &type,
-    unsigned int num_bytes,
     const expr2tc &byte_array,
-    const expr2tc &offset_bits,
-    const guardt &guard);
-  void wrap_in_scalar_step_list(
-    expr2tc &value,
-    std::list<expr2tc> *scalar_step_list,
+    expr2tc offset_bits,
     const guardt &guard);
   void dereference_failure(
     const std::string &error_class,
@@ -414,17 +440,18 @@ private:
     const expr2tc &value,
     const expr2tc &offset,
     const type2tc &type,
-    const guardt &guard);
+    const guardt &guard,
+    modet mode);
   void check_alignment(
     unsigned long minwidth,
     const expr2tc &&offset,
     const guardt &guard);
-  unsigned int compute_num_bytes_to_extract(
+  unsigned int static compute_num_bytes_to_extract(
     const expr2tc offset,
     unsigned long num_bits);
-  void extract_bits_from_byte_array(
-    expr2tc &value,
-    expr2tc offset,
+  static expr2tc extract_bits_from_byte_array(
+    const expr2tc &value,
+    const expr2tc &offset,
     unsigned long num_bits);
 
 public:
diff --git a/src/pointer-analysis/goto_program_dereference.cpp b/src/pointer-analysis/goto_program_dereference.cpp
index cd118e563..96671f84e 100644
--- a/src/pointer-analysis/goto_program_dereference.cpp
+++ b/src/pointer-analysis/goto_program_dereference.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Dereferencing Operations on GOTO Programs
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <pointer-analysis/goto_program_dereference.h>
 #include <util/base_type.h>
 #include <irep2/irep2.h>
@@ -30,14 +22,18 @@ bool goto_program_dereferencet::has_failed_symbol(
       to_symbol2t(expr).thename == "INVALID")
       return false;
 
-    const symbolt &ptr_symbol = ns.lookup(migrate_expr_back(expr));
+    const symbolt &ptr_symbol = *ns.lookup(migrate_expr_back(expr));
 
     const irep_idt &failed_symbol = ptr_symbol.type.failed_symbol();
 
     if(failed_symbol == "")
       return false;
 
-    return !ns.lookup(failed_symbol, symbol);
+    const symbolt *s = ns.lookup(failed_symbol);
+    if(!s)
+      return false;
+    symbol = s;
+    return true;
   }
 
   return false;
@@ -68,7 +64,6 @@ void goto_program_dereferencet::dereference_failure(
       t->location = dereference_location;
       t->location.property(property);
       t->location.comment("dereference failure: " + msg);
-      t->assert_mode = goto_assertions::POINTER_SAFETY;
     }
   }
 }
@@ -231,13 +226,12 @@ void remove_pointers(
   goto_programt &goto_program,
   contextt &context,
   const optionst &options,
-  value_setst &value_sets,
-  const messaget &msg)
+  value_setst &value_sets)
 {
   namespacet ns(context);
 
   goto_program_dereferencet goto_program_dereference(
-    ns, context, options, value_sets, msg);
+    ns, context, options, value_sets);
 
   goto_program_dereference.dereference_program(goto_program);
 }
@@ -246,13 +240,12 @@ void remove_pointers(
   goto_functionst &goto_functions,
   contextt &context,
   const optionst &options,
-  value_setst &value_sets,
-  const messaget &msg)
+  value_setst &value_sets)
 {
   namespacet ns(context);
 
   goto_program_dereferencet goto_program_dereference(
-    ns, context, options, value_sets, msg);
+    ns, context, options, value_sets);
 
   Forall_goto_functions(it, goto_functions)
     goto_program_dereference.dereference_program(it->second.body);
@@ -262,12 +255,11 @@ void pointer_checks(
   goto_programt &goto_program,
   const namespacet &ns,
   const optionst &options,
-  value_setst &value_sets,
-  const messaget &msg)
+  value_setst &value_sets)
 {
-  contextt new_context(msg);
+  contextt new_context;
   goto_program_dereferencet goto_program_dereference(
-    ns, new_context, options, value_sets, msg);
+    ns, new_context, options, value_sets);
   goto_program_dereference.pointer_checks(goto_program);
 }
 
@@ -276,11 +268,10 @@ void pointer_checks(
   const namespacet &ns,
   contextt &context,
   const optionst &options,
-  value_setst &value_sets,
-  const messaget &msg)
+  value_setst &value_sets)
 {
   goto_program_dereferencet goto_program_dereference(
-    ns, context, options, value_sets, msg);
+    ns, context, options, value_sets);
   goto_program_dereference.pointer_checks(goto_functions);
 }
 
@@ -288,13 +279,12 @@ void dereference(
   goto_programt::const_targett target,
   expr2tc &expr,
   const namespacet &ns,
-  value_setst &value_sets,
-  const messaget &msg)
+  value_setst &value_sets)
 {
   optionst options;
-  contextt new_context(msg);
+  contextt new_context;
   goto_program_dereferencet goto_program_dereference(
-    ns, new_context, options, value_sets, msg);
+    ns, new_context, options, value_sets);
 
   goto_program_dereference.dereference_expression(target, expr);
 }
diff --git a/src/pointer-analysis/goto_program_dereference.h b/src/pointer-analysis/goto_program_dereference.h
index a9f9fdc35..ddd04028f 100644
--- a/src/pointer-analysis/goto_program_dereference.h
+++ b/src/pointer-analysis/goto_program_dereference.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Value Set
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_POINTER_ANALYSIS_GOTO_PROGRAM_DEREFERENCE_H
 #define CPROVER_POINTER_ANALYSIS_GOTO_PROGRAM_DEREFERENCE_H
 
@@ -21,13 +13,11 @@ public:
     const namespacet &_ns,
     contextt &_new_context,
     const optionst &_options,
-    value_setst &_value_sets,
-    const messaget &msg)
+    value_setst &_value_sets)
     : options(_options),
       ns(_ns),
       value_sets(_value_sets),
-      dereference(_ns, _new_context, _options, *this, msg),
-      new_code(msg)
+      dereference(_ns, _new_context, _options, *this)
   {
   }
 
@@ -88,15 +78,13 @@ void dereference(
   goto_programt::const_targett target,
   expr2tc &expr,
   const namespacet &ns,
-  value_setst &value_sets,
-  const messaget &msg);
+  value_setst &value_sets);
 
 void remove_pointers(
   goto_programt &goto_program,
   contextt &context,
   const optionst &options,
-  value_setst &value_sets,
-  const messaget &msg);
+  value_setst &value_sets);
 
 void remove_pointers(
   goto_functionst &goto_functions,
diff --git a/src/pointer-analysis/show_value_sets.cpp b/src/pointer-analysis/show_value_sets.cpp
index ac638ebf5..b018cbe9a 100644
--- a/src/pointer-analysis/show_value_sets.cpp
+++ b/src/pointer-analysis/show_value_sets.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Show Value Sets
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <pointer-analysis/show_value_sets.h>
 
 void show_value_sets(
diff --git a/src/pointer-analysis/show_value_sets.h b/src/pointer-analysis/show_value_sets.h
index 50e6e81c1..c9310bb3f 100644
--- a/src/pointer-analysis/show_value_sets.h
+++ b/src/pointer-analysis/show_value_sets.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Show Value Sets
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_GOTO_PROGRAMS_SHOW_VALUE_SETS_H
 #define CPROVER_GOTO_PROGRAMS_SHOW_VALUE_SETS_H
 
diff --git a/src/pointer-analysis/value_set.cpp b/src/pointer-analysis/value_set.cpp
index ae2e8090d..4cebc98aa 100644
--- a/src/pointer-analysis/value_set.cpp
+++ b/src/pointer-analysis/value_set.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Value Set
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <langapi/language_util.h>
 #include <pointer-analysis/value_set.h>
@@ -18,13 +10,13 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <util/i2string.h>
 #include <irep2/irep2.h>
 #include <util/migrate.h>
+#include <util/message.h>
+#include <util/message/format.h>
 #include <util/prefix.h>
 #include <util/simplify_expr.h>
 #include <util/std_code.h>
 #include <util/std_expr.h>
 #include <util/type_byte_size.h>
-#include <util/message/format.h>
-#include <util/message/default_message.h>
 
 object_numberingt value_sett::object_numbering;
 object_number_numberingt value_sett::obj_numbering_refset;
@@ -77,18 +69,18 @@ void value_sett::output(std::ostream &out) const
 
       // Display invalid / unknown objects as just that,
       if(is_invalid2t(o) || is_unknown2t(o))
-        result = from_expr(ns, identifier, o, msg);
+        result = from_expr(ns, identifier, o);
       else
       {
         // Everything else, display as a triple of <object, offset, type>.
-        result = "<" + from_expr(ns, identifier, o, msg) + ", ";
+        result = "<" + from_expr(ns, identifier, o) + ", ";
 
         if(o_it->second.offset_is_set)
           result += integer2string(o_it->second.offset) + "";
         else
           result += "*";
 
-        result += ", " + from_type(ns, identifier, o->type, msg);
+        result += ", " + from_type(ns, identifier, o->type);
 
         result += ">";
       }
@@ -252,14 +244,35 @@ void value_sett::get_value_set_rec(
     assert(is_struct_type(source_type) || is_union_type(source_type));
 #endif
 
-    // Add '.$field' to the suffix, identifying the member from the other
-    // members of the struct's variable.
-    get_value_set_rec(
-      memb.source_value,
-      dest,
-      "." + memb.member.as_string() + suffix,
-      original_type);
-
+    irep_idt single_source;
+    if(is_struct_type(memb.source_value))
+      single_source = memb.member;
+    else if(is_constant_union2t(memb.source_value))
+      single_source = to_constant_union2t(memb.source_value).init_field;
+    if(!single_source.empty())
+    {
+      // Add '.$field' to the suffix, identifying the member from the other
+      // members of the struct's variable.
+      get_value_set_rec(
+        memb.source_value,
+        dest,
+        "." + single_source.as_string() + suffix,
+        original_type);
+    }
+    else
+    {
+      /* We have a member of a union. The value-set of it is the same as the
+       * union of the value-sets of each member. */
+      assert(is_union_type(memb.source_value->type));
+      auto *u =
+        static_cast<const struct_union_data *>(memb.source_value->type.get());
+      for(const irep_idt &name : u->member_names)
+        get_value_set_rec(
+          memb.source_value,
+          dest,
+          "." + name.as_string() + suffix,
+          original_type);
+    }
     return;
   }
 
@@ -399,7 +412,7 @@ void value_sett::get_value_set_rec(
       return;
 
     default:
-      msg.error(fmt::format("Unexpected side-effect: {}", *expr));
+      log_error("Unexpected side-effect: {}", *expr);
       abort();
     }
   }
@@ -485,7 +498,7 @@ void value_sett::get_value_set_rec(
   }
 
   if(
-     /*is_bitor2t(expr) || is_bitand2t(expr) || */  is_bitxor2t(expr) ||
+    is_bitor2t(expr) || is_bitand2t(expr) || is_bitxor2t(expr) ||
     is_bitnand2t(expr) || is_bitnor2t(expr) || is_bitnxor2t(expr))
   {
     assert(expr->get_num_sub_exprs() == 2);
@@ -525,7 +538,7 @@ void value_sett::get_value_set_rec(
     }
   }
 
-  if(is_add2t(expr) || is_sub2t(expr) || is_bitand2t(expr) || is_bitor2t(expr))
+  if(is_add2t(expr) || is_sub2t(expr))
   {
     // Consider pointer arithmetic. This takes takes the form of finding the
     // value sets of the operands, then speculating on how the addition /
@@ -535,56 +548,25 @@ void value_sett::get_value_set_rec(
 
     // find the pointer operand
     // XXXjmorse - polymorphism.
-    const expr2tc *op0, *op1;
-    bool is_linear = false;
-    switch(expr->expr_id) {
-    case expr2t::add_id:
-    case expr2t::sub_id: {
-      auto *aop = static_cast<const arith_2ops *>(expr.get());
-      op0 = &aop->side_1;
-      op1 = &aop->side_2;
-      is_linear = true;
-      break;
-    }
-    case expr2t::bitand_id:
-    case expr2t::bitor_id: {
-      auto *aop = static_cast<const bit_2ops *>(expr.get());
-      op0 = &aop->side_1;
-      op1 = &aop->side_2;
-      break;
-    }
-    default:
-      abort();
-    }
+    const expr2tc &op0 =
+      (is_add2t(expr)) ? to_add2t(expr).side_1 : to_sub2t(expr).side_1;
+    const expr2tc &op1 =
+      (is_add2t(expr)) ? to_add2t(expr).side_2 : to_sub2t(expr).side_2;
 
     assert(
       (!is_pointer_type(expr) ||
-       !(is_pointer_type(*op0) && is_pointer_type(*op1))) &&
+       !(is_pointer_type(op0) && is_pointer_type(op1))) &&
       "Cannot have pointer arithmetic with two pointers as operands");
 
     // Find out what the pointer operand points at, and suck that data into
     // new object maps.
     object_mapt op0_set;
-      get_value_set_rec(*op0, op0_set, "", (*op0)->type, false);
+    if(!is_pointer_type(op1))
+      get_value_set_rec(op0, op0_set, "", op0->type, false);
 
     object_mapt op1_set;
-      get_value_set_rec(*op1, op1_set, "", (*op1)->type, false);
-    
-    auto op_contains_valid_address = [this](value_sett::object_mapt o) -> bool {
-      for(const auto &it : o)
-      {
-        auto expr = object_numbering[it.first];
-        if(is_symbol2t(expr) || is_constant_string2t(expr))
-          return true;
-      }
-
-      return false;
-    };
-
-    if(!op_contains_valid_address(op0_set))
-      op0_set.clear();
-    if(!op_contains_valid_address(op1_set))
-      op1_set.clear();
+    if(!is_pointer_type(op0))
+      get_value_set_rec(op1, op1_set, "", op1->type, false);
 
     /* TODO: The case that both, op0_set and op1_set, are non-empty is not
      *       handled, yet. */
@@ -593,9 +575,8 @@ void value_sett::get_value_set_rec(
     {
       bool op0_is_ptr = !op0_set.empty();
 
-      const expr2tc &ptr_op = op0_is_ptr ? *op0 : *op1;
-      const expr2tc &non_ptr_op = op0_is_ptr ? *op1 : *op0;
-
+      const expr2tc &ptr_op = op0_is_ptr ? op0 : op1;
+      const expr2tc &non_ptr_op = op0_is_ptr ? op1 : op0;
       const object_mapt &pointer_expr_set = op0_is_ptr ? op0_set : op1_set;
 
       type2tc subtype;
@@ -609,7 +590,7 @@ void value_sett::get_value_set_rec(
       bool is_const = false;
       try
       {
-        if(is_linear && is_constant_int2t(non_ptr_op))
+        if(is_constant_int2t(non_ptr_op))
         {
           if(to_constant_int2t(non_ptr_op).value.is_zero())
           {
@@ -657,9 +638,9 @@ void value_sett::get_value_set_rec(
         }
         else
         {
-          msg.error(fmt::format(
+          log_error(
             "Pointer arithmetic on type where we can't determine size\n{}",
-            *subtype));
+            *subtype);
           abort();
         }
       }
@@ -818,10 +799,16 @@ void value_sett::get_reference_set_rec(const expr2tc &expr, object_mapt &dest)
     bool has_const_index_offset = false;
     try
     {
-      if(is_constant_int2t(index.index))
+      /* We put some effort into determining whether the offset is constant
+       * since during symex many are and if they are overlooked we end up
+       * building huge if-then-else chains in all the
+       * dereference::construct_*_dyn_*_offset() methods. */
+      expr2tc idx = index.index;
+      simplify(idx);
+      if(is_constant_int2t(idx))
       {
         index_offset =
-          to_constant_int2t(index.index).value * type_byte_size(index.type);
+          to_constant_int2t(idx).value * type_byte_size(index.type);
         has_const_index_offset = true;
       }
     }
@@ -1294,7 +1281,7 @@ void value_sett::assign_rec(
   }
   else
   {
-    throw std::runtime_error(fmt::format("assign NYI: `{}'", get_expr_id(lhs)));
+    throw std::runtime_error("assign NYI: `{}'" + get_expr_id(lhs));
   }
 }
 
@@ -1439,8 +1426,9 @@ void value_sett::apply_code(const expr2tc &code)
   }
   else
   {
-    throw std::runtime_error(
-      fmt::format("{}\nvalue_sett: unexpected statement", *code));
+    std::ostringstream str;
+    str << code << "\nvalue_sett: unexpected statement";
+    throw std::runtime_error(str.str());
   }
 }
 
@@ -1450,15 +1438,23 @@ value_sett::make_member(const expr2tc &src, const irep_idt &component_name)
   const type2tc &type = src->type;
   assert(is_struct_type(type) || is_union_type(type));
 
-  const std::vector<type2tc> &members = (is_struct_type(type))
-                                          ? to_struct_type(type).members
-                                          : to_union_type(type).members;
+  auto *data = static_cast<const struct_union_data *>(type.get());
+  const std::vector<type2tc> &members = data->members;
 
   if(is_constant_struct2t(src))
   {
-    unsigned no = to_struct_type(type).get_component_number(component_name);
+    unsigned no = data->get_component_number(component_name);
     return to_constant_struct2t(src).datatype_members[no];
   }
+  if(is_constant_union2t(src))
+  {
+    const constant_union2t &un = to_constant_union2t(src);
+    if(un.init_field == component_name)
+    {
+      assert(un.datatype_members.size() == 1);
+      return un.datatype_members[0];
+    }
+  }
   if(is_with2t(src))
   {
     const with2t &with = to_with2t(src);
@@ -1480,8 +1476,7 @@ value_sett::make_member(const expr2tc &src, const irep_idt &component_name)
   }
 
   // give up
-  unsigned no = static_cast<const struct_union_data &>(*type.get())
-                  .get_component_number(component_name);
+  unsigned no = data->get_component_number(component_name);
   const type2tc &subtype = members[no];
   member2tc memb(subtype, src, component_name);
   return memb;
@@ -1489,10 +1484,9 @@ value_sett::make_member(const expr2tc &src, const irep_idt &component_name)
 
 void value_sett::dump() const
 {
-  default_message msg;
   std::ostringstream oss;
   output(oss);
-  msg.debug(oss.str());
+  log_debug("{}", oss.str());
 }
 
 void value_sett::obj_numbering_ref(unsigned int num)
diff --git a/src/pointer-analysis/value_set.h b/src/pointer-analysis/value_set.h
index 0d6275d73..507fc1085 100644
--- a/src/pointer-analysis/value_set.h
+++ b/src/pointer-analysis/value_set.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Value Set
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_POINTER_ANALYSIS_VALUE_SET_H
 #define CPROVER_POINTER_ANALYSIS_VALUE_SET_H
 
@@ -58,20 +50,18 @@ class value_sett
 {
 public:
   /** Primary constructor. Does approximately nothing non-standard. */
-  value_sett(const namespacet &_ns, const messaget &msg)
+  explicit value_sett(const namespacet &_ns)
     : location_number(0),
       ns(_ns),
-      msg(msg),
       xchg_name("value_sett::__ESBMC_xchg_ptr"),
       xchg_num(0)
   {
   }
 
-  explicit value_sett(const value_sett &ref)
+  value_sett(const value_sett &ref)
     : location_number(ref.location_number),
       values(ref.values),
       ns(ref.ns),
-      msg(ref.msg),
       xchg_name("value_sett::__ESBMC_xchg_ptr"),
       xchg_num(0)
   {
@@ -126,7 +116,7 @@ public:
       }
     }
 
-    explicit objectt(bool offset_set [[gnu::unused]], const BigInt &_offset)
+    explicit objectt(bool offset_set [[maybe_unused]], const BigInt &_offset)
       : offset(_offset), offset_is_set(true)
     {
       assert(offset_set);
@@ -674,7 +664,6 @@ public:
 
   /** Namespace for looking up types against. */
   const namespacet &ns;
-  const messaget &msg;
 
   irep_idt xchg_name;
   unsigned long xchg_num;
diff --git a/src/pointer-analysis/value_set_analysis.cpp b/src/pointer-analysis/value_set_analysis.cpp
index 33fa6b3c2..fa96b394a 100644
--- a/src/pointer-analysis/value_set_analysis.cpp
+++ b/src/pointer-analysis/value_set_analysis.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Value Set Propagation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <langapi/language_util.h>
 #include <pointer-analysis/value_set_analysis.h>
 #include <util/cprover_prefix.h>
@@ -57,7 +49,7 @@ void value_set_analysist::add_vars(const goto_programt &goto_program)
 
       if(e_it == entry_cache.end())
       {
-        const symbolt &symbol = ns.lookup(*l_it);
+        const symbolt &symbol = *ns.lookup(*l_it);
 
         std::list<value_sett::entryt> &entries = entry_cache[*l_it];
         get_entries(symbol, entries);
@@ -128,7 +120,7 @@ void value_set_analysist::add_vars(const goto_functionst &goto_functions)
 
       for(auto const &l_it : locals)
       {
-        const symbolt &symbol = ns.lookup(l_it);
+        const symbolt &symbol = *ns.lookup(l_it);
 
         std::list<value_sett::entryt> entries;
         get_entries(symbol, entries);
@@ -172,7 +164,7 @@ bool value_set_analysist::check_type(const typet &type)
 
 void value_set_analysist::convert(
   const goto_programt &goto_program,
-  const irep_idt &identifier [[gnu::unused]],
+  const irep_idt &identifier [[maybe_unused]],
   xmlt &dest) const
 {
   ::locationt previous_location;
diff --git a/src/pointer-analysis/value_set_analysis.h b/src/pointer-analysis/value_set_analysis.h
index 4e28ed2da..eec27069a 100644
--- a/src/pointer-analysis/value_set_analysis.h
+++ b/src/pointer-analysis/value_set_analysis.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Value Set Propagation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_POINTER_ANALYSIS_VALUE_PROPAGATION_H
 #define CPROVER_POINTER_ANALYSIS_VALUE_PROPAGATION_H
 
@@ -18,8 +10,8 @@ class value_set_analysist : public value_setst,
                             public static_analysist<value_set_domaint>
 {
 public:
-  value_set_analysist(const namespacet &_ns, const messaget &msg)
-    : static_analysist<value_set_domaint>(_ns, msg)
+  explicit value_set_analysist(const namespacet &_ns)
+    : static_analysist<value_set_domaint>(_ns)
   {
   }
 
diff --git a/src/pointer-analysis/value_set_domain.cpp b/src/pointer-analysis/value_set_domain.cpp
index d68a6e281..b584637e3 100644
--- a/src/pointer-analysis/value_set_domain.cpp
+++ b/src/pointer-analysis/value_set_domain.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Value Set
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <pointer-analysis/value_set_domain.h>
 #include <irep2/irep2.h>
 #include <util/migrate.h>
@@ -40,7 +32,7 @@ void value_set_domaint::transform(
   case FUNCTION_CALL:
   {
     const code_function_call2t &code = to_code_function_call2t(from_l->code);
-    const symbolt &symbol = ns.lookup(to_l->function);
+    const symbolt &symbol = *ns.lookup(to_l->function);
 
     const std::vector<expr2tc> &arguments = code.operands;
     value_set->do_function_call(symbol, arguments);
diff --git a/src/pointer-analysis/value_set_domain.h b/src/pointer-analysis/value_set_domain.h
index 7bc9b5f42..5579cd333 100644
--- a/src/pointer-analysis/value_set_domain.h
+++ b/src/pointer-analysis/value_set_domain.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Value Set
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_POINTER_ANALYSIS_VALUE_SET_DOMAIN_H
 #define CPROVER_POINTER_ANALYSIS_VALUE_SET_DOMAIN_H
 
@@ -44,16 +36,15 @@ public:
     return value_set->make_union(*other.value_set, keepnew);
   }
 
-  void
-  output(const namespacet &ns [[gnu::unused]], std::ostream &out) const override
+  void output(const namespacet &ns [[maybe_unused]], std::ostream &out)
+    const override
   {
     value_set->output(out);
   }
 
-  void
-  initialize(const namespacet &ns, locationt l, const messaget &msg) override
+  void initialize(const namespacet &ns, locationt l) override
   {
-    value_set = new value_sett(ns, msg);
+    value_set = new value_sett(ns);
     value_set->clear();
     value_set->location_number = l->location_number;
   }
@@ -62,7 +53,7 @@ public:
   transform(const namespacet &ns, locationt from_l, locationt to_l) override;
 
   void get_reference_set(
-    const namespacet &ns [[gnu::unused]],
+    const namespacet &ns [[maybe_unused]],
     const expr2tc &expr,
     value_setst::valuest &dest) override
   {
diff --git a/src/pointer-analysis/value_sets.h b/src/pointer-analysis/value_sets.h
index e32fe7b61..bf27a751a 100644
--- a/src/pointer-analysis/value_sets.h
+++ b/src/pointer-analysis/value_sets.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Value Set Propagation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_POINTER_ANALYSIS_VALUE_SETS_H
 #define CPROVER_POINTER_ANALYSIS_VALUE_SETS_H
 
diff --git a/src/solidity-frontend/pattern_check.cpp b/src/solidity-frontend/pattern_check.cpp
index c981f5818..34b4bcb09 100644
--- a/src/solidity-frontend/pattern_check.cpp
+++ b/src/solidity-frontend/pattern_check.cpp
@@ -3,16 +3,15 @@
 
 pattern_checker::pattern_checker(
   const nlohmann::json &_ast_nodes,
-  const std::string &_target_func,
-  const messaget &msg)
-  : ast_nodes(_ast_nodes), target_func(_target_func), msg(msg)
+  const std::string &_target_func)
+  : ast_nodes(_ast_nodes), target_func(_target_func)
 {
 }
 
 bool pattern_checker::do_pattern_check()
 {
   // TODO: add more functions here to perform more pattern-based checks
-  msg.status(fmt::format("Checking function {} ...", target_func.c_str()));
+  log_status("Checking function {} ...", target_func.c_str());
 
   unsigned index = 0;
   for(nlohmann::json::const_iterator itr = ast_nodes.begin();
@@ -47,9 +46,9 @@ void pattern_checker::check_authorization_through_tx_origin(
 {
   // looking for the pattern require(tx.origin == <VarDeclReference>)
   const nlohmann::json &body_stmt = func["body"]["statements"];
-  msg.progress(
+  log_progress(
     "  - Pattern-based checking: SWC-115 Authorization through tx.origin");
-  msg.debug("statements in function body array ... \n");
+  log_debug("statements in function body array ... \n");
 
   unsigned index = 0;
 
@@ -57,7 +56,7 @@ void pattern_checker::check_authorization_through_tx_origin(
       itr != body_stmt.end();
       ++itr, ++index)
   {
-    msg.status(fmt::format(" checking function body stmt {}", index));
+    log_status(" checking function body stmt {}", index);
     if(itr->contains("nodeType"))
     {
       if((*itr)["nodeType"].get<std::string>() == "ExpressionStatement")
@@ -127,9 +126,9 @@ void pattern_checker::check_tx_origin(const nlohmann::json &left_expr)
       if(left_expr["expression"]["name"].get<std::string>() == "tx")
       {
         //assert(!"Found vulnerability SWC-115 Authorization through tx.origin");
-        msg.error(
+        log_error(
           "Found vulnerability SWC-115 Authorization through tx.origin");
-        msg.error("VERIFICATION FAILED");
+        log_error("VERIFICATION FAILED");
         exit(EXIT_SUCCESS);
       }
     }
diff --git a/src/solidity-frontend/pattern_check.h b/src/solidity-frontend/pattern_check.h
index 3c5641c71..6888983ec 100644
--- a/src/solidity-frontend/pattern_check.h
+++ b/src/solidity-frontend/pattern_check.h
@@ -20,8 +20,7 @@ class pattern_checker
 public:
   pattern_checker(
     const nlohmann::json &_ast_nodes,
-    const std::string &_target_func,
-    const messaget &msg);
+    const std::string &_target_func);
   virtual ~pattern_checker() = default;
 
   bool do_pattern_check();
@@ -36,7 +35,6 @@ public:
 protected:
   const nlohmann::json &ast_nodes;
   const std::string target_func; // function to be verified
-  const messaget &msg;
 };
 
 #endif /* SOLIDITY_FRONTEND_PATTERN_CHECK_H_ */
diff --git a/src/solidity-frontend/solidity_convert.cpp b/src/solidity-frontend/solidity_convert.cpp
index bcb714de9..54ade1f24 100644
--- a/src/solidity-frontend/solidity_convert.cpp
+++ b/src/solidity-frontend/solidity_convert.cpp
@@ -9,21 +9,19 @@
 #include <util/std_code.h>
 #include <util/std_expr.h>
 #include <regex>
-#include <util/message/format.h>
+
 #include <fstream>
 
 solidity_convertert::solidity_convertert(
   contextt &_context,
   nlohmann::json &_ast_json,
   const std::string &_sol_func,
-  const std::string &_contract_path,
-  const messaget &msg)
+  const std::string &_contract_path)
   : context(_context),
     ns(context),
     ast_json(_ast_json),
     sol_func(_sol_func),
     contract_path(_contract_path),
-    msg(msg),
     global_scope_id(0),
     current_scope_var_num(1),
     current_functionDecl(nullptr),
@@ -70,7 +68,7 @@ bool solidity_convertert::convert()
       // pattern-based verification
       assert(itr->contains("nodes"));
       auto pattern_check =
-        std::make_unique<pattern_checker>((*itr)["nodes"], sol_func, msg);
+        std::make_unique<pattern_checker>((*itr)["nodes"], sol_func);
       if(pattern_check->do_pattern_check())
         return true; // 'true' indicates something goes wrong.
     }
@@ -103,11 +101,11 @@ bool solidity_convertert::convert_ast_nodes(const nlohmann::json &contract_def)
     nlohmann::json ast_node = *itr;
     std::string node_name = ast_node["name"].get<std::string>();
     std::string node_type = ast_node["nodeType"].get<std::string>();
-    msg.status(fmt::format(
+    log_debug(
       "@@ Converting node[{}]: name={}, nodeType={} ...",
       index,
       node_name.c_str(),
-      node_type.c_str()));
+      node_type.c_str());
     exprt dummy_decl;
     if(get_decl(ast_node, dummy_decl))
       return true;
@@ -164,10 +162,10 @@ bool solidity_convertert::get_var_decl_stmt(
 
   SolidityGrammar::VarDeclStmtT type =
     SolidityGrammar::get_var_decl_stmt_t(ast_node);
-  msg.status(fmt::format(
+  log_debug(
     "	@@@ got Variable-declaration-statement: "
     "SolidityGrammar::VarDeclStmtT::{}",
-    SolidityGrammar::var_decl_statement_to_str(type)));
+    SolidityGrammar::var_decl_statement_to_str(type));
 
   switch(type)
   {
@@ -272,8 +270,22 @@ bool solidity_convertert::get_var_decl(
     nlohmann::json init_value =
       is_state_var ? ast_node["value"] : ast_node["initialValue"];
 
+    nlohmann::json int_literal_type = nullptr;
+
+    auto expr_type = SolidityGrammar::get_expression_t(init_value);
+    bool expr_is_literal = expr_type == SolidityGrammar::Literal;
+    bool expr_is_un_op = expr_type == SolidityGrammar::UnaryOperatorClass;
+
+    auto subexpr = init_value["subExpression"];
+    bool subexpr_is_literal = subexpr == nullptr
+                                ? false
+                                : SolidityGrammar::get_expression_t(subexpr) ==
+                                    SolidityGrammar::Literal;
+    if(expr_is_literal || (expr_is_un_op && subexpr_is_literal))
+      int_literal_type = ast_node["typeDescriptions"];
+
     exprt val;
-    if(get_expr(init_value, val))
+    if(get_expr(init_value, int_literal_type, val))
       return true;
 
     solidity_gen_typecast(ns, val, t);
@@ -372,7 +384,7 @@ bool solidity_convertert::get_function_definition(
       type.arguments().push_back(param);
       ++num_param_decl;
     }
-    msg.status(fmt::format("  @@@ number of param decls: {}", num_param_decl));
+    log_debug("  @@@ number of param decls: {}", num_param_decl);
   }
 
   added_symbol.type = type;
@@ -461,9 +473,9 @@ bool solidity_convertert::get_block(
   get_start_location_from_stmt(block, location);
 
   SolidityGrammar::BlockT type = SolidityGrammar::get_block_t(block);
-  msg.debug(fmt::format(
+  log_debug(
     "	@@@ got Block: SolidityGrammar::BlockT::{}",
-    SolidityGrammar::block_to_str(type)));
+    SolidityGrammar::block_to_str(type));
 
   switch(type)
   {
@@ -486,7 +498,7 @@ bool solidity_convertert::get_block(
       _block.operands().push_back(statement);
       ++ctr;
     }
-    msg.debug(fmt::format(" \t@@@ CompoundStmt has {} statements", ctr));
+    log_debug(" \t@@@ CompoundStmt has {} statements", ctr);
 
     locationt location_end;
     get_final_location_from_stmt(block, location_end);
@@ -516,9 +528,9 @@ bool solidity_convertert::get_statement(
   // Just pass the new_expr reference to the next layer.
 
   SolidityGrammar::StatementT type = SolidityGrammar::get_statement_t(stmt);
-  msg.status(fmt::format(
+  log_debug(
     "	@@@ got Stmt: SolidityGrammar::StatementT::{}",
-    SolidityGrammar::statement_to_str(type)));
+    SolidityGrammar::statement_to_str(type));
 
   switch(type)
   {
@@ -563,7 +575,7 @@ bool solidity_convertert::get_statement(
       decls.operands().push_back(single_decl);
       ++ctr;
     }
-    msg.debug(fmt::format(" \t@@@ DeclStmt group has {} decls", ctr));
+    log_debug(" \t@@@ DeclStmt group has {} decls", ctr);
 
     new_expr = decls;
     break;
@@ -710,7 +722,35 @@ bool solidity_convertert::get_statement(
   return false;
 }
 
+/**
+ * @brief Populate the out parameter with the expression based on
+ * the solidity expression grammar
+ *
+ * @param expr The expression ast is to be converted to the IR
+ * @param new_expr Out parameter to hold the conversion
+ * @return true iff the conversion has failed
+ * @return false iff the conversion was successful
+ */
 bool solidity_convertert::get_expr(const nlohmann::json &expr, exprt &new_expr)
+{
+  return get_expr(expr, nullptr, new_expr);
+}
+
+/**
+ * @brief Populate the out parameter with the expression based on
+ * the solidity expression grammar
+ *
+ * @param expr The expression that is to be converted to the IR
+ * @param int_literal_type Type information ast to create the the literal
+ * type in the IR (only needed for when the expression is a literal)
+ * @param new_expr Out parameter to hold the conversion
+ * @return true iff the conversion has failed
+ * @return false iff the conversion was successful
+ */
+bool solidity_convertert::get_expr(
+  const nlohmann::json &expr,
+  const nlohmann::json &int_literal_type,
+  exprt &new_expr)
 {
   // For rule expression
   // We need to do location settings to match clang C's number of times to set the locations when recurring
@@ -718,9 +758,9 @@ bool solidity_convertert::get_expr(const nlohmann::json &expr, exprt &new_expr)
   get_start_location_from_stmt(expr, location);
 
   SolidityGrammar::ExpressionT type = SolidityGrammar::get_expression_t(expr);
-  msg.debug(fmt::format(
+  log_debug(
     "	@@@ got Expr: SolidityGrammar::ExpressionT::{}",
-    SolidityGrammar::expression_to_str(type)));
+    SolidityGrammar::expression_to_str(type));
 
   switch(type)
   {
@@ -733,7 +773,7 @@ bool solidity_convertert::get_expr(const nlohmann::json &expr, exprt &new_expr)
   }
   case SolidityGrammar::ExpressionT::UnaryOperatorClass:
   {
-    if(get_unary_operator_expr(expr, new_expr))
+    if(get_unary_operator_expr(expr, int_literal_type, new_expr))
       return true;
     break;
   }
@@ -785,12 +825,16 @@ bool solidity_convertert::get_expr(const nlohmann::json &expr, exprt &new_expr)
     const nlohmann::json &literal = expr["typeDescriptions"];
     SolidityGrammar::ElementaryTypeNameT type_name =
       SolidityGrammar::get_elementary_type_name_t(literal);
+    log_debug(
+      "	@@@ got Literal: SolidityGrammar::ElementaryTypeNameT::{}",
+      SolidityGrammar::elementary_type_name_to_str(type_name));
 
     switch(type_name)
     {
-    case SolidityGrammar::ElementaryTypeNameT::UINT8:
+    case SolidityGrammar::ElementaryTypeNameT::INT_LITERAL:
     {
-      if(convert_integer_literal(literal, the_value, new_expr))
+      assert(int_literal_type != nullptr);
+      if(convert_integer_literal(int_literal_type, the_value, new_expr))
         return true;
       break;
     }
@@ -800,6 +844,12 @@ bool solidity_convertert::get_expr(const nlohmann::json &expr, exprt &new_expr)
         return true;
       break;
     }
+    case SolidityGrammar::ElementaryTypeNameT::STRING_LITERAL:
+    {
+      if(convert_string_literal(the_value, new_expr))
+        return true;
+      break;
+    }
     default:
       assert(!"Literal not implemented");
     }
@@ -841,7 +891,7 @@ bool solidity_convertert::get_expr(const nlohmann::json &expr, exprt &new_expr)
       call.arguments().push_back(single_arg);
       ++num_args;
     }
-    msg.debug(fmt::format("  @@ num_args={}", num_args));
+    log_debug("  @@ num_args={}", num_args);
 
     // 4. Convert call arguments
     new_expr = call;
@@ -864,13 +914,14 @@ bool solidity_convertert::get_expr(const nlohmann::json &expr, exprt &new_expr)
     // wrap it in an ImplicitCastExpr to perform conversion of ArrayToPointerDecay
     nlohmann::json implicit_cast_expr =
       make_implicit_cast_expr(expr["baseExpression"], "ArrayToPointerDecay");
+
     exprt array;
     if(get_expr(implicit_cast_expr, array))
       return true;
 
     // 3. get the position index
     exprt pos;
-    if(get_expr(expr["indexExpression"], pos))
+    if(get_expr(expr["indexExpression"], expr["typeDescriptions"], pos))
       return true;
 
     new_expr = index_exprt(array, pos, t);
@@ -900,18 +951,22 @@ bool solidity_convertert::get_binary_operator_expr(
   exprt lhs, rhs;
   if(expr.contains("leftHandSide"))
   {
+    nlohmann::json literalType = expr["leftHandSide"]["typeDescriptions"];
+
     if(get_expr(expr["leftHandSide"], lhs))
       return true;
 
-    if(get_expr(expr["rightHandSide"], rhs))
+    if(get_expr(expr["rightHandSide"], literalType, rhs))
       return true;
   }
   else if(expr.contains("leftExpression"))
   {
-    if(get_expr(expr["leftExpression"], lhs))
+    nlohmann::json commonType = expr["commonType"];
+
+    if(get_expr(expr["leftExpression"], commonType, lhs))
       return true;
 
-    if(get_expr(expr["rightExpression"], rhs))
+    if(get_expr(expr["rightExpression"], commonType, rhs))
       return true;
   }
   else
@@ -927,9 +982,9 @@ bool solidity_convertert::get_binary_operator_expr(
   // 3. Convert opcode
   SolidityGrammar::ExpressionT opcode =
     SolidityGrammar::get_expr_operator_t(expr);
-  msg.debug(fmt::format(
+  log_debug(
     "	@@@ got binop.getOpcode: SolidityGrammar::{}",
-    SolidityGrammar::expression_to_str(opcode)));
+    SolidityGrammar::expression_to_str(opcode));
   switch(opcode)
   {
   case SolidityGrammar::ExpressionT::BO_Assign:
@@ -978,6 +1033,11 @@ bool solidity_convertert::get_binary_operator_expr(
     new_expr = exprt("mod", t);
     break;
   }
+  case SolidityGrammar::ExpressionT::BO_LAnd:
+  {
+    new_expr = exprt("and", t);
+    break;
+  }
   default:
   {
     assert(!"Unimplemented binary operator");
@@ -995,26 +1055,28 @@ bool solidity_convertert::get_binary_operator_expr(
 
 bool solidity_convertert::get_unary_operator_expr(
   const nlohmann::json &expr,
+  const nlohmann::json &int_literal_type,
   exprt &new_expr)
 {
-  // 1. get type
+  // TODO: Fix me! Currently just support prefix == true,e.g. pre-increment
+  assert(expr["prefix"]);
+
+  // 1. get UnaryOperation opcode
+  SolidityGrammar::ExpressionT opcode =
+    SolidityGrammar::get_unary_expr_operator_t(expr, expr["prefix"]);
+  log_debug(
+    "	@@@ got uniop.getOpcode: SolidityGrammar::{}",
+    SolidityGrammar::expression_to_str(opcode));
+
+  // 2. get type
   typet uniop_type;
-  assert(
-    expr
-      ["prefix"]); // TODO: Fix me! Currently just support prefix == true,e.g. pre-increment
   if(get_type_description(expr["typeDescriptions"], uniop_type))
     return true;
 
-  // 2. get subexpr
+  // 3. get subexpr
   exprt unary_sub;
-  if(get_expr(expr["subExpression"], unary_sub))
+  if(get_expr(expr["subExpression"], int_literal_type, unary_sub))
     return true;
-  // 3. get UnaryOperation opcode
-  SolidityGrammar::ExpressionT opcode =
-    SolidityGrammar::get_expr_operator_t(expr, expr["prefix"]);
-  msg.debug(fmt::format(
-    "	@@@ got uniop.getOpcode: SolidityGrammar::{}",
-    SolidityGrammar::expression_to_str(opcode)));
 
   switch(opcode)
   {
@@ -1028,6 +1090,11 @@ bool solidity_convertert::get_unary_operator_expr(
     new_expr = side_effect_exprt("preincrement", uniop_type);
     break;
   }
+  case SolidityGrammar::ExpressionT::UO_Minus:
+  {
+    new_expr = exprt("unary-", uniop_type);
+    break;
+  }
   default:
   {
     assert(!"Unimplemented unary operator");
@@ -1312,9 +1379,9 @@ bool solidity_convertert::get_type_description(
   }
   default:
   {
-    msg.debug(fmt::format(
+    log_debug(
       "	@@@ got type name=SolidityGrammar::TypeNameT::{}",
-      SolidityGrammar::type_name_to_str(type)));
+      SolidityGrammar::type_name_to_str(type));
     assert(!"Unimplemented type in rule type-name");
     return true;
   }
@@ -1363,8 +1430,7 @@ bool solidity_convertert::get_func_decl_ref_type(
   }
   default:
   {
-    msg.status(fmt::format(
-      "	@@@ Got type={}", SolidityGrammar::func_decl_ref_to_str(type)));
+    log_debug("	@@@ Got type={}", SolidityGrammar::func_decl_ref_to_str(type));
     assert(!"Unimplemented type in auxiliary type to convert function call");
     return true;
   }
@@ -1400,6 +1466,41 @@ bool solidity_convertert::get_array_to_pointer_type(
   return false;
 }
 
+/**
+ * @brief Populate the out `typet` parameter with the uint type specified by type parameter
+ *
+ * @param type The type of the uint to be poulated
+ * @param out The variable that holds the resulting type
+ * @return true iff population failed
+ * @return false iff population was successful
+ */
+bool solidity_convertert::get_elementary_type_name_uint(
+  SolidityGrammar::ElementaryTypeNameT &type,
+  typet &out)
+{
+  const unsigned int uint_size = SolidityGrammar::uint_type_name_to_size(type);
+  out = unsignedbv_typet(uint_size);
+
+  return false;
+}
+
+/**
+ * @brief Populate the out `typet` parameter with the int type specified by type parameter
+ *
+ * @param type The type of the int to be poulated
+ * @param out The variable that holds the resulting type
+ * @return false iff population was successful
+ */
+bool solidity_convertert::get_elementary_type_name_int(
+  SolidityGrammar::ElementaryTypeNameT &type,
+  typet &out)
+{
+  const unsigned int int_size = SolidityGrammar::int_type_name_to_size(type);
+  out = signedbv_typet(int_size);
+
+  return false;
+}
+
 bool solidity_convertert::get_elementary_type_name(
   const nlohmann::json &type_name,
   typet &new_type)
@@ -1410,14 +1511,88 @@ bool solidity_convertert::get_elementary_type_name(
   SolidityGrammar::ElementaryTypeNameT type =
     SolidityGrammar::get_elementary_type_name_t(type_name);
 
+  log_debug(
+    "	@@@ got ElementaryType: SolidityGrammar::ElementaryTypeNameT::{}", type);
+
   switch(type)
   {
   // rule unsigned-integer-type
   case SolidityGrammar::ElementaryTypeNameT::UINT8:
+  case SolidityGrammar::ElementaryTypeNameT::UINT16:
+  case SolidityGrammar::ElementaryTypeNameT::UINT24:
+  case SolidityGrammar::ElementaryTypeNameT::UINT32:
+  case SolidityGrammar::ElementaryTypeNameT::UINT40:
+  case SolidityGrammar::ElementaryTypeNameT::UINT48:
+  case SolidityGrammar::ElementaryTypeNameT::UINT56:
+  case SolidityGrammar::ElementaryTypeNameT::UINT64:
+  case SolidityGrammar::ElementaryTypeNameT::UINT72:
+  case SolidityGrammar::ElementaryTypeNameT::UINT80:
+  case SolidityGrammar::ElementaryTypeNameT::UINT88:
+  case SolidityGrammar::ElementaryTypeNameT::UINT96:
+  case SolidityGrammar::ElementaryTypeNameT::UINT104:
+  case SolidityGrammar::ElementaryTypeNameT::UINT112:
+  case SolidityGrammar::ElementaryTypeNameT::UINT120:
+  case SolidityGrammar::ElementaryTypeNameT::UINT128:
+  case SolidityGrammar::ElementaryTypeNameT::UINT136:
+  case SolidityGrammar::ElementaryTypeNameT::UINT144:
+  case SolidityGrammar::ElementaryTypeNameT::UINT152:
+  case SolidityGrammar::ElementaryTypeNameT::UINT160:
+  case SolidityGrammar::ElementaryTypeNameT::UINT168:
+  case SolidityGrammar::ElementaryTypeNameT::UINT176:
+  case SolidityGrammar::ElementaryTypeNameT::UINT184:
+  case SolidityGrammar::ElementaryTypeNameT::UINT192:
+  case SolidityGrammar::ElementaryTypeNameT::UINT200:
+  case SolidityGrammar::ElementaryTypeNameT::UINT208:
+  case SolidityGrammar::ElementaryTypeNameT::UINT216:
+  case SolidityGrammar::ElementaryTypeNameT::UINT224:
+  case SolidityGrammar::ElementaryTypeNameT::UINT232:
+  case SolidityGrammar::ElementaryTypeNameT::UINT240:
+  case SolidityGrammar::ElementaryTypeNameT::UINT248:
+  case SolidityGrammar::ElementaryTypeNameT::UINT256:
+  {
+    if(get_elementary_type_name_uint(type, new_type))
+      return true;
+    break;
+  }
+  case SolidityGrammar::ElementaryTypeNameT::INT8:
+  case SolidityGrammar::ElementaryTypeNameT::INT16:
+  case SolidityGrammar::ElementaryTypeNameT::INT24:
+  case SolidityGrammar::ElementaryTypeNameT::INT32:
+  case SolidityGrammar::ElementaryTypeNameT::INT40:
+  case SolidityGrammar::ElementaryTypeNameT::INT48:
+  case SolidityGrammar::ElementaryTypeNameT::INT56:
+  case SolidityGrammar::ElementaryTypeNameT::INT64:
+  case SolidityGrammar::ElementaryTypeNameT::INT72:
+  case SolidityGrammar::ElementaryTypeNameT::INT80:
+  case SolidityGrammar::ElementaryTypeNameT::INT88:
+  case SolidityGrammar::ElementaryTypeNameT::INT96:
+  case SolidityGrammar::ElementaryTypeNameT::INT104:
+  case SolidityGrammar::ElementaryTypeNameT::INT112:
+  case SolidityGrammar::ElementaryTypeNameT::INT120:
+  case SolidityGrammar::ElementaryTypeNameT::INT128:
+  case SolidityGrammar::ElementaryTypeNameT::INT136:
+  case SolidityGrammar::ElementaryTypeNameT::INT144:
+  case SolidityGrammar::ElementaryTypeNameT::INT152:
+  case SolidityGrammar::ElementaryTypeNameT::INT160:
+  case SolidityGrammar::ElementaryTypeNameT::INT168:
+  case SolidityGrammar::ElementaryTypeNameT::INT176:
+  case SolidityGrammar::ElementaryTypeNameT::INT184:
+  case SolidityGrammar::ElementaryTypeNameT::INT192:
+  case SolidityGrammar::ElementaryTypeNameT::INT200:
+  case SolidityGrammar::ElementaryTypeNameT::INT208:
+  case SolidityGrammar::ElementaryTypeNameT::INT216:
+  case SolidityGrammar::ElementaryTypeNameT::INT224:
+  case SolidityGrammar::ElementaryTypeNameT::INT232:
+  case SolidityGrammar::ElementaryTypeNameT::INT240:
+  case SolidityGrammar::ElementaryTypeNameT::INT248:
+  case SolidityGrammar::ElementaryTypeNameT::INT256:
+  {
+    if(get_elementary_type_name_int(type, new_type))
+      return true;
+    break;
+  }
+  case SolidityGrammar::ElementaryTypeNameT::INT_LITERAL:
   {
-    new_type = unsigned_char_type();
-    c_type = "unsigned_char";
-    new_type.set("#cpp_type", c_type);
     break;
   }
   case SolidityGrammar::ElementaryTypeNameT::BOOL:
@@ -1427,11 +1602,23 @@ bool solidity_convertert::get_elementary_type_name(
     new_type.set("#cpp_type", c_type);
     break;
   }
+  case SolidityGrammar::ElementaryTypeNameT::STRING:
+  {
+    size_t value_length = 128;
+
+    new_type = array_typet(
+      signed_char_type(),
+      constant_exprt(
+        integer2binary(value_length, bv_width(int_type())),
+        integer2string(value_length),
+        int_type()));
+    break;
+  }
   default:
   {
-    msg.debug(fmt::format(
+    log_debug(
       "	@@@ Got elementary-type-name={}",
-      SolidityGrammar::elementary_type_name_to_str(type)));
+      SolidityGrammar::elementary_type_name_to_str(type));
     assert(!"Unimplemented type in rule elementary-type-name");
     return true;
   }
@@ -1766,7 +1953,7 @@ void solidity_convertert::get_default_symbol(
   std::string id,
   locationt location)
 {
-  symbol.mode = "C";
+  symbol.mode = mode;
   symbol.module = module_name;
   symbol.location = std::move(location);
   symbol.type = std::move(type);
@@ -1776,32 +1963,7 @@ void solidity_convertert::get_default_symbol(
 
 symbolt *solidity_convertert::move_symbol_to_context(symbolt &symbol)
 {
-  symbolt *s = context.find_symbol(symbol.id);
-  if(s == nullptr)
-  {
-    if(context.move(symbol, s))
-    {
-      msg.error(fmt::format(
-        "Couldn't add symbol {} to symbol table\n{}", symbol.name, symbol));
-      abort();
-    }
-  }
-  else
-  {
-    // types that are code means functions
-    if(s->type.is_code())
-    {
-      if(symbol.value.is_not_nil() && !s->value.is_not_nil())
-        s->swap(symbol);
-    }
-    else if(s->is_type)
-    {
-      if(symbol.type.is_not_nil() && !s->type.is_not_nil())
-        s->swap(symbol);
-    }
-  }
-
-  return s;
+  return context.move_symbol_to_context(symbol);
 }
 
 void solidity_convertert::convert_expression_to_code(exprt &expr)
diff --git a/src/solidity-frontend/solidity_convert.h b/src/solidity-frontend/solidity_convert.h
index 64a130536..dc496941b 100644
--- a/src/solidity-frontend/solidity_convert.h
+++ b/src/solidity-frontend/solidity_convert.h
@@ -18,8 +18,7 @@ public:
     contextt &_context,
     nlohmann::json &_ast_json,
     const std::string &_sol_func,
-    const std::string &_contract_path,
-    const messaget &msg);
+    const std::string &_contract_path);
   virtual ~solidity_convertert() = default;
 
   bool convert();
@@ -31,7 +30,7 @@ protected:
     &ast_json; // json for Solidity AST. Use vector for multiple contracts
   const std::string &sol_func;      // Solidity function to be verified
   const std::string &contract_path; //smart contract source file
-  const messaget &msg;
+
   std::string absolute_path;
   std::string contract_contents = "";
   int global_scope_id; // scope id of "ContractDefinition"
@@ -62,8 +61,15 @@ protected:
       new_expr); // For Solidity's mutually inclusive: rule block and rule statement
   bool get_statement(const nlohmann::json &block, exprt &new_expr);
   bool get_expr(const nlohmann::json &expr, exprt &new_expr);
+  bool get_expr(
+    const nlohmann::json &expr,
+    const nlohmann::json &expr_common_type,
+    exprt &new_expr);
   bool get_binary_operator_expr(const nlohmann::json &expr, exprt &new_expr);
-  bool get_unary_operator_expr(const nlohmann::json &expr, exprt &new_expr);
+  bool get_unary_operator_expr(
+    const nlohmann::json &expr,
+    const nlohmann::json &int_literal_type,
+    exprt &new_expr);
   bool get_cast_expr(const nlohmann::json &cast_expr, exprt &new_expr);
   bool get_var_decl_ref(const nlohmann::json &decl, exprt &new_expr);
   bool get_func_decl_ref(const nlohmann::json &decl, exprt &new_expr);
@@ -139,6 +145,17 @@ protected:
     const nlohmann::json &bool_literal,
     std::string the_value,
     exprt &dest);
+  bool convert_string_literal(std::string the_value, exprt &dest);
+
+  static constexpr const char *mode = "C";
+
+private:
+  bool get_elementary_type_name_uint(
+    SolidityGrammar::ElementaryTypeNameT &type,
+    typet &out);
+  bool get_elementary_type_name_int(
+    SolidityGrammar::ElementaryTypeNameT &type,
+    typet &out);
 };
 
 #endif /* SOLIDITY_FRONTEND_SOLIDITY_CONVERT_H_ */
diff --git a/src/solidity-frontend/solidity_convert_literals.cpp b/src/solidity-frontend/solidity_convert_literals.cpp
index f4febe6e3..62fcbcaad 100644
--- a/src/solidity-frontend/solidity_convert_literals.cpp
+++ b/src/solidity-frontend/solidity_convert_literals.cpp
@@ -21,19 +21,12 @@ bool solidity_convertert::convert_integer_literal(
     type.is_unsignedbv() || type.is_signedbv()); // for "_x=100", false || true
 
   exprt the_val;
-  if(type.is_unsignedbv())
-  {
-    // extract the value: unsigned
-    unsigned z_ext_value = std::stoul(the_value, nullptr);
-    the_val = constant_exprt(
-      integer2binary(z_ext_value, bv_width(type)),
-      integer2string(z_ext_value),
-      type);
-  }
-  else
-  {
-    assert(!"Unimplemented - Got signed type. Add sigend bv conversion");
-  }
+  // extract the value: unsigned
+  BigInt z_ext_value = string2integer(the_value);
+  the_val = constant_exprt(
+    integer2binary(z_ext_value, bv_width(type)),
+    integer2string(z_ext_value),
+    type);
 
   dest.swap(the_val);
   return false;
@@ -66,7 +59,31 @@ bool solidity_convertert::convert_bool_literal(
 }
 
 // TODO: Character literal
-// TODO: String literal
+/**
+ * @brief Converts the string literal to a string_constt
+ * 
+ * @param the_value the value of the literal
+ * @param dest return reference
+ * @return true Only if the function fails
+ * @return false Only if the function successfully converts the literal
+ */
+bool solidity_convertert::convert_string_literal(
+  std::string the_value,
+  exprt &dest)
+{
+  size_t string_size = the_value.size();
+  typet type = array_typet(
+    signed_char_type(),
+    constant_exprt(
+      integer2binary(string_size, bv_width(int_type())),
+      integer2string(string_size),
+      int_type()));
+  // TODO: Handle null terminator byte
+  string_constantt string(the_value, type);
+  dest.swap(string);
+
+  return false;
+}
 // TODO: Float literal.
 //    - Note: Currently Solidity does NOT support floating point data types or fp arithmetic.
 //      Everything is done in fixed-point arithmetic as of Solidity compiler v0.8.6.
diff --git a/src/solidity-frontend/solidity_grammar.cpp b/src/solidity-frontend/solidity_grammar.cpp
index 44b662b0e..20b567e9d 100644
--- a/src/solidity-frontend/solidity_grammar.cpp
+++ b/src/solidity-frontend/solidity_grammar.cpp
@@ -1,13 +1,7 @@
-/*******************************************************************\
-
-Module: Solidity Language module
-
-Author: Kunjian Song, kunjian.song@postgrad.manchester.ac.uk
-
-\*******************************************************************/
-
 #include <solidity-frontend/solidity_grammar.h>
 #include <fmt/core.h>
+#include <set>
+#include <util/message.h>
 
 #define ENUM_TO_STR(s)                                                         \
   case s:                                                                      \
@@ -17,6 +11,53 @@ Author: Kunjian Song, kunjian.song@postgrad.manchester.ac.uk
 
 namespace SolidityGrammar
 {
+const std::unordered_map<std::string, ElementaryTypeNameT>
+  uint_string_to_type_map = {
+    {"uint8", UINT8},     {"uint16", UINT16},   {"uint24", UINT24},
+    {"uint32", UINT32},   {"uint40", UINT40},   {"uint48", UINT48},
+    {"uint56", UINT56},   {"uint64", UINT64},   {"uint72", UINT72},
+    {"uint80", UINT80},   {"uint88", UINT88},   {"uint96", UINT96},
+    {"uint104", UINT104}, {"uint112", UINT112}, {"uint120", UINT120},
+    {"uint128", UINT128}, {"uint136", UINT136}, {"uint144", UINT144},
+    {"uint152", UINT152}, {"uint160", UINT160}, {"uint168", UINT168},
+    {"uint176", UINT176}, {"uint184", UINT184}, {"uint192", UINT192},
+    {"uint200", UINT200}, {"uint208", UINT208}, {"uint216", UINT216},
+    {"uint224", UINT224}, {"uint232", UINT232}, {"uint240", UINT240},
+    {"uint248", UINT248}, {"uint256", UINT256},
+};
+
+const std::unordered_map<ElementaryTypeNameT, unsigned int> uint_size_map = {
+  {UINT8, 8},     {UINT16, 16},   {UINT24, 24},   {UINT32, 32},
+  {UINT40, 40},   {UINT48, 48},   {UINT56, 56},   {UINT64, 64},
+  {UINT72, 72},   {UINT80, 80},   {UINT88, 88},   {UINT96, 96},
+  {UINT104, 104}, {UINT112, 112}, {UINT120, 120}, {UINT128, 128},
+  {UINT136, 136}, {UINT144, 144}, {UINT152, 152}, {UINT160, 160},
+  {UINT168, 168}, {UINT176, 176}, {UINT184, 184}, {UINT192, 192},
+  {UINT200, 200}, {UINT208, 208}, {UINT216, 216}, {UINT224, 224},
+  {UINT232, 232}, {UINT240, 240}, {UINT248, 248}, {UINT256, 256},
+};
+const std::map<std::string, ElementaryTypeNameT> int_string_to_type_map = {
+  {"int8", INT8},     {"int16", INT16},   {"int24", INT24},
+  {"int32", INT32},   {"int40", INT40},   {"int48", INT48},
+  {"int56", INT56},   {"int64", INT64},   {"int72", INT72},
+  {"int80", INT80},   {"int88", INT88},   {"int96", INT96},
+  {"int104", INT104}, {"int112", INT112}, {"int120", INT120},
+  {"int128", INT128}, {"int136", INT136}, {"int144", INT144},
+  {"int152", INT152}, {"int160", INT160}, {"int168", INT168},
+  {"int176", INT176}, {"int184", INT184}, {"int192", INT192},
+  {"int200", INT200}, {"int208", INT208}, {"int216", INT216},
+  {"int224", INT224}, {"int232", INT232}, {"int240", INT240},
+  {"int248", INT248}, {"int256", INT256},
+};
+const std::map<ElementaryTypeNameT, unsigned int> int_size_map = {
+  {INT8, 8},     {INT16, 16},   {INT24, 24},   {INT32, 32},   {INT40, 40},
+  {INT48, 48},   {INT56, 56},   {INT64, 64},   {INT72, 72},   {INT80, 80},
+  {INT88, 88},   {INT96, 96},   {INT104, 104}, {INT112, 112}, {INT120, 120},
+  {INT128, 128}, {INT136, 136}, {INT144, 144}, {INT152, 152}, {INT160, 160},
+  {INT168, 168}, {INT176, 176}, {INT184, 184}, {INT192, 192}, {INT200, 200},
+  {INT208, 208}, {INT216, 216}, {INT224, 224}, {INT232, 232}, {INT240, 240},
+  {INT248, 248}, {INT256, 256},
+};
 // rule contract-body-element
 ContractBodyElementT get_contract_body_element_t(const nlohmann::json &element)
 {
@@ -34,11 +75,11 @@ ContractBodyElementT get_contract_body_element_t(const nlohmann::json &element)
   }
   else
   {
-    assert(!((fmt::format(
-                "Got contract-body-element nodeType={}. Unsupported "
-                "contract-body-element type",
-                element["nodeType"].get<std::string>()))
-               .c_str()));
+    log_error(
+      "Got contract-body-element nodeType={}. Unsupported "
+      "contract-body-element type",
+      element["nodeType"].get<std::string>());
+    abort();
   }
   return ContractBodyElementTError;
 }
@@ -65,21 +106,23 @@ TypeNameT get_type_name_t(const nlohmann::json &type_name)
   if(type_name.contains("typeString"))
   {
     // for AST node that contains ["typeName"]["typeDescriptions"]
-    if(type_name["typeString"] == "uint8" || type_name["typeString"] == "bool")
+    std::string typeString = type_name["typeString"].get<std::string>();
+
+    if(
+      uint_string_to_type_map.count(typeString) ||
+      int_string_to_type_map.count(typeString) || typeString == "bool" ||
+      typeString == "string" || typeString.find("literal_string") == 0 ||
+      typeString == "string storage ref" || typeString == "string memory")
     {
       // For state var declaration,
       return ElementaryTypeName;
     }
-    else if(
-      type_name["typeString"].get<std::string>().find("int_const") !=
-      std::string::npos)
+    else if(typeString.find("int_const") != std::string::npos)
     {
       // For Literal, their typeString is like "int_const 100".
       return ElementaryTypeName;
     }
-    else if(
-      type_name["typeString"].get<std::string>().find("function") !=
-      std::string::npos)
+    else if(typeString.find("function") != std::string::npos)
     {
       // FunctionToPointer decay in CallExpr when making a function call
       return Pointer;
@@ -108,10 +151,10 @@ TypeNameT get_type_name_t(const nlohmann::json &type_name)
     }
     else
     {
-      assert(!((fmt::format(
-                  "Got type-name typeString={}. Unsupported type-name type",
-                  type_name["typeString"].get<std::string>()))
-                 .c_str()));
+      log_error(
+        "Got type-name typeString={}. Unsupported type-name type",
+        type_name["typeString"].get<std::string>());
+      abort();
     }
   }
   else
@@ -123,10 +166,10 @@ TypeNameT get_type_name_t(const nlohmann::json &type_name)
     }
     else
     {
-      assert(!((fmt::format(
-                  "Got type-name nodeType={}. Unsupported type-name type",
-                  type_name["nodeType"].get<std::string>()))
-                 .c_str()));
+      log_error(
+        "Got type-name nodeType={}. Unsupported type-name type",
+        type_name["nodeType"].get<std::string>());
+      abort();
     }
   }
 
@@ -155,32 +198,47 @@ const char *type_name_to_str(TypeNameT type)
 // rule elementary-type-name
 ElementaryTypeNameT get_elementary_type_name_t(const nlohmann::json &type_name)
 {
+  std::string typeString = type_name["typeString"].get<std::string>();
   // rule unsigned-integer-type
-  if(type_name["typeString"] == "uint8")
+
+  if(uint_string_to_type_map.count(typeString))
   {
-    return UINT8;
+    return uint_string_to_type_map.at(typeString);
   }
-  else if(type_name["typeString"] == "bool")
+  if(int_string_to_type_map.count(typeString))
+  {
+    return int_string_to_type_map.at(typeString);
+  }
+  if(typeString == "bool")
   {
     return BOOL;
   }
-  else if(
-    type_name["typeString"].get<std::string>().find("int_const") !=
-    std::string::npos)
+  if(typeString.find("int_const") != std::string::npos)
   {
-    // For Literal, their typeString is like "int_const 100".
-    // TODO: Fix me! For simplicity, we assume everything is unsigned int.
-    return UINT8;
+    /**
+     * For Literal, their typeString is like "int_const 100".
+     * There is no additional type info (bitsize, signed/unsigned),
+     * This means it will require additional type info from the parent
+     * expr to create an internal type.
+     */
+    return INT_LITERAL;
   }
-  else
+  if(typeString.find("literal_string") == 0)
   {
-    assert(!((fmt::format(
-                "Got elementary-type-name typeString={}. Unsupported "
-                "elementary-type-name type",
-                type_name["typeString"].get<std::string>()))
-               .c_str()));
+    return STRING_LITERAL;
   }
-  return ElementaryTypeNameTError;
+  if(
+    typeString == "string" || typeString == "string storage ref" ||
+    typeString == "string memory")
+  {
+    return STRING;
+  }
+
+  log_error(
+    "Got elementary-type-name typeString={}. Unsupported "
+    "elementary-type-name type",
+    type_name["typeString"].get<std::string>());
+  abort();
 }
 
 const char *elementary_type_name_to_str(ElementaryTypeNameT type)
@@ -188,7 +246,73 @@ const char *elementary_type_name_to_str(ElementaryTypeNameT type)
   switch(type)
   {
     ENUM_TO_STR(UINT8)
+    ENUM_TO_STR(UINT16)
+    ENUM_TO_STR(UINT24)
+    ENUM_TO_STR(UINT32)
+    ENUM_TO_STR(UINT40)
+    ENUM_TO_STR(UINT48)
+    ENUM_TO_STR(UINT56)
+    ENUM_TO_STR(UINT64)
+    ENUM_TO_STR(UINT72)
+    ENUM_TO_STR(UINT80)
+    ENUM_TO_STR(UINT88)
+    ENUM_TO_STR(UINT96)
+    ENUM_TO_STR(UINT104)
+    ENUM_TO_STR(UINT112)
+    ENUM_TO_STR(UINT120)
+    ENUM_TO_STR(UINT128)
+    ENUM_TO_STR(UINT136)
+    ENUM_TO_STR(UINT144)
+    ENUM_TO_STR(UINT152)
+    ENUM_TO_STR(UINT160)
+    ENUM_TO_STR(UINT168)
+    ENUM_TO_STR(UINT176)
+    ENUM_TO_STR(UINT184)
+    ENUM_TO_STR(UINT192)
+    ENUM_TO_STR(UINT200)
+    ENUM_TO_STR(UINT208)
+    ENUM_TO_STR(UINT216)
+    ENUM_TO_STR(UINT224)
+    ENUM_TO_STR(UINT232)
+    ENUM_TO_STR(UINT240)
+    ENUM_TO_STR(UINT248)
+    ENUM_TO_STR(UINT256)
+    ENUM_TO_STR(INT_LITERAL)
+    ENUM_TO_STR(INT8)
+    ENUM_TO_STR(INT16)
+    ENUM_TO_STR(INT24)
+    ENUM_TO_STR(INT32)
+    ENUM_TO_STR(INT40)
+    ENUM_TO_STR(INT48)
+    ENUM_TO_STR(INT56)
+    ENUM_TO_STR(INT64)
+    ENUM_TO_STR(INT72)
+    ENUM_TO_STR(INT80)
+    ENUM_TO_STR(INT88)
+    ENUM_TO_STR(INT96)
+    ENUM_TO_STR(INT104)
+    ENUM_TO_STR(INT112)
+    ENUM_TO_STR(INT120)
+    ENUM_TO_STR(INT128)
+    ENUM_TO_STR(INT136)
+    ENUM_TO_STR(INT144)
+    ENUM_TO_STR(INT152)
+    ENUM_TO_STR(INT160)
+    ENUM_TO_STR(INT168)
+    ENUM_TO_STR(INT176)
+    ENUM_TO_STR(INT184)
+    ENUM_TO_STR(INT192)
+    ENUM_TO_STR(INT200)
+    ENUM_TO_STR(INT208)
+    ENUM_TO_STR(INT216)
+    ENUM_TO_STR(INT224)
+    ENUM_TO_STR(INT232)
+    ENUM_TO_STR(INT240)
+    ENUM_TO_STR(INT248)
+    ENUM_TO_STR(INT256)
     ENUM_TO_STR(BOOL)
+    ENUM_TO_STR(STRING_LITERAL)
+    ENUM_TO_STR(STRING)
     ENUM_TO_STR(ElementaryTypeNameTError)
   default:
   {
@@ -198,6 +322,16 @@ const char *elementary_type_name_to_str(ElementaryTypeNameT type)
   }
 }
 
+unsigned int uint_type_name_to_size(ElementaryTypeNameT type)
+{
+  return uint_size_map.at(type);
+}
+
+unsigned int int_type_name_to_size(ElementaryTypeNameT type)
+{
+  return int_size_map.at(type);
+}
+
 // rule parameter-list
 ParameterListT get_parameter_list_t(const nlohmann::json &type_name)
 {
@@ -237,10 +371,10 @@ BlockT get_block_t(const nlohmann::json &block)
   }
   else
   {
-    assert(!((fmt::format(
-                "Got block nodeType={}. Unsupported block type",
-                block["nodeType"].get<std::string>()))
-               .c_str()));
+    log_error(
+      "Got block nodeType={}. Unsupported block type",
+      block["nodeType"].get<std::string>());
+    abort();
   }
   return BlockTError;
 }
@@ -293,10 +427,10 @@ StatementT get_statement_t(const nlohmann::json &stmt)
   }
   else
   {
-    assert(!((fmt::format(
-                "Got statement nodeType={}. Unsupported statement type",
-                stmt["nodeType"].get<std::string>()))
-               .c_str()));
+    log_error(
+      "Got statement nodeType={}. Unsupported statement type",
+      stmt["nodeType"].get<std::string>());
+    abort();
   }
   return StatementTError;
 }
@@ -355,15 +489,42 @@ ExpressionT get_expression_t(const nlohmann::json &expr)
   }
   else
   {
-    assert(!((fmt::format(
-                "Got expression nodeType={}. Unsupported expression type",
-                expr["nodeType"].get<std::string>()))
-               .c_str()));
+    log_error(
+      "Got expression nodeType={}. Unsupported expression type",
+      expr["nodeType"].get<std::string>());
+    abort();
   }
   return ExpressionTError;
 }
 
-ExpressionT get_expr_operator_t(const nlohmann::json &expr, bool uo_pre)
+ExpressionT get_unary_expr_operator_t(const nlohmann::json &expr, bool uo_pre)
+{
+  if(expr["operator"] == "--")
+  {
+    if(uo_pre)
+      return UO_PreDec;
+
+    assert(!"Unsupported - UO_PostDec");
+  }
+  if(expr["operator"] == "++")
+  {
+    if(uo_pre)
+      return UO_PreInc;
+
+    assert(!"Unsupported - UO_PostDec");
+  }
+  if(expr["operator"] == "-")
+  {
+    return UO_Minus;
+  }
+  log_error(
+    "Got expression operator={}. Unsupported expression operator",
+    expr["operator"].get<std::string>());
+
+  abort();
+}
+
+ExpressionT get_expr_operator_t(const nlohmann::json &expr)
 {
   if(expr["operator"] == "=")
   {
@@ -397,34 +558,16 @@ ExpressionT get_expr_operator_t(const nlohmann::json &expr, bool uo_pre)
   {
     return BO_Rem;
   }
-  else if(expr["operator"] == "--")
-  {
-    if(uo_pre)
-    {
-      return UO_PreDec;
-    }
-    else
-    {
-      assert(!"Unsupported - UO_PostDec");
-    }
-  }
-  else if(expr["operator"] == "++")
+  else if(expr["operator"] == "&&")
   {
-    if(uo_pre)
-    {
-      return UO_PreInc;
-    }
-    else
-    {
-      assert(!"Unsupported - UO_PostDec");
-    }
+    return BO_LAnd;
   }
   else
   {
-    assert(!((fmt::format(
-                "Got expression operator={}. Unsupported expression operator",
-                expr["operator"].get<std::string>()))
-               .c_str()));
+    log_error(
+      "Got expression operator={}. Unsupported expression operator",
+      expr["operator"].get<std::string>());
+    abort();
   }
 
   return ExpressionTError; // make some old compilers happy
@@ -443,9 +586,11 @@ const char *expression_to_str(ExpressionT type)
     ENUM_TO_STR(BO_NE)
     ENUM_TO_STR(BO_EQ)
     ENUM_TO_STR(BO_Rem)
+    ENUM_TO_STR(BO_LAnd)
     ENUM_TO_STR(UnaryOperatorClass)
     ENUM_TO_STR(UO_PreDec)
     ENUM_TO_STR(UO_PreInc)
+    ENUM_TO_STR(UO_Minus)
     ENUM_TO_STR(DeclRefExprClass)
     ENUM_TO_STR(Literal)
     ENUM_TO_STR(CallExprClass)
@@ -470,11 +615,11 @@ VarDeclStmtT get_var_decl_stmt_t(const nlohmann::json &stmt)
   }
   else
   {
-    assert(!((fmt::format(
-                "Got expression nodeType={}. Unsupported "
-                "variable-declaration-statement operator",
-                stmt["nodeType"].get<std::string>()))
-               .c_str()));
+    log_error(
+      "Got expression nodeType={}. Unsupported "
+      "variable-declaration-statement operator",
+      stmt["nodeType"].get<std::string>());
+    abort();
   }
   return VarDeclStmtTError; // make some old compilers happy
 }
@@ -541,10 +686,8 @@ ImplicitCastTypeT get_implicit_cast_type_t(std::string cast)
   }
   else
   {
-    assert(
-      !((fmt::format(
-           "Got implicit cast type={}. Unsupported case type", cast.c_str()))
-          .c_str()));
+    log_error("Got implicit cast type={}. Unsupported case type", cast.c_str());
+    abort();
   }
 
   return ImplicitCastTypeTError; // to make some old compilers happy
diff --git a/src/solidity-frontend/solidity_grammar.h b/src/solidity-frontend/solidity_grammar.h
index 90469b11e..dc64f2dd6 100644
--- a/src/solidity-frontend/solidity_grammar.h
+++ b/src/solidity-frontend/solidity_grammar.h
@@ -49,14 +49,82 @@ const char *type_name_to_str(TypeNameT type);
 enum ElementaryTypeNameT
 {
   // rule unsigned-integer-type
-  UINT8 = 0,
+  UINT8,
+  UINT16,
+  UINT24,
+  UINT32,
+  UINT40,
+  UINT48,
+  UINT56,
+  UINT64,
+  UINT72,
+  UINT80,
+  UINT88,
+  UINT96,
+  UINT104,
+  UINT112,
+  UINT120,
+  UINT128,
+  UINT136,
+  UINT144,
+  UINT152,
+  UINT160,
+  UINT168,
+  UINT176,
+  UINT184,
+  UINT192,
+  UINT200,
+  UINT208,
+  UINT216,
+  UINT224,
+  UINT232,
+  UINT240,
+  UINT248,
+  UINT256,
+
+  INT_LITERAL,
+  // rule signed-integer-type
+  INT8,
+  INT16,
+  INT24,
+  INT32,
+  INT40,
+  INT48,
+  INT56,
+  INT64,
+  INT72,
+  INT80,
+  INT88,
+  INT96,
+  INT104,
+  INT112,
+  INT120,
+  INT128,
+  INT136,
+  INT144,
+  INT152,
+  INT160,
+  INT168,
+  INT176,
+  INT184,
+  INT192,
+  INT200,
+  INT208,
+  INT216,
+  INT224,
+  INT232,
+  INT240,
+  INT248,
+  INT256,
 
   // rule bool
   BOOL,
 
   // TODO: rule address
   // TODO: rule address payable
-  // TODO: rule string
+  // rule string
+  STRING,
+  STRING_LITERAL,
   // TODO: rule bytes
   // TODO: rule signed-integer-type
   // TODO: rule e
@@ -67,6 +135,10 @@ enum ElementaryTypeNameT
 };
 ElementaryTypeNameT get_elementary_type_name_t(const nlohmann::json &type_name);
 const char *elementary_type_name_to_str(ElementaryTypeNameT type);
+unsigned int uint_type_name_to_size(ElementaryTypeNameT);
+
+unsigned int uint_type_name_to_size(ElementaryTypeNameT);
+unsigned int int_type_name_to_size(ElementaryTypeNameT);
 
 // rule parameter-list
 enum ParameterListT
@@ -120,11 +192,13 @@ enum ExpressionT
   BO_NE,     // !=
   BO_EQ,     // ==
   BO_Rem,    // %
+  BO_LAnd,   // &&
 
   // UnaryOperator
   UnaryOperatorClass,
   UO_PreDec,
   UO_PreInc,
+  UO_Minus,
 
   // rule identifier
   DeclRefExprClass,
@@ -147,7 +221,9 @@ enum ExpressionT
   ExpressionTError
 };
 ExpressionT get_expression_t(const nlohmann::json &expr);
-ExpressionT get_expr_operator_t(const nlohmann::json &expr, bool uo_pre = true);
+ExpressionT get_expr_operator_t(const nlohmann::json &expr);
+ExpressionT
+get_unary_expr_operator_t(const nlohmann::json &expr, bool uo_pre = true);
 const char *expression_to_str(ExpressionT type);
 
 // rule variable-declaration-statement
diff --git a/src/solidity-frontend/solidity_language.cpp b/src/solidity-frontend/solidity_language.cpp
index caf933cd8..6ef1b86a3 100644
--- a/src/solidity-frontend/solidity_language.cpp
+++ b/src/solidity-frontend/solidity_language.cpp
@@ -1,9 +1,3 @@
-/*******************************************************************\
-
-Module: Solidity AST module
-
-\*******************************************************************/
-
 // Remove warnings from Clang headers
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wstrict-aliasing"
@@ -20,19 +14,19 @@ Module: Solidity AST module
 #include <clang-c-frontend/expr2c.h>
 #include <util/c_link.h>
 
-languaget *new_solidity_language(const messaget &msg)
+languaget *new_solidity_language()
 {
-  return new solidity_languaget(msg);
+  return new solidity_languaget;
 }
 
-std::string solidity_languaget::get_temp_file(const messaget &msg)
+std::string solidity_languaget::get_temp_file()
 {
   // Create a temp file for clang-tool
   // needed to convert intrinsics
   auto p = boost::filesystem::temp_directory_path();
   if(!boost::filesystem::exists(p) || !boost::filesystem::is_directory(p))
   {
-    msg.error("Can't find temporary directory (needed to convert intrinsics)");
+    log_error("Can't find temporary directory (needed to convert intrinsics)");
     abort();
   }
 
@@ -41,7 +35,7 @@ std::string solidity_languaget::get_temp_file(const messaget &msg)
   boost::filesystem::create_directory(p);
   if(!boost::filesystem::is_directory(p))
   {
-    msg.error(
+    log_error(
       "Can't create temporary directory (needed to convert intrinsics)");
     abort();
   }
@@ -56,19 +50,14 @@ std::string solidity_languaget::get_temp_file(const messaget &msg)
   return p.string();
 }
 
-solidity_languaget::solidity_languaget(const messaget &msg)
-  : clang_c_languaget(msg)
-{
-}
-
-bool solidity_languaget::parse(const std::string &path, const messaget &msg)
+bool solidity_languaget::parse(const std::string &path)
 {
   // prepare temp file
-  temp_path = get_temp_file(msg);
+  temp_path = get_temp_file();
 
   // get AST nodes of ESBMC intrinsics and the dummy main
   // populate ASTs inherited from parent class
-  clang_c_languaget::parse(temp_path, msg);
+  clang_c_languaget::parse(temp_path);
 
   // Process AST json file
   std::ifstream ast_json_file_stream(path);
@@ -100,39 +89,33 @@ bool solidity_languaget::parse(const std::string &path, const messaget &msg)
   return false;
 }
 
-bool solidity_languaget::convert_intrinsics(
-  contextt &context,
-  const messaget &msg)
+bool solidity_languaget::convert_intrinsics(contextt &context)
 {
-  clang_c_convertert converter(context, ASTs, msg);
+  clang_c_convertert converter(context, ASTs, "C");
   if(converter.convert())
     return true;
   return false;
 }
 
-bool solidity_languaget::typecheck(
-  contextt &context,
-  const std::string &module,
-  const messaget &msg)
+bool solidity_languaget::typecheck(contextt &context, const std::string &module)
 {
-  contextt new_context(msg);
+  contextt new_context;
   convert_intrinsics(
-    new_context, msg); // Add ESBMC and TACAS intrinsic symbols to the context
-  msg.progress("Done conversion of intrinsics...");
+    new_context); // Add ESBMC and TACAS intrinsic symbols to the context
+  log_progress("Done conversion of intrinsics...");
 
   solidity_convertert converter(
-    new_context, ast_json, func_name, smart_contract, msg);
+    new_context, ast_json, func_name, smart_contract);
   if(converter.convert()) // Add Solidity symbols to the context
     return true;
 
-  clang_c_adjust adjuster(new_context, msg);
+  clang_c_adjust adjuster(new_context);
   if(adjuster.adjust())
     return true;
 
   if(c_link(
        context,
        new_context,
-       msg,
        module)) // also populates language_uit::context
     return true;
 
@@ -144,10 +127,10 @@ void solidity_languaget::show_parse(std::ostream &)
   assert(!"come back and continue - solidity_languaget::show_parse");
 }
 
-bool solidity_languaget::final(contextt &context, const messaget &msg)
+bool solidity_languaget::final(contextt &context)
 {
-  add_cprover_library(context, msg);
-  return clang_main(context, msg);
+  add_cprover_library(context);
+  return clang_main(context);
 }
 
 std::string solidity_languaget::temp_c_file()
diff --git a/src/solidity-frontend/solidity_language.h b/src/solidity-frontend/solidity_language.h
index f2a1eccf2..0dc8fa0c1 100644
--- a/src/solidity-frontend/solidity_language.h
+++ b/src/solidity-frontend/solidity_language.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Solidity Language module
-
-Author: Kunjian Song, kunjian.song@postgrad.manchester.ac.uk
-
-\*******************************************************************/
-
 #ifndef SOLIDITY_FRONTEND_SOLIDITY_AST_LANGUAGE_H_
 #define SOLIDITY_FRONTEND_SOLIDITY_AST_LANGUAGE_H_
 
@@ -19,14 +11,11 @@ Author: Kunjian Song, kunjian.song@postgrad.manchester.ac.uk
 class solidity_languaget : public clang_c_languaget
 {
 public:
-  bool parse(const std::string &path, const messaget &msg) override;
+  bool parse(const std::string &path) override;
 
-  bool final(contextt &context, const messaget &msg) override;
+  bool final(contextt &context) override;
 
-  bool typecheck(
-    contextt &context,
-    const std::string &module,
-    const messaget &msg) override;
+  bool typecheck(contextt &context, const std::string &module) override;
 
   std::string id() const override
   {
@@ -39,19 +28,15 @@ public:
   std::string temp_path;
 
   // Functions to handle temp C file used by clang-c-frontend
-  std::string get_temp_file(const messaget &msg);
+  std::string get_temp_file();
   std::string temp_c_file();
 
-  languaget *new_language(const messaget &msg) const override
+  languaget *new_language() const override
   {
-    return new solidity_languaget(msg);
+    return new solidity_languaget;
   }
 
-  // constructor, destructor
-  ~solidity_languaget() override = default;
-  explicit solidity_languaget(const messaget &msg);
-
-  bool convert_intrinsics(contextt &context, const messaget &msg);
+  bool convert_intrinsics(contextt &context);
 
   // store AST json in nlohmann::json data structure
   nlohmann::json ast_json;
@@ -60,6 +45,6 @@ public:
   languaget *clang_c_module;
 };
 
-languaget *new_solidity_language(const messaget &msg);
+languaget *new_solidity_language();
 
 #endif /* SOLIDITY_FRONTEND_SOLIDITY_AST_LANGUAGE_H_ */
diff --git a/src/solvers/bitwuzla/CMakeLists.txt b/src/solvers/bitwuzla/CMakeLists.txt
index 2d9e76c2d..ca8ab00e6 100644
--- a/src/solvers/bitwuzla/CMakeLists.txt
+++ b/src/solvers/bitwuzla/CMakeLists.txt
@@ -22,7 +22,7 @@ if(ENABLE_BITWUZLA)
     target_include_directories(solverbitw
             PRIVATE ${Boost_INCLUDE_DIRS}
             PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})
-    target_link_libraries(solverbitw message message fmt::fmt Bitwuzla::bitwuzla)
+    target_link_libraries(solverbitw fmt::fmt Bitwuzla::bitwuzla)
 
     target_link_libraries(solvers INTERFACE solverbitw)
 
diff --git a/src/solvers/bitwuzla/bitwuzla_conv.cpp b/src/solvers/bitwuzla/bitwuzla_conv.cpp
index b7abee6fa..8fcc714fc 100644
--- a/src/solvers/bitwuzla/bitwuzla_conv.cpp
+++ b/src/solvers/bitwuzla/bitwuzla_conv.cpp
@@ -1,34 +1,29 @@
 #include <bitwuzla_conv.h>
 #include <cstring>
-#include <util/message/format.h>
 
 #define new_ast new_solver_ast<bitw_smt_ast>
 
 void bitwuzla_error_handler(const char *msg)
 {
-  assert(0 && fmt::format("Bitwuzla error encountered\n{}", msg).c_str());
+  log_error("Bitwuzla error encountered\n{}", msg);
   abort();
 }
 
 smt_convt *create_new_bitwuzla_solver(
   const optionst &options,
   const namespacet &ns,
-  tuple_iface **tuple_api [[gnu::unused]],
+  tuple_iface **tuple_api [[maybe_unused]],
   array_iface **array_api,
-  fp_convt **fp_api,
-  const messaget &msg)
+  fp_convt **fp_api)
 {
-  bitwuzla_convt *conv = new bitwuzla_convt(ns, options, msg);
+  bitwuzla_convt *conv = new bitwuzla_convt(ns, options);
   *array_api = static_cast<array_iface *>(conv);
   *fp_api = static_cast<fp_convt *>(conv);
   return conv;
 }
 
-bitwuzla_convt::bitwuzla_convt(
-  const namespacet &ns,
-  const optionst &options,
-  const messaget &msg)
-  : smt_convt(ns, options, msg), array_iface(true, true), fp_convt(this, msg)
+bitwuzla_convt::bitwuzla_convt(const namespacet &ns, const optionst &options)
+  : smt_convt(ns, options), array_iface(true, true), fp_convt(this)
 {
   bitw = bitwuzla_new();
   bitwuzla_set_option(bitw, BITWUZLA_OPT_PRODUCE_MODELS, 1);
@@ -545,15 +540,15 @@ smt_astt bitwuzla_convt::mk_select(smt_astt a, smt_astt b)
     a->sort->get_range_sort());
 }
 
-smt_astt bitwuzla_convt::mk_smt_int(const BigInt &theint [[gnu::unused]])
+smt_astt bitwuzla_convt::mk_smt_int(const BigInt &theint [[maybe_unused]])
 {
-  msg.error("ESBMC can't create integer sorts with Bitwuzla yet");
+  log_error("ESBMC can't create integer sorts with Bitwuzla yet");
   abort();
 }
 
-smt_astt bitwuzla_convt::mk_smt_real(const std::string &str [[gnu::unused]])
+smt_astt bitwuzla_convt::mk_smt_real(const std::string &str [[maybe_unused]])
 {
-  msg.error("ESBMC can't create real sorts with Bitwuzla yet");
+  log_error("ESBMC can't create real sorts with Bitwuzla yet");
   abort();
 }
 
@@ -578,7 +573,7 @@ smt_astt bitwuzla_convt::mk_smt_bool(bool val)
 smt_astt bitwuzla_convt::mk_array_symbol(
   const std::string &name,
   const smt_sort *s,
-  smt_sortt array_subtype [[gnu::unused]])
+  smt_sortt array_subtype [[maybe_unused]])
 {
   return mk_smt_symbol(name, s);
 }
@@ -605,7 +600,7 @@ bitwuzla_convt::mk_smt_symbol(const std::string &name, const smt_sort *s)
     break;
 
   default:
-    msg.error("Unknown type for symbol");
+    log_error("Unknown type for symbol");
     abort();
   }
 
@@ -690,7 +685,7 @@ bool bitwuzla_convt::get_bool(smt_astt a)
     res = false;
     break;
   default:
-    msg.error("Can't get boolean value from Bitwuzla");
+    log_error("Can't get boolean value from Bitwuzla");
     abort();
   }
   return res;
@@ -814,24 +809,17 @@ bitwuzla_convt::convert_array_of(smt_astt init_val, unsigned long domain_width)
 
 void bitwuzla_convt::dump_smt()
 {
-  auto f = msg.get_temp_file();
-  bitwuzla_dump_formula(bitw, "smt2", f.file());
-  msg.insert_file_contents(VerbosityLevel::Debug, f.file());
+  bitwuzla_dump_formula(bitw, "smt2", messaget::state.out);
 }
 
 void bitw_smt_ast::dump() const
 {
-  default_message msg;
-  auto f = msg.get_temp_file();
-  bitwuzla_term_dump(a, "smt2", f.file());
-  msg.insert_file_contents(VerbosityLevel::Debug, f.file());
+  bitwuzla_term_dump(a, "smt2", messaget::state.out);
 }
 
 void bitwuzla_convt::print_model()
 {
-  auto f = msg.get_temp_file();
-  bitwuzla_print_model(bitw, "smt2", f.file());
-  msg.insert_file_contents(VerbosityLevel::Status, f.file());
+  bitwuzla_print_model(bitw, "smt2", messaget::state.out);
 }
 
 smt_sortt bitwuzla_convt::mk_bool_sort()
diff --git a/src/solvers/bitwuzla/bitwuzla_conv.h b/src/solvers/bitwuzla/bitwuzla_conv.h
index 2f40cbbc5..30d5fc481 100644
--- a/src/solvers/bitwuzla/bitwuzla_conv.h
+++ b/src/solvers/bitwuzla/bitwuzla_conv.h
@@ -23,10 +23,7 @@ public:
 class bitwuzla_convt : public smt_convt, public array_iface, public fp_convt
 {
 public:
-  bitwuzla_convt(
-    const namespacet &ns,
-    const optionst &options,
-    const messaget &msg);
+  bitwuzla_convt(const namespacet &ns, const optionst &options);
   ~bitwuzla_convt() override;
 
   void push_ctx() override;
diff --git a/src/solvers/boolector/CMakeLists.txt b/src/solvers/boolector/CMakeLists.txt
index 49245ee18..1241d620e 100644
--- a/src/solvers/boolector/CMakeLists.txt
+++ b/src/solvers/boolector/CMakeLists.txt
@@ -17,12 +17,12 @@ if(ENABLE_BOOLECTOR)
     if(Boolector_VERSION VERSION_LESS Boolector_MIN_VERSION)
         message(FATAL_ERROR "Expected version ${Boolector_MIN_VERSION} or greater")
     endif()
-    
+
     add_library(solverbtor boolector_conv.cpp)
     target_include_directories(solverbtor
             PRIVATE ${Boost_INCLUDE_DIRS}
             PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})
-    target_link_libraries(solverbtor Boolector::boolector message fmt::fmt)
+    target_link_libraries(solverbtor Boolector::boolector fmt::fmt)
 
     target_link_libraries(solvers INTERFACE solverbtor)
 
diff --git a/src/solvers/boolector/boolector_conv.cpp b/src/solvers/boolector/boolector_conv.cpp
index cbf4d6a06..97f66a5de 100644
--- a/src/solvers/boolector/boolector_conv.cpp
+++ b/src/solvers/boolector/boolector_conv.cpp
@@ -1,39 +1,34 @@
 #include <boolector_conv.h>
 #include <cstring>
-#include <util/message/format.h>
 
 #define new_ast new_solver_ast<btor_smt_ast>
 
 void error_handler(const char *msg)
 {
-  assert(0 && fmt::format("Boolector error encountered\n{}", msg).c_str());
+  log_error("Boolector error encountered\n{}", msg);
   abort();
 }
 
 smt_convt *create_new_boolector_solver(
   const optionst &options,
   const namespacet &ns,
-  tuple_iface **tuple_api [[gnu::unused]],
+  tuple_iface **tuple_api [[maybe_unused]],
   array_iface **array_api,
-  fp_convt **fp_api,
-  const messaget &msg)
+  fp_convt **fp_api)
 {
-  boolector_convt *conv = new boolector_convt(ns, options, msg);
+  boolector_convt *conv = new boolector_convt(ns, options);
   *array_api = static_cast<array_iface *>(conv);
   *fp_api = static_cast<fp_convt *>(conv);
   return conv;
 }
 
-boolector_convt::boolector_convt(
-  const namespacet &ns,
-  const optionst &options,
-  const messaget &msg)
-  : smt_convt(ns, options, msg), array_iface(true, true), fp_convt(this, msg)
+boolector_convt::boolector_convt(const namespacet &ns, const optionst &options)
+  : smt_convt(ns, options), array_iface(true, true), fp_convt(this)
 
 {
   if(options.get_bool_option("int-encoding"))
   {
-    msg.error("Boolector does not support integer encoding mode");
+    log_error("Boolector does not support integer encoding mode");
     abort();
   }
 
@@ -515,15 +510,15 @@ smt_astt boolector_convt::mk_select(smt_astt a, smt_astt b)
     a->sort->get_range_sort());
 }
 
-smt_astt boolector_convt::mk_smt_int(const BigInt &theint [[gnu::unused]])
+smt_astt boolector_convt::mk_smt_int(const BigInt &theint [[maybe_unused]])
 {
-  ::boolector_convt::msg.error("Boolector can't create integer sorts");
+  log_error("Boolector can't create integer sorts");
   abort();
 }
 
-smt_astt boolector_convt::mk_smt_real(const std::string &str [[gnu::unused]])
+smt_astt boolector_convt::mk_smt_real(const std::string &str [[maybe_unused]])
 {
-  msg.error("Boolector can't create Real sorts");
+  log_error("Boolector can't create Real sorts");
   abort();
 }
 
@@ -544,7 +539,7 @@ smt_astt boolector_convt::mk_smt_bool(bool val)
 smt_astt boolector_convt::mk_array_symbol(
   const std::string &name,
   const smt_sort *s,
-  smt_sortt array_subtype [[gnu::unused]])
+  smt_sortt array_subtype [[maybe_unused]])
 {
   return mk_smt_symbol(name, s);
 }
@@ -579,7 +574,7 @@ boolector_convt::mk_smt_symbol(const std::string &name, const smt_sort *s)
     break;
 
   default:
-    msg.error("Unknown type for symbol");
+    log_error("Unknown type for symbol");
     abort();
   }
 
@@ -658,7 +653,7 @@ bool boolector_convt::get_bool(smt_astt a)
     res = false;
     break;
   default:
-    msg.error("Can't get boolean value from Boolector");
+    log_error("Can't get boolean value from Boolector");
     abort();
   }
 
@@ -690,7 +685,7 @@ expr2tc boolector_convt::get_array_elem(
     throw type2t::symbolic_type_excp();
 
   uint32_t size;
-  char **indicies, **values;
+  char **indicies = nullptr, **values = nullptr;
   boolector_array_assignment(btor, ast->a, &indicies, &values, &size);
 
   expr2tc ret = gen_zero(subtype);
@@ -795,24 +790,17 @@ boolector_convt::convert_array_of(smt_astt init_val, unsigned long domain_width)
 
 void boolector_convt::dump_smt()
 {
-  auto f = msg.get_temp_file();
-  boolector_dump_smt2(btor, f.file());
-  msg.insert_file_contents(VerbosityLevel::Debug, f.file());
+  boolector_dump_smt2(btor, messaget::state.out);
 }
 
 void btor_smt_ast::dump() const
 {
-  default_message msg;
-  auto f = msg.get_temp_file();
-  boolector_dump_smt2_node(boolector_get_btor(a), f.file(), a);
-  msg.insert_file_contents(VerbosityLevel::Debug, f.file());
+  boolector_dump_smt2_node(boolector_get_btor(a), messaget::state.out, a);
 }
 
 void boolector_convt::print_model()
 {
-  auto f = msg.get_temp_file();
-  boolector_print_model(btor, const_cast<char *>("smt2"), f.file());
-  msg.insert_file_contents(VerbosityLevel::Status, f.file());
+  boolector_print_model(btor, const_cast<char *>("smt2"), messaget::state.out);
 }
 
 smt_sortt boolector_convt::mk_bool_sort()
diff --git a/src/solvers/boolector/boolector_conv.h b/src/solvers/boolector/boolector_conv.h
index e218e86e2..994511570 100644
--- a/src/solvers/boolector/boolector_conv.h
+++ b/src/solvers/boolector/boolector_conv.h
@@ -23,10 +23,7 @@ public:
 class boolector_convt : public smt_convt, public array_iface, public fp_convt
 {
 public:
-  boolector_convt(
-    const namespacet &ns,
-    const optionst &options,
-    const messaget &msg);
+  boolector_convt(const namespacet &ns, const optionst &options);
   ~boolector_convt() override;
 
   void push_ctx() override;
diff --git a/src/solvers/cvc4/cvc_conv.cpp b/src/solvers/cvc4/cvc_conv.cpp
index 82eb2e9d0..5c80e12f2 100644
--- a/src/solvers/cvc4/cvc_conv.cpp
+++ b/src/solvers/cvc4/cvc_conv.cpp
@@ -1,30 +1,25 @@
 #include <util/c_types.h>
 #include <cvc_conv.h>
-#include <util/message/default_message.h>
 
 #define new_ast new_solver_ast<cvc_smt_ast>
 
 smt_convt *create_new_cvc_solver(
   const optionst &options,
   const namespacet &ns,
-  tuple_iface **tuple_api [[gnu::unused]],
+  tuple_iface **tuple_api [[maybe_unused]],
   array_iface **array_api,
-  fp_convt **fp_api,
-  const messaget &msg)
+  fp_convt **fp_api)
 {
-  cvc_convt *conv = new cvc_convt(ns, options, msg);
+  cvc_convt *conv = new cvc_convt(ns, options);
   *array_api = static_cast<array_iface *>(conv);
   *fp_api = static_cast<fp_convt *>(conv);
   return conv;
 }
 
-cvc_convt::cvc_convt(
-  const namespacet &ns,
-  const optionst &options,
-  const messaget &msg)
-  : smt_convt(ns, options, msg),
+cvc_convt::cvc_convt(const namespacet &ns, const optionst &options)
+  : smt_convt(ns, options),
     array_iface(false, false),
-    fp_convt(this, msg),
+    fp_convt(this),
     to_bv_counter(0),
     em(),
     smt(&em),
@@ -1273,18 +1268,16 @@ smt_sortt cvc_convt::mk_fpbv_rm_sort()
 
 void cvc_convt::dump_smt()
 {
-  default_message msg;
   std::ostringstream oss;
   auto const &assertions = smt.getAssertions();
   for(auto const &a : assertions)
     a.printAst(oss, 0);
-  msg.debug(oss.str());
+  log_debug("{}", oss.str());
 }
 
 void cvc_smt_ast::dump() const
 {
-  default_message msg;
   std::ostringstream oss;
   a.printAst(oss, 0);
-  msg.debug(oss.str());
+  log_debug("{}", oss.str());
 }
diff --git a/src/solvers/cvc4/cvc_conv.h b/src/solvers/cvc4/cvc_conv.h
index 9eb213b0b..8ea019be3 100644
--- a/src/solvers/cvc4/cvc_conv.h
+++ b/src/solvers/cvc4/cvc_conv.h
@@ -15,7 +15,7 @@ public:
 class cvc_convt : public smt_convt, public array_iface, public fp_convt
 {
 public:
-  cvc_convt(const namespacet &ns, const optionst &options, const messaget &msg);
+  cvc_convt(const namespacet &ns, const optionst &options);
   ~cvc_convt() override = default;
 
   smt_convt::resultt dec_solve() override;
diff --git a/src/solvers/mathsat/mathsat_conv.cpp b/src/solvers/mathsat/mathsat_conv.cpp
index 24f54c339..3345f425d 100644
--- a/src/solvers/mathsat/mathsat_conv.cpp
+++ b/src/solvers/mathsat/mathsat_conv.cpp
@@ -30,8 +30,8 @@ void mathsat_convt::check_msat_error(msat_term &r) const
 {
   if(MSAT_ERROR_TERM(r))
   {
-    msg.error("Error creating SMT ");
-    msg.error(fmt::format("Error text: \"{}\"", msat_last_error_message(env)));
+    log_error("Error creating SMT ");
+    log_error("Error text: \"{}\"", msat_last_error_message(env));
     abort();
   }
 }
@@ -39,24 +39,20 @@ void mathsat_convt::check_msat_error(msat_term &r) const
 smt_convt *create_new_mathsat_solver(
   const optionst &options,
   const namespacet &ns,
-  tuple_iface **tuple_api [[gnu::unused]],
+  tuple_iface **tuple_api [[maybe_unused]],
   array_iface **array_api,
-  fp_convt **fp_api,
-  const messaget &msg)
+  fp_convt **fp_api)
 {
-  mathsat_convt *conv = new mathsat_convt(ns, options, msg);
+  mathsat_convt *conv = new mathsat_convt(ns, options);
   *array_api = static_cast<array_iface *>(conv);
   *fp_api = static_cast<fp_convt *>(conv);
   return conv;
 }
 
-mathsat_convt::mathsat_convt(
-  const namespacet &ns,
-  const optionst &options,
-  const messaget &msg)
-  : smt_convt(ns, options, msg),
+mathsat_convt::mathsat_convt(const namespacet &ns, const optionst &options)
+  : smt_convt(ns, options),
     array_iface(false, false),
-    fp_convt(this, msg),
+    fp_convt(this),
     use_fp_api(false)
 {
   cfg = msat_parse_config(mathsat_config);
@@ -114,7 +110,7 @@ bool mathsat_convt::get_bool(smt_astt a)
     res = false;
   else
   {
-    msg.error("Boolean model value is neither true or false");
+    log_error("Boolean model value is neither true or false");
     abort();
   }
 
@@ -170,7 +166,7 @@ ieee_floatt mathsat_convt::get_fpbv(smt_astt a)
   size_t ew, sw;
   if(!msat_is_fp_type(env, to_solver_smt_sort<msat_type>(a->sort)->s, &ew, &sw))
   {
-    msg.error("Non FP type passed to mathsat_convt::get_exp_width");
+    log_error("Non FP type passed to mathsat_convt::get_exp_width");
     abort();
   }
 
@@ -773,7 +769,7 @@ smt_astt mathsat_convt::mk_smt_bool(bool val)
 smt_astt mathsat_convt::mk_array_symbol(
   const std::string &name,
   const smt_sort *s,
-  smt_sortt array_subtype [[gnu::unused]])
+  smt_sortt array_subtype [[maybe_unused]])
 {
   return mk_smt_symbol(name, s);
 }
@@ -894,9 +890,8 @@ mathsat_convt::convert_array_of(smt_astt init_val, unsigned long domain_width)
 mathsat_smt_ast::mathsat_smt_ast(
   smt_convt *ctx,
   msat_term _t,
-  const smt_sort *_s,
-  const messaget &msg)
-  : solver_smt_ast<msat_term>(ctx, _t, _s, msg)
+  const smt_sort *_s)
+  : solver_smt_ast<msat_term>(ctx, _t, _s)
 {
   auto convt = dynamic_cast<const mathsat_convt *>(context);
   assert(convt != nullptr);
@@ -905,12 +900,11 @@ mathsat_smt_ast::mathsat_smt_ast(
 
 void mathsat_smt_ast::dump() const
 {
-  default_message msg;
   // We need to get the env
   auto convt = dynamic_cast<const mathsat_convt *>(context);
   assert(convt != nullptr);
 
-  msg.debug(msat_to_smtlib2(convt->env, a));
+  log_debug("{}", msat_to_smtlib2(convt->env, a));
 }
 
 void mathsat_convt::dump_smt()
@@ -920,7 +914,7 @@ void mathsat_convt::dump_smt()
     msat_get_asserted_formulas(env, &num_of_asserted);
 
   for(unsigned i = 0; i < num_of_asserted; i++)
-    msg.status(msat_to_smtlib2(env, asserted_formulas[i]));
+    log_status("{}", msat_to_smtlib2(env, asserted_formulas[i]));
 
   msat_free(asserted_formulas);
 }
diff --git a/src/solvers/mathsat/mathsat_conv.h b/src/solvers/mathsat/mathsat_conv.h
index 4a83c7499..f7bc38ae7 100644
--- a/src/solvers/mathsat/mathsat_conv.h
+++ b/src/solvers/mathsat/mathsat_conv.h
@@ -8,11 +8,7 @@
 class mathsat_smt_ast : public solver_smt_ast<msat_term>
 {
 public:
-  mathsat_smt_ast(
-    smt_convt *ctx,
-    msat_term _t,
-    const smt_sort *_s,
-    const messaget &msg);
+  mathsat_smt_ast(smt_convt *ctx, msat_term _t, const smt_sort *_s);
   ~mathsat_smt_ast() override = default;
 
   void dump() const override;
@@ -21,10 +17,7 @@ public:
 class mathsat_convt : public smt_convt, public array_iface, public fp_convt
 {
 public:
-  mathsat_convt(
-    const namespacet &ns,
-    const optionst &options,
-    const messaget &msg);
+  mathsat_convt(const namespacet &ns, const optionst &options);
   ~mathsat_convt() override;
 
   resultt dec_solve() override;
diff --git a/src/solvers/minisat/minisat_conv.cpp b/src/solvers/minisat/minisat_conv.cpp
index 704380ac5..95b1745d0 100644
--- a/src/solvers/minisat/minisat_conv.cpp
+++ b/src/solvers/minisat/minisat_conv.cpp
@@ -7,9 +7,9 @@ smt_convt *create_new_minisat_solver(
   bool int_encoding,
   const namespacet &ns,
   const optionst &options,
-  tuple_iface **tuple_api [[gnu::unused]],
-  array_iface **array_api [[gnu::unused]],
-  fp_iface **fp_api [[gnu::unused]])
+  tuple_iface **tuple_api [[maybe_unused]],
+  array_iface **array_api [[maybe_unused]],
+  fp_iface **fp_api [[maybe_unused]])
 {
   minisat_convt *conv = new minisat_convt(int_encoding, ns, options);
   return conv;
diff --git a/src/solvers/prop/literal.h b/src/solvers/prop/literal.h
index e90996134..77a215045 100644
--- a/src/solvers/prop/literal.h
+++ b/src/solvers/prop/literal.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_PROPDEC_LITERAL_H
 #define CPROVER_PROPDEC_LITERAL_H
 
diff --git a/src/solvers/prop/pointer_logic.cpp b/src/solvers/prop/pointer_logic.cpp
index 00801a8de..44b5905b7 100644
--- a/src/solvers/prop/pointer_logic.cpp
+++ b/src/solvers/prop/pointer_logic.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Pointer Logic
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <pointer_logic.h>
 #include <util/arith_tools.h>
diff --git a/src/solvers/prop/pointer_logic.h b/src/solvers/prop/pointer_logic.h
index c8a4d04d4..830d9b47a 100644
--- a/src/solvers/prop/pointer_logic.h
+++ b/src/solvers/prop/pointer_logic.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Pointer Logic
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_POINTER_LOGIC_H
 #define CPROVER_POINTER_LOGIC_H
 
diff --git a/src/solvers/sat/bitblast_conv.cpp b/src/solvers/sat/bitblast_conv.cpp
index 0dd734bee..154e351b1 100644
--- a/src/solvers/sat/bitblast_conv.cpp
+++ b/src/solvers/sat/bitblast_conv.cpp
@@ -273,9 +273,9 @@ smt_astt bitblast_convt::mk_func_app(
     break;
   }
   default:
-    msg.error(fmt::format(
+    log_error(
       "Unimplemented SMT function \"{}\" in bitblast convt",
-      smt_func_name_table[f]));
+      smt_func_name_table[f]);
     abort();
   }
 
@@ -293,10 +293,10 @@ smt_sort *bitblast_convt::mk_sort(smt_sort_kind k, ...)
   switch(k)
   {
   case SMT_SORT_INT:
-    msg.error("Can't make Int sorts in bitblaster");
+    log_error("Can't make Int sorts in bitblaster");
     abort();
   case SMT_SORT_REAL:
-    msg.error("Can't make Real sorts in bitblaster");
+    log_error("Can't make Real sorts in bitblaster");
     abort();
   case SMT_SORT_BV:
     uint = va_arg(ap, unsigned long);
@@ -312,23 +312,22 @@ smt_sort *bitblast_convt::mk_sort(smt_sort_kind k, ...)
     s = new bitblast_smt_sort(k);
     break;
   default:
-    msg.error(
-      fmt::format("Unimplemented SMT sort {} in bitblaster conversion", k));
+    log_error("Unimplemented SMT sort {} in bitblaster conversion", k);
     abort();
   }
 
   return s;
 }
 
-smt_ast *bitblast_convt::mk_smt_int(const BigInt &intval [[gnu::unused]])
+smt_ast *bitblast_convt::mk_smt_int(const BigInt &intval [[maybe_unused]])
 {
-  msg.error("Can't create integers in bitblast solver");
+  log_error("Can't create integers in bitblast solver");
   abort();
 }
 
-smt_ast *bitblast_convt::mk_smt_real(const std::string &value [[gnu::unused]])
+smt_ast *bitblast_convt::mk_smt_real(const std::string &value [[maybe_unused]])
 {
-  msg.error("Can't create reals in bitblast solver");
+  log_error("Can't create reals in bitblast solver");
   abort();
 }
 
@@ -381,15 +380,15 @@ smt_astt bitblast_convt::mk_smt_symbol(const std::string &name, smt_sortt sort)
     break;
   }
   default:
-    msg.error(fmt::format(
-      "Unimplemented symbol type {} in bitblast symbol creation", sort->id));
+    log_error(
+      "Unimplemented symbol type {} in bitblast symbol creation", sort->id);
     abort();
   }
 
   return result;
 }
 
-smt_sort *bitblast_convt::mk_struct_sort(const type2tc &t [[gnu::unused]])
+smt_sort *bitblast_convt::mk_struct_sort(const type2tc &t [[maybe_unused]])
 {
   abort();
 }
@@ -433,12 +432,11 @@ bitblast_convt::mk_ast_equality(smt_astt _a, smt_astt _b, smt_sortt ressort)
   {
     // XXX - so, if we have different array encodings in the future then this
     // might get quite funky. Leave it until then, though.
-    msg.error("No direct array equality support in bitblast converter");
+    log_error("No direct array equality support in bitblast converter");
     abort();
   }
   default:
-    msg.error(
-      fmt::format("Invalid sort {} for equality in bitblast", a->sort->id));
+    log_error("Invalid sort {} for equality in bitblast", a->sort->id);
     abort();
   }
 }
diff --git a/src/solvers/smt/array_conv.cpp b/src/solvers/smt/array_conv.cpp
index b153b243c..212d32bf1 100644
--- a/src/solvers/smt/array_conv.cpp
+++ b/src/solvers/smt/array_conv.cpp
@@ -99,7 +99,7 @@ smt_astt array_convt::mk_array_symbol(
   size_t array_size = 1UL << domain_width;
 
   // Create new AST storage
-  array_ast *mast = new_ast(ms, ctx->msg);
+  array_ast *mast = new_ast(ms);
   mast->symname = name;
 
   if(is_unbounded_array(mast->sort))
@@ -187,7 +187,7 @@ smt_astt array_convt::mk_store(
 
   assert(ma->array_fields.size() != 0);
 
-  array_ast *mast = new_ast(ressort, ma->array_fields, ctx->msg);
+  array_ast *mast = new_ast(ressort, ma->array_fields);
 
   // If this is a constant index, simply update that particular field.
   if(is_constant_int2t(idx))
@@ -223,7 +223,7 @@ smt_astt array_convt::mk_store(
 smt_astt array_convt::mk_unbounded_select(
   const array_ast *ma,
   const expr2tc &real_idx,
-  smt_sortt ressort [[gnu::unused]])
+  smt_sortt ressort [[maybe_unused]])
 {
   // Store everything about this select, and return a free variable, that then
   // gets constrained at the end of conversion to tie up with the correct
@@ -294,7 +294,7 @@ smt_astt array_convt::mk_unbounded_store(
   array_indexes[ma->base_array_id].insert(new_idx_rec);
 
   // More nuanced: allocate a new array representation.
-  array_ast *newarr = new_ast(ressort, ctx->msg);
+  array_ast *newarr = new_ast(ressort);
   newarr->base_array_id = ma->base_array_id;
   newarr->array_update_num = array_updates[ma->base_array_id].size();
 
@@ -337,7 +337,7 @@ smt_astt array_convt::array_ite(
   assert(
     true_arr->array_fields.size() != 0 &&
     true_arr->array_fields.size() == false_arr->array_fields.size());
-  array_ast *mast = new_ast(thesort, ctx->msg);
+  array_ast *mast = new_ast(thesort);
   unsigned long i;
   for(i = 0; i < true_arr->array_fields.size(); i++)
   {
@@ -363,7 +363,7 @@ smt_astt array_convt::unbounded_array_ite(
   unsigned int new_arr_id =
     std::min(true_arr->base_array_id, false_arr->base_array_id); // yolo
 
-  array_ast *newarr = new_ast(thesort, ctx->msg);
+  array_ast *newarr = new_ast(thesort);
   newarr->base_array_id = new_arr_id;
   newarr->array_update_num = array_updates[true_arr->base_array_id].size();
 
@@ -405,7 +405,7 @@ smt_astt array_convt::convert_array_of_wsort(
   unsigned long domain_width,
   smt_sortt arr_sort)
 {
-  array_ast *mast = new_ast(arr_sort, ctx->msg);
+  array_ast *mast = new_ast(arr_sort);
   if(is_unbounded_array(arr_sort))
   {
     // If this is an unbounded array, simply store the value of the initializer
@@ -1316,7 +1316,7 @@ void array_convt::add_initial_ackerman_constraints(
   }
 }
 
-smt_astt array_ast::eq(smt_convt *ctx [[gnu::unused]], smt_astt sym) const
+smt_astt array_ast::eq(smt_convt *ctx [[maybe_unused]], smt_astt sym) const
 {
   const array_ast *other = array_downcast(sym);
 
@@ -1328,13 +1328,13 @@ smt_astt array_ast::eq(smt_convt *ctx [[gnu::unused]], smt_astt sym) const
   return array_ctx->mk_bounded_array_equality(this, other);
 }
 
-void array_ast::assign(smt_convt *ctx [[gnu::unused]], smt_astt sym) const
+void array_ast::assign(smt_convt *ctx [[maybe_unused]], smt_astt sym) const
 {
   array_ctx->convert_array_assign(this, sym);
 }
 
 smt_astt array_ast::update(
-  smt_convt *ctx [[gnu::unused]],
+  smt_convt *ctx [[maybe_unused]],
   smt_astt value,
   unsigned int idx,
   expr2tc idx_expr) const
@@ -1347,7 +1347,7 @@ smt_astt array_ast::update(
 }
 
 smt_astt
-array_ast::select(smt_convt *ctx [[gnu::unused]], const expr2tc &idx) const
+array_ast::select(smt_convt *ctx [[maybe_unused]], const expr2tc &idx) const
 {
   // Look up the array subtype sort. If we're unbounded, use the base array id
   // to do that, otherwise pull the subtype out of an element.
@@ -1361,7 +1361,7 @@ array_ast::select(smt_convt *ctx [[gnu::unused]], const expr2tc &idx) const
 }
 
 smt_astt array_ast::ite(
-  smt_convt *ctx [[gnu::unused]],
+  smt_convt *ctx [[maybe_unused]],
   smt_astt cond,
   smt_astt falseop) const
 {
diff --git a/src/solvers/smt/array_conv.h b/src/solvers/smt/array_conv.h
index 48dd6c9cb..ef11dc776 100644
--- a/src/solvers/smt/array_conv.h
+++ b/src/solvers/smt/array_conv.h
@@ -19,7 +19,6 @@
 #include <set>
 #include <solvers/smt/smt_conv.h>
 #include <irep2/irep2.h>
-#include <util/message/default_message.h>
 
 static inline bool is_unbounded_array(const smt_sort *s)
 {
@@ -41,12 +40,8 @@ class array_ast : public smt_ast
 public:
 #define array_downcast(x) static_cast<const array_ast *>(x)
 
-  array_ast(
-    array_convt *actx,
-    smt_convt *ctx,
-    const smt_sort *_s,
-    const messaget &msg)
-    : smt_ast(ctx, _s, msg), symname(""), array_ctx(actx)
+  array_ast(array_convt *actx, smt_convt *ctx, const smt_sort *_s)
+    : smt_ast(ctx, _s), symname(""), array_ctx(actx)
   {
   }
 
@@ -54,9 +49,8 @@ public:
     array_convt *actx,
     smt_convt *ctx,
     const smt_sort *_s,
-    std::vector<smt_astt> _a,
-    const messaget &msg)
-    : smt_ast(ctx, _s, msg),
+    std::vector<smt_astt> _a)
+    : smt_ast(ctx, _s),
       symname(""),
       array_fields(std::move(_a)),
       array_ctx(actx)
@@ -79,8 +73,7 @@ public:
 
   void dump() const override
   {
-    default_message msg;
-    msg.debug(fmt::format("name: {}", symname));
+    log_debug("name: {}", symname);
     for(auto const &e : array_fields)
       e->dump();
   }
@@ -233,15 +226,14 @@ public:
   void execute_new_updates();
   void apply_new_selects();
 
-  inline array_ast *new_ast(smt_sortt _s, const messaget &msg)
+  inline array_ast *new_ast(smt_sortt _s)
   {
-    return new array_ast(this, ctx, _s, msg);
+    return new array_ast(this, ctx, _s);
   }
 
-  inline array_ast *
-  new_ast(smt_sortt _s, const std::vector<smt_astt> &_a, const messaget &msg)
+  inline array_ast *new_ast(smt_sortt _s, const std::vector<smt_astt> &_a)
   {
-    return new array_ast(this, ctx, _s, _a, msg);
+    return new array_ast(this, ctx, _s, _a);
   }
 
   void push_array_ctx() override;
diff --git a/src/solvers/smt/fp/fp_conv.cpp b/src/solvers/smt/fp/fp_conv.cpp
index b75b6d93b..dbb41b22c 100644
--- a/src/solvers/smt/fp/fp_conv.cpp
+++ b/src/solvers/smt/fp/fp_conv.cpp
@@ -42,7 +42,7 @@ static BigInt power2m1(std::size_t n, bool negated)
   return b;
 }
 
-fp_convt::fp_convt(smt_convt *_ctx, const messaget &msg) : ctx(_ctx), _msg(msg)
+fp_convt::fp_convt(smt_convt *_ctx) : ctx(_ctx)
 {
 }
 
@@ -2133,7 +2133,7 @@ smt_astt fp_convt::mk_is_rm(smt_astt &rme, ieee_floatt::rounding_modet rm)
     break;
   }
 
-  _msg.error("Unknown rounding mode");
+  log_error("Unknown rounding mode");
   abort();
 }
 
diff --git a/src/solvers/smt/fp/fp_conv.h b/src/solvers/smt/fp/fp_conv.h
index 958bbc5a7..a86f8c9db 100644
--- a/src/solvers/smt/fp/fp_conv.h
+++ b/src/solvers/smt/fp/fp_conv.h
@@ -7,7 +7,7 @@
 class fp_convt
 {
 public:
-  fp_convt(smt_convt *_ctx, const messaget &msg);
+  explicit fp_convt(smt_convt *_ctx);
   virtual ~fp_convt() = default;
 
   /** Create a floating point bitvector
@@ -221,7 +221,6 @@ public:
 
 private:
   smt_convt *ctx;
-  const messaget &_msg;
 
   void unpack(
     smt_astt &src,
diff --git a/src/solvers/smt/smt_ast.h b/src/solvers/smt/smt_ast.h
index 4929d7db2..0cf8edb7a 100644
--- a/src/solvers/smt/smt_ast.h
+++ b/src/solvers/smt/smt_ast.h
@@ -2,7 +2,7 @@
 #define SOLVERS_SMT_SMT_AST_H_
 
 #include <solvers/smt/smt_sort.h>
-#include <util/message/default_message.h>
+
 #include <irep2/irep2_expr.h>
 
 class smt_convt;
@@ -37,7 +37,7 @@ public:
   /** The solver context */
   const smt_convt *context;
 
-  smt_ast(smt_convt *ctx, smt_sortt s, const messaget &msg);
+  smt_ast(smt_convt *ctx, smt_sortt s);
   virtual ~smt_ast() = default;
 
   // "this" is the true operand.
@@ -84,24 +84,16 @@ public:
 
   virtual void dump() const
   {
-    default_message lmsg;
-    lmsg.debug("Chosen solver doesn't support printing the AST\n");
+    log_debug("Chosen solver doesn't support printing the AST\n");
   }
-
-protected:
-  const messaget &_msg;
 };
 
 template <typename solver_ast>
 class solver_smt_ast : public smt_ast
 {
 public:
-  solver_smt_ast(
-    smt_convt *ctx,
-    solver_ast _a,
-    smt_sortt s,
-    const messaget &msg)
-    : smt_ast(ctx, s, msg), a(_a)
+  solver_smt_ast(smt_convt *ctx, solver_ast _a, smt_sortt s)
+    : smt_ast(ctx, s), a(_a)
   {
   }
 
diff --git a/src/solvers/smt/smt_bitcast.cpp b/src/solvers/smt/smt_bitcast.cpp
index 160ebeeda..22bcdaf4b 100644
--- a/src/solvers/smt/smt_bitcast.cpp
+++ b/src/solvers/smt/smt_bitcast.cpp
@@ -1,8 +1,52 @@
 #include <solvers/smt/smt_conv.h>
 #include <util/type_byte_size.h>
 
-static expr2tc
-flatten_to_bitvector(const expr2tc &new_expr, const messaget &msg)
+/**
+ * Constructs the tree-like concatenation of expressions from a sequence.
+ *
+ * Invokes `extract` for each index in [start,start+n) and concatenates the
+ * results to one expression, which is is returned. The expression forms a
+ * binary tree of minimal height with the `extract(i)` expressions at its
+ * leaves and `concat2t` expressions otherwise.
+ *
+ * For each valid index `i` in the above range, `extract(i)` should return the
+ * `i`ths sub-expression to concatenate.
+ *
+ * @param start   The initial index to invoke `extract` for
+ * @param n       The number of successive elements to extract starting at
+ *                `start`; note: n > 0 only
+ * @param extract Callback to invoke for each valid index
+ *
+ * @return An expression corresponding to the concatenation (in order, from
+ *         `start` to `start+n-1`) of the `extract` results and its size
+ */
+template <typename Extract>
+static expr2tc concat_tree(size_t start, size_t n, const Extract &extract)
+{
+  assert(n);
+  if(n == 1)
+    return extract(start);
+
+  /* here, n > 1: recursively build 2 sub-expressions to concatenate, both of
+   * similar depth logarithmic in n to avoid a stack overflow in convert_ast()
+   * down the line when n is large, for instance in #732 case 2.
+   *
+   * We could also return the size along with the expression in order to
+   * avoid unnecessarily re-computing it in this recursion by calling
+   * type_byte_size_bits() on the exprs for both branches: both results are
+   * already known and available. When `extract` operates on an array, its
+   * subtype's size indeed only would need to be computed once, regardless of
+   * `n`. However, I've not been able to measure performance benefits as the
+   * dynamic allocations `extract` usually performs dwarf the size computation.
+   */
+  expr2tc a = concat_tree(start, n / 2, extract);
+  expr2tc b = concat_tree(start + n / 2, n - n / 2, extract);
+  size_t sz = type_byte_size_bits(a->type).to_uint64() +
+              type_byte_size_bits(b->type).to_uint64();
+  return concat2tc(get_uint_type(sz), a, b);
+}
+
+static expr2tc flatten_to_bitvector(const expr2tc &new_expr)
 {
   // Easy case, no need to concat anything
   if(is_number_type(new_expr))
@@ -21,30 +65,20 @@ flatten_to_bitvector(const expr2tc &new_expr, const messaget &msg)
       is_constant_int2t(arraytype.array_size) &&
       "Can't flatten array with unbounded size");
 
-    auto array_for_ref = arraytype.array_size;
     // Iterate over each element and flatten them
-    const constant_int2t &intref = to_constant_int2t(array_for_ref);
+    const constant_int2t &intref = to_constant_int2t(arraytype.array_size);
     assert(intref.value > 0);
 
-    int sz = intref.value.to_uint64();
+    size_t sz = intref.value.to_uint64();
+    type2tc idx = index_type2();
 
-    // First element
-    expr2tc expr = index2tc(
-      arraytype.subtype, new_expr, constant_int2tc(index_type2(), sz - 1));
-    expr = flatten_to_bitvector(expr, msg);
-
-    // Concat elements if there are more than 1
-    for(int i = sz - 2; i >= 0; i--)
-    {
-      expr2tc tmp = index2tc(
-        arraytype.subtype, new_expr, constant_int2tc(index_type2(), i));
-      tmp = flatten_to_bitvector(tmp, msg);
-      type2tc res_type =
-        get_uint_type(expr->type->get_width() + tmp->type->get_width());
-      expr = concat2tc(res_type, expr, tmp);
-    }
+    auto extract = [&](size_t i) {
+      /* The sub-expression should be flattened as well */
+      return flatten_to_bitvector(index2tc(
+        arraytype.subtype, new_expr, constant_int2tc(idx, sz - i - 1)));
+    };
 
-    return expr;
+    return concat_tree(0, sz, extract);
   }
 
   if(new_expr->type->get_width() == 0)
@@ -56,30 +90,30 @@ flatten_to_bitvector(const expr2tc &new_expr, const messaget &msg)
   {
     const struct_type2t &structtype = to_struct_type(new_expr->type);
 
-    int sz = structtype.members.size();
+    size_t sz = structtype.members.size();
 
     // Iterate over each member and flatten them
-    expr2tc expr = member2tc(
-      structtype.members[sz - 1], new_expr, structtype.member_names[sz - 1]);
-    expr = flatten_to_bitvector(expr, msg);
 
-    // Concat elements if there are more than 1
-    for(int i = sz - 2; i >= 0; i--)
-    {
-      expr2tc tmp =
-        member2tc(structtype.members[i], new_expr, structtype.member_names[i]);
-      tmp = flatten_to_bitvector(tmp, msg);
-      type2tc res_type =
-        get_uint_type(expr->type->get_width() + tmp->type->get_width());
-      expr = concat2tc(res_type, expr, tmp);
-    }
+    auto extract = [&](size_t i) {
+      /* The sub-expression should be flattened as well */
+      return flatten_to_bitvector(member2tc(
+        structtype.members[sz - i - 1],
+        new_expr,
+        structtype.member_names[sz - i - 1]));
+    };
 
-    return expr;
+    return concat_tree(0, sz, extract);
+  }
+
+  if(is_union_type(new_expr))
+  {
+    size_t sz = type_byte_size_bits(new_expr->type).to_uint64();
+    return extract2tc(get_uint_type(sz), new_expr, sz - 1, 0);
   }
 
-  msg.error(fmt::format(
+  log_error(
     "Unrecognized type {} when flattening to bytes",
-    get_type_id(*new_expr->type)));
+    get_type_id(*new_expr->type));
   abort();
 }
 
@@ -98,19 +132,12 @@ smt_astt smt_convt::convert_bitcast(const expr2tc &expr)
     // Converting from struct/array to fp, we simply convert it to bv and use
     // the bv to fp method to do the job for us
     if(is_struct_type(new_from) || is_array_type(new_from))
-      new_from = flatten_to_bitvector(new_from, msg);
+      new_from = flatten_to_bitvector(new_from);
 
     // from bitvectors should go through the fp api
-    if(is_bv_type(new_from))
+    if(is_bv_type(new_from) || is_union_type(new_from))
       return fp_api->mk_from_bv_to_fp(
         convert_ast(new_from), convert_sort(to_type));
-
-    if(is_union_type(new_from))
-    {
-      msg.error(fmt::format(
-        "Unions not supported when bitcasting to fp for now\n{}", *expr));
-      abort();
-    }
   }
   else if(is_bv_type(to_type))
   {
@@ -118,13 +145,10 @@ smt_astt smt_convt::convert_bitcast(const expr2tc &expr)
       return fp_api->mk_from_fp_to_bv(convert_ast(from));
 
     if(is_struct_type(from) || is_array_type(from))
-      return convert_ast(flatten_to_bitvector(from, msg));
+      return convert_ast(flatten_to_bitvector(from));
 
-    if(is_union_type(from)){
-      msg.error(fmt::format(
-        "Unions not supported when bitcasting to bv for now\n{}", *expr));
-      abort();
-    }
+    if(is_union_type(from))
+      return convert_ast(from);
   }
   else if(is_struct_type(to_type))
   {
@@ -139,9 +163,9 @@ smt_astt smt_convt::convert_bitcast(const expr2tc &expr)
     // Converting from array to struct, we convert it to bv and use the bv to
     // struct method to do the job for us
     if(is_array_type(new_from))
-      new_from = flatten_to_bitvector(new_from, msg);
+      new_from = flatten_to_bitvector(new_from);
 
-    if(is_bv_type(new_from))
+    if(is_bv_type(new_from) || is_union_type(new_from))
     {
       const struct_type2t &structtype = to_struct_type(to_type);
 
@@ -161,14 +185,12 @@ smt_astt smt_convt::convert_bitcast(const expr2tc &expr)
 
       return convert_ast(constant_struct2tc(to_type, fields));
     }
-    if(is_union_type(new_from))
-    {
-      msg.error(fmt::format(
-        "Unions not supported when bitcasting to struct for now\n{}", *expr));
-      abort();
-    }
   }
-
+  else if(is_union_type(to_type))
+  {
+    if(is_bv_type(from))
+      return convert_ast(from);
+  }
   else if(is_array_type(to_type))
   {
     expr2tc new_from = from;
@@ -180,9 +202,9 @@ smt_astt smt_convt::convert_bitcast(const expr2tc &expr)
     // Converting from struct to array, we convert it to bv and use the bv to
     // struct method to do the job for us
     if(is_struct_type(new_from))
-      new_from = flatten_to_bitvector(new_from, msg);
+      new_from = flatten_to_bitvector(new_from);
 
-    if(is_bv_type(new_from) )
+    if(is_bv_type(new_from) || is_union_type(new_from))
     {
       // TODO: handle multidimensional arrays
       assert(
@@ -193,8 +215,7 @@ smt_astt smt_convt::convert_bitcast(const expr2tc &expr)
       type2tc subtype = arr_type.subtype;
 
       // We shouldn't have any bit left behind
-      // This will not work for FAMs!
-      //assert(new_from->type->get_width() % subtype->get_width() == 0);
+      assert(new_from->type->get_width() % subtype->get_width() == 0);
       unsigned int num_el = new_from->type->get_width() / subtype->get_width();
 
       std::vector<expr2tc> elems;
@@ -212,12 +233,6 @@ smt_astt smt_convt::convert_bitcast(const expr2tc &expr)
 
       return convert_ast(constant_array2tc(to_type, elems));
     }
-    if(is_union_type(new_from))
-    {
-      msg.error(fmt::format(
-        "Unions not supported when bitcasting to struct for now\n{}", *expr));
-      abort();
-    }
   }
 
   // Cast by value is fine
diff --git a/src/solvers/smt/smt_byteops.cpp b/src/solvers/smt/smt_byteops.cpp
index 17ffd6323..28dc83b86 100644
--- a/src/solvers/smt/smt_byteops.cpp
+++ b/src/solvers/smt/smt_byteops.cpp
@@ -5,7 +5,7 @@ smt_astt smt_convt::convert_byte_extract(const expr2tc &expr)
 {
   if(int_encoding)
   {
-    msg.error(
+    log_error(
       "Refusing to byte extract in integer mode; re-run in "
       "bitvector mode");
     abort();
@@ -79,7 +79,7 @@ smt_astt smt_convt::convert_byte_update(const expr2tc &expr)
 {
   if(int_encoding)
   {
-    msg.error("Can't byte update in integer mode; rerun in bitvector mode");
+    log_error("Can't byte update in integer mode; rerun in bitvector mode");
     abort();
   }
 
diff --git a/src/solvers/smt/smt_casts.cpp b/src/solvers/smt/smt_casts.cpp
index 42913936c..3db303476 100644
--- a/src/solvers/smt/smt_casts.cpp
+++ b/src/solvers/smt/smt_casts.cpp
@@ -2,6 +2,8 @@
 #include <sstream>
 #include <util/base_type.h>
 #include <util/expr_util.h>
+#include <util/message.h>
+#include <util/message/format.h>
 
 smt_astt smt_convt::convert_typecast_to_bool(const typecast2t &cast)
 {
@@ -23,7 +25,7 @@ smt_astt smt_convt::convert_typecast_to_fixedbv_nonint(const expr2tc &expr)
 
   if(is_pointer_type(cast.from))
   {
-    msg.error("Converting pointer to a float is unsupported");
+    log_error("Converting pointer to a float is unsupported");
     abort();
   }
 
@@ -34,7 +36,7 @@ smt_astt smt_convt::convert_typecast_to_fixedbv_nonint(const expr2tc &expr)
   else if(is_fixedbv_type(cast.from))
     return convert_typecast_to_fixedbv_nonint_from_fixedbv(expr);
 
-  msg.error("unexpected typecast to fixedbv");
+  log_error("unexpected typecast to fixedbv");
   abort();
 }
 
@@ -181,7 +183,7 @@ smt_astt smt_convt::convert_typecast_to_fpbv(const typecast2t &cast)
       convert_sort(cast.type),
       convert_rounding_mode(cast.rounding_mode));
 
-  msg.error("Unexpected type in typecast to fpbv");
+  log_error("Unexpected type in typecast to fpbv");
   abort();
 }
 
@@ -201,7 +203,7 @@ smt_astt smt_convt::convert_typecast_from_fpbv(const typecast2t &cast)
       convert_sort(cast.type),
       convert_rounding_mode(cast.rounding_mode));
 
-  msg.error("Unexpected type in typecast from fpbv");
+  log_error("Unexpected type in typecast from fpbv");
   abort();
 }
 
@@ -222,7 +224,7 @@ smt_astt smt_convt::convert_typecast_to_ints(const typecast2t &cast)
   if(is_bool_type(cast.from))
     return convert_typecast_to_ints_from_bool(cast);
 
-  msg.error("Unexpected type in int/ptr typecast");
+  log_error("Unexpected type in int/ptr typecast");
   abort();
 }
 
@@ -305,7 +307,7 @@ smt_convt::convert_typecast_to_ints_from_fbv_sint(const typecast2t &cast)
   if(from_width > to_width)
     return mk_extract(a, to_width - 1, 0);
 
-  msg.error("Malformed cast from signedbv/fixedbv");
+  log_error("Malformed cast from signedbv/fixedbv");
   abort();
 }
 
@@ -508,7 +510,7 @@ smt_astt smt_convt::convert_typecast_to_struct(const typecast2t &cast)
     {
       if(!base_type_eq(struct_type_from.members[i], it, ns))
       {
-        msg.error("Incompatible struct in cast-to-struct");
+        log_error("Incompatible struct in cast-to-struct");
         abort();
       }
 
@@ -628,10 +630,10 @@ smt_astt smt_convt::convert_typecast(const expr2tc &expr)
     if(base_type_eq(cast.type, cast.from->type, ns))
       return convert_ast(cast.from); // No additional conversion required
 
-    msg.error("Can't typecast between unions\n{}");
+    log_error("Can't typecast between unions\n{}");
     abort();
   }
 
-  msg.error(fmt::format("Typecast for unexpected type\n{}", *expr));
+  log_error("Typecast for unexpected type\n{}", *expr);
   abort();
 }
diff --git a/src/solvers/smt/smt_conv.cpp b/src/solvers/smt/smt_conv.cpp
index f402eae84..e3d3a2f79 100644
--- a/src/solvers/smt/smt_conv.cpp
+++ b/src/solvers/smt/smt_conv.cpp
@@ -7,6 +7,8 @@
 #include <util/base_type.h>
 #include <util/c_types.h>
 #include <util/expr_util.h>
+#include <util/message.h>
+#include <util/message/format.h>
 #include <util/type_byte_size.h>
 
 // Helpers extracted from z3_convt.
@@ -61,11 +63,8 @@ smt_convt::get_member_name_field(const type2tc &t, const expr2tc &name) const
   return get_member_name_field(t, str.value);
 }
 
-smt_convt::smt_convt(
-  const namespacet &_ns,
-  const optionst &_options,
-  const messaget &msg)
-  : ctx_level(0), boolean_sort(nullptr), ns(_ns), options(_options), msg(msg)
+smt_convt::smt_convt(const namespacet &_ns, const optionst &_options)
+  : ctx_level(0), boolean_sort(nullptr), ns(_ns), options(_options)
 {
   int_encoding = options.get_bool_option("int-encoding");
   tuple_api = nullptr;
@@ -102,13 +101,6 @@ smt_convt::smt_convt(
 
   machine_ptr = type2tc(new unsignedbv_type2t(config.ansi_c.pointer_width));
 
-  // Pick a modelling array to shoehorn initialization data into. Because
-  // we don't yet have complete data for whether pointers are dynamic or not,
-  // this is the one modelling array that absolutely _has_ to be initialized
-  // to false for each element, which is going to be shoved into
-  // convert_identifier_pointer.
-  dyn_info_arr_name = "__ESBMC_is_dynamic&0#1";
-
   ptr_foo_inited = false;
 }
 
@@ -247,39 +239,48 @@ smt_astt smt_convt::convert_ast(const expr2tc &expr)
   if(cache_result != smt_cache.end())
     return (cache_result->ast);
 
-  // Vectors!
+  /* Vectors!
+   *
+   * Here we need special attention for Vectors, because of the way
+   * they are encoded, an vector expression can reach here with binary
+   * operations that weren't done.
+   *
+   * The simplification module take care of all the operations, but if
+   * for some reason we would like to run ESBMC without simplifications
+   * then we need to apply it here.
+  */
   if(is_vector_type(expr))
   {
     if(is_neg2t(expr))
     {
-      return convert_ast(vector_type2t::distribute_operation(
-        expr->expr_id, to_neg2t(expr).value));
+      return convert_ast(
+        distribute_vector_operation(expr->expr_id, to_neg2t(expr).value));
     }
     if(is_bitnot2t(expr))
     {
-      return convert_ast(vector_type2t::distribute_operation(
-        expr->expr_id, to_bitnot2t(expr).value));
+      return convert_ast(
+        distribute_vector_operation(expr->expr_id, to_bitnot2t(expr).value));
     }
 
     std::shared_ptr<ieee_arith_2ops> ops;
     ops = std::dynamic_pointer_cast<ieee_arith_2ops>(expr);
     if(ops)
     {
-      return convert_ast(vector_type2t::distribute_operation(
+      return convert_ast(distribute_vector_operation(
         ops->expr_id, ops->side_1, ops->side_2, ops->rounding_mode));
     }
     if(is_arith_expr(expr))
     {
       std::shared_ptr<arith_2ops> arith;
       arith = std::dynamic_pointer_cast<arith_2ops>(expr);
-      return convert_ast(vector_type2t::distribute_operation(
+      return convert_ast(distribute_vector_operation(
         arith->expr_id, arith->side_1, arith->side_2));
     }
     std::shared_ptr<bit_2ops> bit;
     bit = std::dynamic_pointer_cast<bit_2ops>(expr);
     if(bit)
-      return convert_ast(vector_type2t::distribute_operation(
-        bit->expr_id, bit->side_1, bit->side_2));
+      return convert_ast(
+        distribute_vector_operation(bit->expr_id, bit->side_1, bit->side_2));
   }
 
   std::vector<smt_astt> args;
@@ -333,11 +334,31 @@ smt_astt smt_convt::convert_ast(const expr2tc &expr)
     break;
   }
   case expr2t::constant_union_id:
-    msg.error("Post-parse union literals are deprecated and broken, sorry");
-    abort();
+  {
+    // Get size
+    const constant_union2t &cu = to_constant_union2t(expr);
+    const std::vector<expr2tc> &dt_memb = cu.datatype_members;
+    expr2tc src_expr =
+      dt_memb.empty() ? gen_zero(get_uint_type(0)) : dt_memb[0];
+#ifndef NDEBUG
+    if(!cu.init_field.empty())
+    {
+      const union_type2t &ut = to_union_type(expr->type);
+      unsigned c = ut.get_component_number(cu.init_field);
+      /* Can only initialize unions by expressions of same type as init_field */
+      assert(src_expr->type == ut.members[c]);
+    }
+#endif
+    a = convert_ast(typecast2tc(
+      get_uint_type(type_byte_size_bits(expr->type).to_uint64()),
+      bitcast2tc(
+        get_uint_type(type_byte_size_bits(src_expr->type).to_uint64()),
+        src_expr)));
+    break;
+  }
   case expr2t::constant_vector_id:
   {
-    a = array_create((constant_vector2tc)expr);
+    a = array_create(expr);
     break;
   }
   case expr2t::constant_array_id:
@@ -633,6 +654,27 @@ smt_astt smt_convt::convert_ast(const expr2tc &expr)
 
       a = srcval->update(this, convert_ast(with.update_value), idx);
     }
+    else if(is_union_type(expr))
+    {
+      uint64_t bits = type_byte_size_bits(expr->type).to_uint64();
+      const union_type2t &tu = to_union_type(expr->type);
+      assert(is_constant_string2t(with.update_field));
+      unsigned c =
+        tu.get_component_number(to_constant_string2t(with.update_field).value);
+      uint64_t mem_bits = type_byte_size_bits(tu.members[c]).to_uint64();
+      expr2tc upd = bitcast2tc(
+        get_uint_type(mem_bits), typecast2tc(tu.members[c], with.update_value));
+      if(mem_bits < bits)
+        upd = concat2tc(
+          get_uint_type(bits),
+          extract2tc(
+            get_uint_type(bits - mem_bits),
+            with.source_value,
+            bits - 1,
+            mem_bits),
+          upd);
+      a = convert_ast(upd);
+    }
     else
     {
       a = convert_array_store(expr);
@@ -1120,8 +1162,7 @@ smt_astt smt_convt::convert_ast(const expr2tc &expr)
     break;
   }
   default:
-    msg.error(fmt::format(
-      "Couldn't convert expression in unrecognised format\n{}", *expr));
+    log_error("Couldn't convert expression in unrecognised format\n{}", *expr);
     abort();
   }
 
@@ -1226,10 +1267,15 @@ smt_sortt smt_convt::convert_sort(const type2tc &type)
     result = mk_array_sort(d, r);
     break;
   }
+  case type2t::union_id:
+  {
+    result = mk_int_bv_sort(type_byte_size_bits(type).to_uint64());
+    break;
+  }
 
   default:
-    msg.error(fmt::format(
-      "Unexpected type ID {} reached SMT conversion", get_type_id(type)));
+    log_error(
+      "Unexpected type ID {} reached SMT conversion", get_type_id(type));
     abort();
   }
 
@@ -1375,8 +1421,7 @@ smt_astt smt_convt::convert_terminal(const expr2tc &expr)
   }
 
   default:
-    msg.error(
-      fmt::format("Converting unrecognized terminal expr to SMT\n{}", *expr));
+    log_error("Converting unrecognized terminal expr to SMT\n{}", *expr);
     abort();
   }
 }
@@ -1591,16 +1636,25 @@ smt_astt smt_convt::convert_rounding_mode(const expr2tc &expr)
 smt_astt smt_convt::convert_member(const expr2tc &expr)
 {
   const member2t &member = to_member2t(expr);
-  unsigned int idx = -1;
 
   // Special case unions: bitcast it to bv then convert it back to the
   // requested member type
-
+  if(is_union_type(member.source_value))
+  {
+    BigInt size = type_byte_size_bits(member.source_value->type);
+    expr2tc to_bv =
+      bitcast2tc(get_uint_type(size.to_uint64()), member.source_value);
+    return convert_ast(bitcast2tc(
+      expr->type,
+      typecast2tc(
+        get_uint_type(type_byte_size_bits(expr->type).to_uint64()), to_bv)));
+  }
 
   assert(
     is_struct_type(member.source_value) ||
     is_pointer_type(member.source_value));
-  idx = get_member_name_field(member.source_value->type, member.member);
+  unsigned int idx =
+    get_member_name_field(member.source_value->type, member.member);
 
   smt_astt src = convert_ast(member.source_value);
   return src->project(this, idx);
@@ -2123,7 +2177,7 @@ expr2tc smt_convt::get(const expr2tc &expr)
   case expr2t::with_id:
   {
     // This will be converted
-    with2t with = to_with2t(res);
+    const with2t &with = to_with2t(res);
     expr2tc update_val = with.update_value;
 
     if(
@@ -2163,7 +2217,7 @@ expr2tc smt_convt::get(const expr2tc &expr)
     {
       if(extracting_from_array_tuple_is_error)
       {
-        msg.error(
+        log_error(
           "Fetching array elements inside tuples currently "
           "unimplemented, sorry");
         abort();
@@ -2254,19 +2308,41 @@ expr2tc smt_convt::get_by_ast(const type2tc &type, smt_astt a)
   case type2t::pointer_id:
     return tuple_api->tuple_get(type, a);
 
+  case type2t::union_id:
+  {
+    expr2tc uint_rep =
+      get_by_ast(get_uint_type(type_byte_size_bits(type).to_uint64()), a);
+    std::vector<expr2tc> members;
+    /* TODO: this violates the assumption in the rest of ESBMC that
+     *       constant_union2t only have at most 1 member initializer.
+     *       Maybe it makes sense to go for one of the largest ones instead of
+     *       all members? */
+    for(const type2tc &member_type : to_union_type(type).members)
+    {
+      expr2tc cast = bitcast2tc(
+        member_type,
+        typecast2tc(
+          get_uint_type(type_byte_size_bits(member_type).to_uint64()),
+          uint_rep));
+      simplify(cast);
+      members.push_back(cast);
+    }
+    return constant_union2tc(
+      type, "" /* TODO: which field assigned last? */, members);
+  }
 
   default:
     if(!options.get_bool_option("non-supported-models-as-zero"))
     {
-      msg.error(fmt::format(
-        "Unimplemented type'd expression ({}) in smt get", type->type_id));
+      log_error(
+        "Unimplemented type'd expression ({}) in smt get", type->type_id);
       abort();
     }
     else
     {
-      msg.warning(fmt::format(
+      log_warning(
         "Unimplemented type'd expression ({}) in smt get. Returning zero!",
-        type->type_id));
+        type->type_id);
       return gen_zero(type);
     }
   }
@@ -2281,6 +2357,7 @@ expr2tc smt_convt::get_by_type(const expr2tc &expr)
   case type2t::signedbv_id:
   case type2t::fixedbv_id:
   case type2t::floatbv_id:
+  case type2t::union_id:
     return get_by_ast(expr->type, convert_ast(expr));
 
   case type2t::array_id:
@@ -2293,16 +2370,15 @@ expr2tc smt_convt::get_by_type(const expr2tc &expr)
   default:
     if(!options.get_bool_option("non-supported-models-as-zero"))
     {
-      msg.error(fmt::format(
-        "Unimplemented type'd expression ({}) in smt get",
-        expr->type->type_id));
+      log_error(
+        "Unimplemented type'd expression ({}) in smt get", expr->type->type_id);
       abort();
     }
     else
     {
-      msg.warning(fmt::format(
+      log_warning(
         "Unimplemented type'd expression ({}) in smt get. Returning zero!",
-        expr->type->type_id));
+        expr->type->type_id);
       return gen_zero(expr->type);
     }
   }
@@ -2320,7 +2396,7 @@ expr2tc smt_convt::get_array(const expr2tc &expr)
   if(w > 10)
     w = 10;
 
-  const array_type2t &ar = to_array_type(flatten_array_type(expr->type));
+  array_type2t ar = to_array_type(flatten_array_type(expr->type));
   constant_int2tc arr_size(index_type2(), BigInt(1 << w));
   type2tc arr_type = type2tc(new array_type2t(ar.subtype, arr_size, false));
   std::vector<expr2tc> fields;
@@ -2340,12 +2416,18 @@ const struct_union_data &smt_convt::get_type_def(const type2tc &type) const
            : dynamic_cast<const struct_union_data &>(*type.get());
 }
 
-smt_astt smt_convt::array_create(
-  const expr2tc &expr,
-  bool is_infinite,
-  const expr2tc &size,
-  const std::vector<expr2tc> &members)
+smt_astt smt_convt::array_create(const expr2tc &expr)
 {
+  if(is_constant_array_of2t(expr))
+    return convert_array_of_prep(expr);
+  // Check size
+  assert(is_constant_array2t(expr) || is_constant_vector2t(expr));
+  expr2tc size = std::static_pointer_cast<array_data>(expr->type)->array_size;
+  bool is_infinite =
+    std::static_pointer_cast<array_data>(expr->type)->size_is_infinite;
+  auto members =
+    std::static_pointer_cast<constant_datatype_data>(expr)->datatype_members;
+
   // Handle constant array expressions: these don't have tuple type and so
   // don't need funky handling, but we need to create a fresh new symbol and
   // repeatedly store the desired data into it, to create an SMT array
@@ -2359,7 +2441,7 @@ smt_astt smt_convt::array_create(
 
   if(!is_constant_int2t(size))
   {
-    msg.error("Non-constant sized array of type constant_array_of2t");
+    log_error("Non-constant sized array of type constant_array_of2t");
     abort();
   }
 
@@ -2384,32 +2466,6 @@ smt_astt smt_convt::array_create(
   return newsym_ast;
 }
 
-smt_astt smt_convt::array_create(const constant_vector2tc &expr)
-{
-  const vector_type2t &arr_type = to_vector_type(expr->type);
-  return array_create(
-    expr,
-    arr_type.size_is_infinite,
-    arr_type.array_size,
-    expr->datatype_members);
-}
-
-smt_astt smt_convt::array_create(const expr2tc &expr)
-{
-  if(is_constant_array_of2t(expr))
-    return convert_array_of_prep(expr);
-  // Check size
-  const array_type2t &arr_type = to_array_type(expr->type);
-
-  assert(is_constant_array2t(expr));
-  const constant_array2t &array = to_constant_array2t(expr);
-  return array_create(
-    expr,
-    arr_type.size_is_infinite,
-    arr_type.array_size,
-    array.datatype_members);
-}
-
 smt_astt smt_convt::convert_array_of_prep(const expr2tc &expr)
 {
   const constant_array_of2t &arrof = to_constant_array_of2t(expr);
@@ -2516,7 +2572,7 @@ smt_astt array_iface::default_convert_array_of(
 }
 
 smt_astt smt_convt::pointer_array_of(
-  const expr2tc &init_val [[gnu::unused]],
+  const expr2tc &init_val [[maybe_unused]],
   unsigned long array_width)
 {
   // Actually a tuple, but the operand is going to be a symbol, null.
@@ -2660,23 +2716,22 @@ smt_astt smt_ast::select(smt_convt *ctx, const expr2tc &idx) const
 }
 
 smt_astt smt_ast::project(
-  smt_convt *ctx [[gnu::unused]],
-  unsigned int idx [[gnu::unused]]) const
+  smt_convt *ctx [[maybe_unused]],
+  unsigned int idx [[maybe_unused]]) const
 {
-  _msg.error("Projecting from non-tuple based AST");
+  log_error("Projecting from non-tuple based AST");
   abort();
 }
 
 void smt_convt::dump_smt()
 {
-  msg.error(fmt::format("SMT dump not implemented for {}", solver_text()));
+  log_error("SMT dump not implemented for {}", solver_text());
   abort();
 }
 
 void smt_convt::print_model()
 {
-  msg.error(
-    fmt::format("SMT model printing not implemented for {}", solver_text()));
+  log_error("SMT model printing not implemented for {}", solver_text());
   abort();
 }
 
@@ -2719,60 +2774,60 @@ expr2tc smt_convt::get_by_value(const type2tc &type, BigInt value)
 
   if(options.get_bool_option("non-supported-models-as-zero"))
   {
-    msg.warning(fmt::format(
-      "Can't generate one for type {}. Returning zero", get_type_id(type)));
+    log_warning(
+      "Can't generate one for type {}. Returning zero", get_type_id(type));
     return gen_zero(type);
   }
 
-  msg.error(fmt::format("Can't generate one for type {}", get_type_id(type)));
+  log_error("Can't generate one for type {}", get_type_id(type));
   abort();
 }
 
 smt_sortt smt_convt::mk_bool_sort()
 {
-  msg.error("Chosen solver doesn't support boolean sorts");
+  log_error("Chosen solver doesn't support boolean sorts");
   abort();
 }
 
 smt_sortt smt_convt::mk_real_sort()
 {
-  msg.error("Chosen solver doesn't support real sorts");
+  log_error("Chosen solver doesn't support real sorts");
   abort();
 }
 
 smt_sortt smt_convt::mk_int_sort()
 {
-  msg.error("Chosen solver doesn't support integer sorts");
+  log_error("Chosen solver doesn't support integer sorts");
   abort();
 }
 
 smt_sortt smt_convt::mk_bv_sort(std::size_t)
 {
-  msg.error("Chosen solver doesn't support bit vector sorts");
+  log_error("Chosen solver doesn't support bit vector sorts");
   abort();
 }
 
 smt_sortt smt_convt::mk_fbv_sort(std::size_t)
 {
-  msg.error("Chosen solver doesn't support bit vector sorts");
+  log_error("Chosen solver doesn't support bit vector sorts");
   abort();
 }
 
 smt_sortt smt_convt::mk_array_sort(smt_sortt, smt_sortt)
 {
-  msg.error("Chosen solver doesn't support array sorts");
+  log_error("Chosen solver doesn't support array sorts");
   abort();
 }
 
 smt_sortt smt_convt::mk_bvfp_sort(std::size_t, std::size_t)
 {
-  msg.error("Chosen solver doesn't support bit vector sorts");
+  log_error("Chosen solver doesn't support bit vector sorts");
   abort();
 }
 
 smt_sortt smt_convt::mk_bvfp_rm_sort()
 {
-  msg.error("Chosen solver doesn't support bit vector sorts");
+  log_error("Chosen solver doesn't support bit vector sorts");
   abort();
 }
 
diff --git a/src/solvers/smt/smt_conv.h b/src/solvers/smt/smt_conv.h
index 6183c6b18..ba133b8f4 100644
--- a/src/solvers/smt/smt_conv.h
+++ b/src/solvers/smt/smt_conv.h
@@ -9,7 +9,7 @@
 #include <solvers/prop/literal.h>
 #include <solvers/prop/pointer_logic.h>
 #include <irep2/irep2_utils.h>
-#include <util/message/message.h>
+#include <util/message.h>
 #include <util/namespace.h>
 #include <util/threeval.h>
 
@@ -34,7 +34,7 @@
  *  from the solver.
  *
  *  To do that, the user must allocate a solver converter object, which extends
- *  the class smt_convt. Current, create_solver_factory will do this, in the
+ *  the class smt_convt. Current, create_solver() will do this, in the
  *  factory-pattern manner (ish). Each solver converter implements all the
  *  abstract methods of smt_convt. When handed an expression to convert,
  *  smt_convt deconstructs it into a series of function applications, which it
@@ -79,7 +79,7 @@
  *
  *  @see smt_convt
  *  @see symex_target_equationt
- *  @see create_solver_factory
+ *  @see create_solver
  *  @see smt_convt::mk_func_app
  */
 
@@ -132,7 +132,7 @@ class smt_convt
 {
 public:
   /* NOTE: I've made this horrible so we remember that there is an
-   * even uglier implementation that just returns an empty 
+   * even uglier implementation that just returns an empty
    * look at where this variable is used for more info :) */
   bool extracting_from_array_tuple_is_error = false;
   /** Shorthand for a vector of smt_ast's */
@@ -142,18 +142,15 @@ public:
   smt_astt
   new_solver_ast(typename the_solver_ast::solver_ast_type ast, smt_sortt sort)
   {
-    return new the_solver_ast(this, ast, sort, msg);
+    return new the_solver_ast(this, ast, sort);
   }
 
   /** Primary constructor. After construction, smt_post_init must be called
    *  before the object is used as a solver converter.
    *
-   *  @param _ns Namespace for looking up the type of certain symbols. 
+   *  @param _ns Namespace for looking up the type of certain symbols.
    *  @param _options Provide all the needed parameters to configure the solver. */
-  smt_convt(
-    const namespacet &_ns,
-    const optionst &_options,
-    const messaget &msg);
+  smt_convt(const namespacet &_ns, const optionst &_options);
 
   virtual ~smt_convt() = default;
 
@@ -649,13 +646,6 @@ public:
   void assert_expr(const expr2tc &e);
   /** Convert constant_array2tc's and constant_array_of2tc's */
   smt_astt array_create(const expr2tc &expr);
-  /** Convert constant_vector2tc's */
-  smt_astt array_create(const constant_vector2tc &expr);
-  smt_astt array_create(
-    const expr2tc &expr,
-    bool is_infinite,
-    const expr2tc &size,
-    const std::vector<expr2tc> &members);
 
   /** Initialize tracking data for the address space records. This also sets
    *  up the symbols / addresses of 'NULL', '0', and the invalid pointer */
@@ -826,13 +816,8 @@ public:
   const namespacet &ns;
   /* Options contain all the parameters set by the user to run ESBMC */
   const optionst &options;
-  const messaget &msg;
 
   bool ptr_foo_inited;
-  /** Full name of the '__ESBMC_is_dynamic' modelling array. The memory space
-   *  stuff may make some assertions using it, see the discussion in the
-   *  constructor. */
-  std::string dyn_info_arr_name;
 
   smt_astt null_ptr_ast;
   smt_astt invalid_ptr_ast;
@@ -880,8 +865,7 @@ public:
 };
 
 // Define here to enable inlining
-inline smt_ast::smt_ast(smt_convt *ctx, smt_sortt s, const messaget &msg)
-  : sort(s), context(ctx), _msg(msg)
+inline smt_ast::smt_ast(smt_convt *ctx, smt_sortt s) : sort(s), context(ctx)
 {
   assert(sort != nullptr);
   ctx->live_asts.push_back(this);
diff --git a/src/solvers/smt/smt_memspace.cpp b/src/solvers/smt/smt_memspace.cpp
index c34cd396c..f6b9f26cf 100644
--- a/src/solvers/smt/smt_memspace.cpp
+++ b/src/solvers/smt/smt_memspace.cpp
@@ -1,6 +1,7 @@
 #include <algorithm>
 #include <sstream>
 #include <solvers/smt/smt_conv.h>
+#include <util/message/format.h>
 #include <util/type_byte_size.h>
 
 /** @file smt_memspace.cpp
@@ -123,14 +124,14 @@ smt_convt::convert_pointer_arith(const expr2tc &expr, const type2tc &type)
     }
     else
     {
-      msg.error("Pointer arithmetic with two pointer operands");
+      log_error("Pointer arithmetic with two pointer operands");
       abort();
     }
     break;
   case 4:
     // Artithmetic operation that has the result type of ptr.
     // Should have been handled at a higher level
-    msg.error("Non-pointer op being interpreted as pointer without cast");
+    log_error("Non-pointer op being interpreted as pointer without cast");
     abort();
     break;
   case 1:
@@ -191,7 +192,7 @@ smt_convt::convert_pointer_arith(const expr2tc &expr, const type2tc &type)
   }
   }
 
-  msg.error("Fell through convert_pointer_logic");
+  log_error("Fell through convert_pointer_logic");
   abort();
 }
 
@@ -241,7 +242,7 @@ smt_astt smt_convt::convert_identifier_pointer(
 
   if(!ptr_foo_inited)
   {
-    msg.error(
+    log_error(
       "SMT solver must call smt_post_init immediately after construction");
     abort();
   }
@@ -249,7 +250,7 @@ smt_astt smt_convt::convert_identifier_pointer(
   if(is_symbol2t(expr))
   {
     const symbol2t &sym = to_symbol2t(expr);
-    if(sym.thename == "NULL" || sym.thename == "0")
+    if(sym.thename == "NULL")
     {
       // For null, other pieces of code will have already initialized its
       // value, so we can just refer to a symbol.
@@ -294,8 +295,7 @@ smt_astt smt_convt::convert_identifier_pointer(
     expr2tc size;
     try
     {
-      uint64_t type_size = expr->type->get_width() / 8;
-      size = constant_int2tc(ptr_loc_type, BigInt(type_size));
+      size = constant_int2tc(ptr_loc_type, type_byte_size(expr->type));
     }
     catch(const array_type2t::dyn_sized_array_excp &e)
     {
@@ -390,18 +390,6 @@ smt_astt smt_convt::init_pointer_obj(unsigned int obj_num, const expr2tc &size)
   // Update array
   bump_addrspace_array(obj_num, range_struct);
 
-  // Finally, ensure that the array storing whether this pointer is dynamic,
-  // is initialized for this ptr to false. That way, only pointers created
-  // through malloc will be marked dynamic.
-
-  type2tc arrtype(new array_type2t(get_bool_type(), expr2tc(), true));
-  symbol2tc allocarr(arrtype, dyn_info_arr_name);
-  constant_int2tc objid(
-    get_uint_type(config.ansi_c.int_width), BigInt(obj_num));
-  index2tc idx(get_bool_type(), allocarr, objid);
-  equality2tc dyn_eq(idx, gen_false_expr());
-  assert_expr(dyn_eq);
-
   return ptr_val;
 }
 
@@ -445,7 +433,7 @@ smt_astt smt_convt::convert_addr_of(const expr2tc &expr)
 
   std::string symbol_name, out;
 
-  if(is_index2t(obj.ptr_obj))
+  if(is_index2t(obj.ptr_obj) || is_member2t(obj.ptr_obj))
   {
     // This might be a composite index/member/blah chain
     expr2tc offs = compute_pointer_offset(obj.ptr_obj);
@@ -453,17 +441,6 @@ smt_astt smt_convt::convert_addr_of(const expr2tc &expr)
 
     address_of2tc addrof(obj.type, base);
     smt_astt a = convert_ast(addrof);
-    return a->update(this, convert_ast(offs), 1);
-  }
-
-  if(is_member2t(obj.ptr_obj))
-  {
-    expr2tc offs = compute_pointer_offset(obj.ptr_obj);
-    expr2tc base = get_base_object(obj.ptr_obj);
-
-    address_of2tc addr(obj.type, base);
-
-    smt_astt a = convert_ast(addr);
 
     // Update pointer offset to offset to that field.
     return a->update(this, convert_ast(offs), 1);
@@ -525,7 +502,7 @@ smt_astt smt_convt::convert_addr_of(const expr2tc &expr)
     return convert_ast(tmp);
   }
 
-  msg.error(fmt::format("Unrecognized address_of operand:\n{}", *expr));
+  log_error("Unrecognized address_of operand:\n{}", *expr);
   abort();
 }
 
@@ -573,8 +550,7 @@ void smt_convt::init_addr_space_array()
   null_ptr_ast = convert_ast(null_ptr_tuple);
   invalid_ptr_ast = convert_ast(invalid_ptr_tuple);
 
-  // Give value to '0', 'NULL', 'INVALID' symbols
-  assert_expr(equality2tc(symbol2tc(pointer_struct, "0"), null_ptr_tuple));
+  // Give value to 'NULL', 'INVALID' symbols
   assert_expr(equality2tc(symbol2tc(pointer_struct, "NULL"), null_ptr_tuple));
   assert_expr(
     equality2tc(symbol2tc(pointer_struct, "INVALID"), invalid_ptr_tuple));
diff --git a/src/solvers/smt/smt_overflow.cpp b/src/solvers/smt/smt_overflow.cpp
index 98eaa2b0a..a157803e7 100644
--- a/src/solvers/smt/smt_overflow.cpp
+++ b/src/solvers/smt/smt_overflow.cpp
@@ -146,7 +146,7 @@ smt_astt smt_convt::overflow_arith(const expr2tc &expr)
   }
 
   default:
-    msg.error("unexpected overflow_arith operand");
+    log_error("unexpected overflow_arith operand");
     abort();
   }
 
@@ -165,7 +165,7 @@ smt_astt smt_convt::overflow_cast(const expr2tc &expr)
 
   if(ocast.bits >= width || ocast.bits == 0)
   {
-    msg.error("SMT conversion: overflow-typecast got wrong number of bits");
+    log_error("SMT conversion: overflow-typecast got wrong number of bits");
     abort();
   }
 
diff --git a/src/solvers/smt/tuple/smt_tuple_array_ast.cpp b/src/solvers/smt/tuple/smt_tuple_array_ast.cpp
index cd33dfa3d..0b89222f4 100644
--- a/src/solvers/smt/tuple/smt_tuple_array_ast.cpp
+++ b/src/solvers/smt/tuple/smt_tuple_array_ast.cpp
@@ -92,7 +92,7 @@ smt_astt array_sym_smt_ast::update(
   }
 
   std::string name = ctx->mk_fresh_name("tuple_array_update::") + ".";
-  tuple_sym_smt_astt result = new array_sym_smt_ast(ctx, sort, name, _msg);
+  tuple_sym_smt_astt result = new array_sym_smt_ast(ctx, sort, name);
 
   // Iterate over all members. They are _all_ indexed and updated.
   unsigned int i = 0;
@@ -123,8 +123,7 @@ smt_astt array_sym_smt_ast::select(smt_convt *ctx, const expr2tc &idx) const
   smt_sortt result_sort = ctx->convert_sort(array_type.subtype);
 
   std::string name = ctx->mk_fresh_name("tuple_array_select::") + ".";
-  tuple_sym_smt_astt result =
-    new tuple_sym_smt_ast(ctx, result_sort, name, _msg);
+  tuple_sym_smt_astt result = new tuple_sym_smt_ast(ctx, result_sort, name);
 
   unsigned int i = 0;
   for(auto const &it : data.members)
@@ -167,7 +166,7 @@ smt_astt array_sym_smt_ast::project(smt_convt *ctx, unsigned int idx) const
     // This is a struct within a struct, so just generate the name prefix of
     // the internal struct being projected.
     sym_name = sym_name + ".";
-    return new array_sym_smt_ast(ctx, s, sym_name, _msg);
+    return new array_sym_smt_ast(ctx, s, sym_name);
   }
 
   // This is a normal variable, so create a normal symbol of its name.
diff --git a/src/solvers/smt/tuple/smt_tuple_array_ast.h b/src/solvers/smt/tuple/smt_tuple_array_ast.h
index 1e21576f4..361844473 100644
--- a/src/solvers/smt/tuple/smt_tuple_array_ast.h
+++ b/src/solvers/smt/tuple/smt_tuple_array_ast.h
@@ -10,12 +10,8 @@ typedef const array_sym_smt_ast *array_sym_smt_astt;
 class array_sym_smt_ast : public tuple_sym_smt_ast
 {
 public:
-  array_sym_smt_ast(
-    smt_convt *ctx,
-    smt_sortt s,
-    const std::string &_name,
-    const messaget &msg)
-    : tuple_sym_smt_ast(ctx, s, _name, msg)
+  array_sym_smt_ast(smt_convt *ctx, smt_sortt s, const std::string &_name)
+    : tuple_sym_smt_ast(ctx, s, _name)
   {
   }
   virtual ~array_sym_smt_ast() = default;
diff --git a/src/solvers/smt/tuple/smt_tuple_node.cpp b/src/solvers/smt/tuple/smt_tuple_node.cpp
index e6dcb1d52..526ee9eb1 100644
--- a/src/solvers/smt/tuple/smt_tuple_node.cpp
+++ b/src/solvers/smt/tuple/smt_tuple_node.cpp
@@ -15,7 +15,7 @@ smt_astt smt_tuple_node_flattener::tuple_create(const expr2tc &structdef)
   name += ".";
 
   tuple_node_smt_ast *result = new tuple_node_smt_ast(
-    *this, ctx, ctx->convert_sort(structdef->type), name, msg);
+    *this, ctx, ctx->convert_sort(structdef->type), name);
   result->elements.resize(structdef->get_num_sub_exprs());
 
   for(unsigned int i = 0; i < structdef->get_num_sub_exprs(); i++)
@@ -40,7 +40,7 @@ smt_astt smt_tuple_node_flattener::tuple_fresh(smt_sortt s, std::string name)
     return array_conv.mk_array_symbol(name, s, subtype);
   }
 
-  return new tuple_node_smt_ast(*this, ctx, s, name, msg);
+  return new tuple_node_smt_ast(*this, ctx, s, name);
 }
 
 smt_astt
@@ -48,7 +48,7 @@ smt_tuple_node_flattener::mk_tuple_symbol(const std::string &name, smt_sortt s)
 {
   // Because this tuple flattening doesn't join tuples through the symbol
   // table, there are some special names that need to be intercepted.
-  if(name == "0" || name == "NULL")
+  if(name == "NULL")
     return ctx->null_ptr_ast;
 
   if(name == "INVALID")
@@ -62,7 +62,7 @@ smt_tuple_node_flattener::mk_tuple_symbol(const std::string &name, smt_sortt s)
     name2 += ".";
 
   assert(s->id != SMT_SORT_ARRAY);
-  return new tuple_node_smt_ast(*this, ctx, s, name2, msg);
+  return new tuple_node_smt_ast(*this, ctx, s, name2);
 }
 
 smt_astt smt_tuple_node_flattener::mk_tuple_array_symbol(const expr2tc &expr)
@@ -108,7 +108,7 @@ smt_astt smt_tuple_node_flattener::tuple_array_create(
   }
   if(!is_constant_int2t(arr_type.array_size))
   {
-    msg.error("Non-constant sized array of type constant_array_of2t");
+    log_error("Non-constant sized array of type constant_array_of2t");
     abort();
   }
 
@@ -182,19 +182,19 @@ expr2tc smt_tuple_node_flattener::tuple_get_rec(tuple_node_smt_astt tuple)
     {
       if(is_fetching_from_array_an_error)
       {
-        msg.error(
+        log_error(
           "Fetching array elements inside tuples currently unimplemented, "
           "sorry");
         abort();
       }
-      msg.warning(
+      log_warning(
         "Fetching array elements inside tuples currently unimplemented, "
         "returning empty expression...");
       res = expr2tc();
     }
     else
     {
-      msg.error("Unexpected type in tuple_get_rec");
+      log_error("Unexpected type in tuple_get_rec");
       abort();
     }
 
diff --git a/src/solvers/smt/tuple/smt_tuple_node.h b/src/solvers/smt/tuple/smt_tuple_node.h
index 67efda876..eaa42f074 100644
--- a/src/solvers/smt/tuple/smt_tuple_node.h
+++ b/src/solvers/smt/tuple/smt_tuple_node.h
@@ -13,11 +13,8 @@ class smt_tuple_node_flattener : public tuple_iface
 public:
   // TODO: Same as the other variable. The current implementation is not good
   bool is_fetching_from_array_an_error = false;
-  smt_tuple_node_flattener(
-    smt_convt *_ctx,
-    const namespacet &_ns,
-    const messaget &msg)
-    : ctx(_ctx), ns(_ns), array_conv(_ctx), msg(msg)
+  smt_tuple_node_flattener(smt_convt *_ctx, const namespacet &_ns)
+    : ctx(_ctx), ns(_ns), array_conv(_ctx)
   {
   }
 
@@ -48,7 +45,6 @@ public:
   smt_convt *ctx;
   const namespacet &ns;
   array_convt array_conv;
-  const messaget &msg;
 };
 
 #endif
diff --git a/src/solvers/smt/tuple/smt_tuple_node_ast.cpp b/src/solvers/smt/tuple/smt_tuple_node_ast.cpp
index 572fea4cb..246a5cc44 100644
--- a/src/solvers/smt/tuple/smt_tuple_node_ast.cpp
+++ b/src/solvers/smt/tuple/smt_tuple_node_ast.cpp
@@ -65,7 +65,7 @@ tuple_node_smt_ast::ite(smt_convt *ctx, smt_astt cond, smt_astt falseop) const
 
   std::string name = ctx->mk_fresh_name("tuple_ite::") + ".";
   tuple_node_smt_ast *result_sym =
-    new tuple_node_smt_ast(flat, ctx, sort, name, _msg);
+    new tuple_node_smt_ast(flat, ctx, sort, name);
 
   const_cast<tuple_node_smt_ast *>(true_val)->make_free(ctx);
   const_cast<tuple_node_smt_ast *>(false_val)->make_free(ctx);
@@ -133,7 +133,7 @@ smt_astt tuple_node_smt_ast::update(
   smt_convt *ctx,
   smt_astt value,
   unsigned int idx,
-  expr2tc idx_expr [[gnu::unused]] /*ndebug*/) const
+  expr2tc idx_expr [[maybe_unused]] /*ndebug*/) const
 {
   smt_convt::ast_vec eqs;
   assert(
@@ -142,8 +142,7 @@ smt_astt tuple_node_smt_ast::update(
     "structure");
 
   std::string name = ctx->mk_fresh_name("tuple_update::") + ".";
-  tuple_node_smt_ast *result =
-    new tuple_node_smt_ast(flat, ctx, sort, name, _msg);
+  tuple_node_smt_ast *result = new tuple_node_smt_ast(flat, ctx, sort, name);
   result->elements = elements;
   result->make_free(ctx);
   result->elements[idx] = value;
@@ -152,10 +151,10 @@ smt_astt tuple_node_smt_ast::update(
 }
 
 smt_astt tuple_node_smt_ast::select(
-  smt_convt *ctx [[gnu::unused]],
-  const expr2tc &idx [[gnu::unused]]) const
+  smt_convt *ctx [[maybe_unused]],
+  const expr2tc &idx [[maybe_unused]]) const
 {
-  _msg.error("Select operation applied to tuple");
+  log_error("Select operation applied to tuple");
   abort();
 }
 
diff --git a/src/solvers/smt/tuple/smt_tuple_node_ast.h b/src/solvers/smt/tuple/smt_tuple_node_ast.h
index e3f083b95..86aff8f70 100644
--- a/src/solvers/smt/tuple/smt_tuple_node_ast.h
+++ b/src/solvers/smt/tuple/smt_tuple_node_ast.h
@@ -2,7 +2,6 @@
 #define SOLVERS_SMT_TUPLE_SMT_TUPLE_NODE_AST_H_
 
 #include <solvers/smt/smt_conv.h>
-#include <util/message/default_message.h>
 
 class tuple_node_smt_ast;
 typedef const tuple_node_smt_ast *tuple_node_smt_astt;
@@ -32,9 +31,8 @@ public:
     smt_tuple_node_flattener &f,
     smt_convt *ctx,
     smt_sortt s,
-    std::string _name,
-    const messaget &msg)
-    : smt_ast(ctx, s, msg), name(std::move(_name)), flat(f)
+    std::string _name)
+    : smt_ast(ctx, s), name(std::move(_name)), flat(f)
   {
   }
   ~tuple_node_smt_ast() override = default;
@@ -59,8 +57,7 @@ public:
 
   void dump() const override
   {
-    default_message msg;
-    msg.debug(fmt::format("name {}", name));
+    log_debug("name {}", name);
     for(auto const &e : elements)
       e->dump();
   }
diff --git a/src/solvers/smt/tuple/smt_tuple_sym.cpp b/src/solvers/smt/tuple/smt_tuple_sym.cpp
index ea85bb06c..ca70115b0 100644
--- a/src/solvers/smt/tuple/smt_tuple_sym.cpp
+++ b/src/solvers/smt/tuple/smt_tuple_sym.cpp
@@ -16,7 +16,7 @@ smt_astt smt_tuple_sym_flattener::tuple_create(const expr2tc &structdef)
   name += ".";
 
   smt_astt result =
-    new tuple_sym_smt_ast(ctx, ctx->convert_sort(structdef->type), name, msg);
+    new tuple_sym_smt_ast(ctx, ctx->convert_sort(structdef->type), name);
 
   for(unsigned int i = 0; i < structdef->get_num_sub_exprs(); i++)
   {
@@ -34,9 +34,9 @@ smt_astt smt_tuple_sym_flattener::tuple_fresh(smt_sortt s, std::string name)
     (name == "") ? ctx->mk_fresh_name("tuple_fresh::") + "." : name;
 
   if(s->id == SMT_SORT_ARRAY)
-    return new array_sym_smt_ast(ctx, s, n, msg);
+    return new array_sym_smt_ast(ctx, s, n);
 
-  return new tuple_sym_smt_ast(ctx, s, n, msg);
+  return new tuple_sym_smt_ast(ctx, s, n);
 }
 
 smt_astt
@@ -50,7 +50,7 @@ smt_tuple_sym_flattener::mk_tuple_symbol(const std::string &name, smt_sortt s)
     name2 += ".";
 
   assert(s->id != SMT_SORT_ARRAY);
-  return new tuple_sym_smt_ast(ctx, s, name2, msg);
+  return new tuple_sym_smt_ast(ctx, s, name2);
 }
 
 smt_astt smt_tuple_sym_flattener::mk_tuple_array_symbol(const expr2tc &expr)
@@ -59,14 +59,14 @@ smt_astt smt_tuple_sym_flattener::mk_tuple_array_symbol(const expr2tc &expr)
   const symbol2t &sym = to_symbol2t(expr);
   std::string name = sym.get_symbol_name() + "[]";
   smt_sortt sort = ctx->convert_sort(sym.type);
-  return new array_sym_smt_ast(ctx, sort, name, msg);
+  return new array_sym_smt_ast(ctx, sort, name);
 }
 
 smt_astt smt_tuple_sym_flattener::tuple_array_create(
   const type2tc &array_type,
   smt_astt *inputargs,
   bool const_array,
-  smt_sortt domain [[gnu::unused]])
+  smt_sortt domain [[maybe_unused]])
 {
   // Create a tuple array from a constant representation. This means that
   // either we have an array_of or a constant_array. Handle this by creating
@@ -75,7 +75,7 @@ smt_astt smt_tuple_sym_flattener::tuple_array_create(
   // XXX - probably more efficient to update each member array, but not now.
   smt_sortt sort = ctx->convert_sort(array_type);
   std::string name = ctx->mk_fresh_name("tuple_array_create::") + ".";
-  smt_astt newsym = new array_sym_smt_ast(ctx, sort, name, msg);
+  smt_astt newsym = new array_sym_smt_ast(ctx, sort, name);
 
   // Check size
   const array_type2t &arr_type = to_array_type(array_type);
@@ -86,7 +86,7 @@ smt_astt smt_tuple_sym_flattener::tuple_array_create(
   }
   if(!is_constant_int2t(arr_type.array_size))
   {
-    msg.error("Non-constant sized array of type constant_array_of2t");
+    log_error("Non-constant sized array of type constant_array_of2t");
     abort();
   }
 
@@ -117,7 +117,7 @@ smt_astt smt_tuple_sym_flattener::tuple_array_create(
 
 expr2tc smt_tuple_sym_flattener::tuple_get(const type2tc &, smt_astt)
 {
-  msg.error(
+  log_error(
     "Fetching tuples from tuple-sym-flattener without the concrete symbol "
     "is currently not implemented, returning empty expression...");
   return expr2tc();
@@ -181,7 +181,7 @@ smt_astt smt_tuple_sym_flattener::tuple_array_of(
   symbol2tc tuple_arr_of_sym(arrtype, irep_idt(name));
 
   smt_sortt sort = ctx->convert_sort(arrtype);
-  smt_astt newsym = new array_sym_smt_ast(ctx, sort, name, msg);
+  smt_astt newsym = new array_sym_smt_ast(ctx, sort, name);
 
   assert(subtype.members.size() == data.datatype_members.size());
   for(unsigned long i = 0; i < subtype.members.size(); i++)
diff --git a/src/solvers/smt/tuple/smt_tuple_sym.h b/src/solvers/smt/tuple/smt_tuple_sym.h
index 632317c1f..6de89112a 100644
--- a/src/solvers/smt/tuple/smt_tuple_sym.h
+++ b/src/solvers/smt/tuple/smt_tuple_sym.h
@@ -10,11 +10,8 @@ typedef const tuple_sym_smt_ast *tuple_sym_smt_astt;
 class smt_tuple_sym_flattener : public tuple_iface
 {
 public:
-  smt_tuple_sym_flattener(
-    smt_convt *_ctx,
-    const namespacet &_ns,
-    const messaget &msg)
-    : ctx(_ctx), ns(_ns), msg(msg)
+  smt_tuple_sym_flattener(smt_convt *_ctx, const namespacet &_ns)
+    : ctx(_ctx), ns(_ns)
   {
   }
 
@@ -39,7 +36,6 @@ public:
 
   smt_convt *ctx;
   const namespacet &ns;
-  const messaget &msg;
 };
 
 #endif
diff --git a/src/solvers/smt/tuple/smt_tuple_sym_ast.cpp b/src/solvers/smt/tuple/smt_tuple_sym_ast.cpp
index 6ae0b682b..1fc852872 100644
--- a/src/solvers/smt/tuple/smt_tuple_sym_ast.cpp
+++ b/src/solvers/smt/tuple/smt_tuple_sym_ast.cpp
@@ -118,7 +118,7 @@ smt_astt tuple_sym_smt_ast::update(
   smt_convt *ctx,
   smt_astt value,
   unsigned int idx,
-  expr2tc idx_expr [[gnu::unused]] /*ndebug*/) const
+  expr2tc idx_expr [[maybe_unused]] /*ndebug*/) const
 {
   smt_convt::ast_vec eqs;
   assert(
@@ -130,7 +130,7 @@ smt_astt tuple_sym_smt_ast::update(
   const struct_union_data &data = ctx->get_type_def(sort->get_tuple_type());
 
   std::string name = ctx->mk_fresh_name("tuple_update::") + ".";
-  tuple_sym_smt_astt result = new tuple_sym_smt_ast(ctx, sort, name, _msg);
+  tuple_sym_smt_astt result = new tuple_sym_smt_ast(ctx, sort, name);
 
   // Iterate over all members, deciding what to do with them.
   for(unsigned int j = 0; j < data.members.size(); j++)
@@ -158,10 +158,10 @@ smt_astt tuple_sym_smt_ast::update(
 }
 
 smt_astt tuple_sym_smt_ast::select(
-  smt_convt *ctx [[gnu::unused]],
-  const expr2tc &idx [[gnu::unused]]) const
+  smt_convt *ctx [[maybe_unused]],
+  const expr2tc &idx [[maybe_unused]]) const
 {
-  _msg.error("Select operation applied to tuple");
+  log_error("Select operation applied to tuple");
   abort();
 }
 
@@ -188,9 +188,9 @@ smt_astt tuple_sym_smt_ast::project(smt_convt *ctx, unsigned int idx) const
     // the internal struct being projected.
     sym_name = sym_name + ".";
     if(is_tuple_array_ast_type(restype))
-      return new array_sym_smt_ast(ctx, s, sym_name, _msg);
+      return new array_sym_smt_ast(ctx, s, sym_name);
 
-    return new tuple_sym_smt_ast(ctx, s, sym_name, _msg);
+    return new tuple_sym_smt_ast(ctx, s, sym_name);
   }
   else
   {
diff --git a/src/solvers/smt/tuple/smt_tuple_sym_ast.h b/src/solvers/smt/tuple/smt_tuple_sym_ast.h
index 2bf3ec028..c35cd8ca3 100644
--- a/src/solvers/smt/tuple/smt_tuple_sym_ast.h
+++ b/src/solvers/smt/tuple/smt_tuple_sym_ast.h
@@ -15,12 +15,8 @@ public:
    *  @param s The sort of the tuple, of type tuple_smt_sort.
    *  @param _name The symbol prefix of the variables representing this tuples
    *               value. */
-  tuple_sym_smt_ast(
-    smt_convt *ctx,
-    smt_sortt s,
-    std::string _name,
-    const messaget &msg)
-    : smt_ast(ctx, s, msg), name(std::move(_name))
+  tuple_sym_smt_ast(smt_convt *ctx, smt_sortt s, std::string _name)
+    : smt_ast(ctx, s), name(std::move(_name))
   {
   }
   ~tuple_sym_smt_ast() override = default;
diff --git a/src/solvers/smtlib/smtlib_conv.cpp b/src/solvers/smtlib/smtlib_conv.cpp
index acb513370..49d4d5391 100644
--- a/src/solvers/smtlib/smtlib_conv.cpp
+++ b/src/solvers/smtlib/smtlib_conv.cpp
@@ -100,24 +100,18 @@ extern sexpr *smtlib_output;
 smt_convt *create_new_smtlib_solver(
   const optionst &options,
   const namespacet &ns,
-  tuple_iface **tuple_api [[gnu::unused]],
+  tuple_iface **tuple_api [[maybe_unused]],
   array_iface **array_api,
-  fp_convt **fp_api,
-  const messaget &msg)
+  fp_convt **fp_api)
 {
-  smtlib_convt *conv = new smtlib_convt(ns, options, msg);
+  smtlib_convt *conv = new smtlib_convt(ns, options);
   *array_api = static_cast<array_iface *>(conv);
   *fp_api = static_cast<fp_convt *>(conv);
   return conv;
 }
 
-smtlib_convt::smtlib_convt(
-  const namespacet &_ns,
-  const optionst &_options,
-  const messaget &msg)
-  : smt_convt(_ns, _options, msg),
-    array_iface(false, false),
-    fp_convt(this, msg)
+smtlib_convt::smtlib_convt(const namespacet &_ns, const optionst &_options)
+  : smt_convt(_ns, _options), array_iface(false, false), fp_convt(this)
 
 {
   temp_sym_count.push_back(1);
@@ -132,7 +126,7 @@ smtlib_convt::smtlib_convt(
   {
     if(config.options.get_option("smtlib-solver-prog") != "")
     {
-      msg.error("Can't solve SMTLIB output and write to a file, sorry");
+      log_error("Can't solve SMTLIB output and write to a file, sorry");
       abort();
     }
 
@@ -140,7 +134,7 @@ smtlib_convt::smtlib_convt(
     out_stream = fopen(cmd.c_str(), "w");
     if(!out_stream)
     {
-      msg.error(fmt::format("Failed to open \"{}\"", cmd));
+      log_error("Failed to open \"{}\"", cmd);
       abort();
     }
 
@@ -163,24 +157,24 @@ smtlib_convt::smtlib_convt(
   cmd = config.options.get_option("smtlib-solver-prog");
   if(cmd == "")
   {
-    msg.error("Must specify an smtlib solver program in smtlib mode");
+    log_error("Must specify an smtlib solver program in smtlib mode");
     abort();
   }
 
 #ifdef _WIN32
   // TODO: The current implementation uses UNIX Process
-  msg.error("smtlib works only in unix systems");
+  log_error("smtlib works only in unix systems");
   abort();
 #else
   if(pipe(inpipe) != 0)
   {
-    msg.error("Couldn't open a pipe for smtlib solver");
+    log_error("Couldn't open a pipe for smtlib solver");
     abort();
   }
 
   if(pipe(outpipe) != 0)
   {
-    msg.error("Couldn't open a pipe for smtlib solver");
+    log_error("Couldn't open a pipe for smtlib solver");
     abort();
   }
 
@@ -198,7 +192,7 @@ smtlib_convt::smtlib_convt(
 
     // Voila
     execlp(cmd.c_str(), cmd.c_str(), NULL);
-    msg.error("Exec of smtlib solver failed");
+    log_error("Exec of smtlib solver failed");
     abort();
   }
   else
@@ -239,7 +233,7 @@ smtlib_convt::smtlib_convt(
   class sexpr &value = s.sexpr_list.back();
   if(!(keyword.token == TOK_KEYWORD && keyword.data == ":name"))
   {
-    msg.error("Bad get-info :name response from solver");
+    log_error("Bad get-info :name response from solver");
     abort();
   }
 
@@ -261,7 +255,7 @@ smtlib_convt::smtlib_convt(
 
   if(v.token == 0 && v.sexpr_list.size() == 2)
   {
-    msg.error("Bad solver version fmt");
+    log_error("Bad solver version fmt");
     abort();
   }
   class sexpr &kw = v.sexpr_list.front();
@@ -301,7 +295,7 @@ std::string smtlib_convt::sort_to_string(const smt_sort *s) const
   case SMT_SORT_BOOL:
     return "Bool";
   default:
-    msg.error("Unexpected sort in smtlib_convt");
+    log_error("Unexpected sort in smtlib_convt");
     abort();
   }
 }
@@ -355,7 +349,7 @@ smtlib_convt::emit_terminal_ast(const smtlib_smt_ast *ast, std::string &output)
     output = ss.str();
     return 0;
   default:
-    msg.error("Invalid terminal AST kind");
+    log_error("Invalid terminal AST kind");
     abort();
   }
 }
@@ -451,15 +445,12 @@ smt_convt::resultt smtlib_convt::dec_solve()
   }
   else if(smtlib_output->token == TOK_KW_ERROR)
   {
-    std::ostringstream oss;
-    oss << "SMTLIB solver returned error: \"" << smtlib_output->data << "\""
-        << "\n";
-    msg.error(oss.str());
+    log_error("SMTLIB solver returned error: \"{}\"", smtlib_output->data);
     return smt_convt::P_ERROR;
   }
   else
   {
-    msg.error("Unrecognized check-sat output from smtlib solver");
+    log_error("Unrecognized check-sat output from smtlib solver");
     abort();
   }
 }
@@ -478,15 +469,15 @@ BigInt smtlib_convt::get_bv(smt_astt a, bool is_signed)
 
   if(smtlib_output->token == TOK_KW_ERROR)
   {
-    msg.error(fmt::format(
+    log_error(
       "Error from smtlib solver when fetching literal value: \"{}\"",
-      smtlib_output->data));
+      smtlib_output->data);
     abort();
   }
 
   else if(smtlib_output->token != 0)
   {
-    msg.error("Unrecognized response to get-value from smtlib solver");
+    log_error("Unrecognized response to get-value from smtlib solver");
     abort();
   }
   // Unpack our value from response list.
@@ -505,7 +496,7 @@ BigInt smtlib_convt::get_bv(smt_astt a, bool is_signed)
   sexpr &respval = *it++;
   if(!(symname.token == TOK_SIMPLESYM && symname.data == name))
   {
-    msg.error("smtlib solver returned different symbol from get-value");
+    log_error("smtlib solver returned different symbol from get-value");
     abort();
   }
 
@@ -517,7 +508,7 @@ BigInt smtlib_convt::get_bv(smt_astt a, bool is_signed)
   }
   else if(respval.token == TOK_NUMERAL)
   {
-    msg.error("Numeral value for integer symbol from smtlib solver");
+    log_error("Numeral value for integer symbol from smtlib solver");
     abort();
   }
 
@@ -558,14 +549,14 @@ smtlib_convt::get_array_elem(smt_astt array, uint64_t index, const type2tc &t)
 
   if(smtlib_output->token == TOK_KW_ERROR)
   {
-    msg.error(fmt::format(
+    log_error(
       "Error from smtlib solver when fetching literal value: \"{}\"",
-      smtlib_output->data));
+      smtlib_output->data);
     abort();
   }
   else if(smtlib_output->token != 0)
   {
-    msg.error("Unrecognized response to get-value from smtlib solver");
+    log_error("Unrecognized response to get-value from smtlib solver");
     abort();
   }
 
@@ -593,7 +584,7 @@ smtlib_convt::get_array_elem(smt_astt array, uint64_t index, const type2tc &t)
   }
   else if(respval.token == TOK_NUMERAL)
   {
-    msg.error("Numeral value for integer symbol from smtlib solver");
+    log_error("Numeral value for integer symbol from smtlib solver");
     abort();
   }
 
@@ -618,7 +609,7 @@ smtlib_convt::get_array_elem(smt_astt array, uint64_t index, const type2tc &t)
   {
     if(!was_integer)
     {
-      msg.error(
+      log_error(
         "smtlib solver didn't provide integer response to integer get-value");
       abort();
     }
@@ -666,13 +657,13 @@ smtlib_convt::get_array_elem(smt_astt array, uint64_t index, const type2tc &t)
         result = gen_true_expr();
       else
       {
-        msg.error("Unrecognized boolean-typed binary number format");
+        log_error("Unrecognized boolean-typed binary number format");
         abort();
       }
     }
     else
     {
-      msg.error(
+      log_error(
         "Unexpected token reading value of boolean symbol from "
         "smtlib solver");
       abort();
@@ -708,14 +699,14 @@ bool smtlib_convt::get_bool(smt_astt a)
 
   if(smtlib_output->token == TOK_KW_ERROR)
   {
-    msg.error(fmt::format(
+    log_error(
       "Error from smtlib solver when fetching literal value: \"{}\"",
-      smtlib_output->data));
+      smtlib_output->data);
     abort();
   }
   else if(smtlib_output->token != 0)
   {
-    msg.error("Unrecognized response to get-value from smtlib solver");
+    log_error("Unrecognized response to get-value from smtlib solver");
     abort();
   }
 
@@ -790,7 +781,7 @@ void smtlib_convt::assert_ast(smt_astt a)
 smt_astt smtlib_convt::mk_smt_int(const BigInt &theint)
 {
   smt_sortt s = mk_int_sort();
-  smtlib_smt_ast *a = new smtlib_smt_ast(this, s, SMT_FUNC_INT, msg);
+  smtlib_smt_ast *a = new smtlib_smt_ast(this, s, SMT_FUNC_INT);
   a->intval = theint;
   return a;
 }
@@ -798,22 +789,21 @@ smt_astt smtlib_convt::mk_smt_int(const BigInt &theint)
 smt_astt smtlib_convt::mk_smt_real(const std::string &str)
 {
   smt_sortt s = mk_real_sort();
-  smtlib_smt_ast *a = new smtlib_smt_ast(this, s, SMT_FUNC_REAL, msg);
+  smtlib_smt_ast *a = new smtlib_smt_ast(this, s, SMT_FUNC_REAL);
   a->realval = str;
   return a;
 }
 
 smt_astt smtlib_convt::mk_smt_bv(const BigInt &theint, smt_sortt s)
 {
-  smtlib_smt_ast *a = new smtlib_smt_ast(this, s, SMT_FUNC_BVINT, msg);
+  smtlib_smt_ast *a = new smtlib_smt_ast(this, s, SMT_FUNC_BVINT);
   a->intval = theint;
   return a;
 }
 
 smt_astt smtlib_convt::mk_smt_bool(bool val)
 {
-  smtlib_smt_ast *a =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BOOL, msg);
+  smtlib_smt_ast *a = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BOOL);
   a->boolval = val;
   return a;
 }
@@ -821,14 +811,14 @@ smt_astt smtlib_convt::mk_smt_bool(bool val)
 smt_astt smtlib_convt::mk_array_symbol(
   const std::string &name,
   const smt_sort *s,
-  smt_sortt array_subtype [[gnu::unused]])
+  smt_sortt array_subtype [[maybe_unused]])
 {
   return mk_smt_symbol(name, s);
 }
 
 smt_astt smtlib_convt::mk_smt_symbol(const std::string &name, const smt_sort *s)
 {
-  smtlib_smt_ast *a = new smtlib_smt_ast(this, s, SMT_FUNC_SYMBOL, msg);
+  smtlib_smt_ast *a = new smtlib_smt_ast(this, s, SMT_FUNC_SYMBOL);
   a->symname = name;
 
   symbol_tablet::iterator it = symbol_table.find(name);
@@ -853,9 +843,9 @@ smt_astt smtlib_convt::mk_smt_symbol(const std::string &name, const smt_sort *s)
   return a;
 }
 
-smt_sort *smtlib_convt::mk_struct_sort(const type2tc &type [[gnu::unused]])
+smt_sort *smtlib_convt::mk_struct_sort(const type2tc &type [[maybe_unused]])
 {
-  msg.error("Attempted to make struct type in smtlib conversion");
+  log_error("Attempted to make struct type in smtlib conversion");
   abort();
 }
 
@@ -863,7 +853,7 @@ smt_astt
 smtlib_convt::mk_extract(smt_astt a, unsigned int high, unsigned int low)
 {
   smt_sortt s = mk_bv_sort(high - low + 1);
-  smtlib_smt_ast *n = new smtlib_smt_ast(this, s, SMT_FUNC_EXTRACT, msg);
+  smtlib_smt_ast *n = new smtlib_smt_ast(this, s, SMT_FUNC_EXTRACT);
   n->extract_high = high;
   n->extract_low = low;
   n->args.push_back(a);
@@ -899,7 +889,7 @@ smt_astt smtlib_convt::mk_zero_ext(smt_astt a, unsigned int topwidth)
 
 smt_astt smtlib_convt::mk_concat(smt_astt a, smt_astt b)
 {
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_CONCAT, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_CONCAT);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -910,17 +900,16 @@ smt_astt smtlib_convt::mk_ite(smt_astt cond, smt_astt t, smt_astt f)
   assert(cond->sort->id == SMT_SORT_BOOL);
   assert(t->sort->get_data_width() == f->sort->get_data_width());
 
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, t->sort, SMT_FUNC_ITE, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, t->sort, SMT_FUNC_ITE);
   ast->args.push_back(cond);
   ast->args.push_back(t);
   ast->args.push_back(f);
   return ast;
 }
 
-int smtliberror(int startsym [[gnu::unused]], const std::string &error)
+int smtliberror(int startsym [[maybe_unused]], const std::string &error)
 {
-  assert(
-    0 && fmt::format("SMTLIB response parsing error: \"{}\"", error).c_str());
+  log_error("SMTLIB response parsing error: \"{}\"", error);
   abort();
 }
 
@@ -937,7 +926,7 @@ smt_astt smtlib_convt::mk_add(smt_astt a, smt_astt b)
   assert(a->sort->id == SMT_SORT_INT || a->sort->id == SMT_SORT_REAL);
   assert(b->sort->id == SMT_SORT_INT || b->sort->id == SMT_SORT_REAL);
   assert(a->sort->id == b->sort->id);
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_ADD, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_ADD);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -948,7 +937,7 @@ smt_astt smtlib_convt::mk_bvadd(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVADD, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVADD);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -959,7 +948,7 @@ smt_astt smtlib_convt::mk_sub(smt_astt a, smt_astt b)
   assert(a->sort->id == SMT_SORT_INT || a->sort->id == SMT_SORT_REAL);
   assert(b->sort->id == SMT_SORT_INT || b->sort->id == SMT_SORT_REAL);
   assert(a->sort->id == b->sort->id);
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_SUB, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_SUB);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -970,7 +959,7 @@ smt_astt smtlib_convt::mk_bvsub(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVSUB, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVSUB);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -981,7 +970,7 @@ smt_astt smtlib_convt::mk_mul(smt_astt a, smt_astt b)
   assert(a->sort->id == SMT_SORT_INT || a->sort->id == SMT_SORT_REAL);
   assert(b->sort->id == SMT_SORT_INT || b->sort->id == SMT_SORT_REAL);
   assert(a->sort->id == b->sort->id);
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_MUL, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_MUL);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -992,7 +981,7 @@ smt_astt smtlib_convt::mk_bvmul(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVMUL, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVMUL);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1003,7 +992,7 @@ smt_astt smtlib_convt::mk_mod(smt_astt a, smt_astt b)
   assert(a->sort->id == SMT_SORT_INT || a->sort->id == SMT_SORT_REAL);
   assert(b->sort->id == SMT_SORT_INT || b->sort->id == SMT_SORT_REAL);
   assert(a->sort->id == b->sort->id);
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_MOD, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_MOD);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1014,7 +1003,7 @@ smt_astt smtlib_convt::mk_bvsmod(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVSMOD, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVSMOD);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1025,7 +1014,7 @@ smt_astt smtlib_convt::mk_bvumod(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVUMOD, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVUMOD);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1036,7 +1025,7 @@ smt_astt smtlib_convt::mk_div(smt_astt a, smt_astt b)
   assert(a->sort->id == SMT_SORT_INT || a->sort->id == SMT_SORT_REAL);
   assert(b->sort->id == SMT_SORT_INT || b->sort->id == SMT_SORT_REAL);
   assert(a->sort->id == b->sort->id);
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_DIV, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_DIV);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1047,7 +1036,7 @@ smt_astt smtlib_convt::mk_bvsdiv(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVSDIV, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVSDIV);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1058,7 +1047,7 @@ smt_astt smtlib_convt::mk_bvudiv(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVUDIV, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVUDIV);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1069,7 +1058,7 @@ smt_astt smtlib_convt::mk_shl(smt_astt a, smt_astt b)
   assert(a->sort->id == SMT_SORT_INT || a->sort->id == SMT_SORT_REAL);
   assert(b->sort->id == SMT_SORT_INT || b->sort->id == SMT_SORT_REAL);
   assert(a->sort->id == b->sort->id);
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_SHL, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_SHL);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1080,7 +1069,7 @@ smt_astt smtlib_convt::mk_bvshl(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVSHL, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVSHL);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1091,7 +1080,7 @@ smt_astt smtlib_convt::mk_bvashr(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVASHR, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVASHR);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1102,7 +1091,7 @@ smt_astt smtlib_convt::mk_bvlshr(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVLSHR, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVLSHR);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1111,7 +1100,7 @@ smt_astt smtlib_convt::mk_bvlshr(smt_astt a, smt_astt b)
 smt_astt smtlib_convt::mk_neg(smt_astt a)
 {
   assert(a->sort->id == SMT_SORT_INT || a->sort->id == SMT_SORT_REAL);
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_NEG, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_NEG);
   ast->args.push_back(a);
   return ast;
 }
@@ -1119,7 +1108,7 @@ smt_astt smtlib_convt::mk_neg(smt_astt a)
 smt_astt smtlib_convt::mk_bvneg(smt_astt a)
 {
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVNEG, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVNEG);
   ast->args.push_back(a);
   return ast;
 }
@@ -1127,7 +1116,7 @@ smt_astt smtlib_convt::mk_bvneg(smt_astt a)
 smt_astt smtlib_convt::mk_bvnot(smt_astt a)
 {
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVNOT, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVNOT);
   ast->args.push_back(a);
   return ast;
 }
@@ -1137,7 +1126,7 @@ smt_astt smtlib_convt::mk_bvnxor(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVNXOR, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVNXOR);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1148,7 +1137,7 @@ smt_astt smtlib_convt::mk_bvnor(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVNOR, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVNOR);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1159,7 +1148,7 @@ smt_astt smtlib_convt::mk_bvnand(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVNAND, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVNAND);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1170,7 +1159,7 @@ smt_astt smtlib_convt::mk_bvxor(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVXOR, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVXOR);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1181,7 +1170,7 @@ smt_astt smtlib_convt::mk_bvor(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVOR, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVOR);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1192,7 +1181,7 @@ smt_astt smtlib_convt::mk_bvand(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVAND, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_BVAND);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1202,7 +1191,7 @@ smt_astt smtlib_convt::mk_implies(smt_astt a, smt_astt b)
 {
   assert(a->sort->id == SMT_SORT_BOOL && b->sort->id == SMT_SORT_BOOL);
   smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_IMPLIES, msg);
+    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_IMPLIES);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1211,8 +1200,7 @@ smt_astt smtlib_convt::mk_implies(smt_astt a, smt_astt b)
 smt_astt smtlib_convt::mk_xor(smt_astt a, smt_astt b)
 {
   assert(a->sort->id == SMT_SORT_BOOL && b->sort->id == SMT_SORT_BOOL);
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_XOR, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_XOR);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1221,8 +1209,7 @@ smt_astt smtlib_convt::mk_xor(smt_astt a, smt_astt b)
 smt_astt smtlib_convt::mk_or(smt_astt a, smt_astt b)
 {
   assert(a->sort->id == SMT_SORT_BOOL && b->sort->id == SMT_SORT_BOOL);
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_OR, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_OR);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1231,8 +1218,7 @@ smt_astt smtlib_convt::mk_or(smt_astt a, smt_astt b)
 smt_astt smtlib_convt::mk_and(smt_astt a, smt_astt b)
 {
   assert(a->sort->id == SMT_SORT_BOOL && b->sort->id == SMT_SORT_BOOL);
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_AND, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_AND);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1241,8 +1227,7 @@ smt_astt smtlib_convt::mk_and(smt_astt a, smt_astt b)
 smt_astt smtlib_convt::mk_not(smt_astt a)
 {
   assert(a->sort->id == SMT_SORT_BOOL);
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_NOT, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_NOT);
   ast->args.push_back(a);
   return ast;
 }
@@ -1251,8 +1236,7 @@ smt_astt smtlib_convt::mk_lt(smt_astt a, smt_astt b)
 {
   assert(a->sort->id == SMT_SORT_INT || a->sort->id == SMT_SORT_REAL);
   assert(b->sort->id == SMT_SORT_INT || b->sort->id == SMT_SORT_REAL);
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_LT, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_LT);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1263,8 +1247,7 @@ smt_astt smtlib_convt::mk_bvult(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BVULT, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BVULT);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1275,8 +1258,7 @@ smt_astt smtlib_convt::mk_bvslt(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BVSLT, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BVSLT);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1286,8 +1268,7 @@ smt_astt smtlib_convt::mk_gt(smt_astt a, smt_astt b)
 {
   assert(a->sort->id == SMT_SORT_INT || a->sort->id == SMT_SORT_REAL);
   assert(b->sort->id == SMT_SORT_INT || b->sort->id == SMT_SORT_REAL);
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_GT, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_GT);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1298,8 +1279,7 @@ smt_astt smtlib_convt::mk_bvugt(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BVUGT, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BVUGT);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1310,8 +1290,7 @@ smt_astt smtlib_convt::mk_bvsgt(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BVUGT, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BVUGT);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1321,8 +1300,7 @@ smt_astt smtlib_convt::mk_le(smt_astt a, smt_astt b)
 {
   assert(a->sort->id == SMT_SORT_INT || a->sort->id == SMT_SORT_REAL);
   assert(b->sort->id == SMT_SORT_INT || b->sort->id == SMT_SORT_REAL);
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_LTE, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_LTE);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1333,8 +1311,7 @@ smt_astt smtlib_convt::mk_bvule(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BVULTE, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BVULTE);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1345,8 +1322,7 @@ smt_astt smtlib_convt::mk_bvsle(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BVSLTE, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BVSLTE);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1356,8 +1332,7 @@ smt_astt smtlib_convt::mk_ge(smt_astt a, smt_astt b)
 {
   assert(a->sort->id == SMT_SORT_INT || a->sort->id == SMT_SORT_REAL);
   assert(b->sort->id == SMT_SORT_INT || b->sort->id == SMT_SORT_REAL);
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_GTE, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_GTE);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1368,8 +1343,7 @@ smt_astt smtlib_convt::mk_bvuge(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BVUGTE, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BVUGTE);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1380,8 +1354,7 @@ smt_astt smtlib_convt::mk_bvsge(smt_astt a, smt_astt b)
   assert(a->sort->id != SMT_SORT_INT && a->sort->id != SMT_SORT_REAL);
   assert(b->sort->id != SMT_SORT_INT && b->sort->id != SMT_SORT_REAL);
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BVSGTE, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_BVSGTE);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1390,8 +1363,7 @@ smt_astt smtlib_convt::mk_bvsge(smt_astt a, smt_astt b)
 smt_astt smtlib_convt::mk_eq(smt_astt a, smt_astt b)
 {
   assert(a->sort->get_data_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_EQ, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_EQ);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1403,7 +1375,7 @@ smt_astt smtlib_convt::mk_store(smt_astt a, smt_astt b, smt_astt c)
   assert(a->sort->get_domain_width() == b->sort->get_data_width());
   assert(
     a->sort->get_range_sort()->get_data_width() == c->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_STORE, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_STORE);
   ast->args.push_back(a);
   ast->args.push_back(b);
   ast->args.push_back(c);
@@ -1414,7 +1386,7 @@ smt_astt smtlib_convt::mk_select(smt_astt a, smt_astt b)
 {
   assert(a->sort->id == SMT_SORT_ARRAY);
   assert(a->sort->get_domain_width() == b->sort->get_data_width());
-  smtlib_smt_ast *ast = new smtlib_smt_ast(this, b->sort, SMT_FUNC_SELECT, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, b->sort, SMT_FUNC_SELECT);
   ast->args.push_back(a);
   ast->args.push_back(b);
   return ast;
@@ -1423,8 +1395,7 @@ smt_astt smtlib_convt::mk_select(smt_astt a, smt_astt b)
 smt_astt smtlib_convt::mk_real2int(smt_astt a)
 {
   assert(a->sort->id == SMT_SORT_REAL);
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, a->sort, SMT_FUNC_REAL2INT, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_REAL2INT);
   ast->args.push_back(a);
   return ast;
 }
@@ -1432,8 +1403,7 @@ smt_astt smtlib_convt::mk_real2int(smt_astt a)
 smt_astt smtlib_convt::mk_int2real(smt_astt a)
 {
   assert(a->sort->id == SMT_SORT_INT);
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, a->sort, SMT_FUNC_INT2REAL, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, a->sort, SMT_FUNC_INT2REAL);
   ast->args.push_back(a);
   return ast;
 }
@@ -1441,8 +1411,7 @@ smt_astt smtlib_convt::mk_int2real(smt_astt a)
 smt_astt smtlib_convt::mk_isint(smt_astt a)
 {
   assert(a->sort->id == SMT_SORT_INT || a->sort->id == SMT_SORT_REAL);
-  smtlib_smt_ast *ast =
-    new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_IS_INT, msg);
+  smtlib_smt_ast *ast = new smtlib_smt_ast(this, boolean_sort, SMT_FUNC_IS_INT);
   ast->args.push_back(a);
   return ast;
 }
diff --git a/src/solvers/smtlib/smtlib_conv.h b/src/solvers/smtlib/smtlib_conv.h
index d5807ecb7..84e465321 100644
--- a/src/solvers/smtlib/smtlib_conv.h
+++ b/src/solvers/smtlib/smtlib_conv.h
@@ -155,12 +155,8 @@ public:
 class smtlib_smt_ast : public smt_ast
 {
 public:
-  smtlib_smt_ast(
-    smt_convt *ctx,
-    const smt_sort *s,
-    smt_func_kind k,
-    const messaget &msg)
-    : smt_ast(ctx, s, msg), kind(k)
+  smtlib_smt_ast(smt_convt *ctx, const smt_sort *s, smt_func_kind k)
+    : smt_ast(ctx, s), kind(k)
   {
   }
   ~smtlib_smt_ast() override = default;
@@ -178,10 +174,7 @@ public:
 class smtlib_convt : public smt_convt, public array_iface, public fp_convt
 {
 public:
-  smtlib_convt(
-    const namespacet &_ns,
-    const optionst &options,
-    const messaget &msg);
+  smtlib_convt(const namespacet &_ns, const optionst &options);
   ~smtlib_convt() override;
 
   resultt dec_solve() override;
diff --git a/src/solvers/solve.cpp b/src/solvers/solve.cpp
index 27d46f6f3..177617832 100644
--- a/src/solvers/solve.cpp
+++ b/src/solvers/solve.cpp
@@ -6,6 +6,8 @@
 #include <solvers/smt/tuple/smt_tuple_node.h>
 #include <solvers/smt/tuple/smt_tuple_sym.h>
 
+#include <unordered_map>
+
 solver_creator create_new_smtlib_solver;
 solver_creator create_new_z3_solver;
 solver_creator create_new_minisat_solver;
@@ -15,7 +17,7 @@ solver_creator create_new_mathsat_solver;
 solver_creator create_new_yices_solver;
 solver_creator create_new_bitwuzla_solver;
 
-const struct esbmc_solver_config esbmc_solvers[] = {
+static const std::unordered_map<std::string, solver_creator *> esbmc_solvers = {
   {"smtlib", create_new_smtlib_solver},
 #ifdef Z3
   {"z3", create_new_z3_solver},
@@ -40,129 +42,83 @@ const struct esbmc_solver_config esbmc_solvers[] = {
 #endif
 };
 
-const std::string list_of_all_solvers[] = {
-  "z3",
+static const std::string all_solvers[] = {
   "smtlib",
+  "z3",
   "minisat",
   "boolector",
-  "mathsat",
   "cvc",
+  "mathsat",
   "yices",
   "bitwuzla"};
 
-const unsigned int total_num_of_solvers =
-  sizeof(list_of_all_solvers) / sizeof(std::string);
-
-const unsigned int esbmc_num_solvers =
-  sizeof(esbmc_solvers) / sizeof(esbmc_solver_config);
-
-static smt_convt *create_solver(
-  const std::string &&the_solver,
-  const optionst &options,
-  const namespacet &ns,
-  tuple_iface **tuple_api,
-  array_iface **array_api,
-  fp_convt **fp_api,
-  const messaget &msg [[gnu::unused]])
-{
-  for(const auto &esbmc_solver : esbmc_solvers)
-  {
-    if(the_solver == esbmc_solver.name)
-    {
-      return esbmc_solver.create(
-        options, ns, tuple_api, array_api, fp_api, msg);
-    }
-  }
-
-  msg.error(fmt::format(
-    "The {} solver has not been built into this version of ESBMC, sorry",
-    the_solver));
-  abort();
-}
-
-static const std::string pick_default_solver(const messaget &msg)
+static std::string pick_default_solver()
 {
 #ifdef BOOLECTOR
-  msg.status("No solver specified; defaulting to Boolector");
+  log_status("No solver specified; defaulting to Boolector");
   return "boolector";
 #else
-  // Pick whatever's first in the list.
-  if(esbmc_num_solvers == 1)
-  {
-    msg.error(
-      "No solver backends built into ESBMC; please either build "
-      "some in, or explicitly configure the smtlib backend");
-    abort();
-  }
-  else
+  // Pick whatever's first in the list except for the smtlib solver
+  for(const std::string &name : all_solvers)
   {
-    msg.status(fmt::format(
-      "No solver specified; defaulting to {}", esbmc_solvers[1].name));
-    return esbmc_solvers[1].name;
+    if(name == "smtlib" || !esbmc_solvers.count(name))
+      continue;
+    log_status("No solver specified; defaulting to {}", name);
+    return name;
   }
+  log_error(
+    "No solver backends built into ESBMC; please either build "
+    "some in, or explicitly configure the smtlib backend");
+  abort();
 #endif
 }
 
-static smt_convt *pick_solver(
-  const namespacet &ns,
-  const optionst &options,
-  tuple_iface **tuple_api,
-  array_iface **array_api,
-  fp_convt **fp_api,
-  const messaget &msg)
+static solver_creator &
+pick_solver(std::string &solver_name, const optionst &options)
 {
-  unsigned int i;
-  std::string the_solver;
-
-  for(i = 0; i < total_num_of_solvers; i++)
+  if(solver_name == "")
   {
-    if(options.get_bool_option(list_of_all_solvers[i]))
-    {
-      if(the_solver != "")
+    // Pick one based on options.
+    for(const std::string &name : all_solvers)
+      if(options.get_bool_option(name))
       {
-        msg.error("Please only specify one solver");
-        abort();
-      }
+        if(solver_name != "")
+        {
+          log_error("Please only specify one solver");
+          abort();
+        }
 
-      the_solver = list_of_all_solvers[i];
-    }
+        solver_name = name;
+      }
   }
 
-  if(the_solver == "")
-    the_solver = pick_default_solver(msg);
-
-  return create_solver(
-    std::move(the_solver), options, ns, tuple_api, array_api, fp_api, msg);
-}
+  if(solver_name == "")
+    solver_name = options.get_option("default-solver");
 
-smt_convt *create_solver_factory1(
-  const std::string &solver_name,
-  const namespacet &ns,
-  const optionst &options,
-  tuple_iface **tuple_api,
-  array_iface **array_api,
-  fp_convt **fp_api,
-  const messaget &msg)
-{
   if(solver_name == "")
-    // Pick one based on options.
-    return pick_solver(ns, options, tuple_api, array_api, fp_api, msg);
+    solver_name = pick_default_solver();
 
-  return create_solver(
-    std::move(solver_name), options, ns, tuple_api, array_api, fp_api, msg);
+  auto it = esbmc_solvers.find(solver_name);
+  if(it != esbmc_solvers.end())
+    return *it->second;
+
+  log_error(
+    "The {} solver has not been built into this version of ESBMC, sorry",
+    solver_name);
+  abort();
 }
 
-smt_convt *create_solver_factory(
-  const std::string &solver_name,
+smt_convt *create_solver(
+  std::string solver_name,
   const namespacet &ns,
-  const optionst &options,
-  const messaget &msg)
+  const optionst &options)
 {
   tuple_iface *tuple_api = nullptr;
   array_iface *array_api = nullptr;
   fp_convt *fp_api = nullptr;
-  smt_convt *ctx = create_solver_factory1(
-    solver_name, ns, options, &tuple_api, &array_api, &fp_api, msg);
+
+  solver_creator &factory = pick_solver(solver_name, options);
+  smt_convt *ctx = factory(options, ns, &tuple_api, &array_api, &fp_api);
 
   bool node_flat = options.get_bool_option("tuple-node-flattener");
   bool sym_flat = options.get_bool_option("tuple-sym-flattener");
@@ -175,13 +131,13 @@ smt_convt *create_solver_factory(
     ctx->set_tuple_iface(tuple_api);
   // Use the node flattener if specified
   else if(node_flat)
-    ctx->set_tuple_iface(new smt_tuple_node_flattener(ctx, ns, msg));
+    ctx->set_tuple_iface(new smt_tuple_node_flattener(ctx, ns));
   // Use the symbol flattener if specified
   else if(sym_flat)
-    ctx->set_tuple_iface(new smt_tuple_sym_flattener(ctx, ns, msg));
+    ctx->set_tuple_iface(new smt_tuple_sym_flattener(ctx, ns));
   // Default: node flattener
   else
-    ctx->set_tuple_iface(new smt_tuple_node_flattener(ctx, ns, msg));
+    ctx->set_tuple_iface(new smt_tuple_node_flattener(ctx, ns));
 
   // Pick an array flattener to use. Again, pick the solver native one by
   // default, or the one specified, or if none of the above then use the built
@@ -194,7 +150,7 @@ smt_convt *create_solver_factory(
     ctx->set_array_iface(new array_convt(ctx));
 
   if(fp_api == nullptr || fp_to_bv)
-    ctx->set_fp_conv(new fp_convt(ctx, msg));
+    ctx->set_fp_conv(new fp_convt(ctx));
   else
     ctx->set_fp_conv(fp_api);
 
diff --git a/src/solvers/solve.h b/src/solvers/solve.h
index 148e493d2..04e3e1de0 100644
--- a/src/solvers/solve.h
+++ b/src/solvers/solve.h
@@ -5,37 +5,18 @@
 #include <string>
 #include <util/config.h>
 #include <util/namespace.h>
-#include <util/message/message.h>
+#include <util/message.h>
 
 typedef smt_convt *(solver_creator)(
   const optionst &options,
   const namespacet &ns,
   tuple_iface **tuple_api,
   array_iface **array_api,
-  fp_convt **fp_api,
-  const messaget &msg);
+  fp_convt **fp_api);
 
-typedef smt_convt *(*solver_creator_ptr)(
-  const optionst &options,
-  const namespacet &ns,
-  tuple_iface **tuple_api,
-  array_iface **array_api,
-  fp_convt **fp_api,
-  const messaget &msg);
-
-struct esbmc_solver_config
-{
-  std::string name;
-  solver_creator_ptr create;
-};
-
-extern const struct esbmc_solver_config esbmc_solvers[];
-extern const unsigned int esbmc_num_solvers;
-
-smt_convt *create_solver_factory(
-  const std::string &solver_name,
+smt_convt *create_solver(
+  std::string solver_name,
   const namespacet &ns,
-  const optionst &options,
-  const messaget &msg);
+  const optionst &options);
 
 #endif
diff --git a/src/solvers/yices/CMakeLists.txt b/src/solvers/yices/CMakeLists.txt
index 1317ed820..61441ac8b 100644
--- a/src/solvers/yices/CMakeLists.txt
+++ b/src/solvers/yices/CMakeLists.txt
@@ -52,9 +52,9 @@ if(ENABLE_YICES)
     if(DEFINED GMP_DIR)
         find_library(LIBGMP_CUSTOM gmp NAMES libgmp.a HINTS ${GMP_DIR} PATH_SUFFIXES lib NO_DEFAULT_PATH)
         message(STATUS "Custom gmp found: ${LIBGMP_CUSTOM}")
-        target_link_libraries(solveryices message fmt::fmt "${Yices_LIB}" "${LIBGMP_CUSTOM}")
+        target_link_libraries(solveryices fmt::fmt "${Yices_LIB}" "${LIBGMP_CUSTOM}")
     else ()
-        target_link_libraries(solveryices message fmt::fmt "${Yices_LIB}")
+        target_link_libraries(solveryices fmt::fmt "${Yices_LIB}")
     endif ()
 
     target_link_libraries(solvers INTERFACE solveryices)
diff --git a/src/solvers/yices/yices_conv.cpp b/src/solvers/yices/yices_conv.cpp
index 5a39cd858..b73d6ece4 100644
--- a/src/solvers/yices/yices_conv.cpp
+++ b/src/solvers/yices/yices_conv.cpp
@@ -4,7 +4,7 @@
 #include <sstream>
 #include <yices_conv.h>
 #include <assert.h>
-#include <util/message/default_message.h>
+
 // From yices 2.3 (I think) various API calls have had new non-binary
 // operand versions added. The maintainers have chosen to break backwards
 // compatibility in the process by moving the old functions to new names, and
@@ -24,21 +24,17 @@ smt_convt *create_new_yices_solver(
   const namespacet &ns,
   tuple_iface **tuple_api,
   array_iface **array_api,
-  fp_convt **fp_api,
-  const messaget &msg)
+  fp_convt **fp_api)
 {
-  yices_convt *conv = new yices_convt(ns, options, msg);
+  yices_convt *conv = new yices_convt(ns, options);
   *array_api = static_cast<array_iface *>(conv);
   *fp_api = static_cast<fp_convt *>(conv);
   *tuple_api = static_cast<tuple_iface *>(conv);
   return conv;
 }
 
-yices_convt::yices_convt(
-  const namespacet &ns,
-  const optionst &options,
-  const messaget &msg)
-  : smt_convt(ns, options, msg), array_iface(false, false), fp_convt(this, msg)
+yices_convt::yices_convt(const namespacet &ns, const optionst &options)
+  : smt_convt(ns, options), array_iface(false, false), fp_convt(this)
 {
   yices_init();
 
@@ -68,12 +64,8 @@ void yices_convt::push_ctx()
 
   if(res != 0)
   {
-    {
-      auto f = msg.get_temp_file();
-      yices_print_error(f.file());
-      msg.insert_file_contents(VerbosityLevel::Error, f.file());
-    }
-    msg.error("Error pushing yices context");
+    yices_print_error(messaget::state.err);
+    log_error("Error pushing yices context");
     abort();
   }
 }
@@ -84,12 +76,8 @@ void yices_convt::pop_ctx()
 
   if(res != 0)
   {
-    {
-      auto f = msg.get_temp_file();
-      yices_print_error(f.file());
-      msg.insert_file_contents(VerbosityLevel::Error, f.file());
-    }
-    msg.error("Error poping yices context");
+    yices_print_error(messaget::state.err);
+    log_error("Error poping yices context");
     abort();
   }
 
@@ -670,7 +658,7 @@ smt_astt yices_convt::mk_select(smt_astt a, smt_astt b)
 
 smt_astt yices_convt::mk_isint(smt_astt)
 {
-  msg.error(
+  log_error(
     "Yices does not support an is-integer operation on reals, "
     "therefore certain casts and operations don't work, sorry");
   abort();
@@ -726,7 +714,7 @@ smt_astt yices_convt::mk_smt_symbol(const std::string &name, smt_sortt s)
 smt_astt yices_convt::mk_array_symbol(
   const std::string &name,
   smt_sortt s,
-  smt_sortt array_subtype [[gnu::unused]])
+  smt_sortt array_subtype [[maybe_unused]])
 {
   // For array symbols, store the symbol name in the ast to implement
   // assign semantics
@@ -798,7 +786,7 @@ bool yices_convt::get_bool(smt_astt a)
   const yices_smt_ast *ast = to_solver_smt_ast<yices_smt_ast>(a);
   if(yices_get_bool_value(yices_get_model(yices_ctx, 1), ast->a, &val))
   {
-    msg.error("Can't get boolean value from Yices");
+    log_error("Can't get boolean value from Yices");
     abort();
   }
 
@@ -951,7 +939,7 @@ smt_astt yices_convt::tuple_array_create(
   const type2tc &array_type,
   smt_astt *inputargs,
   bool const_array,
-  smt_sortt domain [[gnu::unused]])
+  smt_sortt domain [[maybe_unused]])
 {
   const array_type2t &arr_type = to_array_type(array_type);
   const constant_int2t &thesize = to_constant_int2t(arr_type.array_size);
@@ -1111,9 +1099,7 @@ expr2tc yices_convt::tuple_get(const expr2tc &expr)
 
 void yices_convt::print_model()
 {
-  auto f = msg.get_temp_file();
-  yices_print_model(f.file(), yices_get_model(yices_ctx, 1));
-  msg.insert_file_contents(VerbosityLevel::Status, f.file());
+  yices_print_model(messaget::state.out, yices_get_model(yices_ctx, 1));
 }
 
 smt_sortt yices_convt::mk_bool_sort()
@@ -1165,9 +1151,7 @@ smt_sortt yices_convt::mk_bvfp_rm_sort()
 
 void yices_smt_ast::dump() const
 {
-  default_message msg;
-  auto f = msg.get_temp_file();
-  yices_pp_term(f.file(), a, 80, 10, 0);
-  yices_pp_type(f.file(), to_solver_smt_sort<type_t>(sort)->s, 80, 10, 0);
-  msg.insert_file_contents(VerbosityLevel::Debug, f.file());
+  yices_pp_term(messaget::state.out, a, 80, 10, 0);
+  yices_pp_type(
+    messaget::state.out, to_solver_smt_sort<type_t>(sort)->s, 80, 10, 0);
 }
diff --git a/src/solvers/yices/yices_conv.h b/src/solvers/yices/yices_conv.h
index d82012ca8..3d445f962 100644
--- a/src/solvers/yices/yices_conv.h
+++ b/src/solvers/yices/yices_conv.h
@@ -7,18 +7,14 @@
 class yices_smt_ast : public solver_smt_ast<term_t>
 {
 public:
-  yices_smt_ast(
-    smt_convt *ctx,
-    term_t _t,
-    const smt_sort *_s,
-    const messaget &msg)
-    : solver_smt_ast<term_t>(ctx, _t, _s, msg)
+  yices_smt_ast(smt_convt *ctx, term_t _t, const smt_sort *_s)
+    : solver_smt_ast<term_t>(ctx, _t, _s)
   {
     // Detect term errors
     if(a == NULL_TERM)
     {
       yices_print_error(stderr);
-      msg.error("Error creating yices term");
+      log_error("Error creating yices term");
       abort();
     }
   }
@@ -47,10 +43,7 @@ class yices_convt : public smt_convt,
                     public fp_convt
 {
 public:
-  yices_convt(
-    const namespacet &ns,
-    const optionst &options,
-    const messaget &msg);
+  yices_convt(const namespacet &ns, const optionst &options);
   ~yices_convt() override;
 
   resultt dec_solve() override;
diff --git a/src/solvers/z3/CMakeLists.txt b/src/solvers/z3/CMakeLists.txt
index 3644d11aa..42ee68544 100644
--- a/src/solvers/z3/CMakeLists.txt
+++ b/src/solvers/z3/CMakeLists.txt
@@ -33,12 +33,12 @@ if(ENABLE_Z3)
 
     message(STATUS "Using Z3 at: ${Z3_LIB}")
     string(REGEX MATCH "(Z3 )?([0-9]+.[0-9]+.[0-9]+.[0-9]+)"  REGEX_OUTPUT ${Z3_VERSION})
-    set(Z3_VERSION "${CMAKE_MATCH_2}")  
+    set(Z3_VERSION "${CMAKE_MATCH_2}")
     message(STATUS "Z3 version: ${Z3_VERSION}")
     if(Z3_VERSION VERSION_LESS Z3_MIN_VERSION)
         message(FATAL_ERROR "Expected version ${Z3_MIN_VERSION} or greater")
     endif()
-    
+
 
     add_library(solverz3 z3_conv.cpp)
     target_include_directories(solverz3
@@ -56,11 +56,13 @@ if(ENABLE_Z3)
 
     # Install dll for Windows
     if(WIN32)
-        find_file(Z3_DLL libz3.dll HINTS ${Z3_DIR} $ENV{HOME}/z3 PATH_SUFFIXES lib bin)
+      find_file(Z3_DLL libz3.dll HINTS ${Z3_DIR} $ENV{HOME}/z3 PATH_SUFFIXES lib bin)
+      if(NOT Z3_DLL STREQUAL "Z3_DLL-NOTFOUND")
         message(STATUS "Windows will install ${Z3_DLL}")
         install(FILES ${Z3_DLL} DESTINATION bin)
+      endif()
     endif()
-    
+
     set(ESBMC_ENABLE_z3 1 PARENT_SCOPE)
     set(ESBMC_AVAILABLE_SOLVERS "${ESBMC_AVAILABLE_SOLVERS} z3" PARENT_SCOPE)
 endif()
diff --git a/src/solvers/z3/z3_conv.cpp b/src/solvers/z3/z3_conv.cpp
index 9af222da2..cf83ca938 100644
--- a/src/solvers/z3/z3_conv.cpp
+++ b/src/solvers/z3/z3_conv.cpp
@@ -1,10 +1,3 @@
-/*******************************************************************
-   Module:
-
-   Author: Lucas Cordeiro, lcc08r@ecs.soton.ac.uk
-
- \*******************************************************************/
-
 #include <cassert>
 #include <z3_conv.h>
 
@@ -12,12 +5,7 @@
 
 static void error_handler(Z3_context c, Z3_error_code e)
 {
-  std::ostringstream oss;
-  oss << "Z3 error " << e << " encountered"
-      << "\n";
-  oss << Z3_get_error_msg(c, e);
-  default_message msg;
-  msg.error(oss.str());
+  log_error("Z3 error {} encountered", Z3_get_error_msg(c, e));
   abort();
 }
 
@@ -26,23 +14,19 @@ smt_convt *create_new_z3_solver(
   const namespacet &ns,
   tuple_iface **tuple_api,
   array_iface **array_api,
-  fp_convt **fp_api,
-  const messaget &msg)
+  fp_convt **fp_api)
 {
-  z3_convt *conv = new z3_convt(ns, options, msg);
+  z3_convt *conv = new z3_convt(ns, options);
   *tuple_api = static_cast<tuple_iface *>(conv);
   *array_api = static_cast<array_iface *>(conv);
   *fp_api = static_cast<fp_convt *>(conv);
   return conv;
 }
 
-z3_convt::z3_convt(
-  const namespacet &_ns,
-  const optionst &_options,
-  const messaget &msg)
-  : smt_convt(_ns, _options, msg),
+z3_convt::z3_convt(const namespacet &_ns, const optionst &_options)
+  : smt_convt(_ns, _options),
     array_iface(true, true),
-    fp_convt(this, msg),
+    fp_convt(this),
     z3_ctx(),
     solver((z3::tactic(z3_ctx, "simplify") & z3::tactic(z3_ctx, "solve-eqs") &
             z3::tactic(z3_ctx, "simplify") & z3::tactic(z3_ctx, "smt"))
@@ -58,6 +42,12 @@ z3_convt::z3_convt(
   Z3_set_error_handler(z3_ctx, error_handler);
 }
 
+z3_convt::~z3_convt()
+{
+  // delete ASTs before destructing z3_ctx: this speeds up the latter, see #752
+  delete_all_asts();
+}
+
 void z3_convt::push_ctx()
 {
   smt_convt::push_ctx();
@@ -97,14 +87,14 @@ z3_convt::mk_tuple_update(const z3::expr &t, unsigned i, const z3::expr &newval)
   z3::sort ty = t.get_sort();
   if(!ty.is_datatype())
   {
-    msg.error("argument must be a tuple");
+    log_error("argument must be a tuple");
     abort();
   }
 
   std::size_t num_fields = Z3_get_tuple_sort_num_fields(z3_ctx, ty);
   if(i >= num_fields)
   {
-    msg.error("invalid tuple update, index is too big");
+    log_error("invalid tuple update, index is too big");
     abort();
   }
 
@@ -133,14 +123,14 @@ z3::expr z3_convt::mk_tuple_select(const z3::expr &t, unsigned i)
   z3::sort ty = t.get_sort();
   if(!ty.is_datatype())
   {
-    msg.error("Z3 conversion: argument must be a tuple");
+    log_error("Z3 conversion: argument must be a tuple");
     abort();
   }
 
   size_t num_fields = Z3_get_tuple_sort_num_fields(z3_ctx, ty);
   if(i >= num_fields)
   {
-    msg.error("Z3 conversion: invalid tuple select, index is too large");
+    log_error("Z3 conversion: invalid tuple select, index is too large");
     abort();
   }
 
@@ -896,7 +886,7 @@ smt_astt z3_convt::mk_smt_bool(bool val)
 smt_astt z3_convt::mk_array_symbol(
   const std::string &name,
   const smt_sort *s,
-  smt_sortt array_subtype [[gnu::unused]])
+  smt_sortt array_subtype [[maybe_unused]])
 {
   return mk_smt_symbol(name, s);
 }
@@ -1190,7 +1180,7 @@ bool z3_convt::get_bool(smt_astt a)
     res = false;
     break;
   default:
-    msg.error("Can't get boolean value from Z3");
+    log_error("Can't get boolean value from Z3");
     abort();
   }
 
@@ -1207,7 +1197,7 @@ BigInt z3_convt::get_bv(smt_astt a, bool is_signed)
 
   // Not a numeral? Let's not try to convert it
   std::string bin;
-  bool is_numeral [[gnu::unused]] = e.as_binary(bin);
+  bool is_numeral [[maybe_unused]] = e.as_binary(bin);
   assert(is_numeral);
   /* 'bin' contains the ascii representation of the bit-vector, msb-first,
    * no leading zeroes; zero-extend if possible */
@@ -1270,12 +1260,10 @@ z3_convt::get_array_elem(smt_astt array, uint64_t index, const type2tc &subtype)
 
 void z3_smt_ast::dump() const
 {
-  default_message msg;
-  std::ostringstream oss;
-  oss << Z3_ast_to_string(a.ctx(), a) << "\n";
-  oss << "sort is " << Z3_sort_to_string(a.ctx(), Z3_get_sort(a.ctx(), a))
-      << "\n";
-  msg.debug(oss.str());
+  log_debug(
+    "{}\nsort is {}",
+    Z3_ast_to_string(a.ctx(), a),
+    Z3_sort_to_string(a.ctx(), Z3_get_sort(a.ctx(), a)));
 }
 
 void z3_convt::dump_smt()
@@ -1290,10 +1278,10 @@ void z3_convt::dump_smt()
   else
   {
     // print to screen
-    default_message msg;
+
     std::ostringstream oss;
     print_smt_formulae(oss);
-    msg.debug(oss.str());
+    log_debug("{}", oss.str());
   }
 }
 
@@ -1371,7 +1359,7 @@ smt_astt z3_convt::mk_smt_fpbv_neg(smt_astt op)
 
 void z3_convt::print_model()
 {
-  msg.status(Z3_model_to_string(z3_ctx, solver.get_model()));
+  log_status("{}", Z3_model_to_string(z3_ctx, solver.get_model()));
 }
 
 smt_sortt z3_convt::mk_fpbv_sort(const unsigned ew, const unsigned sw)
diff --git a/src/solvers/z3/z3_conv.h b/src/solvers/z3/z3_conv.h
index 416f05405..3264cc573 100644
--- a/src/solvers/z3/z3_conv.h
+++ b/src/solvers/z3/z3_conv.h
@@ -1,18 +1,9 @@
-/*******************************************************************\
-
-Module:
-
-Author: Lucas Cordeiro, lcc08r@ecs.soton.ac.uk
-
-\*******************************************************************/
-
 #ifndef _ESBMC_SOLVERS_Z3_Z3_CONV_H
 #define _ESBMC_SOLVERS_Z3_Z3_CONV_H
 
 #include <solvers/smt/smt_conv.h>
 #include <z3++.h>
 #include <fstream>
-#include <util/message/default_message.h>
 
 class z3_smt_ast : public solver_smt_ast<z3::expr>
 {
@@ -29,14 +20,16 @@ public:
   void dump() const override;
 };
 
+/* Be sure to not make smt_convt a *virtual* base class: our dtor ~z3_convt()
+ * erases all smt_asts early. */
 class z3_convt : public smt_convt,
                  public tuple_iface,
                  public array_iface,
                  public fp_convt
 {
 public:
-  z3_convt(const namespacet &ns, const optionst &options, const messaget &msg);
-  ~z3_convt() override = default;
+  z3_convt(const namespacet &ns, const optionst &options);
+  ~z3_convt() override;
 
 public:
   void push_ctx() override;
diff --git a/src/util/CMakeLists.txt b/src/util/CMakeLists.txt
index bb046c56f..53ef45c96 100644
--- a/src/util/CMakeLists.txt
+++ b/src/util/CMakeLists.txt
@@ -12,7 +12,7 @@ target_link_libraries(filesystem PUBLIC ${Boost_LIBRARIES})
 add_library(crypto_hash crypto_hash.cpp)
 target_include_directories(crypto_hash PUBLIC ${Boost_INCLUDE_DIRS})
 target_link_libraries(crypto_hash PUBLIC ${Boost_LIBRARIES})
-  
+
 add_library(util_esbmc xml_irep.cpp xml.cpp
         arith_tools.cpp base_type.cpp cmdline.cpp config.cpp context.cpp
         expr_util.cpp i2string.cpp location.cpp
@@ -28,7 +28,7 @@ add_library(util_esbmc xml_irep.cpp xml.cpp
         signal_catcher.cpp migrate.cpp show_symbol_table.cpp
         type_byte_size.cpp goto_expr_factory.cpp
         string_constant.cpp c_types.cpp ieee_float.cpp c_qualifiers.cpp
-        c_sizeof.cpp c_link.cpp c_typecast.cpp fix_symbol.cpp
+        c_sizeof.cpp c_link.cpp c_typecast.cpp fix_symbol.cpp destructor.cpp
         )
 # Boost is needed by anything that touches irep2
 target_include_directories(util_esbmc
@@ -37,7 +37,6 @@ target_include_directories(util_esbmc
         PRIVATE ${Boost_INCLUDE_DIRS}
         )
 
-target_link_libraries(util_esbmc irep2 default_message fmt::fmt ${Boost_LIBRARIES})
+target_link_libraries(util_esbmc PUBLIC irep2 fmt::fmt ${Boost_LIBRARIES})
 
-add_subdirectory(message)
 target_link_libraries(algorithms gotoprograms)
diff --git a/src/util/algorithms.cpp b/src/util/algorithms.cpp
index c9c069122..bd6a0caf9 100644
--- a/src/util/algorithms.cpp
+++ b/src/util/algorithms.cpp
@@ -1,8 +1,8 @@
 #include <util/algorithms.h>
-#include <util/message/message.h>
+#include <util/message.h>
 #include <goto-programs/goto_loops.h>
 #include <goto-programs/remove_skip.h>
-bool goto_functions_algorithm::run()
+bool goto_functions_algorithm::run(goto_functionst &goto_functions)
 {
   Forall_goto_functions(it, goto_functions)
   {
@@ -10,8 +10,7 @@ bool goto_functions_algorithm::run()
     runOnFunction(*it);
     if(it->second.body_available)
     {
-      const messaget msg;
-      goto_loopst goto_loops(it->first, goto_functions, it->second, msg);
+      goto_loopst goto_loops(it->first, goto_functions, it->second);
       auto function_loops = goto_loops.get_loops();
       number_of_loops += function_loops.size();
       if(function_loops.size())
@@ -39,4 +38,4 @@ bool goto_functions_algorithm::runOnFunction(
   std::pair<const dstring, goto_functiont> &)
 {
   return true;
-}
\ No newline at end of file
+}
diff --git a/src/util/algorithms.h b/src/util/algorithms.h
index 625fcd664..a72dbe39a 100644
--- a/src/util/algorithms.h
+++ b/src/util/algorithms.h
@@ -1,27 +1,14 @@
-/*******************************************************************\
- Module: Algorithm Interface
- Author: Rafael S Menezes
- Date: May 2021
-
- Description: The algorithm interface is to be used for
-              every kind of logic that uses a generic datastructure
-              to be reasoned: containers, CFG, goto-programs, loops.
-
-              The idea is that we don't need to look over a million
-              of lines in the flow of esbmc when we only want to do 
-              a small analysis.
-\*******************************************************************/
-
 #ifndef ESBMC_ALGORITHM_H
 #define ESBMC_ALGORITHM_H
 
 #include <goto-programs/goto_functions.h>
 #include <goto-programs/loopst.h>
 #include <goto-programs/goto_loops.h>
-#include <util/message/message.h>
+#include <util/message.h>
 /**
  * @brief Base interface to run an algorithm in esbmc
  */
+template <typename T>
 class algorithm
 {
 public:
@@ -30,16 +17,16 @@ public:
   }
 
   /**
-   * @brief Executes the algorithm
-   * 
+   * @brief Executes the algorithm over a T object
+   *
    * @return success of the algorithm
    */
-  virtual bool run() = 0;
+  virtual bool run(T &) = 0;
 
   /**
    * @brief Says wether the algorithm is a plain analysis
    * or if it also changes the structure
-   * 
+   *
    */
   bool has_sideeffect()
   {
@@ -54,13 +41,10 @@ protected:
 /**
  * @brief Base interface for goto-functions algorithms
  */
-class goto_functions_algorithm : public algorithm
+class goto_functions_algorithm : public algorithm<goto_functionst>
 {
 public:
-  explicit goto_functions_algorithm(
-    goto_functionst &goto_functions,
-    bool sideffect)
-    : algorithm(sideffect), goto_functions(goto_functions)
+  explicit goto_functions_algorithm(bool sideffect) : algorithm(sideffect)
   {
   }
 
@@ -73,17 +57,15 @@ public:
     return number_of_loops;
   }
 
-  bool run() override;
+  bool run(goto_functionst &) override;
 
 protected:
   virtual bool runOnFunction(std::pair<const dstring, goto_functiont> &F);
   virtual bool runOnLoop(loopst &loop, goto_programt &goto_program);
-  goto_functionst &goto_functions;
-  ;
 
 private:
   unsigned number_of_functions = 0;
   unsigned number_of_loops = 0;
 };
 
-#endif //ESBMC_ALGORITHM_H
\ No newline at end of file
+#endif //ESBMC_ALGORITHM_H
diff --git a/src/util/arith_tools.cpp b/src/util/arith_tools.cpp
index a93a9d891..9837e6849 100644
--- a/src/util/arith_tools.cpp
+++ b/src/util/arith_tools.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <util/arith_tools.h>
 #include <util/bitvector.h>
diff --git a/src/util/arith_tools.h b/src/util/arith_tools.h
index beec401c5..35b0c7a9f 100644
--- a/src/util/arith_tools.h
+++ b/src/util/arith_tools.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_ARITH_TOOLS_H
 #define CPROVER_ARITH_TOOLS_H
 
diff --git a/src/util/array_name.cpp b/src/util/array_name.cpp
index bdac83613..debaba63b 100644
--- a/src/util/array_name.cpp
+++ b/src/util/array_name.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Misc Utilities
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <util/array_name.h>
 #include <irep2/irep2_expr.h>
 
@@ -16,8 +8,9 @@ std::string array_name(const namespacet &ns, const expr2tc &expr)
 
   if(is_symbol2t(expr))
   {
-    const symbolt &symbol = ns.lookup(to_symbol2t(expr).thename);
-    return "array `" + id2string(symbol.name) + "'";
+    const symbolt *symbol = ns.lookup(to_symbol2t(expr).thename);
+    assert(symbol);
+    return "array `" + id2string(symbol->name) + "'";
   }
 
   if(is_constant_string2t(expr))
diff --git a/src/util/array_name.h b/src/util/array_name.h
index 1e93805c2..7425f90f7 100644
--- a/src/util/array_name.h
+++ b/src/util/array_name.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Misc Utilities
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <util/expr.h>
 #include <irep2/irep2.h>
 #include <util/namespace.h>
diff --git a/src/util/base_type.cpp b/src/util/base_type.cpp
index 71755e015..b2e55ce09 100644
--- a/src/util/base_type.cpp
+++ b/src/util/base_type.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Base Type Computation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <util/base_type.h>
 #include <irep2/irep2_utils.h>
 #include <util/std_types.h>
@@ -15,11 +7,9 @@ void base_type(type2tc &type, const namespacet &ns)
 {
   if(is_symbol_type(type))
   {
-    const symbolt *symbol;
+    const symbolt *symbol = ns.lookup(to_symbol_type(type).symbol_name);
 
-    if(
-      !ns.lookup(to_symbol_type(type).symbol_name, symbol) && symbol->is_type &&
-      !symbol->type.is_nil())
+    if(symbol && symbol->is_type && !symbol->type.is_nil())
     {
       type = migrate_type(symbol->type);
       base_type(type, ns); // recursive call
@@ -46,11 +36,9 @@ void base_type(typet &type, const namespacet &ns)
 {
   if(type.id() == "symbol")
   {
-    const symbolt *symbol;
+    const symbolt *symbol = ns.lookup(type.identifier());
 
-    if(
-      !ns.lookup(type.identifier(), symbol) && symbol->is_type &&
-      !symbol->type.is_nil())
+    if(symbol && symbol->is_type && !symbol->type.is_nil())
     {
       type = symbol->type;
       base_type(type, ns); // recursive call
@@ -116,23 +104,25 @@ bool base_type_eqt::base_type_eq_rec(const type2tc &type1, const type2tc &type2)
 
   if(is_symbol_type(type1))
   {
-    const symbolt &symbol = ns.lookup(to_symbol_type(type1).symbol_name);
+    const symbolt *symbol = ns.lookup(to_symbol_type(type1).symbol_name);
+    assert(symbol);
 
-    if(!symbol.is_type)
-      throw "symbol " + id2string(symbol.name) + " is not a type";
+    if(!symbol->is_type)
+      throw "symbol " + id2string(symbol->name) + " is not a type";
 
-    type2tc tmp = migrate_type(symbol.type);
+    type2tc tmp = migrate_type(symbol->type);
     return base_type_eq_rec(tmp, type2);
   }
 
   if(is_symbol_type(type2))
   {
-    const symbolt &symbol = ns.lookup(to_symbol_type(type2).symbol_name);
+    const symbolt *symbol = ns.lookup(to_symbol_type(type2).symbol_name);
+    assert(symbol);
 
-    if(!symbol.is_type)
-      throw "symbol " + id2string(symbol.name) + " is not a type";
+    if(!symbol->is_type)
+      throw "symbol " + id2string(symbol->name) + " is not a type";
 
-    type2tc tmp = migrate_type(symbol.type);
+    type2tc tmp = migrate_type(symbol->type);
     return base_type_eq_rec(type1, tmp);
   }
 
@@ -252,22 +242,24 @@ bool base_type_eqt::base_type_eq_rec(const typet &type1, const typet &type2)
 
   if(type1.id() == "symbol")
   {
-    const symbolt &symbol = ns.lookup(type1.identifier());
+    const symbolt *symbol = ns.lookup(type1.identifier());
+    assert(symbol);
 
-    if(!symbol.is_type)
-      throw "symbol " + id2string(symbol.name) + " is not a type";
+    if(!symbol->is_type)
+      throw "symbol " + id2string(symbol->name) + " is not a type";
 
-    return base_type_eq_rec(symbol.type, type2);
+    return base_type_eq_rec(symbol->type, type2);
   }
 
   if(type2.id() == "symbol")
   {
-    const symbolt &symbol = ns.lookup(type2.identifier());
+    const symbolt *symbol = ns.lookup(type2.identifier());
+    assert(symbol);
 
-    if(!symbol.is_type)
-      throw "symbol " + id2string(symbol.name) + " is not a type";
+    if(!symbol->is_type)
+      throw "symbol " + id2string(symbol->name) + " is not a type";
 
-    return base_type_eq_rec(type1, symbol.type);
+    return base_type_eq_rec(type1, symbol->type);
   }
 
   if(type1.id() != type2.id())
@@ -453,8 +445,8 @@ static bool is_subclass_of_rec(
   const std::string &subname,
   const namespacet &ns)
 {
-  const symbolt *symbol = nullptr;
-  if(!ns.lookup(supername, symbol))
+  const symbolt *symbol = ns.lookup(supername);
+  if(symbol)
   {
     // look at the list of bases; see if the subclass name is a base of this
     // object. Currently, old-irep.
diff --git a/src/util/base_type.h b/src/util/base_type.h
index 0ead4800e..6df5e44fd 100644
--- a/src/util/base_type.h
+++ b/src/util/base_type.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Base Type Computation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_BASE_TYPE_H
 #define CPROVER_BASE_TYPE_H
 
diff --git a/src/util/bitvector.cpp b/src/util/bitvector.cpp
index aa7c98833..2d6476d05 100644
--- a/src/util/bitvector.cpp
+++ b/src/util/bitvector.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cstdlib>
 #include <util/bitvector.h>
 
diff --git a/src/util/c_link.cpp b/src/util/c_link.cpp
index 18d98fda6..90fa904c5 100644
--- a/src/util/c_link.cpp
+++ b/src/util/c_link.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: ANSI-C Linking
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <clang-c-frontend/expr2c.h>
 #include <unordered_set>
 #include <util/base_type.h>
@@ -13,21 +5,41 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <util/fix_symbol.h>
 #include <util/i2string.h>
 #include <util/location.h>
+#include <util/message/format.h>
 #include <util/namespace.h>
 #include <util/typecheck.h>
 
 namespace
 {
+class merged_namespacet : public namespacet
+{
+  namespacet second;
+
+public:
+  merged_namespacet(const contextt &primary, const contextt &secondary)
+    : namespacet(primary), second(secondary)
+  {
+  }
+
+  unsigned get_max(const std::string &prefix) const override
+  {
+    return std::max(namespacet::get_max(prefix), second.get_max(prefix));
+  }
+
+  const symbolt *lookup(const irep_idt &name) const override
+  {
+    const symbolt *s = namespacet::lookup(name);
+    if(!s)
+      s = second.lookup(name);
+    return s;
+  }
+};
+
 class c_linkt : public typecheckt
 {
 public:
-  c_linkt(
-    contextt &_context,
-    contextt &_new_context,
-    std::string _module,
-    const messaget &_message_handler)
-    : typecheckt(_message_handler),
-      context(_context),
+  c_linkt(contextt &_context, contextt &_new_context, std::string _module)
+    : context(_context),
       new_context(_new_context),
       module(std::move(_module)),
       ns(_context, _new_context),
@@ -48,13 +60,13 @@ protected:
   void move(symbolt &new_symbol);
 
   // overload to use language specific syntax
-  std::string to_string(const exprt &expr) override;
-  std::string to_string(const typet &type) override;
+  std::string to_string(const exprt &expr);
+  std::string to_string(const typet &type);
 
   contextt &context;
   contextt &new_context;
   std::string module;
-  namespacet ns;
+  merged_namespacet ns;
 
   typedef std::unordered_set<irep_idt, irep_id_hash> known_modulest;
   known_modulest known_modules;
@@ -78,8 +90,8 @@ void c_linkt::duplicate(symbolt &in_context, symbolt &new_symbol)
 {
   if(new_symbol.is_type != in_context.is_type)
   {
-    str << "class conflict on symbol `" << in_context.name << "'";
-    throw 0;
+    log_error("class conflict on symbol `{}'", in_context.name);
+    abort();
   }
 
   if(new_symbol.is_type)
@@ -144,15 +156,18 @@ void c_linkt::duplicate_symbol(symbolt &in_context, symbolt &new_symbol)
 
   if(is_code_in_context != is_code_new_symbol)
   {
-    err_location(new_symbol.location);
-    str << "error: conflicting definition for symbol \"" << in_context.name
-        << "\""
-        << "\n";
-    str << "old definition: " << to_string(in_context.type) << "\n";
-    str << "Module: " << in_context.module << "\n";
-    str << "new definition: " << to_string(new_symbol.type) << "\n";
-    str << "Module: " << new_symbol.module;
-    throw 0;
+    log_error(
+      "error: conflicting definition for symbol \"{}\"\n"
+      "old definition: {}\n"
+      "Module: {}\n"
+      "new definition: {}\n"
+      "Module: {}",
+      in_context.name,
+      to_string(in_context.type),
+      in_context.module,
+      to_string(new_symbol.type),
+      new_symbol.module);
+    abort();
   }
 
   if(is_code_in_context)
@@ -178,20 +193,22 @@ void c_linkt::duplicate_symbol(symbolt &in_context, symbolt &new_symbol)
       else if(base_type_eq(in_context.type, new_symbol.type, ns))
       {
         // keep the one in in_context -- libraries come last!
-        str << "warning: function `" << in_context.name << "' in module `"
-            << new_symbol.module << "' is shadowed by a definition in module `"
-            << in_context.module << "'";
-        warning();
+        log_warning(
+          "warning: function `{}' in module `{}' "
+          "is shadowed by a definition in module `{}'",
+          in_context.name,
+          new_symbol.module,
+          in_context.module);
       }
       else
       {
-        err_location(new_symbol.value);
-        str << "error: duplicate definition of function `" << in_context.name
-            << "'"
-            << "\n";
-        str << "In module `" << in_context.module << "' and module `"
-            << new_symbol.module << "'";
-        throw 0;
+        log_error(
+          "error: duplicate definition of function `{}'\n"
+          "In module `{}' and module `{}'\n"
+          "Location: {}",
+          in_context.name,
+          in_context.module,
+          new_symbol.value.location());
       }
     }
   }
@@ -244,15 +261,19 @@ void c_linkt::duplicate_symbol(symbolt &in_context, symbolt &new_symbol)
 #endif
       else
       {
-        err_location(new_symbol.location);
-        str << "error: conflicting definition for variable `" << in_context.name
-            << "'"
-            << "\n";
-        str << "old definition: " << to_string(in_context.type) << "\n";
-        str << "Module: " << in_context.module << "\n";
-        str << "new definition: " << to_string(new_symbol.type) << "\n";
-        str << "Module: " << new_symbol.module;
-        throw 0;
+        log_error(
+          "error: conflicting definition for variable `{}'\n"
+          "old definition: {}\n"
+          "Module: {}\n"
+          "new definition: {}\n"
+          "Module: {}\n"
+          "Location: {}",
+          in_context.name,
+          to_string(in_context.type),
+          in_context.module,
+          to_string(new_symbol.type),
+          new_symbol.module,
+          new_symbol.location);
       }
     }
 
@@ -266,15 +287,18 @@ void c_linkt::duplicate_symbol(symbolt &in_context, symbolt &new_symbol)
       }
       else if(!base_type_eq(in_context.value, new_symbol.value, ns))
       {
-        err_location(new_symbol.value);
-        str << "error: conflicting initializers for variable `"
-            << in_context.name << "'"
-            << "\n";
-        str << "old value: " << to_string(in_context.value) << "\n";
-        str << "Module: " << in_context.module << "\n";
-        str << "new value: " << to_string(new_symbol.value) << "\n";
-        str << "Module: " << new_symbol.module;
-        throw 0;
+        log_error(
+          "error: conflicting initializers for variable `{}'\n"
+          "old value: {}\n"
+          "Module: {}\n"
+          "new value: {}\n"
+          "Module: {}",
+          in_context.name,
+          to_string(in_context.value),
+          in_context.module,
+          to_string(new_symbol.value),
+          new_symbol.module);
+        abort();
       }
     }
   }
@@ -328,12 +352,8 @@ void c_linkt::move(symbolt &new_symbol)
 }
 } /* end anonymous namespace */
 
-bool c_link(
-  contextt &context,
-  contextt &new_context,
-  const messaget &message_handler,
-  const std::string &module)
+bool c_link(contextt &context, contextt &new_context, const std::string &module)
 {
-  c_linkt c_link(context, new_context, module, message_handler);
+  c_linkt c_link(context, new_context, module);
   return c_link.typecheck_main();
 }
diff --git a/src/util/c_link.h b/src/util/c_link.h
index 3876882da..4c4079141 100644
--- a/src/util/c_link.h
+++ b/src/util/c_link.h
@@ -1,21 +1,12 @@
-/*******************************************************************\
-
-Module: ANSI-C Linking
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_C_LINK_H
 #define CPROVER_C_LINK_H
 
 #include <util/context.h>
-#include <util/message/message.h>
+#include <util/message.h>
 
 bool c_link(
   contextt &context,
   contextt &new_context,
-  const messaget &message_handler,
   const std::string &module);
 
 #endif
diff --git a/src/util/c_misc.cpp b/src/util/c_misc.cpp
index 41d831447..5ae5db51a 100644
--- a/src/util/c_misc.cpp
+++ b/src/util/c_misc.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: ANSI-C Misc Utilities
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cstdio>
 #include <util/c_misc.h>
 
diff --git a/src/util/c_misc.h b/src/util/c_misc.h
index 22eff3c91..b7e3667df 100644
--- a/src/util/c_misc.h
+++ b/src/util/c_misc.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: ANSI-C Misc Utilities
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_C_MISC_H
 #define CPROVER_C_MISC_H
 
diff --git a/src/util/c_qualifiers.cpp b/src/util/c_qualifiers.cpp
index 2f05fa736..4144ab9a0 100644
--- a/src/util/c_qualifiers.cpp
+++ b/src/util/c_qualifiers.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <util/c_qualifiers.h>
 
 std::string c_qualifierst::as_string() const
diff --git a/src/util/c_qualifiers.h b/src/util/c_qualifiers.h
index 8607e0d01..086be0831 100644
--- a/src/util/c_qualifiers.h
+++ b/src/util/c_qualifiers.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_ANSI_C_C_QUALIFIERS_H
 #define CPROVER_ANSI_C_C_QUALIFIERS_H
 
diff --git a/src/util/c_sizeof.cpp b/src/util/c_sizeof.cpp
index b00b414db..8444970b3 100644
--- a/src/util/c_sizeof.cpp
+++ b/src/util/c_sizeof.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Conversion of sizeof Expressions
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <util/arith_tools.h>
 #include <util/c_sizeof.h>
 #include <util/c_types.h>
diff --git a/src/util/c_sizeof.h b/src/util/c_sizeof.h
index 2c2ce1a50..8f5829ca9 100644
--- a/src/util/c_sizeof.h
+++ b/src/util/c_sizeof.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <util/expr.h>
 #include <irep2/irep2.h>
 #include <util/namespace.h>
diff --git a/src/util/c_typecast.cpp b/src/util/c_typecast.cpp
index 55188f291..6ee43cd07 100644
--- a/src/util/c_typecast.cpp
+++ b/src/util/c_typecast.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <util/base_type.h>
 #include <util/c_qualifiers.h>
@@ -361,9 +353,7 @@ c_typecastt::c_typet c_typecastt::get_c_type(const type2tc &type)
     signedbv_type2tc signed_type = type;
     unsigned width = signed_type->width;
 
-    if(width == 128)
-      return INT128;
-    else if(width <= config.ansi_c.char_width)
+    if(width <= config.ansi_c.char_width)
       return CHAR;
     else if(width <= config.ansi_c.int_width)
       return INT;
@@ -379,9 +369,7 @@ c_typecastt::c_typet c_typecastt::get_c_type(const type2tc &type)
     unsignedbv_type2tc unsigned_type = type;
     unsigned width = unsigned_type->width;
 
-    if(width == 128)
-      return UINT128;
-    else if(width <= config.ansi_c.char_width)
+    if(width <= config.ansi_c.char_width)
       return UCHAR;
     else if(width <= config.ansi_c.int_width)
       return UINT;
diff --git a/src/util/c_typecast.h b/src/util/c_typecast.h
index 92f7e7376..d075ab294 100644
--- a/src/util/c_typecast.h
+++ b/src/util/c_typecast.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_C_TYPECAST_H
 #define CPROVER_C_TYPECAST_H
 
diff --git a/src/util/c_types.cpp b/src/util/c_types.cpp
index d7fa43342..5fbf127b0 100644
--- a/src/util/c_types.cpp
+++ b/src/util/c_types.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <util/c_types.h>
 #include <util/config.h>
 #include <util/std_types.h>
diff --git a/src/util/c_types.h b/src/util/c_types.h
index 7722c99a3..6318ec46a 100644
--- a/src/util/c_types.h
+++ b/src/util/c_types.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_C_TYPES_H
 #define CPROVER_C_TYPES_H
 
diff --git a/src/util/cmdline.cpp b/src/util/cmdline.cpp
index 5ce63525c..90964a9a5 100644
--- a/src/util/cmdline.cpp
+++ b/src/util/cmdline.cpp
@@ -1,22 +1,14 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <cstdlib>
+#include <sstream>
 
 #include <util/cmdline.h>
-#include <sstream>
-#include <util/message/format.h>
+#include <util/message.h>
 
 /* Parses 's' according to a simple interpretation of shell rules, taking only
  * whitespace and the characters ', " and \ into account. */
 static std::vector<std::string>
-simple_shell_unescape(const char *s, const messaget &msg, const char *var)
+simple_shell_unescape(const char *s, const char *var)
 {
   static const char WHITE[] = " \t\r\n\f\v";
 
@@ -96,7 +88,7 @@ simple_shell_unescape(const char *s, const messaget &msg, const char *var)
         }
         break;
       case ESC:
-        msg.error("Arrived at an unreachable place");
+        log_error("Arrived at an unreachable place");
         abort();
       }
       arg.push_back(*s++);
@@ -104,10 +96,10 @@ simple_shell_unescape(const char *s, const messaget &msg, const char *var)
   done:
     if(mode)
     {
-      msg.warning(fmt::format(
+      log_warning(
         "cannot parse environment variable {}: unfinished {}, ignoring...",
         var,
-        mode));
+        mode);
       return {};
     }
     split.emplace_back(std::move(arg));
@@ -115,8 +107,6 @@ simple_shell_unescape(const char *s, const messaget &msg, const char *var)
   return split;
 }
 
-std::string verification_file;
-
 cmdlinet::~cmdlinet()
 {
   clear();
@@ -207,7 +197,7 @@ bool cmdlinet::parse(
   {
     boost::program_options::store(
       boost::program_options::command_line_parser(
-        simple_shell_unescape(getenv("ESBMC_OPTS"), msg, "ESBMC_OPTS"))
+        simple_shell_unescape(getenv("ESBMC_OPTS"), "ESBMC_OPTS"))
         .options(all_cmdline_options)
         .run(),
       vm);
@@ -220,15 +210,13 @@ bool cmdlinet::parse(
   }
   catch(std::exception &e)
   {
-    msg.error(fmt::format("ESBMC error: {}", e.what()));
+    log_error("ESBMC error: {}", e.what());
     return true;
   }
 
   if(vm.count("input-file"))
-  {
     args = vm["input-file"].as<std::vector<std::string>>();
-    verification_file = args.back();
-  }
+
   for(auto &it : vm)
   {
     std::list<std::string> res;
diff --git a/src/util/cmdline.h b/src/util/cmdline.h
index a9d6fc574..7aad5d549 100644
--- a/src/util/cmdline.h
+++ b/src/util/cmdline.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_CMDLINE_H
 #define CPROVER_CMDLINE_H
 
@@ -14,7 +6,6 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <vector>
 #include <map>
 #include <boost/program_options.hpp>
-#include <util/message/message.h>
 
 /* WORKAROUND: On *BSD macOS the include of some system headers
  * makes the definition of isset as a macro, which conflicts with
@@ -47,13 +38,12 @@ public:
   argst args;
   boost::program_options::variables_map vm;
   boost::program_options::options_description cmdline_options;
-  cmdlinet(const messaget &msg) : msg(msg)
+  cmdlinet()
   {
   }
   ~cmdlinet();
   typedef std::map<std::string, std::list<std::string>> options_mapt;
   options_mapt options_map;
-  const messaget &msg;
 };
 
 #endif
diff --git a/src/util/config.cpp b/src/util/config.cpp
index c389cf5af..25580e121 100644
--- a/src/util/config.cpp
+++ b/src/util/config.cpp
@@ -1,15 +1,8 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <algorithm>
 #include <regex>
 
 #include <util/config.h>
+#include <util/message.h>
 
 configt config;
 
@@ -56,8 +49,7 @@ static const eregex ARM("(arm|thumb|aarch64c?)(eb|_be)?");
 static const eregex MIPS("mips(64|isa64|isa64sb1)?(r[0-9]+)?(el|le)?.*");
 static const eregex POWERPC("(ppc|powerpc)(64)?(le)?");
 
-static configt::ansi_ct::endianesst
-arch_endianness(const std::string &arch, const messaget &msg)
+static configt::ansi_ct::endianesst arch_endianness(const std::string &arch)
 {
   if(std::regex_match(arch, X86) || arch == "riscv32" || arch == "riscv64")
     return configt::ansi_ct::IS_LITTLE_ENDIAN;
@@ -73,7 +65,7 @@ arch_endianness(const std::string &arch, const messaget &msg)
                            : configt::ansi_ct::IS_BIG_ENDIAN;
   if(arch == "none")
     return configt::ansi_ct::NO_ENDIANESS;
-  msg.error("unknown arch '" + arch + "', cannot determine endianness\n");
+  log_error("unknown arch '{}', cannot determine endianness", arch);
   abort();
 }
 
@@ -97,7 +89,7 @@ std::string configt::triple::to_string() const
   return arch + "-" + vendor + "-" + os + (flavor.empty() ? "" : "-" + flavor);
 }
 
-bool configt::set(const cmdlinet &cmdline, const messaget &msg)
+bool configt::set(const cmdlinet &cmdline)
 {
   if(cmdline.isset("function"))
     main = cmdline.getval("function");
@@ -119,10 +111,22 @@ bool configt::set(const cmdlinet &cmdline, const messaget &msg)
 
   if(cmdline.isset("floatbv") && cmdline.isset("fixedbv"))
   {
-    msg.error("Can't set both floatbv and fixedbv modes");
+    log_error("Can't set both floatbv and fixedbv modes");
     return true;
   }
 
+  if(cmdline.isset("no-slice-name"))
+  {
+    const std::list<std::string> &args = cmdline.get_values("no-slice-name");
+    no_slice_names = {begin(args), end(args)};
+  }
+
+  if(cmdline.isset("no-slice-id"))
+  {
+    const std::list<std::string> &args = cmdline.get_values("no-slice-id");
+    no_slice_ids = {begin(args), end(args)};
+  }
+
   ansi_c.use_fixed_for_float = cmdline.isset("fixedbv");
 
   // this is the default
@@ -166,7 +170,7 @@ bool configt::set(const cmdlinet &cmdline, const messaget &msg)
 
   if(req_target > 1)
   {
-    msg.error(
+    log_error(
       "only at most one target can be specified via "
       "--i386-{win32,macos,linux}, --ppc-macos and --no-arch\n");
     return true;
@@ -181,7 +185,7 @@ bool configt::set(const cmdlinet &cmdline, const messaget &msg)
 
   if(have_16 + have_32 + have_64 > 1)
   {
-    msg.error("Only one of --16, --32 and --64 is supported");
+    log_error("Only one of --16, --32 and --64 is supported");
     return true;
   }
 
@@ -196,14 +200,14 @@ bool configt::set(const cmdlinet &cmdline, const messaget &msg)
 
   if(cmdline.isset("little-endian") && cmdline.isset("big-endian"))
   {
-    msg.error("Can't set both little and big endian modes");
+    log_error("Can't set both little and big endian modes");
     return true;
   }
 
   ansi_c.endianess = cmdline.isset("little-endian") ? ansi_ct::IS_LITTLE_ENDIAN
                      : cmdline.isset("big-endian")
                        ? ansi_ct::IS_BIG_ENDIAN
-                       : arch_endianness(ansi_c.target.arch, msg);
+                       : arch_endianness(ansi_c.target.arch);
 
   ansi_c.lib = ansi_c.target.arch == "none" || cmdline.isset("no-library")
                  ? ansi_ct::LIB_NONE
diff --git a/src/util/config.h b/src/util/config.h
index 3fc12e1ab..979deb400 100644
--- a/src/util/config.h
+++ b/src/util/config.h
@@ -1,16 +1,10 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_UTIL_CONFIG_H
 #define CPROVER_UTIL_CONFIG_H
 
+#include <unordered_set>
 #include <util/cmdline.h>
 #include <util/options.h>
+#include <langapi/mode.h>
 
 #ifndef GNUC_PREREQ
 #if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
@@ -82,6 +76,9 @@ public:
 
 #undef dm
 
+  // Language the frontend has been parsing
+  language_idt language = language_idt::NONE;
+
   struct ansi_ct
   {
     // for ANSI-C
@@ -132,8 +129,10 @@ public:
   } ansi_c;
 
   std::string main;
+  std::unordered_set<std::string> no_slice_names;
+  std::unordered_set<std::string> no_slice_ids;
 
-  bool set(const cmdlinet &cmdline, const messaget &msg);
+  bool set(const cmdlinet &cmdline);
 
   optionst options;
 
diff --git a/src/util/context.cpp b/src/util/context.cpp
index be7af719f..982b7bcac 100644
--- a/src/util/context.cpp
+++ b/src/util/context.cpp
@@ -1,13 +1,6 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <util/context.h>
-#include <util/message/default_message.h>
+#include <util/message.h>
+#include <util/message/format.h>
 
 bool contextt::add(const symbolt &symbol)
 {
@@ -46,7 +39,7 @@ bool contextt::move(symbolt &symbol, symbolt *&new_symbol)
 
 void contextt::dump() const
 {
-  msg.debug("\nSymbols:");
+  log_debug("\nSymbols:");
   // Do assignments based on "value".
   foreach_operand([](const symbolt &s) { s.dump(); });
 }
@@ -72,7 +65,7 @@ void contextt::erase_symbol(irep_idt name)
   symbolst::iterator it = symbols.find(name);
   if(it == symbols.end())
   {
-    msg.error("Couldn't find symbol to erase");
+    log_error("Couldn't find symbol to erase");
     abort();
   }
 
@@ -117,3 +110,31 @@ void contextt::foreach_operand_impl_in_order(symbol_delegate &expr)
     expr(*ordered_symbol);
   }
 }
+symbolt *contextt::move_symbol_to_context(symbolt &symbol)
+{
+  symbolt *s = find_symbol(symbol.id);
+  if(s == nullptr)
+  {
+    if(move(symbol, s))
+    {
+      log_error(
+        "Couldn't add symbol {} to symbol table\n{}", symbol.name, symbol);
+      abort();
+    }
+  }
+  else
+  {
+    // types that are code means functions
+    if(s->type.is_code())
+    {
+      if(symbol.value.is_not_nil() && !s->value.is_not_nil())
+        s->swap(symbol);
+    }
+    else if(s->is_type)
+    {
+      if(symbol.type.is_not_nil() && !s->type.is_not_nil())
+        s->swap(symbol);
+    }
+  }
+  return s;
+}
diff --git a/src/util/context.h b/src/util/context.h
index 47bfa75d7..2e0bc954c 100644
--- a/src/util/context.h
+++ b/src/util/context.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_CONTEXT_H
 #define CPROVER_CONTEXT_H
 
@@ -15,6 +7,7 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <util/config.h>
 #include <util/symbol.h>
 #include <util/type.h>
+#include <util/message.h>
 
 typedef std::unordered_map<irep_idt, symbolt, irep_id_hash> symbolst;
 typedef std::vector<symbolt *> ordered_symbolst;
@@ -35,7 +28,7 @@ class contextt
 public:
   typedef ::symbolst symbolst;
   typedef ::ordered_symbolst ordered_symbolst;
-  explicit contextt(const messaget &msg) : msg(msg)
+  explicit contextt()
   {
   }
   ~contextt() = default;
@@ -47,7 +40,7 @@ public:
     // copy assignment operator for old frontend typechecking
     if(&rhs == this) // check self assignment
     {
-      msg.error("Context is copying itself");
+      log_error("Context is copying itself");
     }
 
     // Since the const messaget& member breaks default copy assignment operation in this class,
@@ -71,6 +64,7 @@ public:
     symbolt *new_symbol;
     return move(symbol, new_symbol);
   }
+  symbolt *move_symbol_to_context(symbolt &symbol);
 
   void clear()
   {
@@ -126,9 +120,6 @@ public:
     return symbols.size();
   }
 
-protected:
-  const messaget &msg;
-
 private:
   symbolst symbols;
   ordered_symbolst ordered_symbols;
diff --git a/src/util/crypto_hash.cpp b/src/util/crypto_hash.cpp
index bd46ba347..8e7dcf855 100644
--- a/src/util/crypto_hash.cpp
+++ b/src/util/crypto_hash.cpp
@@ -15,9 +15,9 @@ public:
   boost::uuids::detail::sha1 s;
 };
 
-bool crypto_hash::operator<(const crypto_hash h2) const
+bool crypto_hash::operator<(const crypto_hash &h2) const
 {
-  if(memcmp(hash, h2.hash, CRYPTO_HASH_SIZE) < 0)
+  if(memcmp(hash, h2.hash, sizeof(hash)) < 0)
     return true;
 
   return false;
diff --git a/src/util/crypto_hash.h b/src/util/crypto_hash.h
index 927003668..768dac325 100644
--- a/src/util/crypto_hash.h
+++ b/src/util/crypto_hash.h
@@ -6,15 +6,13 @@
 
 class crypto_hash_private;
 
-#define CRYPTO_HASH_SIZE 32
-
 class crypto_hash
 {
 public:
   std::shared_ptr<crypto_hash_private> p_crypto;
   unsigned int hash[5];
 
-  bool operator<(const crypto_hash h2) const;
+  bool operator<(const crypto_hash &h2) const;
 
   std::string to_string() const;
 
diff --git a/src/util/destructor.cpp b/src/util/destructor.cpp
new file mode 100644
index 000000000..656e24df7
--- /dev/null
+++ b/src/util/destructor.cpp
@@ -0,0 +1,28 @@
+#include <std_types.h>
+#include <std_code.h>
+#include <util/destructor.h>
+
+code_function_callt get_destructor(const namespacet &ns, const typet &type)
+{
+  if(type.id() == "symbol")
+    return get_destructor(ns, ns.follow(type));
+
+  if(type.id() == "struct")
+  {
+    const struct_typet &struct_type = to_struct_type(type);
+
+    auto it = ns.get_context().symbol_base_map.find(
+      "~" + struct_type.tag().as_string());
+    if(it != ns.get_context().symbol_base_map.end())
+    {
+      const symbolt *cpp_delete = ns.get_context().find_symbol(it->second);
+
+      code_function_callt function_call;
+      function_call.function() = symbol_exprt(cpp_delete->id, cpp_delete->type);
+
+      return function_call;
+    }
+  }
+
+  return static_cast<const code_function_callt &>(get_nil_irep());
+}
diff --git a/src/util/destructor.h b/src/util/destructor.h
new file mode 100644
index 000000000..01912d4d0
--- /dev/null
+++ b/src/util/destructor.h
@@ -0,0 +1,13 @@
+#ifndef CPROVER_GOTO_PROGRAMS_DESTRUCTOR_H
+#define CPROVER_GOTO_PROGRAMS_DESTRUCTOR_H
+
+#include <util/expr.h>
+#include <util/namespace.h>
+
+/**
+ * Get an expr to represent destructor function call
+ * for cpp delete
+ */
+code_function_callt get_destructor(const namespacet &ns, const typet &type);
+
+#endif
diff --git a/src/util/dstring.cpp b/src/util/dstring.cpp
index 65853ca29..5eb0e4ab7 100644
--- a/src/util/dstring.cpp
+++ b/src/util/dstring.cpp
@@ -1,9 +1 @@
-/*******************************************************************\
-
-Module: Container for C-Strings
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <util/dstring.h>
diff --git a/src/util/dstring.h b/src/util/dstring.h
index 8be152f17..c2d55c160 100644
--- a/src/util/dstring.h
+++ b/src/util/dstring.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Container for C-Strings
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef DSTRING_H
 #define DSTRING_H
 
@@ -55,7 +47,7 @@ public:
     return as_string()[i];
   }
 
-  // warning! the address returned is not stable
+  // the address returned is guaranteed to be stable
   inline const char *c_str() const
   {
     return as_string().c_str();
diff --git a/src/util/expr.cpp b/src/util/expr.cpp
index ff9f535b0..3191ef65f 100644
--- a/src/util/expr.cpp
+++ b/src/util/expr.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Expression Representation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <cstdlib>
 #include <util/expr.h>
diff --git a/src/util/expr.h b/src/util/expr.h
index 1b5ecfdea..39f4a98f2 100644
--- a/src/util/expr.h
+++ b/src/util/expr.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_EXPR_H
 #define CPROVER_EXPR_H
 
diff --git a/src/util/expr_util.cpp b/src/util/expr_util.cpp
index e5fe7b1d1..c5cae2a32 100644
--- a/src/util/expr_util.cpp
+++ b/src/util/expr_util.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <util/bitvector.h>
 #include <util/expr_util.h>
 #include <util/fixedbv.h>
@@ -297,9 +289,9 @@ exprt make_binary(const exprt &expr)
   return previous;
 }
 
-bool expr_has_float(const exprt &src)
+bool expr_has_floatbv(const exprt &src)
 {
   auto t = src.type();
   return t.is_vector() ? to_vector_type(t).subtype().is_floatbv()
                        : t.is_floatbv();
-}
\ No newline at end of file
+}
diff --git a/src/util/expr_util.h b/src/util/expr_util.h
index e8d9d6193..413e5b2ad 100644
--- a/src/util/expr_util.h
+++ b/src/util/expr_util.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <util/expr.h>
 #include <util/std_types.h>
 #include <util/symbol.h>
@@ -52,4 +44,4 @@ void make_next_state(exprt &expr);
 
 exprt make_binary(const exprt &src);
 
-bool expr_has_float(const exprt &src);
+bool expr_has_floatbv(const exprt &src);
diff --git a/src/util/filesystem.cpp b/src/util/filesystem.cpp
index 57b30c409..ca0b9d0fa 100644
--- a/src/util/filesystem.cpp
+++ b/src/util/filesystem.cpp
@@ -18,7 +18,7 @@ tmp_path::~tmp_path()
 {
   if(_keep)
     return;
-  uintmax_t removed [[gnu::unused]] = boost::filesystem::remove_all(_path);
+  uintmax_t removed [[maybe_unused]] = boost::filesystem::remove_all(_path);
   assert(removed >= 1 && "expected to remove temp path");
 }
 
diff --git a/src/util/filesystem.h b/src/util/filesystem.h
index c31e892ec..cbb538455 100644
--- a/src/util/filesystem.h
+++ b/src/util/filesystem.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: File operations
-
-Author: Rafael Menezes, rafael.sa.menezes@outlook.com
-
-\*******************************************************************/
-
 #pragma once
 
 #include <cstdio> /* FILE */
diff --git a/src/util/fix_symbol.cpp b/src/util/fix_symbol.cpp
index d30bc578e..c56e18689 100644
--- a/src/util/fix_symbol.cpp
+++ b/src/util/fix_symbol.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: ANSI-C Linking
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <util/fix_symbol.h>
 
 void fix_symbolt::fix_symbol(symbolt &symbol)
diff --git a/src/util/fix_symbol.h b/src/util/fix_symbol.h
index 5aa19462d..032333197 100644
--- a/src/util/fix_symbol.h
+++ b/src/util/fix_symbol.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: ANSI-C Linking
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <util/context.h>
 #include <util/replace_symbol.h>
 
diff --git a/src/util/fixedbv.cpp b/src/util/fixedbv.cpp
index 3ec6a0712..2d5a80684 100644
--- a/src/util/fixedbv.cpp
+++ b/src/util/fixedbv.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <util/arith_tools.h>
 #include <util/fixedbv.h>
 #include <util/std_types.h>
diff --git a/src/util/fixedbv.h b/src/util/fixedbv.h
index 0057466a0..7aadba617 100644
--- a/src/util/fixedbv.h
+++ b/src/util/fixedbv.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_FIXEDBV_UTIL_H
 #define CPROVER_FIXEDBV_UTIL_H
 
diff --git a/src/util/format_constant.cpp b/src/util/format_constant.cpp
index 3474b6831..ddb01deac 100644
--- a/src/util/format_constant.cpp
+++ b/src/util/format_constant.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <util/fixedbv.h>
 #include <util/format_constant.h>
 #include <util/ieee_float.h>
diff --git a/src/util/format_constant.h b/src/util/format_constant.h
index 5ccc1f693..9cdea7ae2 100644
--- a/src/util/format_constant.h
+++ b/src/util/format_constant.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_FORMAT_CONSTANT_H
 #define CPROVER_FORMAT_CONSTANT_H
 
diff --git a/src/util/format_spec.h b/src/util/format_spec.h
index f600e152e..8f2a4bbb3 100644
--- a/src/util/format_spec.h
+++ b/src/util/format_spec.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_FORMAT_SPEC_H
 #define CPROVER_FORMAT_SPEC_H
 
diff --git a/src/util/goto_expr_factory.cpp b/src/util/goto_expr_factory.cpp
index 60cd84cc6..d6dc01a73 100644
--- a/src/util/goto_expr_factory.cpp
+++ b/src/util/goto_expr_factory.cpp
@@ -1,5 +1,3 @@
-// Rafael S Menezes - 03/2021
-
 #include <util/goto_expr_factory.h>
 
 constant_int2tc create_value_expr(int value, type2tc type)
@@ -25,4 +23,4 @@ greaterthanequal2tc create_greaterthanequal_relation(expr2tc &lhs, expr2tc &rhs)
 
   greaterthanequal2tc relation(lhs_typecast, rhs_typecast);
   return relation;
-}
\ No newline at end of file
+}
diff --git a/src/util/goto_expr_factory.h b/src/util/goto_expr_factory.h
index d4de96e34..9b211f958 100644
--- a/src/util/goto_expr_factory.h
+++ b/src/util/goto_expr_factory.h
@@ -1,8 +1,3 @@
-/*******************************************************************\
-Module: Helper functions to generate GOTO expressions
-Author: Rafael S Menezes
-Date: March 2021
-\*******************************************************************/
 #pragma once
 
 #include "goto-symex/symex_target_equation.h"
@@ -35,4 +30,4 @@ lessthanequal2tc create_lessthanequal_relation(expr2tc &lhs, expr2tc &rhs);
  * @return int negative means error, positive is the quantity to unroll
  */
 greaterthanequal2tc
-create_greaterthanequal_relation(expr2tc &lhs, expr2tc &rhs);
\ No newline at end of file
+create_greaterthanequal_relation(expr2tc &lhs, expr2tc &rhs);
diff --git a/src/util/guard.cpp b/src/util/guard.cpp
index 6d9cd29b4..5aa3824cc 100644
--- a/src/util/guard.cpp
+++ b/src/util/guard.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Symbolic Execution
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <algorithm>
 #include <util/guard.h>
 #include <irep2/irep2_utils.h>
diff --git a/src/util/guard.h b/src/util/guard.h
index 4956c20c4..31641c188 100644
--- a/src/util/guard.h
+++ b/src/util/guard.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module: Guard Data Structure
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_GUARD_H
 #define CPROVER_GUARD_H
 
diff --git a/src/util/i2string.cpp b/src/util/i2string.cpp
index d19a18512..2a960ba0d 100644
--- a/src/util/i2string.cpp
+++ b/src/util/i2string.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #define USE_SPRINTF
 
 #ifdef USE_SPRINTF
diff --git a/src/util/i2string.h b/src/util/i2string.h
index e22ba4159..f5361c051 100644
--- a/src/util/i2string.h
+++ b/src/util/i2string.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <string>
 
 std::string i2string(int i);
diff --git a/src/util/ieee_float.cpp b/src/util/ieee_float.cpp
index 97bcee32f..7b54301a7 100644
--- a/src/util/ieee_float.cpp
+++ b/src/util/ieee_float.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <limits>
 #include <util/arith_tools.h>
diff --git a/src/util/ieee_float.h b/src/util/ieee_float.h
index 326ee5012..039b82c3b 100644
--- a/src/util/ieee_float.h
+++ b/src/util/ieee_float.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_IEEE_FLOAT_H
 #define CPROVER_IEEE_FLOAT_H
 
diff --git a/src/util/irep.cpp b/src/util/irep.cpp
index 2f7c0e3d4..7ff3f99d4 100644
--- a/src/util/irep.cpp
+++ b/src/util/irep.cpp
@@ -1,16 +1,8 @@
-/*******************************************************************\
-
-Module: Internal Representation
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <cstdlib>
 #include <util/i2string.h>
 #include <util/irep.h>
-#include <util/message/default_message.h>
+#include <util/message.h>
 
 irept nil_rep_storage;
 
@@ -20,8 +12,7 @@ const irept::dt empty_d;
 
 void irept::dump() const
 {
-  default_message msg;
-  msg.debug(pretty(0));
+  log_debug("{}", pretty(0));
 }
 
 const irept &get_nil_irep()
diff --git a/src/util/irep.h b/src/util/irep.h
index 2f6727ee3..6d82f4309 100644
--- a/src/util/irep.h
+++ b/src/util/irep.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_IREP_H
 #define CPROVER_IREP_H
 
@@ -39,8 +31,6 @@ typedef dstring_hash irep_id_hash;
   for(irept::named_subt::iterator it = (irep).begin(); it != (irep).end(); it++)
 
 class typet;
-class
-  messaget; // This forward decl is needed because locationt (which is an irep) is used inside messaget
 
 class irept
 {
diff --git a/src/util/irep_serialization.cpp b/src/util/irep_serialization.cpp
index 2ddabd581..85f5bdce1 100644
--- a/src/util/irep_serialization.cpp
+++ b/src/util/irep_serialization.cpp
@@ -1,13 +1,3 @@
-/*******************************************************************\
-
-Module: binary irep conversions with hashing
-
-Author: CM Wintersteiger
-
-Date: May 2007
-
-\*******************************************************************/
-
 #include <sstream>
 #include <util/irep_serialization.h>
 
diff --git a/src/util/irep_serialization.h b/src/util/irep_serialization.h
index 779792b0a..56ff1cb27 100644
--- a/src/util/irep_serialization.h
+++ b/src/util/irep_serialization.h
@@ -1,13 +1,3 @@
-/*******************************************************************\
-
-Module: binary irep conversions with hashing
-
-Author: CM Wintersteiger
-
-Date: May 2007
-
-\*******************************************************************/
-
 #ifndef IREP_SERIALIZATION_H_
 #define IREP_SERIALIZATION_H_
 
diff --git a/src/util/language.h b/src/util/language.h
index e1270a471..880254979 100644
--- a/src/util/language.h
+++ b/src/util/language.h
@@ -1,18 +1,9 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_LANGUAGE_H
 #define CPROVER_LANGUAGE_H
 
 #include <cstdio>
 #include <set>
 #include <util/context.h>
-#include <util/message/message.h>
 #include <util/namespace.h>
 
 class languaget
@@ -20,7 +11,7 @@ class languaget
 public:
   // parse file
 
-  virtual bool parse(const std::string &path, const messaget &msg) = 0;
+  virtual bool parse(const std::string &path) = 0;
 
   // add external dependencies of a given module to set
 
@@ -35,7 +26,7 @@ public:
   }
 
   // final adjustments, e.g., initialization and call to main()
-  virtual bool final(contextt &, const messaget &)
+  virtual bool final(contextt &)
   {
     return false;
   }
@@ -47,10 +38,7 @@ public:
   }
 
   // type check a module in the currently parsed file
-  virtual bool typecheck(
-    contextt &context,
-    const std::string &module,
-    const messaget &msg) = 0;
+  virtual bool typecheck(contextt &context, const std::string &module) = 0;
 
   // language id / description
   virtual std::string id() const
@@ -73,13 +61,8 @@ public:
   virtual bool
   from_type(const typet &type, std::string &code, const namespacet &ns) = 0;
 
-  virtual languaget *new_language(const messaget &msg) const = 0;
+  virtual languaget *new_language() const = 0;
 
-  // constructor / destructor
-
-  explicit languaget(const messaget &msg) : msg(msg)
-  {
-  }
   virtual ~languaget() = default;
 
   inline void set_func_name(const std::string _path)
@@ -95,7 +78,6 @@ public:
 #endif
 
 protected:
-  const messaget &msg;
   // function name for verification that requires this information before GOTO conversion phase.
   std::string func_name = "";
 #ifdef ENABLE_SOLIDITY_FRONTEND
diff --git a/src/util/language_file.cpp b/src/util/language_file.cpp
index 6260094fb..2695793e3 100644
--- a/src/util/language_file.cpp
+++ b/src/util/language_file.cpp
@@ -1,14 +1,7 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <fstream>
 #include <util/language.h>
 #include <util/language_file.h>
+#include <util/message.h>
 #include <util/std_types.h>
 
 language_filet::~language_filet()
@@ -38,7 +31,7 @@ bool language_filest::parse()
 
     if(!infile)
     {
-      msg.error("Failed to open " + it.first);
+      log_error("Failed to open {}", it.first);
       return true;
     }
 
@@ -46,9 +39,9 @@ bool language_filest::parse()
 
     languaget &language = *(it.second.language);
 
-    if(language.parse(it.first, msg))
+    if(language.parse(it.first))
     {
-      msg.error("Parsing of " + it.first + " failed");
+      log_error("Parsing of {} failed", it.first);
       return true;
     }
 
@@ -67,7 +60,7 @@ bool language_filest::typecheck(contextt &context)
   for(filemapt::iterator it=filemap.begin();
       it!=filemap.end(); it++)
   {
-    if(it->second.language->interfaces(context, *get_message_handler()))
+    if(it->second.language->interfaces(context))
       return true;
   }
 #endif
@@ -92,7 +85,7 @@ bool language_filest::typecheck(contextt &context)
   for(auto &it : filemap)
   {
     if(it.second.modules.empty())
-      if(it.second.language->typecheck(context, "", msg))
+      if(it.second.language->typecheck(context, ""))
         return true;
   }
 
@@ -117,7 +110,7 @@ bool language_filest::final(contextt &context)
   for(auto &it : filemap)
   {
     if(languages.insert(it.second.language->id()).second)
-      if(it.second.language->final(context, msg))
+      if(it.second.language->final(context))
         return true;
   }
 #endif
@@ -131,7 +124,7 @@ bool language_filest::interfaces(contextt &)
   for(filemapt::iterator it=filemap.begin();
       it!=filemap.end(); it++)
   {
-    if(it->second.language->interfaces(context, *get_message_handler()))
+    if(it->second.language->interfaces(context))
       return true;
   }
 #endif
@@ -148,7 +141,7 @@ bool language_filest::typecheck_module(
 
   if(it == modulemap.end())
   {
-    msg.error("found no file that provides module " + module);
+    log_error("found no file that provides module {}", module);
     return true;
   }
 
@@ -168,7 +161,7 @@ bool language_filest::typecheck_module(
 
   if(module.in_progress)
   {
-    msg.error("circular dependency in " + module.name);
+    log_error("circular dependency in {}", module.name);
     return true;
   }
 
@@ -191,9 +184,9 @@ bool language_filest::typecheck_module(
 
   // type check it
 
-  msg.status("Type-checking " + module.name);
+  log_status("Type-checking {}", module.name);
 
-  if(module.file->language->typecheck(context, module.name, msg))
+  if(module.file->language->typecheck(context, module.name))
   {
     module.in_progress = false;
     return true;
@@ -220,16 +213,17 @@ void language_filest::typecheck_virtual_methods(contextt &context)
           component.get_bool("is_virtual") &&
           !(component.get_bool("is_pure_virtual")))
         {
-          const symbolt &member_function =
+          const symbolt *member_function =
             namespacet(context).lookup(component.get_name());
+          assert(member_function);
 
-          if(member_function.value.is_nil())
+          if(member_function->value.is_nil())
           {
-            msg.error(
-              member_function.location.as_string() +
+            log_error(
+              member_function->location.as_string() +
               ": The virtual method isn't pure virtual and hasn't a "
               "method implementation ");
-            msg.error("CONVERSION ERROR");
+            log_error("CONVERSION ERROR");
             abort();
           }
         }
diff --git a/src/util/language_file.h b/src/util/language_file.h
index fbefcce9a..ceb63d267 100644
--- a/src/util/language_file.h
+++ b/src/util/language_file.h
@@ -1,17 +1,8 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_LANGUAGE_FILE_H
 #define CPROVER_LANGUAGE_FILE_H
 
 #include <set>
 #include <util/context.h>
-#include <util/message/message.h>
 
 class language_modulet
 {
@@ -52,10 +43,6 @@ public:
   typedef std::map<std::string, language_modulet> modulemapt;
   modulemapt modulemap;
 
-  explicit language_filest(const messaget &msg) : msg(msg)
-  {
-  }
-
   void clear_files()
   {
     filemap.clear();
@@ -78,7 +65,6 @@ public:
   }
 
 protected:
-  const messaget &msg;
   bool typecheck_module(contextt &context, language_modulet &module);
 
   bool typecheck_module(contextt &context, const std::string &module);
diff --git a/src/util/location.cpp b/src/util/location.cpp
index c76dedb2a..ac0d4445f 100644
--- a/src/util/location.cpp
+++ b/src/util/location.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <util/location.h>
 
 std::string locationt::as_string() const
diff --git a/src/util/location.h b/src/util/location.h
index ce0438b91..6cb2e69f5 100644
--- a/src/util/location.h
+++ b/src/util/location.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_LOCATION_H
 #define CPROVER_LOCATION_H
 
diff --git a/src/util/message.h b/src/util/message.h
new file mode 100644
index 000000000..d0901fb03
--- /dev/null
+++ b/src/util/message.h
@@ -0,0 +1,120 @@
+/*******************************************************************\
+
+Module: Message System. This system is used to send messages through
+    ESBMC execution.
+Author: Daniel Kroening, kroening@kroening.com
+
+Maintainers:
+- @2021: Rafael S Menezes, rafael.sa.menezes@outlook.com
+
+\*******************************************************************/
+#pragma once
+
+#include <cstdio>
+#include <fmt/format.h>
+#include <util/message/format.h>
+#include <util/location.h>
+
+/**
+ * @brief Verbosity refers to the max level
+ * of which inputs are going to be printed out
+ *
+ * The level adds up to the greater level which means
+ * that if the level is set to 3 all messages of value
+ * 0,1,2,3 are going to be printed but 4+ will not be printed
+ *
+ * The number is where it appeared in the definition, in the
+ * implementation below Debug is the highest value
+ */
+enum class VerbosityLevel : char
+{
+  None,     // No message output
+  Error,    // fatal errors are printed
+  Warning,  // warnings are printend
+  Result,   // results of the analysis (including CE)
+  Progress, // progress notifications
+  Status,   // all kinds of things esbmc is doing that may be useful to the user
+  Debug     // messages that are only useful if you need to debug.
+};
+
+struct messaget
+{
+  static inline class
+  {
+    template <typename... Args>
+    void println(FILE *f, VerbosityLevel lvl, Args &&...args) const
+    {
+      if(lvl == VerbosityLevel::Error)
+        fmt::print(f, "ERROR: ");
+      fmt::print(f, std::forward<Args>(args)...);
+      fmt::print(f, "\n");
+    }
+
+  public:
+    VerbosityLevel verbosity;
+    FILE *out;
+    FILE *err;
+
+    FILE *target(VerbosityLevel lvl) const
+    {
+      return lvl > verbosity                ? nullptr
+             : lvl == VerbosityLevel::Error ? err
+                                            : out;
+    }
+
+    void set_flushln() const
+    {
+/* Win32 interprets _IOLBF as _IOFBF (and then chokes on size=0) */
+#if !defined(_WIN32) || defined(_WIN64) || defined(__CYGWIN__)
+      setvbuf(out, NULL, _IOLBF, 0);
+      setvbuf(err, NULL, _IOLBF, 0);
+#endif
+    }
+
+    template <typename File, typename Line, typename... Args>
+    bool logln(
+      VerbosityLevel lvl,
+      const File &file,
+      const Line &line,
+      Args &&...args) const
+    {
+      FILE *f = target(lvl);
+      if(!f)
+        return false;
+      println(f, lvl, std::forward<Args>(args)...);
+      return true;
+      /* unused: */
+      (void)file;
+      (void)line;
+    }
+  } state = {VerbosityLevel::Status, stdout, stderr};
+};
+
+static inline void
+print(VerbosityLevel lvl, std::string_view msg, const locationt &loc)
+{
+  messaget::state.logln(lvl, loc.get_file(), loc.get_line(), "{}", msg);
+}
+
+// Macro to generate log functions
+#define log_message(name, verbosity)                                           \
+  template <typename... Args>                                                  \
+  static inline void log_##name(std::string_view fmt, Args &&...args)          \
+  {                                                                            \
+    messaget::state.logln(                                                     \
+      verbosity, __FILE__, __LINE__, fmt, std::forward<Args>(args)...);        \
+  }
+
+log_message(error, VerbosityLevel::Error);
+log_message(result, VerbosityLevel::Result);
+log_message(warning, VerbosityLevel::Warning);
+log_message(progress, VerbosityLevel::Progress);
+log_message(status, VerbosityLevel::Status);
+log_message(debug, VerbosityLevel::Debug);
+
+#undef log_message
+
+// TODO: Eventually this will be removed
+#ifdef ENABLE_OLD_FRONTEND
+#define err_location(E) (E).location().dump()
+#endif
diff --git a/src/util/message/CMakeLists.txt b/src/util/message/CMakeLists.txt
deleted file mode 100644
index e4082b508..000000000
--- a/src/util/message/CMakeLists.txt
+++ /dev/null
@@ -1,17 +0,0 @@
-add_library(message_handler message_handler.cpp)
-add_library(message message.cpp)
-add_library(default_message default_message.cpp)
-add_library(message_stream message_stream.cpp)
-add_library(fmt_message_handler fmt_message_handler.cpp)
-
-target_include_directories(message_handler
-        PRIVATE ${Boost_INCLUDE_DIRS}
-)
-
-target_include_directories(message
-        PRIVATE ${Boost_INCLUDE_DIRS}
-        )
-
-target_link_libraries(message filesystem ${Boost_LIBRARIES})
-target_link_libraries(fmt_message_handler fmt::fmt message_handler)
-target_link_libraries(default_message message fmt_message_handler)
diff --git a/src/util/message/default_message.cpp b/src/util/message/default_message.cpp
deleted file mode 100644
index 42c9d2244..000000000
--- a/src/util/message/default_message.cpp
+++ /dev/null
@@ -1,22 +0,0 @@
-/*******************************************************************\
-
-Module: Default message specialization. This should be used for
- common debug and CLI operations where the output is done through
- stdout/stderr
-
-Author: Rafael Menezes, rafael.sa.menezes@outlook.com
-
-Maintainers:
-\*******************************************************************/
-
-#include <memory>
-#include <util/message/default_message.h>
-#include <util/message/fmt_message_handler.h>
-
-default_message::default_message()
-{
-  std::shared_ptr<message_handlert> handler =
-    std::make_shared<fmt_message_handler>();
-  this->add_message_handler(handler);
-  set_verbosity(VerbosityLevel::Debug);
-}
diff --git a/src/util/message/default_message.h b/src/util/message/default_message.h
deleted file mode 100644
index 4ac8bc627..000000000
--- a/src/util/message/default_message.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/*******************************************************************\
-
-Module: Default message specialization. This should be used for
- common debug and CLI operations where the output is done through
- stdout/stderr
-
-Author: Rafael Menezes, rafael.sa.menezes@outlook.com
-
-Maintainers:
-\*******************************************************************/
-
-#ifndef ESBMC_DEFAULT_MESSAGE_H
-#define ESBMC_DEFAULT_MESSAGE_H
-
-#include <util/message/message.h>
-class default_message : public messaget
-{
-public:
-  default_message();
-
-  static FILE *out;
-  static FILE *err;
-};
-
-#endif //ESBMC_DEFAULT_MESSAGE_H
diff --git a/src/util/message/fmt_message_handler.cpp b/src/util/message/fmt_message_handler.cpp
deleted file mode 100644
index 123aad789..000000000
--- a/src/util/message/fmt_message_handler.cpp
+++ /dev/null
@@ -1,30 +0,0 @@
-#include <util/message/fmt_message_handler.h>
-#include <fmt/core.h>
-
-void fmt_message_handler::print(
-  VerbosityLevel level,
-  const std::string &message) const
-{
-  fmt::print(files.at(level), "{}\n", message);
-}
-
-fmt_message_handler::fmt_message_handler()
-{
-  initialize(stdout, stderr);
-}
-
-fmt_message_handler::fmt_message_handler(FILE *out, FILE *err)
-{
-  initialize(out, err);
-}
-
-void fmt_message_handler::initialize(FILE *out, FILE *err)
-{
-  files[VerbosityLevel::None] = nullptr;
-  files[VerbosityLevel::Error] = err;
-  files[VerbosityLevel::Warning] = out;
-  files[VerbosityLevel::Result] = out;
-  files[VerbosityLevel::Progress] = out;
-  files[VerbosityLevel::Status] = out;
-  files[VerbosityLevel::Debug] = out;
-}
\ No newline at end of file
diff --git a/src/util/message/fmt_message_handler.h b/src/util/message/fmt_message_handler.h
deleted file mode 100644
index 535314af1..000000000
--- a/src/util/message/fmt_message_handler.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/*******************************************************************\
-Module: FMT Message Handler specialization.
-
-Author: Rafael S Menezes, rafael.sa.menezes@outlook.com
-
-\*******************************************************************/
-#pragma once
-#include <util/message/message_handler.h>
-
-/**
- * @brief This is a specialization that by using
- * the fmt library prints messages into FILE* objects
- * 
- */
-class fmt_message_handler : public file_message_handler
-{
-public:
-  fmt_message_handler();
-  fmt_message_handler(FILE *out, FILE *err);
-  virtual void
-  print(VerbosityLevel level, const std::string &message) const override;
-
-private:
-  void initialize(FILE *out, FILE *err);
-};
\ No newline at end of file
diff --git a/src/util/message/message.cpp b/src/util/message/message.cpp
deleted file mode 100644
index 858900f23..000000000
--- a/src/util/message/message.cpp
+++ /dev/null
@@ -1,29 +0,0 @@
-/*******************************************************************\
-
-Module: 
-
-Author: Rafael Menezes, rafael.sa.menezes@outlook.com
-
-Maintainers:
-\*******************************************************************/
-
-#include <util/message/message.h>
-#include <util/filesystem.h>
-
-file_operations::tmp_file messaget::get_temp_file()
-{
-  return file_operations::create_tmp_file("esbmc-%%%%-%%%%");
-}
-
-void messaget::insert_file_contents(VerbosityLevel l, FILE *f) const
-{
-  const int MAX_LINE_LENGTH = 1024;
-  // Go to the beginning of the file
-  fseek(f, 0, SEEK_SET);
-  char line[MAX_LINE_LENGTH] = {0};
-
-  // Read every line of file
-  while(fgets(line, MAX_LINE_LENGTH, f))
-    // Send to message print method
-    print(l, line);
-}
diff --git a/src/util/message/message.h b/src/util/message/message.h
deleted file mode 100644
index 561a1cb04..000000000
--- a/src/util/message/message.h
+++ /dev/null
@@ -1,203 +0,0 @@
-/*******************************************************************\
-
-Module: Message System. This system is used to send messages through
-    ESBMC execution.
-Author: Daniel Kroening, kroening@kroening.com
-
-Maintainers:
-- @2021: Rafael S Menezes, rafael.sa.menezes@outlook.com
-
-\*******************************************************************/
-#pragma once
-
-#include <memory>
-#include <util/message/message_handler.h>
-#include <util/location.h>
-#include <util/filesystem.h>
-
-/**
- * @brief messaget is used to send messages that
- * can be implemented by any kind of frontend
- *
- * It may be from colorful output to full GUI modules,
- * this can also hold a number of of message_handlers
- *
- */
-class messaget
-{
-public:
-  // PRINT Functions
-
-  /**
-   * @brief Prints an error message
-   *
-   * @param message string to be printed
-   * @param location location where the message happened
-   */
-  virtual void
-  error(const std::string &message, const std::string location = "") const
-  {
-    print(VerbosityLevel::Error, "### ERROR: \n" + message, location);
-  }
-  /**
-   * @brief Prints a warning message
-   *
-   * @param message string to be printed
-   * @param location location where the message happened
-   */
-  virtual void
-  warning(const std::string &message, const std::string location = "") const
-  {
-    print(VerbosityLevel::Warning, message, location);
-  }
-  /**
-   * @brief Prints a result message
-   *
-   * @param message string to be printed
-   * @param location location where the message happened
-   */
-  virtual void
-  result(const std::string &message, const std::string location = "") const
-  {
-    print(VerbosityLevel::Result, message, location);
-  }
-  /**
-   * @brief Prints a progress message
-   *
-   * @param message string to be printed
-   * @param progress: float from 0-1 that represents the current progress of the latest task. (-1 means infinite)
-   * @param location location where the message happened
-   * @return an index representing this progress
-   */
-  virtual unsigned progress(
-    const std::string &message,
-    double progress [[gnu::unused]] = -1,
-    const std::string location = "") const
-  {
-    print(VerbosityLevel::Progress, message, location);
-    return 0;
-  }
-
-  /**
-   * @brief Updates progress of specific task
-   *
-   * @param index of task
-   * @param progress new progress status
-   */
-  virtual void update_progress(
-    unsigned index [[gnu::unused]],
-    double progress [[gnu::unused]]) const
-  {
-  }
-  /**
-   * @brief Prints a status message
-   *
-   * @param message string to be printed
-   * @param location location where the message happened
-   */
-  virtual void
-  status(const std::string &message, const std::string location = "") const
-  {
-    print(VerbosityLevel::Status, message, location);
-  }
-  /**
-   * @brief Prints a debug message
-   *
-   * @param message string to be printed
-   * @param location location where the message happened
-   */
-  virtual void
-  debug(const std::string &message, const std::string location = "") const
-  {
-    print(VerbosityLevel::Debug, message, location);
-  }
-
-  /**
-   * @brief Set the verbosity level
-   *
-   * @param _verbosity new verbosity leveel
-   */
-  virtual void set_verbosity(VerbosityLevel _verbosity)
-  {
-    verbosity = _verbosity;
-  }
-
-  /**
-   * @brief Get the verbosity level
-   *
-   * @return VerbosityLevel level
-   */
-  virtual VerbosityLevel get_verbosity() const
-  {
-    return verbosity;
-  }
-
-  virtual ~messaget() = default;
-  virtual void print(
-    VerbosityLevel level,
-    const std::string &message,
-    const std::string file = "") const
-  {
-    // Check if the message should be printed
-    if((int)level > (int)verbosity)
-      return;
-
-    // Send the message to all handlers
-    for(const auto &x : handlers)
-    {
-      if(file != "")
-      {
-        locationt l;
-        l.set_file(file);
-        x->print(level, message, l);
-      }
-      else
-        x->print(level, message);
-    }
-  }
-
-  virtual void print(
-    VerbosityLevel level,
-    const std::string &message,
-    const locationt l) const
-  {
-    // Check if the message should be printed
-    if(level > verbosity)
-      return;
-
-    for(const auto &x : handlers)
-      x->print(level, message, l);
-  }
-
-  /**
-   * @brief Append a message_handler to be used
-   *
-   * @param handler to be appended
-   */
-  void add_message_handler(std::shared_ptr<message_handlert> &handler)
-  {
-    handlers.push_back(handler);
-  }
-
-  /**
-   * @brief Returns a temporary FILE* descriptor for message outputs.
-   *
-   * @return
-   */
-  static file_operations::tmp_file get_temp_file();
-
-  /**
-   * @brief Insert all contents of the file into all message handlers
-   * and then closes the file.
-   *
-   * @param l verbosity level of the file
-   * @param f file pointer with the file contents.
-   */
-  void insert_file_contents(VerbosityLevel l, FILE *f) const;
-
-protected:
-  // Current verbosity level
-  VerbosityLevel verbosity = VerbosityLevel::Status;
-  // All message_handlers used
-  std::vector<std::shared_ptr<message_handlert>> handlers;
-};
diff --git a/src/util/message/message_handler.cpp b/src/util/message/message_handler.cpp
deleted file mode 100644
index ff9be063e..000000000
--- a/src/util/message/message_handler.cpp
+++ /dev/null
@@ -1,58 +0,0 @@
-/*******************************************************************\
-
-Module: Message Handler System. This system is responsible for all IO
-  operations regarding the message system of ESBMC
-
-Author: Daniel Kroening, kroening@kroening.com
-
-Maintainers:
-- @2021: Rafael S Menezes, rafael.sa.menezes@outlook.com
-
-\*******************************************************************/
-
-#include <util/i2string.h>
-#include <util/message/message_handler.h>
-
-void message_handlert::print(
-  VerbosityLevel level,
-  const std::string &message,
-  const locationt &location) const
-{
-  std::string dest;
-
-  const irep_idt &file = location.get_file();
-  const irep_idt &line = location.get_line();
-  const irep_idt &column = location.get_column();
-  const irep_idt &function = location.get_function();
-
-  if(file != "")
-  {
-    if(dest != "")
-      dest += " ";
-    dest += "file " + id2string(file);
-  }
-  if(line != "")
-  {
-    if(dest != "")
-      dest += " ";
-    dest += "line " + id2string(line);
-  }
-  if(column != "")
-  {
-    if(dest != "")
-      dest += " ";
-    dest += "column " + id2string(column);
-  }
-  if(function != "")
-  {
-    if(dest != "")
-      dest += " ";
-    dest += "function " + id2string(function);
-  }
-
-  if(dest != "")
-    dest += ": ";
-  dest += message;
-
-  print(level, dest);
-}
diff --git a/src/util/message/message_handler.h b/src/util/message/message_handler.h
deleted file mode 100644
index da83cfdee..000000000
--- a/src/util/message/message_handler.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*******************************************************************\
-
-Module: Message Handler System. This system is responsible for all IO
-  operations regarding the message system of ESBMC
-
-Author: Daniel Kroening, kroening@kroening.com
-
-Maintainers:
-- @2021: Rafael S Menezes, rafael.sa.menezes@outlook.com
-
-\*******************************************************************/
-
-#ifndef CPROVER_MESSAGE_H
-
-#define CPROVER_MESSAGE_H
-
-#include <string>
-#include <sstream>
-#include <util/location.h>
-#include <util/message/verbosity.h>
-
-/**
- * @brief Message_handler is an interface for low-level print
- * operations, if you need to redirect ESBMC output this
- * is the class which you should specialize.
- * 
- */
-class message_handlert
-{
-public:
-  /**
-   * @brief print the messsage
-   * 
-   * @param level verbosity level of message
-   * @param message string with the mensage to be printed
-   */
-  virtual void
-  print(VerbosityLevel level, const std::string &message) const = 0;
-
-  /**
-   * @brief print the message alongisde its location
-   * 
-   * @param level verbosity level of message
-   * @param message string with the message to be printed
-   * @param location add the message location
-   */
-  virtual void print(
-    VerbosityLevel level,
-    const std::string &message,
-    const locationt &location) const;
-
-  virtual ~message_handlert() = default;
-};
-
-/**
- * @brief This specialization will send print statements into a
- * FILE*
- * 
- * NOTE: The memory management for FILE* is not handled by this class
- */
-class file_message_handler : public message_handlert
-{
-public:
-  virtual void set_file(VerbosityLevel v, FILE *f)
-  {
-    files[v] = f;
-  }
-
-protected:
-  std::unordered_map<VerbosityLevel, FILE *> files;
-};
-
-#endif
diff --git a/src/util/message/message_stream.cpp b/src/util/message/message_stream.cpp
deleted file mode 100644
index 9b98ee3f6..000000000
--- a/src/util/message/message_stream.cpp
+++ /dev/null
@@ -1,152 +0,0 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
-#include <cstring>
-#include <util/message/message_stream.h>
-
-void message_streamt::error_parse_line(
-  VerbosityLevel level,
-  const std::string &line)
-{
-  std::string error_msg = line;
-
-  const char *tptr = line.c_str();
-
-  if(strncmp(tptr, "file ", 5) == 0)
-  {
-    int state = 0;
-    std::string file, line_no, column, _error_msg, function;
-
-    tptr += 5;
-
-    char previous = 0;
-
-    while(*tptr != 0)
-    {
-      if(strncmp(tptr, " line ", 6) == 0 && state != 4)
-      {
-        state = 1;
-        tptr += 6;
-        continue;
-      }
-      if(strncmp(tptr, " column ", 8) == 0 && state != 4)
-      {
-        state = 2;
-        tptr += 8;
-        continue;
-      }
-      else if(strncmp(tptr, " function ", 10) == 0 && state != 4)
-      {
-        state = 3;
-        tptr += 10;
-        continue;
-      }
-      else if(*tptr == ':' && state != 4)
-      {
-        if(tptr[1] == ' ' && previous != ':')
-        {
-          state = 4;
-          tptr++;
-          while(*tptr == ' ')
-            tptr++;
-          continue;
-        }
-      }
-
-      if(state == 0) // file
-        file += *tptr;
-      else if(state == 1) // line number
-        line_no += *tptr;
-      else if(state == 2) // column
-        column += *tptr;
-      else if(state == 3) // function
-        function += *tptr;
-      else if(state == 4) // error message
-        _error_msg += *tptr;
-
-      previous = *tptr;
-
-      tptr++;
-    }
-
-    if(state == 4)
-    {
-      saved_error_location.set_line(line_no);
-      saved_error_location.set_file(file);
-      saved_error_location.set_column(column);
-      error_msg = _error_msg;
-      saved_error_location.set_function(function);
-    }
-  }
-  else
-  {
-    int state = 0;
-    std::string file, line_no;
-
-    while(*tptr != 0)
-    {
-      if(state == 0)
-      {
-        if(*tptr == ':')
-          state++;
-        else
-          file += *tptr;
-      }
-      else if(state == 1)
-      {
-        if(*tptr == ':')
-          state++;
-        else if(isdigit(*tptr))
-          line_no += *tptr;
-        else
-          state = 3;
-      }
-
-      tptr++;
-    }
-
-    if(state == 2)
-    {
-      saved_error_location.set_line(line_no);
-      saved_error_location.set_file(file);
-      saved_error_location.set_function("");
-      saved_error_location.set_column("");
-    }
-  }
-
-  message_handler.print(level, error_msg, saved_error_location);
-}
-
-void message_streamt::error_parse(
-  VerbosityLevel level,
-  const std::string &error)
-{
-  const char *tptr = error.c_str();
-
-  std::string line;
-
-  while(true)
-  {
-    switch(*tptr)
-    {
-    case 0:
-      return;
-    case '\n':
-      error_parse_line(level, line);
-      line.clear();
-      break;
-
-    case '\r':
-      break;
-    default:
-      line += *tptr;
-    }
-
-    tptr++;
-  }
-}
diff --git a/src/util/message/message_stream.h b/src/util/message/message_stream.h
deleted file mode 100644
index 27d3c3e41..000000000
--- a/src/util/message/message_stream.h
+++ /dev/null
@@ -1,127 +0,0 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
-#ifndef CPROVER_ERROR_HANDLER_H
-#define CPROVER_ERROR_HANDLER_H
-
-#include <sstream>
-#include <util/expr.h>
-#include <util/message/message_handler.h>
-#include <util/message/message.h>
-class message_streamt
-{
-public:
-  message_streamt(const messaget &_message_handler)
-    : message_handler(_message_handler),
-      error_found(false),
-      saved_error_location(static_cast<const locationt &>(get_nil_irep()))
-  {
-  }
-
-  virtual ~message_streamt() = default;
-
-  // overload to use language specific syntax
-  virtual std::string to_string(const exprt &expr)
-  {
-    return expr.to_string();
-  }
-  virtual std::string to_string(const typet &type)
-  {
-    return type.to_string();
-  }
-
-  void err_location(const exprt &expr)
-  {
-    saved_error_location = expr.find_location();
-  }
-  void err_location(const typet &type)
-  {
-    saved_error_location = type.location();
-  }
-  void err_location(const irept &irep)
-  {
-    saved_error_location = (const locationt &)irep.cmt_location();
-  }
-  void err_location(const locationt &_location)
-  {
-    saved_error_location = _location;
-  }
-
-  void error(const std::string &message)
-  {
-    send_msg(VerbosityLevel::Error, message);
-  }
-
-  void warning(const std::string &message)
-  {
-    send_msg(VerbosityLevel::Warning, message);
-  }
-
-  void error()
-  {
-    send_msg(VerbosityLevel::Error, str.str());
-    clear_err();
-  }
-
-  void warning()
-  {
-    send_msg(VerbosityLevel::Warning, str.str());
-    clear_err();
-  }
-
-  void status()
-  {
-    send_msg(VerbosityLevel::Status, str.str());
-    clear_err();
-  }
-
-  std::ostringstream str;
-
-  bool get_error_found() const
-  {
-    return error_found;
-  }
-
-  const messaget &get_message_handler()
-  {
-    return message_handler;
-  }
-
-  void error_parse(VerbosityLevel level)
-  {
-    error_parse(level, str.str());
-    clear_err();
-  }
-
-  void clear_err()
-  {
-    str.clear();
-    str.str("");
-  }
-
-protected:
-  const messaget &message_handler;
-  bool error_found;
-  locationt saved_error_location;
-
-  void send_msg(VerbosityLevel level, const std::string &message)
-  {
-    if(message == "")
-      return;
-    if((char)level <= (char)VerbosityLevel::Error)
-      error_found = true;
-    message_handler.print(level, message, saved_error_location);
-    saved_error_location.make_nil();
-  }
-
-  void error_parse_line(VerbosityLevel level, const std::string &line);
-
-  void error_parse(VerbosityLevel level, const std::string &error);
-};
-
-#endif
diff --git a/src/util/message/verbosity.h b/src/util/message/verbosity.h
deleted file mode 100644
index ff420477a..000000000
--- a/src/util/message/verbosity.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*******************************************************************\
-
-Module: This defines the verbosity LEVELS to be used throghout the program
-
-Author: Rafael Menezes, rafael.sa.menezes@outlook.com
-
-Maintainers:
-\*******************************************************************/
-#pragma once
-
-/**
-   * @brief Verbosity refers to the max level
-   * of which inputs are going to be printed out
-   *
-   * The level adds up to the greater level which means
-   * that if the level is set to 3 all messages of value
-   * 0,1,2,3 are going to be printed but 4+ will not be printed
-   *
-   * The number is where it appeared in the definition, in the
-   * implementation below DEBUG is the highest value
-   */
-enum class VerbosityLevel : char
-{
-  None,     // No message output
-  Error,    // fatal errors are printed
-  Warning,  // warnings are printend
-  Result,   // results of the analysis (including CE)
-  Progress, // progress notifications
-  Status,   // all kinds of esbmc is doing that may be useful to the user
-  Debug     // messages that are only useful if you need to debug.
-};
\ No newline at end of file
diff --git a/src/util/migrate.cpp b/src/util/migrate.cpp
index 6eba825c9..e9d56feab 100644
--- a/src/util/migrate.cpp
+++ b/src/util/migrate.cpp
@@ -1,13 +1,12 @@
 #include <util/c_types.h>
 #include <util/config.h>
 #include <irep2/irep2_utils.h>
+#include <util/message/format.h>
 #include <util/migrate.h>
 #include <util/namespace.h>
 #include <util/prefix.h>
 #include <util/simplify_expr.h>
 #include <util/type_byte_size.h>
-#include <util/message/format.h>
-#include <message/default_message.h>
 
 // File for old irep -> new irep conversions.
 
@@ -20,7 +19,7 @@
 // Why is this a global? Because there are over three hundred call sites to
 // migrate_expr, and it's a huge task to fix them all up to pass a namespace
 // down.
-namespacet *migrate_namespace_lookup = nullptr;
+const namespacet *migrate_namespace_lookup = nullptr;
 
 static std::map<irep_idt, BigInt> bin2int_map_signed, bin2int_map_unsigned;
 
@@ -113,17 +112,12 @@ type2tc migrate_type(const typet &type)
     type2tc subtype = migrate_type(type.subtype());
     expr2tc size((expr2t *)nullptr);
 
-    if(type.find(typet::a_size).id() == "infinity")
-    {
-      assert(
-        0 &&
-        "Vector type has a constant size\n"
-        "Please, refer to: "
-        "https://clang.llvm.org/docs/"
-        "LanguageExtensions.html#vectors-and-extended-vectors");
-      abort();
-    }
-
+    assert(
+      (type.find(typet::a_size).id() != "infinity") &&
+      "Vector type has a constant size\n"
+      "Please, refer to: "
+      "https://clang.llvm.org/docs/"
+      "LanguageExtensions.html#vectors-and-extended-vectors");
     exprt sz = (exprt &)type.find(typet::a_size);
     simplify(sz);
     migrate_expr(sz, size);
@@ -171,10 +165,7 @@ type2tc migrate_type(const typet &type)
     if(name.as_string() == "")
       name = type.get("name"); // C++
 
-    irep_idt ispacked = type.get("packed");
-    bool packed = false;
-    if(ispacked.as_string() == "true")
-      packed = true;
+    bool packed = type.get_bool("packed");
 
     struct_type2t *s =
       new struct_type2t(members, names, pretty_names, name, packed);
@@ -334,8 +325,7 @@ type2tc migrate_type(const typet &type)
     return type2tc(new string_type2t(iwidth));
   }
 
-  default_message msg;
-  msg.error(fmt::format("{}", type));
+  log_error("{}", type);
   abort();
 }
 
@@ -463,14 +453,14 @@ convert_operand_pair(const exprt &expr, expr2tc &arg1, expr2tc &arg2)
 
 expr2tc sym_name_to_symbol(irep_idt init, type2tc type)
 {
-  const symbolt *sym;
+  const symbolt *sym = migrate_namespace_lookup->lookup(init);
   symbol2t::renaming_level target_level;
   unsigned int level1_num = 0, thread_num = 0, node_num = 0, level2_num = 0;
 
   const std::string &thestr = init.as_string();
   // If this is an existing symbol name, then we're not renamed at all. Can't
   // rely on @ and ! symbols in the string "sadly".
-  if(migrate_namespace_lookup->lookup(init, sym) == false)
+  if(sym)
   {
     // This is a level0 name.
 
@@ -556,175 +546,6 @@ expr2tc sym_name_to_symbol(irep_idt init, type2tc type)
     type, thename, target_level, level1_num, level2_num, thread_num, node_num));
 }
 
-// Functions to flatten union literals to not contain anything of union type.
-// Everything should become a byte array, as we slowly purge concrete unions
-static expr2tc flatten_union(const exprt &expr);
-
-static void flatten_to_bytes(const exprt &expr, std::vector<expr2tc> &bytes)
-{
-  // Migrate to irep2 for sanity. We can't have recursive unions.
-  expr2tc new_expr;
-  migrate_expr(expr, new_expr);
-
-  // Awkwardly, this array literal might not be completely fixed-value, if
-  // encoded in the middle of a function body or something that refers to other
-  // variables.
-  if(is_array_type(new_expr))
-  {
-    // Assume only fixed-size arrays (because you can't have variable size
-    // members of unions).
-    const array_type2t &arraytype = to_array_type(new_expr->type);
-    assert(
-      !arraytype.size_is_infinite && !is_nil_expr(arraytype.array_size) &&
-      is_constant_int2t(arraytype.array_size) &&
-      "Can't flatten array in union literal with unbounded size");
-
-    // Iterate over each field and flatten to bytes
-    const constant_int2t &intref = to_constant_int2t(arraytype.array_size);
-    for(unsigned int i = 0; i < intref.value.to_uint64(); i++)
-    {
-      index2tc idx(arraytype.subtype, new_expr, gen_ulong(i));
-      flatten_to_bytes(migrate_expr_back(idx), bytes);
-    }
-  }
-  else if(is_struct_type(new_expr))
-  {
-    // Iterate over each field.
-    const struct_type2t &structtype = to_struct_type(new_expr->type);
-    BigInt member_offset_bits = 0;
-    bool been_inside_bits_region = false;
-    BigInt bitfields_first_byte = 0;
-    for(unsigned long i = 0; i < structtype.members.size(); i++)
-    {
-      BigInt member_size_bits = type_byte_size_bits(structtype.members[i]);
-      // If this member is a bitfield, extract everything as it is until
-      // the next member aligned to a byte as all such members can only
-      // be of scalar type
-      if(member_size_bits % 8 != 0 || member_offset_bits % 8 != 0)
-      {
-        // This is the first bit-field within the region.
-        // So we update its first byte
-        if(!been_inside_bits_region)
-        {
-          bitfields_first_byte = member_offset_bits / 8;
-          been_inside_bits_region = true;
-        }
-      }
-      else
-      {
-        // This means that we just came out of the region comprised by
-        // bit-fields and we need to extract this region as it is
-        // before we try extract current member
-        if(been_inside_bits_region)
-        {
-          bool is_big_endian =
-            config.ansi_c.endianess == configt::ansi_ct::IS_BIG_ENDIAN;
-          for(unsigned long j = bitfields_first_byte.to_uint64();
-              j < (member_offset_bits / 8).to_uint64();
-              j++)
-          {
-            byte_extract2tc struct_byte(
-              get_uint8_type(), new_expr, gen_ulong(j), is_big_endian);
-            bytes.push_back(struct_byte);
-          }
-          been_inside_bits_region = false;
-        }
-        // Now we can flatten to bytes this member as most likely it is not a bit-field.
-        // And even if it is a bit-field it is aligned to a byte and its
-        // size
-        member2tc memb(
-          structtype.members[i], new_expr, structtype.member_names[i]);
-        flatten_to_bytes(migrate_expr_back(memb), bytes);
-      }
-      member_offset_bits += member_size_bits;
-    }
-    // This means that the struct ended on a bitfield.
-    // Hence, we need to do some final extractions.
-    if(been_inside_bits_region)
-    {
-      bool is_big_endian =
-        config.ansi_c.endianess == configt::ansi_ct::IS_BIG_ENDIAN;
-      for(unsigned long j = bitfields_first_byte.to_uint64();
-          j < (member_offset_bits / 8).to_uint64();
-          j++)
-      {
-        byte_extract2tc struct_byte(
-          get_uint8_type(), new_expr, gen_ulong(j), is_big_endian);
-        bytes.push_back(struct_byte);
-      }
-    }
-  }
-  else if(is_union_type(new_expr))
-  {
-    // This is an expression that evaluates to a union -- probably a symbol
-    // name. It can't be a union literal, because that would have been
-    // recursively flattened. In this circumstance we are *not* required to
-    // actually perform any flattening, because something else in the union
-    // transformation should have transformed it to a byte array. Simply take
-    // the address (it has to have storage), cast to byte array, and index.
-    BigInt size = type_byte_size(new_expr->type);
-    address_of2tc addrof(new_expr->type, new_expr);
-    type2tc byteptr(new pointer_type2t(get_uint8_type()));
-    typecast2tc cast(byteptr, addrof);
-
-    // Produce N bytes
-    for(unsigned int i = 0; i < size.to_uint64(); i++)
-    {
-      index2tc idx(get_uint8_type(), cast, gen_ulong(i));
-      flatten_to_bytes(migrate_expr_back(idx), bytes);
-    }
-  }
-  else if(is_number_type(new_expr) || is_pointer_type(new_expr))
-  {
-    BigInt size = type_byte_size(new_expr->type);
-
-    bool is_big_endian =
-      config.ansi_c.endianess == configt::ansi_ct::IS_BIG_ENDIAN;
-    for(unsigned int i = 0; i < size.to_uint64(); i++)
-    {
-      byte_extract2tc ext(
-        get_uint8_type(), new_expr, gen_ulong(i), is_big_endian);
-      bytes.push_back(ext);
-    }
-  }
-  else
-  {
-    assert(
-      0 && fmt::format(
-             "Unrecognized type {}  when flattening union literal",
-             get_type_id(*new_expr->type))
-             .c_str());
-  }
-}
-
-static expr2tc flatten_union(const exprt &expr)
-{
-  type2tc type;
-  type = migrate_type(expr.type());
-  BigInt full_size = type_byte_size(type);
-
-  // Union literals should have zero/one field.
-  assert(
-    expr.operands().size() < 2 && "Union literal with more than one field");
-
-  // Cannot have unbounded size; flatten to an array of bytes.
-  std::vector<expr2tc> byte_array;
-
-  if(expr.operands().size() == 1)
-    flatten_to_bytes(expr.op0(), byte_array);
-
-  // Potentially extend this array further if this literal is smaller than
-  // the overall size of the union.
-  expr2tc abyte = gen_zero(get_uint8_type());
-  while(byte_array.size() < full_size.to_uint64())
-    byte_array.push_back(abyte);
-
-  expr2tc size = gen_ulong(byte_array.size());
-  type2tc arraytype(new array_type2t(get_uint8_type(), size, false));
-  constant_array2tc arr(arraytype, byte_array);
-  return arr;
-}
-
 void migrate_expr(const exprt &expr, expr2tc &new_expr_ref)
 {
   type2tc type;
@@ -877,9 +698,20 @@ void migrate_expr(const exprt &expr, expr2tc &new_expr_ref)
   }
   else if(expr.id() == typet::t_union)
   {
-    // Unions are now being transformed into byte arrays at all stages past
-    // parsing.
-    new_expr_ref = flatten_union(expr);
+    type = migrate_type(expr.type());
+
+    std::vector<expr2tc> members;
+    forall_operands(it, expr)
+    {
+      expr2tc new_ref;
+      migrate_expr(*it, new_ref);
+
+      members.push_back(new_ref);
+    }
+
+    constant_union2t *u =
+      new constant_union2t(type, expr.component_name(), members);
+    new_expr_ref = expr2tc(u);
   }
   else if(expr.id() == "string-constant")
   {
@@ -910,14 +742,12 @@ void migrate_expr(const exprt &expr, expr2tc &new_expr_ref)
       members.push_back(new_ref);
     }
 
-    expr2t *a;
     if(
       (expr.id() == irept::id_constant && expr.type().id() == typet::t_array) ||
       expr.id() == typet::t_array)
-      a = new constant_array2t(type, members);
+      new_expr_ref = constant_array2tc(type, members);
     else
-      a = new constant_vector2t(type, members);
-    new_expr_ref = expr2tc(a);
+      new_expr_ref = constant_vector2tc(type, members);
   }
   else if(expr.id() == exprt::arrayof)
   {
@@ -1797,9 +1627,8 @@ void migrate_expr(const exprt &expr, expr2tc &new_expr_ref)
     }
     else
     {
-      assert(
-        0 && fmt::format("Unexpected side-effect statement: ", expr.statement())
-               .c_str());
+      log_error("Unexpected side-effect statement: {}", expr.statement());
+      abort();
     }
 
     new_expr_ref =
@@ -2029,8 +1858,7 @@ void migrate_expr(const exprt &expr, expr2tc &new_expr_ref)
   }
   else
   {
-    default_message msg;
-    msg.error(fmt::format("{}\nmigrate expr failed", expr));
+    log_error("{}\nmigrate expr failed", expr);
     abort();
   }
 }
@@ -2070,7 +1898,7 @@ typet migrate_type_back(const type2tc &ref)
     thetype.components() = comps;
     thetype.set("tag", irep_idt(ref2.name));
     if(ref2.packed)
-      thetype.set("packed", irep_idt("true"));
+      thetype.set("packed", true);
     return std::move(thetype);
   }
   case type2t::union_id:
@@ -2144,14 +1972,8 @@ typet migrate_type_back(const type2tc &ref)
 
     vector_typet thetype;
     thetype.subtype() = migrate_type_back(ref2.subtype);
-    if(ref2.size_is_infinite)
-    {
-      thetype.set("size", "infinity");
-    }
-    else
-    {
-      thetype.size() = migrate_expr_back(ref2.array_size);
-    }
+    assert(!ref2.size_is_infinite);
+    thetype.size() = migrate_expr_back(ref2.array_size);
 
     return std::move(thetype);
   }
@@ -2227,8 +2049,8 @@ typet migrate_type_back(const type2tc &ref)
     return ret;
   }
   default:
-    default_message msg;
-    msg.error("Unrecognized type in migrate_type_back");
+
+    log_error("Unrecognized type in migrate_type_back");
     abort();
   }
 }
@@ -2297,7 +2119,7 @@ exprt migrate_expr_back(const expr2tc &ref)
     exprt theunion("union", thetype);
     for(auto const &it : ref2.datatype_members)
       theunion.operands().push_back(migrate_expr_back(it));
-
+    theunion.component_name(ref2.init_field);
     return theunion;
   }
   case expr2t::constant_array_id:
@@ -2853,8 +2675,7 @@ exprt migrate_expr_back(const expr2tc &ref)
     }
     else
     {
-      default_message msg;
-      msg.error("Invalid operand to overflow2t when backmigrating");
+      log_error("Invalid operand to overflow2t when backmigrating");
       abort();
     }
     return theexpr;
@@ -3026,8 +2847,8 @@ exprt migrate_expr_back(const expr2tc &ref)
       theexpr.statement("postdecrement");
       break;
     default:
-      default_message msg;
-      msg.error("Unexpected side effect type when back-converting");
+
+      log_error("Unexpected side effect type when back-converting");
       abort();
     }
 
@@ -3148,6 +2969,7 @@ exprt migrate_expr_back(const expr2tc &ref)
   {
     const code_goto2t &ref2 = to_code_goto2t(ref);
     exprt codeexpr("code", code_typet());
+    codeexpr.statement(irep_idt("goto"));
     codeexpr.set("destination", ref2.target);
     return codeexpr;
   }
@@ -3155,7 +2977,7 @@ exprt migrate_expr_back(const expr2tc &ref)
   {
     const code_asm2t &ref2 = to_code_asm2t(ref);
     exprt codeexpr("code", migrate_type_back(ref2.type));
-    codeexpr.statement("asm");
+    codeexpr.statement(irep_idt("asm"));
     // Don't actually set a piece of assembly as the operand here; it serves
     // no purpose.
     codeexpr.operands().resize(1);
@@ -3256,8 +3078,8 @@ exprt migrate_expr_back(const expr2tc &ref)
     return back;
   }
   default:
-    default_message msg;
-    msg.error("Unrecognized expr in migrate_expr_back");
+
+    log_error("Unrecognized expr in migrate_expr_back");
     abort();
   }
 }
diff --git a/src/util/migrate.h b/src/util/migrate.h
index 8439b5060..bd1ddb362 100644
--- a/src/util/migrate.h
+++ b/src/util/migrate.h
@@ -11,7 +11,7 @@
 
 // Don't ask
 class namespacet;
-extern namespacet *migrate_namespace_lookup;
+extern const namespacet *migrate_namespace_lookup;
 
 type2tc migrate_type(const typet &type);
 void migrate_expr(const exprt &expr, expr2tc &new_expr);
diff --git a/src/util/mp_arith.cpp b/src/util/mp_arith.cpp
index 234d45f11..c14eb8b53 100644
--- a/src/util/mp_arith.cpp
+++ b/src/util/mp_arith.cpp
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <cctype>
 #include <cstdlib>
diff --git a/src/util/mp_arith.h b/src/util/mp_arith.h
index 39270cd93..fec431353 100644
--- a/src/util/mp_arith.h
+++ b/src/util/mp_arith.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_MP_ARITH_H
 #define CPROVER_MP_ARITH_H
 
diff --git a/src/util/namespace.cpp b/src/util/namespace.cpp
index 661636e3f..4ffe61012 100644
--- a/src/util/namespace.cpp
+++ b/src/util/namespace.cpp
@@ -1,18 +1,9 @@
-/*******************************************************************\
-
-Module: Namespace
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #include <cassert>
 #include <cstring>
 #include <util/namespace.h>
-#include <util/message/format.h>
-#include <util/message/default_message.h>
+#include <util/message.h>
 
-unsigned get_max(const std::string &prefix, const contextt *context)
+unsigned namespacet::get_max(const std::string &prefix) const
 {
   unsigned max_nr = 0;
 
@@ -24,74 +15,31 @@ unsigned get_max(const std::string &prefix, const contextt *context)
   return max_nr;
 }
 
-unsigned namespacet::get_max(const std::string &prefix) const
-{
-  unsigned m = 0;
-
-  if(context1 != nullptr)
-    m = std::max(m, ::get_max(prefix, context1));
-
-  if(context2 != nullptr)
-    m = std::max(m, ::get_max(prefix, context2));
-
-  return m;
-}
-
-bool namespacet::lookup(const irep_idt &name, const symbolt *&symbol) const
-{
-  const symbolt *s = nullptr;
-
-  s = context1->find_symbol(name);
-  if(s != nullptr)
-  {
-    symbol = s;
-    return false;
-  }
-
-  if(context2 != nullptr)
-  {
-    s = context2->find_symbol(name);
-    if(s != nullptr)
-    {
-      symbol = s;
-      return false;
-    }
-  }
-
-  return true;
-}
-
-const symbolt &namespacet::lookup(const irep_idt &name) const
+const symbolt *namespacet::lookup(const irep_idt &name) const
 {
-  const symbolt *symbol;
-  if(lookup(name, symbol))
-  {
-    assert(
-      0 && fmt::format("Failed to find symbol {} not found", id2string(name))
-             .c_str());
-  }
-  return *symbol;
+  return context->find_symbol(name);
 }
 
 void namespacet::follow_symbol(irept &irep) const
 {
   while(irep.id() == "symbol")
   {
-    const symbolt &symbol = lookup(irep);
+    const symbolt *symbol = lookup(irep);
+    assert(symbol);
 
-    if(symbol.is_type)
+    if(symbol->is_type)
     {
-      if(symbol.type.is_nil())
+      if(symbol->type.is_nil())
         return;
 
-      irep = symbol.type;
+      irep = symbol->type;
     }
     else
     {
-      if(symbol.value.is_nil())
+      if(symbol->value.is_nil())
         return;
 
-      irep = symbol.value;
+      irep = symbol->value;
     }
   }
 }
@@ -101,14 +49,15 @@ const typet &namespacet::follow(const typet &src) const
   if(!src.is_symbol())
     return src;
 
-  const symbolt *symbol = &lookup(src);
+  const symbolt *symbol = lookup(src);
 
   // let's hope it's not cyclic...
   while(true)
   {
+    assert(symbol);
     assert(symbol->is_type);
     if(!symbol->type.is_symbol())
       return symbol->type;
-    symbol = &lookup(symbol->type);
+    symbol = lookup(symbol->type);
   }
 }
diff --git a/src/util/namespace.h b/src/util/namespace.h
index 4c8261bd7..034d54ead 100644
--- a/src/util/namespace.h
+++ b/src/util/namespace.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_NAMESPACE_H
 #define CPROVER_NAMESPACE_H
 
@@ -13,21 +5,15 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <irep2/irep2.h>
 #include <util/migrate.h>
 
-// second: true <=> not found
-
 class namespacet
 {
 public:
-  const symbolt &lookup(const irep_idt &name) const;
-
-  const symbolt &lookup(const irept &irep) const
+  virtual const symbolt *lookup(const irep_idt &name) const;
+  const symbolt *lookup(const irept &irep) const
   {
     return lookup(irep.identifier());
   }
 
-  virtual ~namespacet() = default;
-
-  virtual bool lookup(const irep_idt &name, const symbolt *&symbol) const;
   void follow_symbol(irept &irep) const;
 
   const typet &follow(const typet &src) const;
@@ -41,33 +27,21 @@ public:
 
   namespacet() = delete;
 
-  namespacet(const contextt &_context)
-  {
-    context1 = &_context;
-    context2 = nullptr;
-  }
-
-  namespacet(const contextt &_context1, const contextt &_context2)
-  {
-    context1 = &_context1;
-    context2 = &_context2;
-  }
+  virtual ~namespacet() = default;
 
-  namespacet(const contextt *_context1, const contextt *_context2)
+  namespacet(const contextt &_context) : context(&_context)
   {
-    context1 = _context1;
-    context2 = _context2;
   }
 
-  unsigned get_max(const std::string &prefix) const;
+  virtual unsigned get_max(const std::string &prefix) const;
 
   const contextt &get_context() const
   {
-    return *context1;
+    return *context;
   }
 
 protected:
-  const contextt *context1, *context2;
+  const contextt *context;
 };
 
 #endif
diff --git a/src/util/simplify_expr.h b/src/util/simplify_expr.h
index 29506abc6..27d1b7273 100644
--- a/src/util/simplify_expr.h
+++ b/src/util/simplify_expr.h
@@ -1,11 +1,3 @@
-/*******************************************************************\
-
-Module:
-
-Author: Daniel Kroening, kroening@kroening.com
-
-\*******************************************************************/
-
 #ifndef CPROVER_SIMPLIFY_EXPR_H
 #define CPROVER_SIMPLIFY_EXPR_H
 
diff --git a/src/util/simplify_expr2.cpp b/src/util/simplify_expr2.cpp
index efc1dee35..e204ff4b9 100644
--- a/src/util/simplify_expr2.cpp
+++ b/src/util/simplify_expr2.cpp
@@ -7,7 +7,6 @@
 #include <irep2/irep2.h>
 #include <irep2/irep2_utils.h>
 #include <util/type_byte_size.h>
-#include <util/message/default_message.h>
 
 expr2tc expr2t::do_simplify() const
 {

     if(is_constant(op1))
@@ -516,9 +517,10 @@ struct Multor
     // Is a vector operation ? Apply the op
     if(is_constant_vector2t(op1) || is_constant_vector2t(op2))
     {
-      std::function<expr2tc(type2tc, expr2tc, expr2tc)> op =
-        [](type2tc t, expr2tc e1, expr2tc e2) { return mul2tc(t, e1, e2); };
-      return vector_type2t::distribute_operation(op, op1, op2);
+      auto op = [](type2tc t, expr2tc e1, expr2tc e2) {
+        return mul2tc(t, e1, e2);
+      };
+      return distribute_vector_operation(op, op1, op2);
     }
 
     if(is_constant(op1))
@@ -576,9 +578,10 @@ struct Divtor
     // Is a vector operation ? Apply the op
     if(is_constant_vector2t(op1) || is_constant_vector2t(op2))
     {
-      std::function<expr2tc(type2tc, expr2tc, expr2tc)> op =
-        [](type2tc t, expr2tc e1, expr2tc e2) { return div2tc(t, e1, e2); };
-      return vector_type2t::distribute_operation(op, op1, op2);
+      auto op = [](type2tc t, expr2tc e1, expr2tc e2) {
+        return div2tc(t, e1, e2);
+      };
+      return distribute_vector_operation(op, op1, op2);
     }
 
     if(is_constant(op2))
@@ -646,10 +649,10 @@ expr2tc modulus2t::do_simplify() const
     is_constant_vector2t(simplied_side_1) ||
     is_constant_vector2t(simplied_side_2))
   {
-    std::function<expr2tc(type2tc, expr2tc, expr2tc)> op =
-      [](type2tc t, expr2tc e1, expr2tc e2) { return modulus2tc(t, e1, e2); };
-    return vector_type2t::distribute_operation(
-      op, simplied_side_1, simplied_side_2);
+    auto op = [](type2tc t, expr2tc e1, expr2tc e2) {
+      return modulus2tc(t, e1, e2);
+    };
+    return distribute_vector_operation(op, simplied_side_1, simplied_side_2);
   }
 
   if(is_bv_type(type))
@@ -807,9 +810,8 @@ expr2tc with2t::do_simplify() const
     if(thetype.members[no] != update_value->type)
       return expr2tc();
 
-    std::vector<expr2tc> newmembers;
-    newmembers.push_back(update_value);
-    return constant_union2tc(type, newmembers);
+    std::vector<expr2tc> newmembers = {update_value};
+    return constant_union2tc(type, thetype.member_names[no], newmembers);
   }
   else if(is_constant_array2t(source_value) && is_constant_int2t(update_field))
   {
@@ -821,7 +823,7 @@ expr2tc with2t::do_simplify() const
     if(index.value.is_negative())
       return expr2tc();
 
-    if(index.as_ulong() >= array.datatype_members.size())
+    if(index.value >= array.datatype_members.size())
       return expr2tc();
 
     constant_array2tc arr = array;
@@ -838,7 +840,7 @@ expr2tc with2t::do_simplify() const
     if(index.value.is_negative())
       return expr2tc();
 
-    if(index.as_ulong() >= vec.datatype_members.size())
+    if(index.value >= vec.datatype_members.size())
       return expr2tc();
 
     constant_vector2tc vec2 = vec;
@@ -885,11 +887,9 @@ expr2tc member2t::do_simplify() const
     if(is_constant_struct2t(source_value))
     {
       s = to_constant_struct2t(source_value).datatype_members[no];
-      default_message
-        msg; // This can be the default, because base_type will not print anything
       assert(
         is_pointer_type(type) ||
-        base_type_eq(type, s->type, namespacet(contextt(msg))));
+        base_type_eq(type, s->type, namespacet(contextt())));
     }
     else
     {
@@ -906,10 +906,10 @@ expr2tc member2t::do_simplify() const
        * field is in the constant union /isn't/ the field we're selecting from
        * it. So don't simplify it, because we can't. */
       // This can be the default, because base_type will not print anything
-      default_message msg;
+
       if(
         !is_pointer_type(type) &&
-        !base_type_eq(type, s->type, namespacet(contextt(msg))))
+        !base_type_eq(type, s->type, namespacet(contextt())))
         return expr2tc();
     }
 
@@ -1011,19 +1011,19 @@ expr2tc pointer_offset2t::do_simplify() const
 expr2tc index2t::do_simplify() const
 {
   expr2tc new_index = try_simplification(index);
-  //expr2tc src = try_simplification(source_value);
+  expr2tc src = try_simplification(source_value);
 
-  if(is_with2t(source_value))
+  if(is_with2t(src))
   {
     // Index is the same as an update to the thing we're indexing; we can
     // just take the update value from the "with" below.
-    if(new_index == to_with2t(source_value).update_field)
-      return to_with2t(source_value).update_value;
+    if(new_index == to_with2t(src).update_field)
+      return to_with2t(src).update_value;
 
     return expr2tc();
   }
 
-  if(is_constant_array2t(source_value) && is_constant_int2t(new_index))
+  if(is_constant_array2t(src) && is_constant_int2t(new_index))
   {
     // Index might be greater than the constant array size. This means we can't
     // simplify it, and the user might be eaten by an assertion failure in the
@@ -1032,7 +1032,7 @@ expr2tc index2t::do_simplify() const
     if(idx.value.is_negative())
       return expr2tc();
 
-    const constant_array2t &arr = to_constant_array2t(source_value);
+    const constant_array2t &arr = to_constant_array2t(src);
     unsigned long the_idx = idx.as_ulong();
     if(the_idx >= arr.datatype_members.size())
       return expr2tc();
@@ -1050,21 +1050,20 @@ expr2tc index2t::do_simplify() const
     if(idx.value.is_negative())
       return expr2tc();
 
-    unsigned long the_idx = idx.as_ulong();
-    if(the_idx >= arr.datatype_members.size())
+    if(idx.value >= arr.datatype_members.size())
       return expr2tc();
 
-    return arr.datatype_members[the_idx];
+    return arr.datatype_members[idx.as_ulong()];
   }
 
-  if(is_constant_string2t(source_value) && is_constant_int2t(new_index))
+  if(is_constant_string2t(src) && is_constant_int2t(new_index))
   {
     // Same index situation
     const constant_int2t &idx = to_constant_int2t(new_index);
     if(idx.value.is_negative())
       return expr2tc();
 
-    const constant_string2t &str = to_constant_string2t(source_value);
+    const constant_string2t &str = to_constant_string2t(src);
     unsigned long the_idx = idx.as_ulong();
     if(the_idx > str.value.as_string().size()) // allow reading null term.
       return expr2tc();
@@ -1076,8 +1075,11 @@ expr2tc index2t::do_simplify() const
   }
 
   // Only thing this index can evaluate to is the default value of this array
-  if(is_constant_array_of2t(source_value))
-    return to_constant_array_of2t(source_value).initializer;
+  if(is_constant_array_of2t(src))
+    return to_constant_array_of2t(src).initializer;
+
+  if(src != source_value || new_index != index)
+    return index2tc(type, src, new_index);
 
   return expr2tc();
 }
@@ -1397,26 +1399,6 @@ static expr2tc do_bit_munge_operation(
       expr2tc(new constructor(type, simplified_side_1, simplified_side_2)));
 
   return expr2tc();
-  /*
-  // This has potentially become negative. Check the top bit.
-  __uint128_t upper_bit = 1;
-  upper_bit <<= (type->get_width() - 1);
-  if(val1 & upper_bit && is_signedbv_type(type))
-  {
-    // Sign extend.
-    val1 |= ULLONG_MAX << (type->get_width());
-  }
-
-  // And now, restore, paying attention to whether this is supposed to be
-  // signed or not.
-  constant_int2t *theint;
-  if(is_signedbv_type(type))
-    theint = new constant_int2t(type, BigInt(val1));
-  else
-    theint = new constant_int2t(type, BigInt((uint64_t)val1));
-
-  return expr2tc(theint);
-  */
 }
 
+expr2tc byte_extract2t::do_simplify() const
+{
+  expr2tc src = try_simplification(source_value);
+  expr2tc off = try_simplification(source_offset);
+
+  if(is_array_type(src))
+  {
+    const array_type2t &at = to_array_type(src->type);
+    if(is_bv_type(at.subtype) && at.subtype->get_width() == type->get_width())
+      return try_simplification(
+        bitcast2tc(type, index2tc(at.subtype, src, off)));
+  }
+
+  if(is_constant_int2t(off) && type == get_uint8_type())
+  {
+    const BigInt &off_value = to_constant_int2t(off).value;
+    if(src->type == type && off_value.is_zero())
+      return src;
+
+    if(off_value.is_uint64() && is_constant_expr(src))
+    {
+      uint64_t off64 = off_value.to_uint64();
+      if(is_constant_int2t(src) && off64 * 8 >= off64)
+      {
+        off64 *= 8;
+        const BigInt &src_value = to_constant_int2t(src).value;
+        bool neg = is_signedbv_type(src) && src_value.is_negative();
+        unsigned width = src->type->get_width();
+        /* width bits in ss...ss|...|ssssssss|xxxxxxxx|xxxxxxxx|...|xxxxxxxx|
+         * at most 64 bits x; s = neg ? 1 : 0; off64 is in bits */
+        if(
+          (neg ? src_value.is_int64() : src_value.is_uint64()) &&
+          off64 + 8 <= width)
+        {
+          /* We assume two's complement, as does do_bit_munge_operation() */
+
+          /* constant repetition of sign bit? */
+          if(big_endian ? off64 + 64 + 8 <= width : off64 >= 64)
+            return constant_int2tc(type, BigInt(neg ? 0xff : 0x00));
+          /* now we know that we are extracting part of |xxxxxxxx|...|xxxxxxxx| */
+          uint64_t x = neg ? src_value.to_int64() : src_value.to_uint64();
+          if(big_endian)
+          {
+            /* off64 + 64 + 8 > width and off64 + 8 <= width
+             * i.e. width-off64-8 in [0,64) */
+            off64 = width - off64 - 8;
+          }
+          return constant_int2tc(type, BigInt((x >> off64) & 0xff));
+        }
+        /* XXX how to simplify this? */
+      }
+    }
+  }
+
+  if(src != source_value || off != source_offset)
+    return byte_extract2tc(type, src, off, big_endian);
+
+  return {};
+}
+
