Description: Fix multiarch include paths and Python mypy invocation
 This patch addresses two critical issues for Debian/Ubuntu packaging:
 .
 1. Multiarch include path support: On modern Debian/Ubuntu systems (e.g.,
    Ubuntu 24.04), system C headers such as stddef.h are located in the
    multiarch directory (/usr/include/<arch>-linux-gnu) and are not
    reachable from ESBMC's sysroot alone. This patch adds automatic
    detection and inclusion of the multiarch include path to Clang's
    compiler arguments, ensuring that system headers can be found via
    #include_next directives. This is particularly important for the C++
    frontend where standard library headers depend on these system headers.
 .
 2. Python mypy invocation: The original code directly invokes "mypy" as a
    standalone executable, which may not be available in $PATH on
    Debian/Ubuntu systems where only the python3-mypy package is installed
    (without the mypy binary). This patch changes the invocation to use
    "python3 -m mypy", which works reliably with the python3-mypy package
    where the library is importable as a module even if no binary is
    installed.
 .
 This patch is essential for successful builds on Debian/Ubuntu systems
 and ensures compatibility with the Debian packaging policy.
Author: Weiqi Wang <lukewang19@icloud.com>
Forwarded: no
Last-Update: 2026-01-26

--- esbmc-7.11.0+fix1.orig/src/clang-c-frontend/clang_c_language.cpp
+++ esbmc-7.11.0+fix1/src/clang-c-frontend/clang_c_language.cpp
@@ -49,6 +49,29 @@ void clang_c_languaget::build_include_ar
     compiler_args.push_back("-Wno-implicit-function-declaration");
   }
 
+  // On some distributions (e.g., Ubuntu 24.04), the system C headers such as
+  // stddef.h only live in the multiarch directory
+  //   /usr/include/<arch>-linux-gnu
+  // and are not reachable from the ESBMC sysroot alone.  Our internal
+  // header wrappers (e.g., headers/stddef.h) use `#include_next <stddef.h>`
+  // to fall back to the system variant, so we must ensure that Clang can
+  // actually see the multiarch include directory.
+  //
+  // This is particularly important for the C++ frontend, where standard
+  // library headers from the host toolchain include <cstddef>, which
+  // in turn relies on stddef.h being resolvable via include_next.
+  if (config.ansi_c.target.os == "linux" && !config.ansi_c.target.arch.empty())
+  {
+    std::string multiarch_path =
+      "/usr/include/" + config.ansi_c.target.arch + "-linux-gnu";
+
+    if (boost::filesystem::exists(multiarch_path))
+    {
+      compiler_args.push_back("-isystem");
+      compiler_args.push_back(multiarch_path);
+    }
+  }
+
   compiler_args.push_back("-resource-dir");
   compiler_args.push_back(clang_resource_dir());
 
--- esbmc-7.11.0+fix1.orig/src/python-frontend/parser.py
+++ esbmc-7.11.0+fix1/src/python-frontend/parser.py
@@ -455,10 +455,15 @@ def main():
     output_dir = sys.argv[2]
 
     # Type checking input program with mypy
+    # Use the current Python interpreter to invoke mypy as a module to avoid
+    # relying on a standalone "mypy" executable being present in $PATH.  This
+    # works reliably with the python3-mypy package on Debian/Ubuntu, where the
+    # library is importable as "mypy" even if no "mypy" binary is installed.
+    mypy_cmd = [sys.executable, "-m", "mypy", "--strict", filename]
     result = subprocess.run(
-    ["mypy", "--strict", filename],
-    capture_output=True,
-    text=True)
+        mypy_cmd,
+        capture_output=True,
+        text=True)
 
     if result.returncode != 0:
         print("\033[93m\nType checking warning:\033[0m")
